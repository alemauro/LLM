{
  "log": {
    "version": "1.2",
    "creator": {
      "name": "WebInspector",
      "version": "537.36"
    },
    "pages": [
      {
        "startedDateTime": "2025-08-06T21:33:06.636Z",
        "id": "page_1",
        "title": "http://localhost:5174/",
        "pageTimings": {
          "onContentLoad": 153.95100000023376,
          "onLoad": 194.99899999937043
        }
      }
    ],
    "entries": [
      {
        "_connectionId": "184573",
        "_initiator": {
          "type": "other"
        },
        "_priority": "VeryHigh",
        "_resourceType": "document",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=0"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"256-OylPyjXSBydLCZK3cN19AjRsU1k\""
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "document"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "navigate"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "none"
            },
            {
              "name": "Sec-Fetch-User",
              "value": "?1"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "Upgrade-Insecure-Requests",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 606,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 598,
            "mimeType": "text/html",
            "text": "<!DOCTYPE html>\r\n<html lang=\"es\">\r\n<head>\n  <script type=\"module\">import { injectIntoGlobalHook } from \"/@react-refresh\";\ninjectIntoGlobalHook(window);\nwindow.$RefreshReg$ = () => {};\nwindow.$RefreshSig$ = () => (type) => type;</script>\n\n  <script type=\"module\" src=\"/@vite/client\"></script>\n\r\n  <meta charset=\"UTF-8\">\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n  <title>LLM (Infomed Guru)</title>\r\n  <link rel=\"icon\" type=\"image/png\" href=\"/favicon.png\">\r\n</head>\r\n<body>\r\n  <div id=\"root\"></div>\r\n  <script type=\"module\" src=\"/main.tsx\"></script>\r\n</body>\r\n</html>"
          },
          "redirectURL": "",
          "headersSize": 127,
          "bodySize": 0,
          "_transferSize": 127,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.634Z",
        "time": 6.903000001329929,
        "timings": {
          "blocked": 2.6270000004728793,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.125,
          "wait": 3.861000000907108,
          "receive": 0.2899999999499414,
          "_blocked_queueing": 1.839000000472879,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184618",
        "_initiator": {
          "type": "parser",
          "url": "http://localhost:5174/",
          "lineNumber": 8
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@vite/client",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"5cca-63JLiz26NHTsVcEC2TDfbOsKVcU\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 515,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 137837,
            "mimeType": "text/javascript",
            "text": "import \"/@fs/home/jano/DEV_WSL/LLM/node_modules/vite/dist/client/env.mjs\";\n\nclass HMRContext {\n  constructor(hmrClient, ownerPath) {\n    this.hmrClient = hmrClient;\n    this.ownerPath = ownerPath;\n    if (!hmrClient.dataMap.has(ownerPath)) {\n      hmrClient.dataMap.set(ownerPath, {});\n    }\n    const mod = hmrClient.hotModulesMap.get(ownerPath);\n    if (mod) {\n      mod.callbacks = [];\n    }\n    const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);\n    if (staleListeners) {\n      for (const [event, staleFns] of staleListeners) {\n        const listeners = hmrClient.customListenersMap.get(event);\n        if (listeners) {\n          hmrClient.customListenersMap.set(\n            event,\n            listeners.filter((l) => !staleFns.includes(l))\n          );\n        }\n      }\n    }\n    this.newListeners = /* @__PURE__ */ new Map();\n    hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);\n  }\n  get data() {\n    return this.hmrClient.dataMap.get(this.ownerPath);\n  }\n  accept(deps, callback) {\n    if (typeof deps === \"function\" || !deps) {\n      this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));\n    } else if (typeof deps === \"string\") {\n      this.acceptDeps([deps], ([mod]) => callback?.(mod));\n    } else if (Array.isArray(deps)) {\n      this.acceptDeps(deps, callback);\n    } else {\n      throw new Error(`invalid hot.accept() usage.`);\n    }\n  }\n  // export names (first arg) are irrelevant on the client side, they're\n  // extracted in the server for propagation\n  acceptExports(_, callback) {\n    this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));\n  }\n  dispose(cb) {\n    this.hmrClient.disposeMap.set(this.ownerPath, cb);\n  }\n  prune(cb) {\n    this.hmrClient.pruneMap.set(this.ownerPath, cb);\n  }\n  // Kept for backward compatibility (#11036)\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  decline() {\n  }\n  invalidate(message) {\n    this.hmrClient.notifyListeners(\"vite:invalidate\", {\n      path: this.ownerPath,\n      message\n    });\n    this.send(\"vite:invalidate\", { path: this.ownerPath, message });\n    this.hmrClient.logger.debug(\n      `[vite] invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`\n    );\n  }\n  on(event, cb) {\n    const addToMap = (map) => {\n      const existing = map.get(event) || [];\n      existing.push(cb);\n      map.set(event, existing);\n    };\n    addToMap(this.hmrClient.customListenersMap);\n    addToMap(this.newListeners);\n  }\n  off(event, cb) {\n    const removeFromMap = (map) => {\n      const existing = map.get(event);\n      if (existing === void 0) {\n        return;\n      }\n      const pruned = existing.filter((l) => l !== cb);\n      if (pruned.length === 0) {\n        map.delete(event);\n        return;\n      }\n      map.set(event, pruned);\n    };\n    removeFromMap(this.hmrClient.customListenersMap);\n    removeFromMap(this.newListeners);\n  }\n  send(event, data) {\n    this.hmrClient.messenger.send(\n      JSON.stringify({ type: \"custom\", event, data })\n    );\n  }\n  acceptDeps(deps, callback = () => {\n  }) {\n    const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {\n      id: this.ownerPath,\n      callbacks: []\n    };\n    mod.callbacks.push({\n      deps,\n      fn: callback\n    });\n    this.hmrClient.hotModulesMap.set(this.ownerPath, mod);\n  }\n}\nclass HMRMessenger {\n  constructor(connection) {\n    this.connection = connection;\n    this.queue = [];\n  }\n  send(message) {\n    this.queue.push(message);\n    this.flush();\n  }\n  flush() {\n    if (this.connection.isReady()) {\n      this.queue.forEach((msg) => this.connection.send(msg));\n      this.queue = [];\n    }\n  }\n}\nclass HMRClient {\n  constructor(logger, connection, importUpdatedModule) {\n    this.logger = logger;\n    this.importUpdatedModule = importUpdatedModule;\n    this.hotModulesMap = /* @__PURE__ */ new Map();\n    this.disposeMap = /* @__PURE__ */ new Map();\n    this.pruneMap = /* @__PURE__ */ new Map();\n    this.dataMap = /* @__PURE__ */ new Map();\n    this.customListenersMap = /* @__PURE__ */ new Map();\n    this.ctxToListenersMap = /* @__PURE__ */ new Map();\n    this.updateQueue = [];\n    this.pendingUpdateQueue = false;\n    this.messenger = new HMRMessenger(connection);\n  }\n  async notifyListeners(event, data) {\n    const cbs = this.customListenersMap.get(event);\n    if (cbs) {\n      await Promise.allSettled(cbs.map((cb) => cb(data)));\n    }\n  }\n  clear() {\n    this.hotModulesMap.clear();\n    this.disposeMap.clear();\n    this.pruneMap.clear();\n    this.dataMap.clear();\n    this.customListenersMap.clear();\n    this.ctxToListenersMap.clear();\n  }\n  // After an HMR update, some modules are no longer imported on the page\n  // but they may have left behind side effects that need to be cleaned up\n  // (.e.g style injections)\n  async prunePaths(paths) {\n    await Promise.all(\n      paths.map((path) => {\n        const disposer = this.disposeMap.get(path);\n        if (disposer) return disposer(this.dataMap.get(path));\n      })\n    );\n    paths.forEach((path) => {\n      const fn = this.pruneMap.get(path);\n      if (fn) {\n        fn(this.dataMap.get(path));\n      }\n    });\n  }\n  warnFailedUpdate(err, path) {\n    if (!err.message.includes(\"fetch\")) {\n      this.logger.error(err);\n    }\n    this.logger.error(\n      `[hmr] Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`\n    );\n  }\n  /**\n   * buffer multiple hot updates triggered by the same src change\n   * so that they are invoked in the same order they were sent.\n   * (otherwise the order may be inconsistent because of the http request round trip)\n   */\n  async queueUpdate(payload) {\n    this.updateQueue.push(this.fetchUpdate(payload));\n    if (!this.pendingUpdateQueue) {\n      this.pendingUpdateQueue = true;\n      await Promise.resolve();\n      this.pendingUpdateQueue = false;\n      const loading = [...this.updateQueue];\n      this.updateQueue = [];\n      (await Promise.all(loading)).forEach((fn) => fn && fn());\n    }\n  }\n  async fetchUpdate(update) {\n    const { path, acceptedPath } = update;\n    const mod = this.hotModulesMap.get(path);\n    if (!mod) {\n      return;\n    }\n    let fetchedModule;\n    const isSelfUpdate = path === acceptedPath;\n    const qualifiedCallbacks = mod.callbacks.filter(\n      ({ deps }) => deps.includes(acceptedPath)\n    );\n    if (isSelfUpdate || qualifiedCallbacks.length > 0) {\n      const disposer = this.disposeMap.get(acceptedPath);\n      if (disposer) await disposer(this.dataMap.get(acceptedPath));\n      try {\n        fetchedModule = await this.importUpdatedModule(update);\n      } catch (e) {\n        this.warnFailedUpdate(e, acceptedPath);\n      }\n    }\n    return () => {\n      for (const { deps, fn } of qualifiedCallbacks) {\n        fn(\n          deps.map((dep) => dep === acceptedPath ? fetchedModule : void 0)\n        );\n      }\n      const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;\n      this.logger.debug(`[vite] hot updated: ${loggedPath}`);\n    };\n  }\n}\n\nconst hmrConfigName = \"vite.config.ts\";\nconst base$1 = \"/\" || \"/\";\nfunction h(e, attrs = {}, ...children) {\n  const elem = document.createElement(e);\n  for (const [k, v] of Object.entries(attrs)) {\n    elem.setAttribute(k, v);\n  }\n  elem.append(...children);\n  return elem;\n}\nconst templateStyle = (\n  /*css*/\n  `\n:host {\n  position: fixed;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 99999;\n  --monospace: 'SFMono-Regular', Consolas,\n  'Liberation Mono', Menlo, Courier, monospace;\n  --red: #ff5555;\n  --yellow: #e2aa53;\n  --purple: #cfa4ff;\n  --cyan: #2dd9da;\n  --dim: #c9c9c9;\n\n  --window-background: #181818;\n  --window-color: #d8d8d8;\n}\n\n.backdrop {\n  position: fixed;\n  z-index: 99999;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  overflow-y: scroll;\n  margin: 0;\n  background: rgba(0, 0, 0, 0.66);\n}\n\n.window {\n  font-family: var(--monospace);\n  line-height: 1.5;\n  max-width: 80vw;\n  color: var(--window-color);\n  box-sizing: border-box;\n  margin: 30px auto;\n  padding: 2.5vh 4vw;\n  position: relative;\n  background: var(--window-background);\n  border-radius: 6px 6px 8px 8px;\n  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);\n  overflow: hidden;\n  border-top: 8px solid var(--red);\n  direction: ltr;\n  text-align: left;\n}\n\npre {\n  font-family: var(--monospace);\n  font-size: 16px;\n  margin-top: 0;\n  margin-bottom: 1em;\n  overflow-x: scroll;\n  scrollbar-width: none;\n}\n\npre::-webkit-scrollbar {\n  display: none;\n}\n\npre.frame::-webkit-scrollbar {\n  display: block;\n  height: 5px;\n}\n\npre.frame::-webkit-scrollbar-thumb {\n  background: #999;\n  border-radius: 5px;\n}\n\npre.frame {\n  scrollbar-width: thin;\n}\n\n.message {\n  line-height: 1.3;\n  font-weight: 600;\n  white-space: pre-wrap;\n}\n\n.message-body {\n  color: var(--red);\n}\n\n.plugin {\n  color: var(--purple);\n}\n\n.file {\n  color: var(--cyan);\n  margin-bottom: 0;\n  white-space: pre-wrap;\n  word-break: break-all;\n}\n\n.frame {\n  color: var(--yellow);\n}\n\n.stack {\n  font-size: 13px;\n  color: var(--dim);\n}\n\n.tip {\n  font-size: 13px;\n  color: #999;\n  border-top: 1px dotted #999;\n  padding-top: 13px;\n  line-height: 1.8;\n}\n\ncode {\n  font-size: 13px;\n  font-family: var(--monospace);\n  color: var(--yellow);\n}\n\n.file-link {\n  text-decoration: underline;\n  cursor: pointer;\n}\n\nkbd {\n  line-height: 1.5;\n  font-family: ui-monospace, Menlo, Monaco, Consolas, \"Liberation Mono\", \"Courier New\", monospace;\n  font-size: 0.75rem;\n  font-weight: 700;\n  background-color: rgb(38, 40, 44);\n  color: rgb(166, 167, 171);\n  padding: 0.15rem 0.3rem;\n  border-radius: 0.25rem;\n  border-width: 0.0625rem 0.0625rem 0.1875rem;\n  border-style: solid;\n  border-color: rgb(54, 57, 64);\n  border-image: initial;\n}\n`\n);\nconst createTemplate = () => h(\n  \"div\",\n  { class: \"backdrop\", part: \"backdrop\" },\n  h(\n    \"div\",\n    { class: \"window\", part: \"window\" },\n    h(\n      \"pre\",\n      { class: \"message\", part: \"message\" },\n      h(\"span\", { class: \"plugin\", part: \"plugin\" }),\n      h(\"span\", { class: \"message-body\", part: \"message-body\" })\n    ),\n    h(\"pre\", { class: \"file\", part: \"file\" }),\n    h(\"pre\", { class: \"frame\", part: \"frame\" }),\n    h(\"pre\", { class: \"stack\", part: \"stack\" }),\n    h(\n      \"div\",\n      { class: \"tip\", part: \"tip\" },\n      \"Click outside, press \",\n      h(\"kbd\", {}, \"Esc\"),\n      \" key, or fix the code to dismiss.\",\n      h(\"br\"),\n      \"You can also disable this overlay by setting \",\n      h(\"code\", { part: \"config-option-name\" }, \"server.hmr.overlay\"),\n      \" to \",\n      h(\"code\", { part: \"config-option-value\" }, \"false\"),\n      \" in \",\n      h(\"code\", { part: \"config-file-name\" }, hmrConfigName),\n      \".\"\n    )\n  ),\n  h(\"style\", {}, templateStyle)\n);\nconst fileRE = /(?:[a-zA-Z]:\\\\|\\/).*?:\\d+:\\d+/g;\nconst codeframeRE = /^(?:>?\\s*\\d+\\s+\\|.*|\\s+\\|\\s*\\^.*)\\r?\\n/gm;\nconst { HTMLElement = class {\n} } = globalThis;\nclass ErrorOverlay extends HTMLElement {\n  constructor(err, links = true) {\n    super();\n    this.root = this.attachShadow({ mode: \"open\" });\n    this.root.appendChild(createTemplate());\n    codeframeRE.lastIndex = 0;\n    const hasFrame = err.frame && codeframeRE.test(err.frame);\n    const message = hasFrame ? err.message.replace(codeframeRE, \"\") : err.message;\n    if (err.plugin) {\n      this.text(\".plugin\", `[plugin:${err.plugin}] `);\n    }\n    this.text(\".message-body\", message.trim());\n    const [file] = (err.loc?.file || err.id || \"unknown file\").split(`?`);\n    if (err.loc) {\n      this.text(\".file\", `${file}:${err.loc.line}:${err.loc.column}`, links);\n    } else if (err.id) {\n      this.text(\".file\", file);\n    }\n    if (hasFrame) {\n      this.text(\".frame\", err.frame.trim());\n    }\n    this.text(\".stack\", err.stack, links);\n    this.root.querySelector(\".window\").addEventListener(\"click\", (e) => {\n      e.stopPropagation();\n    });\n    this.addEventListener(\"click\", () => {\n      this.close();\n    });\n    this.closeOnEsc = (e) => {\n      if (e.key === \"Escape\" || e.code === \"Escape\") {\n        this.close();\n      }\n    };\n    document.addEventListener(\"keydown\", this.closeOnEsc);\n  }\n  text(selector, text, linkFiles = false) {\n    const el = this.root.querySelector(selector);\n    if (!linkFiles) {\n      el.textContent = text;\n    } else {\n      let curIndex = 0;\n      let match;\n      fileRE.lastIndex = 0;\n      while (match = fileRE.exec(text)) {\n        const { 0: file, index } = match;\n        if (index != null) {\n          const frag = text.slice(curIndex, index);\n          el.appendChild(document.createTextNode(frag));\n          const link = document.createElement(\"a\");\n          link.textContent = file;\n          link.className = \"file-link\";\n          link.onclick = () => {\n            fetch(\n              new URL(\n                `${base$1}__open-in-editor?file=${encodeURIComponent(file)}`,\n                import.meta.url\n              )\n            );\n          };\n          el.appendChild(link);\n          curIndex += frag.length + file.length;\n        }\n      }\n    }\n  }\n  close() {\n    this.parentNode?.removeChild(this);\n    document.removeEventListener(\"keydown\", this.closeOnEsc);\n  }\n}\nconst overlayId = \"vite-error-overlay\";\nconst { customElements } = globalThis;\nif (customElements && !customElements.get(overlayId)) {\n  customElements.define(overlayId, ErrorOverlay);\n}\n\nconsole.debug(\"[vite] connecting...\");\nconst importMetaUrl = new URL(import.meta.url);\nconst serverHost = \"localhost:5173/\";\nconst socketProtocol = null || (importMetaUrl.protocol === \"https:\" ? \"wss\" : \"ws\");\nconst hmrPort = null;\nconst socketHost = `${null || importMetaUrl.hostname}:${hmrPort || importMetaUrl.port}${\"/\"}`;\nconst directSocketHost = \"localhost:5173/\";\nconst base = \"/\" || \"/\";\nconst wsToken = \"B0ljPQ3LU_Ss\";\nlet socket;\ntry {\n  let fallback;\n  if (!hmrPort) {\n    fallback = () => {\n      socket = setupWebSocket(socketProtocol, directSocketHost, () => {\n        const currentScriptHostURL = new URL(import.meta.url);\n        const currentScriptHost = currentScriptHostURL.host + currentScriptHostURL.pathname.replace(/@vite\\/client$/, \"\");\n        console.error(\n          `[vite] failed to connect to websocket.\nyour current setup:\n  (browser) ${currentScriptHost} <--[HTTP]--> ${serverHost} (server)\n  (browser) ${socketHost} <--[WebSocket (failing)]--> ${directSocketHost} (server)\nCheck out your Vite / network configuration and https://vite.dev/config/server-options.html#server-hmr .`\n        );\n      });\n      socket.addEventListener(\n        \"open\",\n        () => {\n          console.info(\n            \"[vite] Direct websocket connection fallback. Check out https://vite.dev/config/server-options.html#server-hmr to remove the previous connection error.\"\n          );\n        },\n        { once: true }\n      );\n    };\n  }\n  socket = setupWebSocket(socketProtocol, socketHost, fallback);\n} catch (error) {\n  console.error(`[vite] failed to connect to websocket (${error}). `);\n}\nfunction setupWebSocket(protocol, hostAndPath, onCloseWithoutOpen) {\n  const socket2 = new WebSocket(\n    `${protocol}://${hostAndPath}?token=${wsToken}`,\n    \"vite-hmr\"\n  );\n  let isOpened = false;\n  socket2.addEventListener(\n    \"open\",\n    () => {\n      isOpened = true;\n      notifyListeners(\"vite:ws:connect\", { webSocket: socket2 });\n    },\n    { once: true }\n  );\n  socket2.addEventListener(\"message\", async ({ data }) => {\n    handleMessage(JSON.parse(data));\n  });\n  socket2.addEventListener(\"close\", async ({ wasClean }) => {\n    if (wasClean) return;\n    if (!isOpened && onCloseWithoutOpen) {\n      onCloseWithoutOpen();\n      return;\n    }\n    notifyListeners(\"vite:ws:disconnect\", { webSocket: socket2 });\n    if (hasDocument) {\n      console.log(`[vite] server connection lost. Polling for restart...`);\n      await waitForSuccessfulPing(protocol, hostAndPath);\n      location.reload();\n    }\n  });\n  return socket2;\n}\nfunction cleanUrl(pathname) {\n  const url = new URL(pathname, \"http://vite.dev\");\n  url.searchParams.delete(\"direct\");\n  return url.pathname + url.search;\n}\nlet isFirstUpdate = true;\nconst outdatedLinkTags = /* @__PURE__ */ new WeakSet();\nconst debounceReload = (time) => {\n  let timer;\n  return () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(() => {\n      location.reload();\n    }, time);\n  };\n};\nconst pageReload = debounceReload(50);\nconst hmrClient = new HMRClient(\n  console,\n  {\n    isReady: () => socket && socket.readyState === 1,\n    send: (message) => socket.send(message)\n  },\n  async function importUpdatedModule({\n    acceptedPath,\n    timestamp,\n    explicitImportRequired,\n    isWithinCircularImport\n  }) {\n    const [acceptedPathWithoutQuery, query] = acceptedPath.split(`?`);\n    const importPromise = import(\n      /* @vite-ignore */\n      base + acceptedPathWithoutQuery.slice(1) + `?${explicitImportRequired ? \"import&\" : \"\"}t=${timestamp}${query ? `&${query}` : \"\"}`\n    );\n    if (isWithinCircularImport) {\n      importPromise.catch(() => {\n        console.info(\n          `[hmr] ${acceptedPath} failed to apply HMR as it's within a circular import. Reloading page to reset the execution order. To debug and break the circular import, you can run \\`vite --debug hmr\\` to log the circular dependency path if a file change triggered it.`\n        );\n        pageReload();\n      });\n    }\n    return await importPromise;\n  }\n);\nasync function handleMessage(payload) {\n  switch (payload.type) {\n    case \"connected\":\n      console.debug(`[vite] connected.`);\n      hmrClient.messenger.flush();\n      setInterval(() => {\n        if (socket.readyState === socket.OPEN) {\n          socket.send('{\"type\":\"ping\"}');\n        }\n      }, 30000);\n      break;\n    case \"update\":\n      notifyListeners(\"vite:beforeUpdate\", payload);\n      if (hasDocument) {\n        if (isFirstUpdate && hasErrorOverlay()) {\n          location.reload();\n          return;\n        } else {\n          if (enableOverlay) {\n            clearErrorOverlay();\n          }\n          isFirstUpdate = false;\n        }\n      }\n      await Promise.all(\n        payload.updates.map(async (update) => {\n          if (update.type === \"js-update\") {\n            return hmrClient.queueUpdate(update);\n          }\n          const { path, timestamp } = update;\n          const searchUrl = cleanUrl(path);\n          const el = Array.from(\n            document.querySelectorAll(\"link\")\n          ).find(\n            (e) => !outdatedLinkTags.has(e) && cleanUrl(e.href).includes(searchUrl)\n          );\n          if (!el) {\n            return;\n          }\n          const newPath = `${base}${searchUrl.slice(1)}${searchUrl.includes(\"?\") ? \"&\" : \"?\"}t=${timestamp}`;\n          return new Promise((resolve) => {\n            const newLinkTag = el.cloneNode();\n            newLinkTag.href = new URL(newPath, el.href).href;\n            const removeOldEl = () => {\n              el.remove();\n              console.debug(`[vite] css hot updated: ${searchUrl}`);\n              resolve();\n            };\n            newLinkTag.addEventListener(\"load\", removeOldEl);\n            newLinkTag.addEventListener(\"error\", removeOldEl);\n            outdatedLinkTags.add(el);\n            el.after(newLinkTag);\n          });\n        })\n      );\n      notifyListeners(\"vite:afterUpdate\", payload);\n      break;\n    case \"custom\": {\n      notifyListeners(payload.event, payload.data);\n      break;\n    }\n    case \"full-reload\":\n      notifyListeners(\"vite:beforeFullReload\", payload);\n      if (hasDocument) {\n        if (payload.path && payload.path.endsWith(\".html\")) {\n          const pagePath = decodeURI(location.pathname);\n          const payloadPath = base + payload.path.slice(1);\n          if (pagePath === payloadPath || payload.path === \"/index.html\" || pagePath.endsWith(\"/\") && pagePath + \"index.html\" === payloadPath) {\n            pageReload();\n          }\n          return;\n        } else {\n          pageReload();\n        }\n      }\n      break;\n    case \"prune\":\n      notifyListeners(\"vite:beforePrune\", payload);\n      await hmrClient.prunePaths(payload.paths);\n      break;\n    case \"error\": {\n      notifyListeners(\"vite:error\", payload);\n      if (hasDocument) {\n        const err = payload.err;\n        if (enableOverlay) {\n          createErrorOverlay(err);\n        } else {\n          console.error(\n            `[vite] Internal Server Error\n${err.message}\n${err.stack}`\n          );\n        }\n      }\n      break;\n    }\n    default: {\n      const check = payload;\n      return check;\n    }\n  }\n}\nfunction notifyListeners(event, data) {\n  hmrClient.notifyListeners(event, data);\n}\nconst enableOverlay = true;\nconst hasDocument = \"document\" in globalThis;\nfunction createErrorOverlay(err) {\n  clearErrorOverlay();\n  document.body.appendChild(new ErrorOverlay(err));\n}\nfunction clearErrorOverlay() {\n  document.querySelectorAll(overlayId).forEach((n) => n.close());\n}\nfunction hasErrorOverlay() {\n  return document.querySelectorAll(overlayId).length;\n}\nasync function waitForSuccessfulPing(socketProtocol2, hostAndPath, ms = 1e3) {\n  const pingHostProtocol = socketProtocol2 === \"wss\" ? \"https\" : \"http\";\n  const ping = async () => {\n    try {\n      await fetch(`${pingHostProtocol}://${hostAndPath}`, {\n        mode: \"no-cors\",\n        headers: {\n          // Custom headers won't be included in a request with no-cors so (ab)use one of the\n          // safelisted headers to identify the ping request\n          Accept: \"text/x-vite-ping\"\n        }\n      });\n      return true;\n    } catch {\n    }\n    return false;\n  };\n  if (await ping()) {\n    return;\n  }\n  await wait(ms);\n  while (true) {\n    if (document.visibilityState === \"visible\") {\n      if (await ping()) {\n        break;\n      }\n      await wait(ms);\n    } else {\n      await waitForWindowShow();\n    }\n  }\n}\nfunction wait(ms) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\nfunction waitForWindowShow() {\n  return new Promise((resolve) => {\n    const onChange = async () => {\n      if (document.visibilityState === \"visible\") {\n        resolve();\n        document.removeEventListener(\"visibilitychange\", onChange);\n      }\n    };\n    document.addEventListener(\"visibilitychange\", onChange);\n  });\n}\nconst sheetsMap = /* @__PURE__ */ new Map();\nif (\"document\" in globalThis) {\n  document.querySelectorAll(\"style[data-vite-dev-id]\").forEach((el) => {\n    sheetsMap.set(el.getAttribute(\"data-vite-dev-id\"), el);\n  });\n}\nconst cspNonce = \"document\" in globalThis ? document.querySelector(\"meta[property=csp-nonce]\")?.nonce : void 0;\nlet lastInsertedStyle;\nfunction updateStyle(id, content) {\n  let style = sheetsMap.get(id);\n  if (!style) {\n    style = document.createElement(\"style\");\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-vite-dev-id\", id);\n    style.textContent = content;\n    if (cspNonce) {\n      style.setAttribute(\"nonce\", cspNonce);\n    }\n    if (!lastInsertedStyle) {\n      document.head.appendChild(style);\n      setTimeout(() => {\n        lastInsertedStyle = void 0;\n      }, 0);\n    } else {\n      lastInsertedStyle.insertAdjacentElement(\"afterend\", style);\n    }\n    lastInsertedStyle = style;\n  } else {\n    style.textContent = content;\n  }\n  sheetsMap.set(id, style);\n}\nfunction removeStyle(id) {\n  const style = sheetsMap.get(id);\n  if (style) {\n    document.head.removeChild(style);\n    sheetsMap.delete(id);\n  }\n}\nfunction createHotContext(ownerPath) {\n  return new HMRContext(hmrClient, ownerPath);\n}\nfunction injectQuery(url, queryToInject) {\n  if (url[0] !== \".\" && url[0] !== \"/\") {\n    return url;\n  }\n  const pathname = url.replace(/[?#].*$/, \"\");\n  const { search, hash } = new URL(url, \"http://vite.dev\");\n  return `${pathname}?${queryToInject}${search ? `&` + search.slice(1) : \"\"}${hash || \"\"}`;\n}\n\nexport { ErrorOverlay, createHotContext, injectQuery, removeStyle, updateStyle };\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNsaWVudCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgXCIvQGZzL2hvbWUvamFuby9ERVZfV1NML0xMTS9ub2RlX21vZHVsZXMvdml0ZS9kaXN0L2NsaWVudC9lbnYubWpzXCI7XG5cbmNsYXNzIEhNUkNvbnRleHQge1xuICBjb25zdHJ1Y3RvcihobXJDbGllbnQsIG93bmVyUGF0aCkge1xuICAgIHRoaXMuaG1yQ2xpZW50ID0gaG1yQ2xpZW50O1xuICAgIHRoaXMub3duZXJQYXRoID0gb3duZXJQYXRoO1xuICAgIGlmICghaG1yQ2xpZW50LmRhdGFNYXAuaGFzKG93bmVyUGF0aCkpIHtcbiAgICAgIGhtckNsaWVudC5kYXRhTWFwLnNldChvd25lclBhdGgsIHt9KTtcbiAgICB9XG4gICAgY29uc3QgbW9kID0gaG1yQ2xpZW50LmhvdE1vZHVsZXNNYXAuZ2V0KG93bmVyUGF0aCk7XG4gICAgaWYgKG1vZCkge1xuICAgICAgbW9kLmNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBjb25zdCBzdGFsZUxpc3RlbmVycyA9IGhtckNsaWVudC5jdHhUb0xpc3RlbmVyc01hcC5nZXQob3duZXJQYXRoKTtcbiAgICBpZiAoc3RhbGVMaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAoY29uc3QgW2V2ZW50LCBzdGFsZUZuc10gb2Ygc3RhbGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gaG1yQ2xpZW50LmN1c3RvbUxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgaG1yQ2xpZW50LmN1c3RvbUxpc3RlbmVyc01hcC5zZXQoXG4gICAgICAgICAgICBldmVudCxcbiAgICAgICAgICAgIGxpc3RlbmVycy5maWx0ZXIoKGwpID0+ICFzdGFsZUZucy5pbmNsdWRlcyhsKSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubmV3TGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBobXJDbGllbnQuY3R4VG9MaXN0ZW5lcnNNYXAuc2V0KG93bmVyUGF0aCwgdGhpcy5uZXdMaXN0ZW5lcnMpO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmhtckNsaWVudC5kYXRhTWFwLmdldCh0aGlzLm93bmVyUGF0aCk7XG4gIH1cbiAgYWNjZXB0KGRlcHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBkZXBzID09PSBcImZ1bmN0aW9uXCIgfHwgIWRlcHMpIHtcbiAgICAgIHRoaXMuYWNjZXB0RGVwcyhbdGhpcy5vd25lclBhdGhdLCAoW21vZF0pID0+IGRlcHM/Lihtb2QpKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXBzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLmFjY2VwdERlcHMoW2RlcHNdLCAoW21vZF0pID0+IGNhbGxiYWNrPy4obW9kKSk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRlcHMpKSB7XG4gICAgICB0aGlzLmFjY2VwdERlcHMoZGVwcywgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaG90LmFjY2VwdCgpIHVzYWdlLmApO1xuICAgIH1cbiAgfVxuICAvLyBleHBvcnQgbmFtZXMgKGZpcnN0IGFyZykgYXJlIGlycmVsZXZhbnQgb24gdGhlIGNsaWVudCBzaWRlLCB0aGV5J3JlXG4gIC8vIGV4dHJhY3RlZCBpbiB0aGUgc2VydmVyIGZvciBwcm9wYWdhdGlvblxuICBhY2NlcHRFeHBvcnRzKF8sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5hY2NlcHREZXBzKFt0aGlzLm93bmVyUGF0aF0sIChbbW9kXSkgPT4gY2FsbGJhY2s/Lihtb2QpKTtcbiAgfVxuICBkaXNwb3NlKGNiKSB7XG4gICAgdGhpcy5obXJDbGllbnQuZGlzcG9zZU1hcC5zZXQodGhpcy5vd25lclBhdGgsIGNiKTtcbiAgfVxuICBwcnVuZShjYikge1xuICAgIHRoaXMuaG1yQ2xpZW50LnBydW5lTWFwLnNldCh0aGlzLm93bmVyUGF0aCwgY2IpO1xuICB9XG4gIC8vIEtlcHQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKCMxMTAzNilcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICBkZWNsaW5lKCkge1xuICB9XG4gIGludmFsaWRhdGUobWVzc2FnZSkge1xuICAgIHRoaXMuaG1yQ2xpZW50Lm5vdGlmeUxpc3RlbmVycyhcInZpdGU6aW52YWxpZGF0ZVwiLCB7XG4gICAgICBwYXRoOiB0aGlzLm93bmVyUGF0aCxcbiAgICAgIG1lc3NhZ2VcbiAgICB9KTtcbiAgICB0aGlzLnNlbmQoXCJ2aXRlOmludmFsaWRhdGVcIiwgeyBwYXRoOiB0aGlzLm93bmVyUGF0aCwgbWVzc2FnZSB9KTtcbiAgICB0aGlzLmhtckNsaWVudC5sb2dnZXIuZGVidWcoXG4gICAgICBgW3ZpdGVdIGludmFsaWRhdGUgJHt0aGlzLm93bmVyUGF0aH0ke21lc3NhZ2UgPyBgOiAke21lc3NhZ2V9YCA6IFwiXCJ9YFxuICAgICk7XG4gIH1cbiAgb24oZXZlbnQsIGNiKSB7XG4gICAgY29uc3QgYWRkVG9NYXAgPSAobWFwKSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZyA9IG1hcC5nZXQoZXZlbnQpIHx8IFtdO1xuICAgICAgZXhpc3RpbmcucHVzaChjYik7XG4gICAgICBtYXAuc2V0KGV2ZW50LCBleGlzdGluZyk7XG4gICAgfTtcbiAgICBhZGRUb01hcCh0aGlzLmhtckNsaWVudC5jdXN0b21MaXN0ZW5lcnNNYXApO1xuICAgIGFkZFRvTWFwKHRoaXMubmV3TGlzdGVuZXJzKTtcbiAgfVxuICBvZmYoZXZlbnQsIGNiKSB7XG4gICAgY29uc3QgcmVtb3ZlRnJvbU1hcCA9IChtYXApID0+IHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nID0gbWFwLmdldChldmVudCk7XG4gICAgICBpZiAoZXhpc3RpbmcgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwcnVuZWQgPSBleGlzdGluZy5maWx0ZXIoKGwpID0+IGwgIT09IGNiKTtcbiAgICAgIGlmIChwcnVuZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG1hcC5kZWxldGUoZXZlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBtYXAuc2V0KGV2ZW50LCBwcnVuZWQpO1xuICAgIH07XG4gICAgcmVtb3ZlRnJvbU1hcCh0aGlzLmhtckNsaWVudC5jdXN0b21MaXN0ZW5lcnNNYXApO1xuICAgIHJlbW92ZUZyb21NYXAodGhpcy5uZXdMaXN0ZW5lcnMpO1xuICB9XG4gIHNlbmQoZXZlbnQsIGRhdGEpIHtcbiAgICB0aGlzLmhtckNsaWVudC5tZXNzZW5nZXIuc2VuZChcbiAgICAgIEpTT04uc3RyaW5naWZ5KHsgdHlwZTogXCJjdXN0b21cIiwgZXZlbnQsIGRhdGEgfSlcbiAgICApO1xuICB9XG4gIGFjY2VwdERlcHMoZGVwcywgY2FsbGJhY2sgPSAoKSA9PiB7XG4gIH0pIHtcbiAgICBjb25zdCBtb2QgPSB0aGlzLmhtckNsaWVudC5ob3RNb2R1bGVzTWFwLmdldCh0aGlzLm93bmVyUGF0aCkgfHwge1xuICAgICAgaWQ6IHRoaXMub3duZXJQYXRoLFxuICAgICAgY2FsbGJhY2tzOiBbXVxuICAgIH07XG4gICAgbW9kLmNhbGxiYWNrcy5wdXNoKHtcbiAgICAgIGRlcHMsXG4gICAgICBmbjogY2FsbGJhY2tcbiAgICB9KTtcbiAgICB0aGlzLmhtckNsaWVudC5ob3RNb2R1bGVzTWFwLnNldCh0aGlzLm93bmVyUGF0aCwgbW9kKTtcbiAgfVxufVxuY2xhc3MgSE1STWVzc2VuZ2VyIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbikge1xuICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgdGhpcy5xdWV1ZSA9IFtdO1xuICB9XG4gIHNlbmQobWVzc2FnZSkge1xuICAgIHRoaXMucXVldWUucHVzaChtZXNzYWdlKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbi5pc1JlYWR5KCkpIHtcbiAgICAgIHRoaXMucXVldWUuZm9yRWFjaCgobXNnKSA9PiB0aGlzLmNvbm5lY3Rpb24uc2VuZChtc2cpKTtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEhNUkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGxvZ2dlciwgY29ubmVjdGlvbiwgaW1wb3J0VXBkYXRlZE1vZHVsZSkge1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuaW1wb3J0VXBkYXRlZE1vZHVsZSA9IGltcG9ydFVwZGF0ZWRNb2R1bGU7XG4gICAgdGhpcy5ob3RNb2R1bGVzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRpc3Bvc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMucHJ1bmVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZGF0YU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5jdXN0b21MaXN0ZW5lcnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuY3R4VG9MaXN0ZW5lcnNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMudXBkYXRlUXVldWUgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdVcGRhdGVRdWV1ZSA9IGZhbHNlO1xuICAgIHRoaXMubWVzc2VuZ2VyID0gbmV3IEhNUk1lc3Nlbmdlcihjb25uZWN0aW9uKTtcbiAgfVxuICBhc3luYyBub3RpZnlMaXN0ZW5lcnMoZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBjYnMgPSB0aGlzLmN1c3RvbUxpc3RlbmVyc01hcC5nZXQoZXZlbnQpO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChjYnMubWFwKChjYikgPT4gY2IoZGF0YSkpKTtcbiAgICB9XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5ob3RNb2R1bGVzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5kaXNwb3NlTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5wcnVuZU1hcC5jbGVhcigpO1xuICAgIHRoaXMuZGF0YU1hcC5jbGVhcigpO1xuICAgIHRoaXMuY3VzdG9tTGlzdGVuZXJzTWFwLmNsZWFyKCk7XG4gICAgdGhpcy5jdHhUb0xpc3RlbmVyc01hcC5jbGVhcigpO1xuICB9XG4gIC8vIEFmdGVyIGFuIEhNUiB1cGRhdGUsIHNvbWUgbW9kdWxlcyBhcmUgbm8gbG9uZ2VyIGltcG9ydGVkIG9uIHRoZSBwYWdlXG4gIC8vIGJ1dCB0aGV5IG1heSBoYXZlIGxlZnQgYmVoaW5kIHNpZGUgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2xlYW5lZCB1cFxuICAvLyAoLmUuZyBzdHlsZSBpbmplY3Rpb25zKVxuICBhc3luYyBwcnVuZVBhdGhzKHBhdGhzKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwYXRocy5tYXAoKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3QgZGlzcG9zZXIgPSB0aGlzLmRpc3Bvc2VNYXAuZ2V0KHBhdGgpO1xuICAgICAgICBpZiAoZGlzcG9zZXIpIHJldHVybiBkaXNwb3Nlcih0aGlzLmRhdGFNYXAuZ2V0KHBhdGgpKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICBjb25zdCBmbiA9IHRoaXMucHJ1bmVNYXAuZ2V0KHBhdGgpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKHRoaXMuZGF0YU1hcC5nZXQocGF0aCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhcm5GYWlsZWRVcGRhdGUoZXJyLCBwYXRoKSB7XG4gICAgaWYgKCFlcnIubWVzc2FnZS5pbmNsdWRlcyhcImZldGNoXCIpKSB7XG4gICAgICB0aGlzLmxvZ2dlci5lcnJvcihlcnIpO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5lcnJvcihcbiAgICAgIGBbaG1yXSBGYWlsZWQgdG8gcmVsb2FkICR7cGF0aH0uIFRoaXMgY291bGQgYmUgZHVlIHRvIHN5bnRheCBlcnJvcnMgb3IgaW1wb3J0aW5nIG5vbi1leGlzdGVudCBtb2R1bGVzLiAoc2VlIGVycm9ycyBhYm92ZSlgXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogYnVmZmVyIG11bHRpcGxlIGhvdCB1cGRhdGVzIHRyaWdnZXJlZCBieSB0aGUgc2FtZSBzcmMgY2hhbmdlXG4gICAqIHNvIHRoYXQgdGhleSBhcmUgaW52b2tlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGV5IHdlcmUgc2VudC5cbiAgICogKG90aGVyd2lzZSB0aGUgb3JkZXIgbWF5IGJlIGluY29uc2lzdGVudCBiZWNhdXNlIG9mIHRoZSBodHRwIHJlcXVlc3Qgcm91bmQgdHJpcClcbiAgICovXG4gIGFzeW5jIHF1ZXVlVXBkYXRlKHBheWxvYWQpIHtcbiAgICB0aGlzLnVwZGF0ZVF1ZXVlLnB1c2godGhpcy5mZXRjaFVwZGF0ZShwYXlsb2FkKSk7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdVcGRhdGVRdWV1ZSkge1xuICAgICAgdGhpcy5wZW5kaW5nVXBkYXRlUXVldWUgPSB0cnVlO1xuICAgICAgYXdhaXQgUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLnBlbmRpbmdVcGRhdGVRdWV1ZSA9IGZhbHNlO1xuICAgICAgY29uc3QgbG9hZGluZyA9IFsuLi50aGlzLnVwZGF0ZVF1ZXVlXTtcbiAgICAgIHRoaXMudXBkYXRlUXVldWUgPSBbXTtcbiAgICAgIChhd2FpdCBQcm9taXNlLmFsbChsb2FkaW5nKSkuZm9yRWFjaCgoZm4pID0+IGZuICYmIGZuKCkpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmZXRjaFVwZGF0ZSh1cGRhdGUpIHtcbiAgICBjb25zdCB7IHBhdGgsIGFjY2VwdGVkUGF0aCB9ID0gdXBkYXRlO1xuICAgIGNvbnN0IG1vZCA9IHRoaXMuaG90TW9kdWxlc01hcC5nZXQocGF0aCk7XG4gICAgaWYgKCFtb2QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZldGNoZWRNb2R1bGU7XG4gICAgY29uc3QgaXNTZWxmVXBkYXRlID0gcGF0aCA9PT0gYWNjZXB0ZWRQYXRoO1xuICAgIGNvbnN0IHF1YWxpZmllZENhbGxiYWNrcyA9IG1vZC5jYWxsYmFja3MuZmlsdGVyKFxuICAgICAgKHsgZGVwcyB9KSA9PiBkZXBzLmluY2x1ZGVzKGFjY2VwdGVkUGF0aClcbiAgICApO1xuICAgIGlmIChpc1NlbGZVcGRhdGUgfHwgcXVhbGlmaWVkQ2FsbGJhY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGRpc3Bvc2VyID0gdGhpcy5kaXNwb3NlTWFwLmdldChhY2NlcHRlZFBhdGgpO1xuICAgICAgaWYgKGRpc3Bvc2VyKSBhd2FpdCBkaXNwb3Nlcih0aGlzLmRhdGFNYXAuZ2V0KGFjY2VwdGVkUGF0aCkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmV0Y2hlZE1vZHVsZSA9IGF3YWl0IHRoaXMuaW1wb3J0VXBkYXRlZE1vZHVsZSh1cGRhdGUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLndhcm5GYWlsZWRVcGRhdGUoZSwgYWNjZXB0ZWRQYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgeyBkZXBzLCBmbiB9IG9mIHF1YWxpZmllZENhbGxiYWNrcykge1xuICAgICAgICBmbihcbiAgICAgICAgICBkZXBzLm1hcCgoZGVwKSA9PiBkZXAgPT09IGFjY2VwdGVkUGF0aCA/IGZldGNoZWRNb2R1bGUgOiB2b2lkIDApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCBsb2dnZWRQYXRoID0gaXNTZWxmVXBkYXRlID8gcGF0aCA6IGAke2FjY2VwdGVkUGF0aH0gdmlhICR7cGF0aH1gO1xuICAgICAgdGhpcy5sb2dnZXIuZGVidWcoYFt2aXRlXSBob3QgdXBkYXRlZDogJHtsb2dnZWRQYXRofWApO1xuICAgIH07XG4gIH1cbn1cblxuY29uc3QgaG1yQ29uZmlnTmFtZSA9IFwidml0ZS5jb25maWcudHNcIjtcbmNvbnN0IGJhc2UkMSA9IFwiL1wiIHx8IFwiL1wiO1xuZnVuY3Rpb24gaChlLCBhdHRycyA9IHt9LCAuLi5jaGlsZHJlbikge1xuICBjb25zdCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlKTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoYXR0cnMpKSB7XG4gICAgZWxlbS5zZXRBdHRyaWJ1dGUoaywgdik7XG4gIH1cbiAgZWxlbS5hcHBlbmQoLi4uY2hpbGRyZW4pO1xuICByZXR1cm4gZWxlbTtcbn1cbmNvbnN0IHRlbXBsYXRlU3R5bGUgPSAoXG4gIC8qY3NzKi9cbiAgYFxuOmhvc3Qge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgei1pbmRleDogOTk5OTk7XG4gIC0tbW9ub3NwYWNlOiAnU0ZNb25vLVJlZ3VsYXInLCBDb25zb2xhcyxcbiAgJ0xpYmVyYXRpb24gTW9ubycsIE1lbmxvLCBDb3VyaWVyLCBtb25vc3BhY2U7XG4gIC0tcmVkOiAjZmY1NTU1O1xuICAtLXllbGxvdzogI2UyYWE1MztcbiAgLS1wdXJwbGU6ICNjZmE0ZmY7XG4gIC0tY3lhbjogIzJkZDlkYTtcbiAgLS1kaW06ICNjOWM5Yzk7XG5cbiAgLS13aW5kb3ctYmFja2dyb3VuZDogIzE4MTgxODtcbiAgLS13aW5kb3ctY29sb3I6ICNkOGQ4ZDg7XG59XG5cbi5iYWNrZHJvcCB7XG4gIHBvc2l0aW9uOiBmaXhlZDtcbiAgei1pbmRleDogOTk5OTk7XG4gIHRvcDogMDtcbiAgbGVmdDogMDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgb3ZlcmZsb3cteTogc2Nyb2xsO1xuICBtYXJnaW46IDA7XG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC42Nik7XG59XG5cbi53aW5kb3cge1xuICBmb250LWZhbWlseTogdmFyKC0tbW9ub3NwYWNlKTtcbiAgbGluZS1oZWlnaHQ6IDEuNTtcbiAgbWF4LXdpZHRoOiA4MHZ3O1xuICBjb2xvcjogdmFyKC0td2luZG93LWNvbG9yKTtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgbWFyZ2luOiAzMHB4IGF1dG87XG4gIHBhZGRpbmc6IDIuNXZoIDR2dztcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICBiYWNrZ3JvdW5kOiB2YXIoLS13aW5kb3ctYmFja2dyb3VuZCk7XG4gIGJvcmRlci1yYWRpdXM6IDZweCA2cHggOHB4IDhweDtcbiAgYm94LXNoYWRvdzogMCAxOXB4IDM4cHggcmdiYSgwLDAsMCwwLjMwKSwgMCAxNXB4IDEycHggcmdiYSgwLDAsMCwwLjIyKTtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgYm9yZGVyLXRvcDogOHB4IHNvbGlkIHZhcigtLXJlZCk7XG4gIGRpcmVjdGlvbjogbHRyO1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xufVxuXG5wcmUge1xuICBmb250LWZhbWlseTogdmFyKC0tbW9ub3NwYWNlKTtcbiAgZm9udC1zaXplOiAxNnB4O1xuICBtYXJnaW4tdG9wOiAwO1xuICBtYXJnaW4tYm90dG9tOiAxZW07XG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcbiAgc2Nyb2xsYmFyLXdpZHRoOiBub25lO1xufVxuXG5wcmU6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cblxucHJlLmZyYW1lOjotd2Via2l0LXNjcm9sbGJhciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBoZWlnaHQ6IDVweDtcbn1cblxucHJlLmZyYW1lOjotd2Via2l0LXNjcm9sbGJhci10aHVtYiB7XG4gIGJhY2tncm91bmQ6ICM5OTk7XG4gIGJvcmRlci1yYWRpdXM6IDVweDtcbn1cblxucHJlLmZyYW1lIHtcbiAgc2Nyb2xsYmFyLXdpZHRoOiB0aGluO1xufVxuXG4ubWVzc2FnZSB7XG4gIGxpbmUtaGVpZ2h0OiAxLjM7XG4gIGZvbnQtd2VpZ2h0OiA2MDA7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbn1cblxuLm1lc3NhZ2UtYm9keSB7XG4gIGNvbG9yOiB2YXIoLS1yZWQpO1xufVxuXG4ucGx1Z2luIHtcbiAgY29sb3I6IHZhcigtLXB1cnBsZSk7XG59XG5cbi5maWxlIHtcbiAgY29sb3I6IHZhcigtLWN5YW4pO1xuICBtYXJnaW4tYm90dG9tOiAwO1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG4gIHdvcmQtYnJlYWs6IGJyZWFrLWFsbDtcbn1cblxuLmZyYW1lIHtcbiAgY29sb3I6IHZhcigtLXllbGxvdyk7XG59XG5cbi5zdGFjayB7XG4gIGZvbnQtc2l6ZTogMTNweDtcbiAgY29sb3I6IHZhcigtLWRpbSk7XG59XG5cbi50aXAge1xuICBmb250LXNpemU6IDEzcHg7XG4gIGNvbG9yOiAjOTk5O1xuICBib3JkZXItdG9wOiAxcHggZG90dGVkICM5OTk7XG4gIHBhZGRpbmctdG9wOiAxM3B4O1xuICBsaW5lLWhlaWdodDogMS44O1xufVxuXG5jb2RlIHtcbiAgZm9udC1zaXplOiAxM3B4O1xuICBmb250LWZhbWlseTogdmFyKC0tbW9ub3NwYWNlKTtcbiAgY29sb3I6IHZhcigtLXllbGxvdyk7XG59XG5cbi5maWxlLWxpbmsge1xuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG5rYmQge1xuICBsaW5lLWhlaWdodDogMS41O1xuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBNZW5sbywgTW9uYWNvLCBDb25zb2xhcywgXCJMaWJlcmF0aW9uIE1vbm9cIiwgXCJDb3VyaWVyIE5ld1wiLCBtb25vc3BhY2U7XG4gIGZvbnQtc2l6ZTogMC43NXJlbTtcbiAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDM4LCA0MCwgNDQpO1xuICBjb2xvcjogcmdiKDE2NiwgMTY3LCAxNzEpO1xuICBwYWRkaW5nOiAwLjE1cmVtIDAuM3JlbTtcbiAgYm9yZGVyLXJhZGl1czogMC4yNXJlbTtcbiAgYm9yZGVyLXdpZHRoOiAwLjA2MjVyZW0gMC4wNjI1cmVtIDAuMTg3NXJlbTtcbiAgYm9yZGVyLXN0eWxlOiBzb2xpZDtcbiAgYm9yZGVyLWNvbG9yOiByZ2IoNTQsIDU3LCA2NCk7XG4gIGJvcmRlci1pbWFnZTogaW5pdGlhbDtcbn1cbmBcbik7XG5jb25zdCBjcmVhdGVUZW1wbGF0ZSA9ICgpID0+IGgoXG4gIFwiZGl2XCIsXG4gIHsgY2xhc3M6IFwiYmFja2Ryb3BcIiwgcGFydDogXCJiYWNrZHJvcFwiIH0sXG4gIGgoXG4gICAgXCJkaXZcIixcbiAgICB7IGNsYXNzOiBcIndpbmRvd1wiLCBwYXJ0OiBcIndpbmRvd1wiIH0sXG4gICAgaChcbiAgICAgIFwicHJlXCIsXG4gICAgICB7IGNsYXNzOiBcIm1lc3NhZ2VcIiwgcGFydDogXCJtZXNzYWdlXCIgfSxcbiAgICAgIGgoXCJzcGFuXCIsIHsgY2xhc3M6IFwicGx1Z2luXCIsIHBhcnQ6IFwicGx1Z2luXCIgfSksXG4gICAgICBoKFwic3BhblwiLCB7IGNsYXNzOiBcIm1lc3NhZ2UtYm9keVwiLCBwYXJ0OiBcIm1lc3NhZ2UtYm9keVwiIH0pXG4gICAgKSxcbiAgICBoKFwicHJlXCIsIHsgY2xhc3M6IFwiZmlsZVwiLCBwYXJ0OiBcImZpbGVcIiB9KSxcbiAgICBoKFwicHJlXCIsIHsgY2xhc3M6IFwiZnJhbWVcIiwgcGFydDogXCJmcmFtZVwiIH0pLFxuICAgIGgoXCJwcmVcIiwgeyBjbGFzczogXCJzdGFja1wiLCBwYXJ0OiBcInN0YWNrXCIgfSksXG4gICAgaChcbiAgICAgIFwiZGl2XCIsXG4gICAgICB7IGNsYXNzOiBcInRpcFwiLCBwYXJ0OiBcInRpcFwiIH0sXG4gICAgICBcIkNsaWNrIG91dHNpZGUsIHByZXNzIFwiLFxuICAgICAgaChcImtiZFwiLCB7fSwgXCJFc2NcIiksXG4gICAgICBcIiBrZXksIG9yIGZpeCB0aGUgY29kZSB0byBkaXNtaXNzLlwiLFxuICAgICAgaChcImJyXCIpLFxuICAgICAgXCJZb3UgY2FuIGFsc28gZGlzYWJsZSB0aGlzIG92ZXJsYXkgYnkgc2V0dGluZyBcIixcbiAgICAgIGgoXCJjb2RlXCIsIHsgcGFydDogXCJjb25maWctb3B0aW9uLW5hbWVcIiB9LCBcInNlcnZlci5obXIub3ZlcmxheVwiKSxcbiAgICAgIFwiIHRvIFwiLFxuICAgICAgaChcImNvZGVcIiwgeyBwYXJ0OiBcImNvbmZpZy1vcHRpb24tdmFsdWVcIiB9LCBcImZhbHNlXCIpLFxuICAgICAgXCIgaW4gXCIsXG4gICAgICBoKFwiY29kZVwiLCB7IHBhcnQ6IFwiY29uZmlnLWZpbGUtbmFtZVwiIH0sIGhtckNvbmZpZ05hbWUpLFxuICAgICAgXCIuXCJcbiAgICApXG4gICksXG4gIGgoXCJzdHlsZVwiLCB7fSwgdGVtcGxhdGVTdHlsZSlcbik7XG5jb25zdCBmaWxlUkUgPSAvKD86W2EtekEtWl06XFxcXHxcXC8pLio/OlxcZCs6XFxkKy9nO1xuY29uc3QgY29kZWZyYW1lUkUgPSAvXig/Oj4/XFxzKlxcZCtcXHMrXFx8Lip8XFxzK1xcfFxccypcXF4uKilcXHI/XFxuL2dtO1xuY29uc3QgeyBIVE1MRWxlbWVudCA9IGNsYXNzIHtcbn0gfSA9IGdsb2JhbFRoaXM7XG5jbGFzcyBFcnJvck92ZXJsYXkgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGVyciwgbGlua3MgPSB0cnVlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6IFwib3BlblwiIH0pO1xuICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZChjcmVhdGVUZW1wbGF0ZSgpKTtcbiAgICBjb2RlZnJhbWVSRS5sYXN0SW5kZXggPSAwO1xuICAgIGNvbnN0IGhhc0ZyYW1lID0gZXJyLmZyYW1lICYmIGNvZGVmcmFtZVJFLnRlc3QoZXJyLmZyYW1lKTtcbiAgICBjb25zdCBtZXNzYWdlID0gaGFzRnJhbWUgPyBlcnIubWVzc2FnZS5yZXBsYWNlKGNvZGVmcmFtZVJFLCBcIlwiKSA6IGVyci5tZXNzYWdlO1xuICAgIGlmIChlcnIucGx1Z2luKSB7XG4gICAgICB0aGlzLnRleHQoXCIucGx1Z2luXCIsIGBbcGx1Z2luOiR7ZXJyLnBsdWdpbn1dIGApO1xuICAgIH1cbiAgICB0aGlzLnRleHQoXCIubWVzc2FnZS1ib2R5XCIsIG1lc3NhZ2UudHJpbSgpKTtcbiAgICBjb25zdCBbZmlsZV0gPSAoZXJyLmxvYz8uZmlsZSB8fCBlcnIuaWQgfHwgXCJ1bmtub3duIGZpbGVcIikuc3BsaXQoYD9gKTtcbiAgICBpZiAoZXJyLmxvYykge1xuICAgICAgdGhpcy50ZXh0KFwiLmZpbGVcIiwgYCR7ZmlsZX06JHtlcnIubG9jLmxpbmV9OiR7ZXJyLmxvYy5jb2x1bW59YCwgbGlua3MpO1xuICAgIH0gZWxzZSBpZiAoZXJyLmlkKSB7XG4gICAgICB0aGlzLnRleHQoXCIuZmlsZVwiLCBmaWxlKTtcbiAgICB9XG4gICAgaWYgKGhhc0ZyYW1lKSB7XG4gICAgICB0aGlzLnRleHQoXCIuZnJhbWVcIiwgZXJyLmZyYW1lLnRyaW0oKSk7XG4gICAgfVxuICAgIHRoaXMudGV4dChcIi5zdGFja1wiLCBlcnIuc3RhY2ssIGxpbmtzKTtcbiAgICB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihcIi53aW5kb3dcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9KTtcbiAgICB0aGlzLmNsb3NlT25Fc2MgPSAoZSkgPT4ge1xuICAgICAgaWYgKGUua2V5ID09PSBcIkVzY2FwZVwiIHx8IGUuY29kZSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLmNsb3NlT25Fc2MpO1xuICB9XG4gIHRleHQoc2VsZWN0b3IsIHRleHQsIGxpbmtGaWxlcyA9IGZhbHNlKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgaWYgKCFsaW5rRmlsZXMpIHtcbiAgICAgIGVsLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGN1ckluZGV4ID0gMDtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIGZpbGVSRS5sYXN0SW5kZXggPSAwO1xuICAgICAgd2hpbGUgKG1hdGNoID0gZmlsZVJFLmV4ZWModGV4dCkpIHtcbiAgICAgICAgY29uc3QgeyAwOiBmaWxlLCBpbmRleCB9ID0gbWF0Y2g7XG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgZnJhZyA9IHRleHQuc2xpY2UoY3VySW5kZXgsIGluZGV4KTtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShmcmFnKSk7XG4gICAgICAgICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgICAgICAgIGxpbmsudGV4dENvbnRlbnQgPSBmaWxlO1xuICAgICAgICAgIGxpbmsuY2xhc3NOYW1lID0gXCJmaWxlLWxpbmtcIjtcbiAgICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBmZXRjaChcbiAgICAgICAgICAgICAgbmV3IFVSTChcbiAgICAgICAgICAgICAgICBgJHtiYXNlJDF9X19vcGVuLWluLWVkaXRvcj9maWxlPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGZpbGUpfWAsXG4gICAgICAgICAgICAgICAgaW1wb3J0Lm1ldGEudXJsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBlbC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgICBjdXJJbmRleCArPSBmcmFnLmxlbmd0aCArIGZpbGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5jbG9zZU9uRXNjKTtcbiAgfVxufVxuY29uc3Qgb3ZlcmxheUlkID0gXCJ2aXRlLWVycm9yLW92ZXJsYXlcIjtcbmNvbnN0IHsgY3VzdG9tRWxlbWVudHMgfSA9IGdsb2JhbFRoaXM7XG5pZiAoY3VzdG9tRWxlbWVudHMgJiYgIWN1c3RvbUVsZW1lbnRzLmdldChvdmVybGF5SWQpKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShvdmVybGF5SWQsIEVycm9yT3ZlcmxheSk7XG59XG5cbmNvbnNvbGUuZGVidWcoXCJbdml0ZV0gY29ubmVjdGluZy4uLlwiKTtcbmNvbnN0IGltcG9ydE1ldGFVcmwgPSBuZXcgVVJMKGltcG9ydC5tZXRhLnVybCk7XG5jb25zdCBzZXJ2ZXJIb3N0ID0gXCJsb2NhbGhvc3Q6NTE3My9cIjtcbmNvbnN0IHNvY2tldFByb3RvY29sID0gbnVsbCB8fCAoaW1wb3J0TWV0YVVybC5wcm90b2NvbCA9PT0gXCJodHRwczpcIiA/IFwid3NzXCIgOiBcIndzXCIpO1xuY29uc3QgaG1yUG9ydCA9IG51bGw7XG5jb25zdCBzb2NrZXRIb3N0ID0gYCR7bnVsbCB8fCBpbXBvcnRNZXRhVXJsLmhvc3RuYW1lfToke2htclBvcnQgfHwgaW1wb3J0TWV0YVVybC5wb3J0fSR7XCIvXCJ9YDtcbmNvbnN0IGRpcmVjdFNvY2tldEhvc3QgPSBcImxvY2FsaG9zdDo1MTczL1wiO1xuY29uc3QgYmFzZSA9IFwiL1wiIHx8IFwiL1wiO1xuY29uc3Qgd3NUb2tlbiA9IFwiQjBsalBRM0xVX1NzXCI7XG5sZXQgc29ja2V0O1xudHJ5IHtcbiAgbGV0IGZhbGxiYWNrO1xuICBpZiAoIWhtclBvcnQpIHtcbiAgICBmYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHNvY2tldCA9IHNldHVwV2ViU29ja2V0KHNvY2tldFByb3RvY29sLCBkaXJlY3RTb2NrZXRIb3N0LCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY3JpcHRIb3N0VVJMID0gbmV3IFVSTChpbXBvcnQubWV0YS51cmwpO1xuICAgICAgICBjb25zdCBjdXJyZW50U2NyaXB0SG9zdCA9IGN1cnJlbnRTY3JpcHRIb3N0VVJMLmhvc3QgKyBjdXJyZW50U2NyaXB0SG9zdFVSTC5wYXRobmFtZS5yZXBsYWNlKC9Adml0ZVxcL2NsaWVudCQvLCBcIlwiKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBgW3ZpdGVdIGZhaWxlZCB0byBjb25uZWN0IHRvIHdlYnNvY2tldC5cbnlvdXIgY3VycmVudCBzZXR1cDpcbiAgKGJyb3dzZXIpICR7Y3VycmVudFNjcmlwdEhvc3R9IDwtLVtIVFRQXS0tPiAke3NlcnZlckhvc3R9IChzZXJ2ZXIpXG4gIChicm93c2VyKSAke3NvY2tldEhvc3R9IDwtLVtXZWJTb2NrZXQgKGZhaWxpbmcpXS0tPiAke2RpcmVjdFNvY2tldEhvc3R9IChzZXJ2ZXIpXG5DaGVjayBvdXQgeW91ciBWaXRlIC8gbmV0d29yayBjb25maWd1cmF0aW9uIGFuZCBodHRwczovL3ZpdGUuZGV2L2NvbmZpZy9zZXJ2ZXItb3B0aW9ucy5odG1sI3NlcnZlci1obXIgLmBcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwib3BlblwiLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgICAgXCJbdml0ZV0gRGlyZWN0IHdlYnNvY2tldCBjb25uZWN0aW9uIGZhbGxiYWNrLiBDaGVjayBvdXQgaHR0cHM6Ly92aXRlLmRldi9jb25maWcvc2VydmVyLW9wdGlvbnMuaHRtbCNzZXJ2ZXItaG1yIHRvIHJlbW92ZSB0aGUgcHJldmlvdXMgY29ubmVjdGlvbiBlcnJvci5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIHsgb25jZTogdHJ1ZSB9XG4gICAgICApO1xuICAgIH07XG4gIH1cbiAgc29ja2V0ID0gc2V0dXBXZWJTb2NrZXQoc29ja2V0UHJvdG9jb2wsIHNvY2tldEhvc3QsIGZhbGxiYWNrKTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIGNvbnNvbGUuZXJyb3IoYFt2aXRlXSBmYWlsZWQgdG8gY29ubmVjdCB0byB3ZWJzb2NrZXQgKCR7ZXJyb3J9KS4gYCk7XG59XG5mdW5jdGlvbiBzZXR1cFdlYlNvY2tldChwcm90b2NvbCwgaG9zdEFuZFBhdGgsIG9uQ2xvc2VXaXRob3V0T3Blbikge1xuICBjb25zdCBzb2NrZXQyID0gbmV3IFdlYlNvY2tldChcbiAgICBgJHtwcm90b2NvbH06Ly8ke2hvc3RBbmRQYXRofT90b2tlbj0ke3dzVG9rZW59YCxcbiAgICBcInZpdGUtaG1yXCJcbiAgKTtcbiAgbGV0IGlzT3BlbmVkID0gZmFsc2U7XG4gIHNvY2tldDIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBcIm9wZW5cIixcbiAgICAoKSA9PiB7XG4gICAgICBpc09wZW5lZCA9IHRydWU7XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoXCJ2aXRlOndzOmNvbm5lY3RcIiwgeyB3ZWJTb2NrZXQ6IHNvY2tldDIgfSk7XG4gICAgfSxcbiAgICB7IG9uY2U6IHRydWUgfVxuICApO1xuICBzb2NrZXQyLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGFzeW5jICh7IGRhdGEgfSkgPT4ge1xuICAgIGhhbmRsZU1lc3NhZ2UoSlNPTi5wYXJzZShkYXRhKSk7XG4gIH0pO1xuICBzb2NrZXQyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBhc3luYyAoeyB3YXNDbGVhbiB9KSA9PiB7XG4gICAgaWYgKHdhc0NsZWFuKSByZXR1cm47XG4gICAgaWYgKCFpc09wZW5lZCAmJiBvbkNsb3NlV2l0aG91dE9wZW4pIHtcbiAgICAgIG9uQ2xvc2VXaXRob3V0T3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub3RpZnlMaXN0ZW5lcnMoXCJ2aXRlOndzOmRpc2Nvbm5lY3RcIiwgeyB3ZWJTb2NrZXQ6IHNvY2tldDIgfSk7XG4gICAgaWYgKGhhc0RvY3VtZW50KSB7XG4gICAgICBjb25zb2xlLmxvZyhgW3ZpdGVdIHNlcnZlciBjb25uZWN0aW9uIGxvc3QuIFBvbGxpbmcgZm9yIHJlc3RhcnQuLi5gKTtcbiAgICAgIGF3YWl0IHdhaXRGb3JTdWNjZXNzZnVsUGluZyhwcm90b2NvbCwgaG9zdEFuZFBhdGgpO1xuICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNvY2tldDI7XG59XG5mdW5jdGlvbiBjbGVhblVybChwYXRobmFtZSkge1xuICBjb25zdCB1cmwgPSBuZXcgVVJMKHBhdGhuYW1lLCBcImh0dHA6Ly92aXRlLmRldlwiKTtcbiAgdXJsLnNlYXJjaFBhcmFtcy5kZWxldGUoXCJkaXJlY3RcIik7XG4gIHJldHVybiB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xufVxubGV0IGlzRmlyc3RVcGRhdGUgPSB0cnVlO1xuY29uc3Qgb3V0ZGF0ZWRMaW5rVGFncyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuY29uc3QgZGVib3VuY2VSZWxvYWQgPSAodGltZSkgPT4ge1xuICBsZXQgdGltZXI7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgaWYgKHRpbWVyKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgdGltZXIgPSBudWxsO1xuICAgIH1cbiAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfSwgdGltZSk7XG4gIH07XG59O1xuY29uc3QgcGFnZVJlbG9hZCA9IGRlYm91bmNlUmVsb2FkKDUwKTtcbmNvbnN0IGhtckNsaWVudCA9IG5ldyBITVJDbGllbnQoXG4gIGNvbnNvbGUsXG4gIHtcbiAgICBpc1JlYWR5OiAoKSA9PiBzb2NrZXQgJiYgc29ja2V0LnJlYWR5U3RhdGUgPT09IDEsXG4gICAgc2VuZDogKG1lc3NhZ2UpID0+IHNvY2tldC5zZW5kKG1lc3NhZ2UpXG4gIH0sXG4gIGFzeW5jIGZ1bmN0aW9uIGltcG9ydFVwZGF0ZWRNb2R1bGUoe1xuICAgIGFjY2VwdGVkUGF0aCxcbiAgICB0aW1lc3RhbXAsXG4gICAgZXhwbGljaXRJbXBvcnRSZXF1aXJlZCxcbiAgICBpc1dpdGhpbkNpcmN1bGFySW1wb3J0XG4gIH0pIHtcbiAgICBjb25zdCBbYWNjZXB0ZWRQYXRoV2l0aG91dFF1ZXJ5LCBxdWVyeV0gPSBhY2NlcHRlZFBhdGguc3BsaXQoYD9gKTtcbiAgICBjb25zdCBpbXBvcnRQcm9taXNlID0gaW1wb3J0KFxuICAgICAgLyogQHZpdGUtaWdub3JlICovXG4gICAgICBiYXNlICsgYWNjZXB0ZWRQYXRoV2l0aG91dFF1ZXJ5LnNsaWNlKDEpICsgYD8ke2V4cGxpY2l0SW1wb3J0UmVxdWlyZWQgPyBcImltcG9ydCZcIiA6IFwiXCJ9dD0ke3RpbWVzdGFtcH0ke3F1ZXJ5ID8gYCYke3F1ZXJ5fWAgOiBcIlwifWBcbiAgICApO1xuICAgIGlmIChpc1dpdGhpbkNpcmN1bGFySW1wb3J0KSB7XG4gICAgICBpbXBvcnRQcm9taXNlLmNhdGNoKCgpID0+IHtcbiAgICAgICAgY29uc29sZS5pbmZvKFxuICAgICAgICAgIGBbaG1yXSAke2FjY2VwdGVkUGF0aH0gZmFpbGVkIHRvIGFwcGx5IEhNUiBhcyBpdCdzIHdpdGhpbiBhIGNpcmN1bGFyIGltcG9ydC4gUmVsb2FkaW5nIHBhZ2UgdG8gcmVzZXQgdGhlIGV4ZWN1dGlvbiBvcmRlci4gVG8gZGVidWcgYW5kIGJyZWFrIHRoZSBjaXJjdWxhciBpbXBvcnQsIHlvdSBjYW4gcnVuIFxcYHZpdGUgLS1kZWJ1ZyBobXJcXGAgdG8gbG9nIHRoZSBjaXJjdWxhciBkZXBlbmRlbmN5IHBhdGggaWYgYSBmaWxlIGNoYW5nZSB0cmlnZ2VyZWQgaXQuYFxuICAgICAgICApO1xuICAgICAgICBwYWdlUmVsb2FkKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGltcG9ydFByb21pc2U7XG4gIH1cbik7XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKHBheWxvYWQpIHtcbiAgc3dpdGNoIChwYXlsb2FkLnR5cGUpIHtcbiAgICBjYXNlIFwiY29ubmVjdGVkXCI6XG4gICAgICBjb25zb2xlLmRlYnVnKGBbdml0ZV0gY29ubmVjdGVkLmApO1xuICAgICAgaG1yQ2xpZW50Lm1lc3Nlbmdlci5mbHVzaCgpO1xuICAgICAgc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICBpZiAoc29ja2V0LnJlYWR5U3RhdGUgPT09IHNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgc29ja2V0LnNlbmQoJ3tcInR5cGVcIjpcInBpbmdcIn0nKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwMDApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInVwZGF0ZVwiOlxuICAgICAgbm90aWZ5TGlzdGVuZXJzKFwidml0ZTpiZWZvcmVVcGRhdGVcIiwgcGF5bG9hZCk7XG4gICAgICBpZiAoaGFzRG9jdW1lbnQpIHtcbiAgICAgICAgaWYgKGlzRmlyc3RVcGRhdGUgJiYgaGFzRXJyb3JPdmVybGF5KCkpIHtcbiAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGVuYWJsZU92ZXJsYXkpIHtcbiAgICAgICAgICAgIGNsZWFyRXJyb3JPdmVybGF5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRmlyc3RVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgIHBheWxvYWQudXBkYXRlcy5tYXAoYXN5bmMgKHVwZGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICh1cGRhdGUudHlwZSA9PT0gXCJqcy11cGRhdGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIGhtckNsaWVudC5xdWV1ZVVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IHBhdGgsIHRpbWVzdGFtcCB9ID0gdXBkYXRlO1xuICAgICAgICAgIGNvbnN0IHNlYXJjaFVybCA9IGNsZWFuVXJsKHBhdGgpO1xuICAgICAgICAgIGNvbnN0IGVsID0gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpXG4gICAgICAgICAgKS5maW5kKFxuICAgICAgICAgICAgKGUpID0+ICFvdXRkYXRlZExpbmtUYWdzLmhhcyhlKSAmJiBjbGVhblVybChlLmhyZWYpLmluY2x1ZGVzKHNlYXJjaFVybClcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV3UGF0aCA9IGAke2Jhc2V9JHtzZWFyY2hVcmwuc2xpY2UoMSl9JHtzZWFyY2hVcmwuaW5jbHVkZXMoXCI/XCIpID8gXCImXCIgOiBcIj9cIn10PSR7dGltZXN0YW1wfWA7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdMaW5rVGFnID0gZWwuY2xvbmVOb2RlKCk7XG4gICAgICAgICAgICBuZXdMaW5rVGFnLmhyZWYgPSBuZXcgVVJMKG5ld1BhdGgsIGVsLmhyZWYpLmhyZWY7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVPbGRFbCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoYFt2aXRlXSBjc3MgaG90IHVwZGF0ZWQ6ICR7c2VhcmNoVXJsfWApO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3TGlua1RhZy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCByZW1vdmVPbGRFbCk7XG4gICAgICAgICAgICBuZXdMaW5rVGFnLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCByZW1vdmVPbGRFbCk7XG4gICAgICAgICAgICBvdXRkYXRlZExpbmtUYWdzLmFkZChlbCk7XG4gICAgICAgICAgICBlbC5hZnRlcihuZXdMaW5rVGFnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoXCJ2aXRlOmFmdGVyVXBkYXRlXCIsIHBheWxvYWQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImN1c3RvbVwiOiB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnMocGF5bG9hZC5ldmVudCwgcGF5bG9hZC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiZnVsbC1yZWxvYWRcIjpcbiAgICAgIG5vdGlmeUxpc3RlbmVycyhcInZpdGU6YmVmb3JlRnVsbFJlbG9hZFwiLCBwYXlsb2FkKTtcbiAgICAgIGlmIChoYXNEb2N1bWVudCkge1xuICAgICAgICBpZiAocGF5bG9hZC5wYXRoICYmIHBheWxvYWQucGF0aC5lbmRzV2l0aChcIi5odG1sXCIpKSB7XG4gICAgICAgICAgY29uc3QgcGFnZVBhdGggPSBkZWNvZGVVUkkobG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWRQYXRoID0gYmFzZSArIHBheWxvYWQucGF0aC5zbGljZSgxKTtcbiAgICAgICAgICBpZiAocGFnZVBhdGggPT09IHBheWxvYWRQYXRoIHx8IHBheWxvYWQucGF0aCA9PT0gXCIvaW5kZXguaHRtbFwiIHx8IHBhZ2VQYXRoLmVuZHNXaXRoKFwiL1wiKSAmJiBwYWdlUGF0aCArIFwiaW5kZXguaHRtbFwiID09PSBwYXlsb2FkUGF0aCkge1xuICAgICAgICAgICAgcGFnZVJlbG9hZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFnZVJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicHJ1bmVcIjpcbiAgICAgIG5vdGlmeUxpc3RlbmVycyhcInZpdGU6YmVmb3JlUHJ1bmVcIiwgcGF5bG9hZCk7XG4gICAgICBhd2FpdCBobXJDbGllbnQucHJ1bmVQYXRocyhwYXlsb2FkLnBhdGhzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICBub3RpZnlMaXN0ZW5lcnMoXCJ2aXRlOmVycm9yXCIsIHBheWxvYWQpO1xuICAgICAgaWYgKGhhc0RvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IGVyciA9IHBheWxvYWQuZXJyO1xuICAgICAgICBpZiAoZW5hYmxlT3ZlcmxheSkge1xuICAgICAgICAgIGNyZWF0ZUVycm9yT3ZlcmxheShlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICBgW3ZpdGVdIEludGVybmFsIFNlcnZlciBFcnJvclxuJHtlcnIubWVzc2FnZX1cbiR7ZXJyLnN0YWNrfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgY29uc3QgY2hlY2sgPSBwYXlsb2FkO1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGV2ZW50LCBkYXRhKSB7XG4gIGhtckNsaWVudC5ub3RpZnlMaXN0ZW5lcnMoZXZlbnQsIGRhdGEpO1xufVxuY29uc3QgZW5hYmxlT3ZlcmxheSA9IHRydWU7XG5jb25zdCBoYXNEb2N1bWVudCA9IFwiZG9jdW1lbnRcIiBpbiBnbG9iYWxUaGlzO1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JPdmVybGF5KGVycikge1xuICBjbGVhckVycm9yT3ZlcmxheSgpO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5ldyBFcnJvck92ZXJsYXkoZXJyKSk7XG59XG5mdW5jdGlvbiBjbGVhckVycm9yT3ZlcmxheSgpIHtcbiAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChvdmVybGF5SWQpLmZvckVhY2goKG4pID0+IG4uY2xvc2UoKSk7XG59XG5mdW5jdGlvbiBoYXNFcnJvck92ZXJsYXkoKSB7XG4gIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG92ZXJsYXlJZCkubGVuZ3RoO1xufVxuYXN5bmMgZnVuY3Rpb24gd2FpdEZvclN1Y2Nlc3NmdWxQaW5nKHNvY2tldFByb3RvY29sMiwgaG9zdEFuZFBhdGgsIG1zID0gMWUzKSB7XG4gIGNvbnN0IHBpbmdIb3N0UHJvdG9jb2wgPSBzb2NrZXRQcm90b2NvbDIgPT09IFwid3NzXCIgPyBcImh0dHBzXCIgOiBcImh0dHBcIjtcbiAgY29uc3QgcGluZyA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZmV0Y2goYCR7cGluZ0hvc3RQcm90b2NvbH06Ly8ke2hvc3RBbmRQYXRofWAsIHtcbiAgICAgICAgbW9kZTogXCJuby1jb3JzXCIsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAvLyBDdXN0b20gaGVhZGVycyB3b24ndCBiZSBpbmNsdWRlZCBpbiBhIHJlcXVlc3Qgd2l0aCBuby1jb3JzIHNvIChhYil1c2Ugb25lIG9mIHRoZVxuICAgICAgICAgIC8vIHNhZmVsaXN0ZWQgaGVhZGVycyB0byBpZGVudGlmeSB0aGUgcGluZyByZXF1ZXN0XG4gICAgICAgICAgQWNjZXB0OiBcInRleHQveC12aXRlLXBpbmdcIlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGlmIChhd2FpdCBwaW5nKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYXdhaXQgd2FpdChtcyk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgIGlmIChhd2FpdCBwaW5nKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhd2FpdCB3YWl0KG1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgd2FpdEZvcldpbmRvd1Nob3coKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdhaXQobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5mdW5jdGlvbiB3YWl0Rm9yV2luZG93U2hvdygpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcInZpc2libGVcIikge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIG9uQ2hhbmdlKTtcbiAgfSk7XG59XG5jb25zdCBzaGVldHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuaWYgKFwiZG9jdW1lbnRcIiBpbiBnbG9iYWxUaGlzKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtkYXRhLXZpdGUtZGV2LWlkXVwiKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgIHNoZWV0c01hcC5zZXQoZWwuZ2V0QXR0cmlidXRlKFwiZGF0YS12aXRlLWRldi1pZFwiKSwgZWwpO1xuICB9KTtcbn1cbmNvbnN0IGNzcE5vbmNlID0gXCJkb2N1bWVudFwiIGluIGdsb2JhbFRoaXMgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtwcm9wZXJ0eT1jc3Atbm9uY2VdXCIpPy5ub25jZSA6IHZvaWQgMDtcbmxldCBsYXN0SW5zZXJ0ZWRTdHlsZTtcbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlKGlkLCBjb250ZW50KSB7XG4gIGxldCBzdHlsZSA9IHNoZWV0c01hcC5nZXQoaWQpO1xuICBpZiAoIXN0eWxlKSB7XG4gICAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcImRhdGEtdml0ZS1kZXYtaWRcIiwgaWQpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICBpZiAoY3NwTm9uY2UpIHtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIGNzcE5vbmNlKTtcbiAgICB9XG4gICAgaWYgKCFsYXN0SW5zZXJ0ZWRTdHlsZSkge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbGFzdEluc2VydGVkU3R5bGUgPSB2b2lkIDA7XG4gICAgICB9LCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEluc2VydGVkU3R5bGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KFwiYWZ0ZXJlbmRcIiwgc3R5bGUpO1xuICAgIH1cbiAgICBsYXN0SW5zZXJ0ZWRTdHlsZSA9IHN0eWxlO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgfVxuICBzaGVldHNNYXAuc2V0KGlkLCBzdHlsZSk7XG59XG5mdW5jdGlvbiByZW1vdmVTdHlsZShpZCkge1xuICBjb25zdCBzdHlsZSA9IHNoZWV0c01hcC5nZXQoaWQpO1xuICBpZiAoc3R5bGUpIHtcbiAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICBzaGVldHNNYXAuZGVsZXRlKGlkKTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlSG90Q29udGV4dChvd25lclBhdGgpIHtcbiAgcmV0dXJuIG5ldyBITVJDb250ZXh0KGhtckNsaWVudCwgb3duZXJQYXRoKTtcbn1cbmZ1bmN0aW9uIGluamVjdFF1ZXJ5KHVybCwgcXVlcnlUb0luamVjdCkge1xuICBpZiAodXJsWzBdICE9PSBcIi5cIiAmJiB1cmxbMF0gIT09IFwiL1wiKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBjb25zdCBwYXRobmFtZSA9IHVybC5yZXBsYWNlKC9bPyNdLiokLywgXCJcIik7XG4gIGNvbnN0IHsgc2VhcmNoLCBoYXNoIH0gPSBuZXcgVVJMKHVybCwgXCJodHRwOi8vdml0ZS5kZXZcIik7XG4gIHJldHVybiBgJHtwYXRobmFtZX0/JHtxdWVyeVRvSW5qZWN0fSR7c2VhcmNoID8gYCZgICsgc2VhcmNoLnNsaWNlKDEpIDogXCJcIn0ke2hhc2ggfHwgXCJcIn1gO1xufVxuXG5leHBvcnQgeyBFcnJvck92ZXJsYXksIGNyZWF0ZUhvdENvbnRleHQsIGluamVjdFF1ZXJ5LCByZW1vdmVTdHlsZSwgdXBkYXRlU3R5bGUgfTtcbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFFO0FBQ0EsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNyQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDM0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDdEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2xFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNsRSxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUN0RCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUM5QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2hFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTtBQUN4RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXO0FBQzVDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEUsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDZixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdEQsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDYixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxRQUFRO0FBQ2xFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDYixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDO0FBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU87QUFDYixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2hELENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNoQyxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDZixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3RELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDZixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLENBQUMsQ0FBQztBQUNyRCxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDckQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ1gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUTtBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQzFELENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQztBQUNELEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNwQixDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7QUFDakMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNqQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRCxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDakIsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDO0FBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3hELENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ2xELENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN0QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDMUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNwQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSTtBQUN6RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUU7QUFDMUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7QUFDNUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzlELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNSLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNoSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU07QUFDakUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0FBQy9ELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztBQUNyRixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3JELENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3JDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUN0QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDN0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUMxQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQy9DLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQztBQUNwRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO0FBQ25FLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUMvRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQy9DLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0FBQ3RELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUMxRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDN0UsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDdkMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3hDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVCLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDM0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDZCxDQUFDO0FBQ0QsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNsQixDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNWLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNkLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNmLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDMUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQy9DLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNwQixDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3BCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNqQjtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQzFCLENBQUM7QUFDRDtBQUNBLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1YsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDckIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2xDLENBQUM7QUFDRDtBQUNBLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7QUFDekIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDcEIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDckIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO0FBQ2pDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDekUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNuQixDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ25CLENBQUM7QUFDRDtBQUNBLEdBQUcsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hCLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3hCLENBQUM7QUFDRDtBQUNBLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDaEIsQ0FBQztBQUNEO0FBQ0EsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDakIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNkLENBQUM7QUFDRDtBQUNBLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3JCLENBQUM7QUFDRDtBQUNBLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3hCLENBQUM7QUFDRDtBQUNBLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDVixDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDbkIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0FBQ3hCLENBQUM7QUFDRDtBQUNBLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEIsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZCLENBQUM7QUFDRDtBQUNBLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQixDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFDeEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO0FBQ3hCLENBQUM7QUFDRDtBQUNBLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDUixDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN2QixDQUFDO0FBQ0Q7QUFDQSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ1IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDbEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDcEIsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNkLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUM5QixDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNwQixDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsQ0FBQztBQUNEO0FBQ0EsSUFBSSxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNsQixDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDWixDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUM3QixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQ2xCLENBQUM7QUFDRDtBQUNBLEdBQUcsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDbEcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUMxQixDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDekIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUM5QyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUN0QixDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNoQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUN4QixDQUFDO0FBQ0QsQ0FBQztBQUNELENBQUMsQ0FBQztBQUNGLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNSLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDMUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNkLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3RFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMxRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUNiLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDSixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztBQUMvQixDQUFDLENBQUM7QUFDRixLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEQsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDL0QsS0FBSyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztBQUNqQixLQUFLLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUN4QyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzlELENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO0FBQ2xGLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDN0UsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUM7QUFDMUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDMUQsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ2pELENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM1QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ2hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHO0FBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRCxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDdkMsS0FBSyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7QUFDdEMsRUFBRSxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkQsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUNEO0FBQ0EsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDL0MsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNyQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDcEYsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3JCLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RixLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDM0MsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDL0IsR0FBRyxDQUFDLE1BQU0sQ0FBQztBQUNYLEdBQUcsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7QUFDZixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDOUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxSCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDO0FBQ2pELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3BFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDbEYsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNmLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ3ZCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3BLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNWLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNoRSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztBQUNqQixDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEUsQ0FBQztBQUNELFFBQVEsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUN2QixDQUFDLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDO0FBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdELENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxDQUFDO0FBQzFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDYixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsUUFBUSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQUNELFFBQVEsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDbkQsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUNwQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7QUFDbkMsQ0FBQztBQUNELEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN6QixLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDaEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUNGLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN0QyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQzNDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDSixDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLHNCQUFzQjtBQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsd0JBQXdCLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDakMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLHdCQUF3QixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQztBQUNqQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hSLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUM7QUFDRixLQUFLLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQ3JCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2pELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2pELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDM0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUNqQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztBQUNuRixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNuQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQzdHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNkLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUM7QUFDN0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLGdCQUFnQixDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM5RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUNqQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNWLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNSLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ25ELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ3ZCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDeEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ3hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUNoSixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDaEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQ3ZCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxLQUFLO0FBQ3pDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNiLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQzVCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUM7QUFDbkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDO0FBQ0QsUUFBUSxDQUFDLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxTQUFTLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFDRCxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDM0IsS0FBSyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDO0FBQzdDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7QUFDdEIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNuRCxDQUFDO0FBQ0QsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqRSxDQUFDO0FBQ0QsUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDckQsQ0FBQztBQUNELEtBQUssQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsZUFBZSxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzlFLENBQUMsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVCLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRztBQUM3RixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU87QUFDNUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUNwQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNiLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNqQixDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0osQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDakIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDaEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNaLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDO0FBQ0QsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUM7QUFDRCxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQ25FLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLGdCQUFnQixDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzVELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFDRCxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUM1QyxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0FBQy9CLENBQUMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDM0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUNELEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUMvRyxHQUFHLENBQUMsaUJBQWlCLENBQUM7QUFDdEIsUUFBUSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDZixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzVDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7QUFDN0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDdkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDVixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUNoQyxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQzNCLENBQUM7QUFDRCxRQUFRLENBQUMsV0FBVyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDMUIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDbEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUN6QixDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRCxRQUFRLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUN0QyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDOUMsQ0FBQztBQUNELFFBQVEsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUM7QUFDZixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzRixDQUFDO0FBQ0Q7QUFDQSxNQUFNLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQzsifQ=="
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.652Z",
        "time": 9.776999997610693,
        "timings": {
          "blocked": 4.1720000008598435,
          "dns": 0.0050000000000000044,
          "ssl": -1,
          "connect": 0.9129999999999999,
          "send": 0.397,
          "wait": 3.543999998861691,
          "receive": 0.7459999978891574,
          "_blocked_queueing": 3.6670000008598436,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184622",
        "_initiator": {
          "type": "parser",
          "url": "http://localhost:5174/",
          "lineNumber": 17
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/main.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"4da-KsJIufb+yS2ENkHMxyPSngX0Ei8\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 510,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 2365,
            "mimeType": "text/javascript",
            "text": "import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport __vite__cjsImport1_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const React = __vite__cjsImport1_react.__esModule ? __vite__cjsImport1_react.default : __vite__cjsImport1_react;\nimport __vite__cjsImport2_reactDom_client from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-dom_client.js?v=2a7591ed\"; const ReactDOM = __vite__cjsImport2_reactDom_client.__esModule ? __vite__cjsImport2_reactDom_client.default : __vite__cjsImport2_reactDom_client;\nimport App from \"/App.tsx\";\nimport \"/styles/index.css\";\nimport \"/styles/markdown.css\";\nimport \"/styles/file-upload.css\";\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n  /* @__PURE__ */ jsxDEV(React.StrictMode, { children: /* @__PURE__ */ jsxDEV(App, {}, void 0, false, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/main.tsx\",\n    lineNumber: 10,\n    columnNumber: 5\n  }, this) }, void 0, false, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/main.tsx\",\n    lineNumber: 9,\n    columnNumber: 3\n  }, this)\n);\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBU0k7QUFUSixPQUFPQSxXQUFXO0FBQ2xCLE9BQU9DLGNBQWM7QUFDckIsT0FBT0MsU0FBUztBQUNoQixPQUFPO0FBQ1AsT0FBTztBQUNQLE9BQU87QUFFUEQsU0FBU0UsV0FBV0MsU0FBU0MsZUFBZSxNQUFNLENBQUUsRUFBRUM7QUFBQUEsRUFDcEQsdUJBQUMsTUFBTSxZQUFOLEVBQ0MsaUNBQUMsU0FBRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBQUksS0FETjtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBRUE7QUFDRiIsIm5hbWVzIjpbIlJlYWN0IiwiUmVhY3RET00iLCJBcHAiLCJjcmVhdGVSb290IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInJlbmRlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJtYWluLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tL2NsaWVudCc7XHJcbmltcG9ydCBBcHAgZnJvbSAnLi9BcHAnO1xyXG5pbXBvcnQgJy4vc3R5bGVzL2luZGV4LmNzcyc7XHJcbmltcG9ydCAnLi9zdHlsZXMvbWFya2Rvd24uY3NzJztcclxuaW1wb3J0ICcuL3N0eWxlcy9maWxlLXVwbG9hZC5jc3MnO1xyXG5cclxuUmVhY3RET00uY3JlYXRlUm9vdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm9vdCcpISkucmVuZGVyKFxyXG4gIDxSZWFjdC5TdHJpY3RNb2RlPlxyXG4gICAgPEFwcCAvPlxyXG4gIDwvUmVhY3QuU3RyaWN0TW9kZT5cclxuKTsiXSwiZmlsZSI6Ii9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL21haW4udHN4In0="
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.653Z",
        "time": 9.988000001865439,
        "timings": {
          "blocked": 4.487000000364846,
          "dns": 0.010000000000000009,
          "ssl": -1,
          "connect": 0.42300000000000004,
          "send": 0.643,
          "wait": 4.190999998680781,
          "receive": 0.23400000281981193,
          "_blocked_queueing": 3.7730000003648456,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184622",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/",
          "lineNumber": 3
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@react-refresh",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"5459-W4xlIRvs7CzM1FW1IVU0Uw0TIxA\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 517,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 117548,
            "mimeType": "text/javascript",
            "text": "import { injectQuery as __vite__injectQuery } from \"/@vite/client\";/* global window */\n/* eslint-disable eqeqeq, prefer-const, @typescript-eslint/no-empty-function */\n\n/*! Copyright (c) Meta Platforms, Inc. and affiliates. **/\n/**\n * This is simplified pure-js version of https://github.com/facebook/react/blob/main/packages/react-refresh/src/ReactFreshRuntime.js\n * without IE11 compatibility and verbose isDev checks.\n * Some utils are appended at the bottom for HMR integration.\n */\n\nconst REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref')\nconst REACT_MEMO_TYPE = Symbol.for('react.memo')\n\n// We never remove these associations.\n// It's OK to reference families, but use WeakMap/Set for types.\nlet allFamiliesByID = new Map()\nlet allFamiliesByType = new WeakMap()\nlet allSignaturesByType = new WeakMap()\n\n// This WeakMap is read by React, so we only put families\n// that have actually been edited here. This keeps checks fast.\nconst updatedFamiliesByType = new WeakMap()\n\n// This is cleared on every performReactRefresh() call.\n// It is an array of [Family, NextType] tuples.\nlet pendingUpdates = []\n\n// This is injected by the renderer via DevTools global hook.\nconst helpersByRendererID = new Map()\n\nconst helpersByRoot = new Map()\n\n// We keep track of mounted roots so we can schedule updates.\nconst mountedRoots = new Set()\n// If a root captures an error, we remember it so we can retry on edit.\nconst failedRoots = new Set()\n\n// We also remember the last element for every root.\n// It needs to be weak because we do this even for roots that failed to mount.\n// If there is no WeakMap, we won't attempt to do retrying.\nlet rootElements = new WeakMap()\nlet isPerformingRefresh = false\n\nfunction computeFullKey(signature) {\n  if (signature.fullKey !== null) {\n    return signature.fullKey\n  }\n\n  let fullKey = signature.ownKey\n  let hooks\n  try {\n    hooks = signature.getCustomHooks()\n  } catch (err) {\n    // This can happen in an edge case, e.g. if expression like Foo.useSomething\n    // depends on Foo which is lazily initialized during rendering.\n    // In that case just assume we'll have to remount.\n    signature.forceReset = true\n    signature.fullKey = fullKey\n    return fullKey\n  }\n\n  for (let i = 0; i < hooks.length; i++) {\n    const hook = hooks[i]\n    if (typeof hook !== 'function') {\n      // Something's wrong. Assume we need to remount.\n      signature.forceReset = true\n      signature.fullKey = fullKey\n      return fullKey\n    }\n    const nestedHookSignature = allSignaturesByType.get(hook)\n    if (nestedHookSignature === undefined) {\n      // No signature means Hook wasn't in the source code, e.g. in a library.\n      // We'll skip it because we can assume it won't change during this session.\n      continue\n    }\n    const nestedHookKey = computeFullKey(nestedHookSignature)\n    if (nestedHookSignature.forceReset) {\n      signature.forceReset = true\n    }\n    fullKey += '\\n---\\n' + nestedHookKey\n  }\n\n  signature.fullKey = fullKey\n  return fullKey\n}\n\nfunction haveEqualSignatures(prevType, nextType) {\n  const prevSignature = allSignaturesByType.get(prevType)\n  const nextSignature = allSignaturesByType.get(nextType)\n\n  if (prevSignature === undefined && nextSignature === undefined) {\n    return true\n  }\n  if (prevSignature === undefined || nextSignature === undefined) {\n    return false\n  }\n  if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {\n    return false\n  }\n  if (nextSignature.forceReset) {\n    return false\n  }\n\n  return true\n}\n\nfunction isReactClass(type) {\n  return type.prototype && type.prototype.isReactComponent\n}\n\nfunction canPreserveStateBetween(prevType, nextType) {\n  if (isReactClass(prevType) || isReactClass(nextType)) {\n    return false\n  }\n  if (haveEqualSignatures(prevType, nextType)) {\n    return true\n  }\n  return false\n}\n\nfunction resolveFamily(type) {\n  // Only check updated types to keep lookups fast.\n  return updatedFamiliesByType.get(type)\n}\n\n// This is a safety mechanism to protect against rogue getters and Proxies.\nfunction getProperty(object, property) {\n  try {\n    return object[property]\n  } catch (err) {\n    // Intentionally ignore.\n    return undefined\n  }\n}\n\nfunction performReactRefresh() {\n  if (pendingUpdates.length === 0) {\n    return null\n  }\n  if (isPerformingRefresh) {\n    return null\n  }\n\n  isPerformingRefresh = true\n  try {\n    const staleFamilies = new Set()\n    const updatedFamilies = new Set()\n\n    const updates = pendingUpdates\n    pendingUpdates = []\n    updates.forEach(([family, nextType]) => {\n      // Now that we got a real edit, we can create associations\n      // that will be read by the React reconciler.\n      const prevType = family.current\n      updatedFamiliesByType.set(prevType, family)\n      updatedFamiliesByType.set(nextType, family)\n      family.current = nextType\n\n      // Determine whether this should be a re-render or a re-mount.\n      if (canPreserveStateBetween(prevType, nextType)) {\n        updatedFamilies.add(family)\n      } else {\n        staleFamilies.add(family)\n      }\n    })\n\n    // TODO: rename these fields to something more meaningful.\n    const update = {\n      updatedFamilies, // Families that will re-render preserving state\n      staleFamilies, // Families that will be remounted\n    }\n\n    helpersByRendererID.forEach((helpers) => {\n      // Even if there are no roots, set the handler on first update.\n      // This ensures that if *new* roots are mounted, they'll use the resolve handler.\n      helpers.setRefreshHandler(resolveFamily)\n    })\n\n    let didError = false\n    let firstError = null\n\n    // We snapshot maps and sets that are mutated during commits.\n    // If we don't do this, there is a risk they will be mutated while\n    // we iterate over them. For example, trying to recover a failed root\n    // may cause another root to be added to the failed list -- an infinite loop.\n    const failedRootsSnapshot = new Set(failedRoots)\n    const mountedRootsSnapshot = new Set(mountedRoots)\n    const helpersByRootSnapshot = new Map(helpersByRoot)\n\n    failedRootsSnapshot.forEach((root) => {\n      const helpers = helpersByRootSnapshot.get(root)\n      if (helpers === undefined) {\n        throw new Error(\n          'Could not find helpers for a root. This is a bug in React Refresh.',\n        )\n      }\n      if (!failedRoots.has(root)) {\n        // No longer failed.\n      }\n      if (rootElements === null) {\n        return\n      }\n      if (!rootElements.has(root)) {\n        return\n      }\n      const element = rootElements.get(root)\n      try {\n        helpers.scheduleRoot(root, element)\n      } catch (err) {\n        if (!didError) {\n          didError = true\n          firstError = err\n        }\n        // Keep trying other roots.\n      }\n    })\n    mountedRootsSnapshot.forEach((root) => {\n      const helpers = helpersByRootSnapshot.get(root)\n      if (helpers === undefined) {\n        throw new Error(\n          'Could not find helpers for a root. This is a bug in React Refresh.',\n        )\n      }\n      if (!mountedRoots.has(root)) {\n        // No longer mounted.\n      }\n      try {\n        helpers.scheduleRefresh(root, update)\n      } catch (err) {\n        if (!didError) {\n          didError = true\n          firstError = err\n        }\n        // Keep trying other roots.\n      }\n    })\n    if (didError) {\n      throw firstError\n    }\n    return update\n  } finally {\n    isPerformingRefresh = false\n  }\n}\n\nfunction register(type, id) {\n  if (type === null) {\n    return\n  }\n  if (typeof type !== 'function' && typeof type !== 'object') {\n    return\n  }\n\n  // This can happen in an edge case, e.g. if we register\n  // return value of a HOC but it returns a cached component.\n  // Ignore anything but the first registration for each type.\n  if (allFamiliesByType.has(type)) {\n    return\n  }\n  // Create family or remember to update it.\n  // None of this bookkeeping affects reconciliation\n  // until the first performReactRefresh() call above.\n  let family = allFamiliesByID.get(id)\n  if (family === undefined) {\n    family = { current: type }\n    allFamiliesByID.set(id, family)\n  } else {\n    pendingUpdates.push([family, type])\n  }\n  allFamiliesByType.set(type, family)\n\n  // Visit inner types because we might not have registered them.\n  if (typeof type === 'object' && type !== null) {\n    switch (getProperty(type, '$$typeof')) {\n      case REACT_FORWARD_REF_TYPE:\n        register(type.render, id + '$render')\n        break\n      case REACT_MEMO_TYPE:\n        register(type.type, id + '$type')\n        break\n    }\n  }\n}\n\nfunction setSignature(type, key, forceReset, getCustomHooks) {\n  if (!allSignaturesByType.has(type)) {\n    allSignaturesByType.set(type, {\n      forceReset,\n      ownKey: key,\n      fullKey: null,\n      getCustomHooks: getCustomHooks || (() => []),\n    })\n  }\n  // Visit inner types because we might not have signed them.\n  if (typeof type === 'object' && type !== null) {\n    switch (getProperty(type, '$$typeof')) {\n      case REACT_FORWARD_REF_TYPE:\n        setSignature(type.render, key, forceReset, getCustomHooks)\n        break\n      case REACT_MEMO_TYPE:\n        setSignature(type.type, key, forceReset, getCustomHooks)\n        break\n    }\n  }\n}\n\n// This is lazily called during first render for a type.\n// It captures Hook list at that time so inline requires don't break comparisons.\nfunction collectCustomHooksForSignature(type) {\n  const signature = allSignaturesByType.get(type)\n  if (signature !== undefined) {\n    computeFullKey(signature)\n  }\n}\n\nexport function injectIntoGlobalHook(globalObject) {\n  // For React Native, the global hook will be set up by require('react-devtools-core').\n  // That code will run before us. So we need to monkeypatch functions on existing hook.\n\n  // For React Web, the global hook will be set up by the extension.\n  // This will also run before us.\n  let hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__\n  if (hook === undefined) {\n    // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.\n    // Note that in this case it's important that renderer code runs *after* this method call.\n    // Otherwise, the renderer will think that there is no global hook, and won't do the injection.\n    let nextID = 0\n    globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {\n      renderers: new Map(),\n      supportsFiber: true,\n      inject: (injected) => nextID++,\n      onScheduleFiberRoot: (id, root, children) => {},\n      onCommitFiberRoot: (id, root, maybePriorityLevel, didError) => {},\n      onCommitFiberUnmount() {},\n    }\n  }\n\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // Using console['warn'] to evade Babel and ESLint\n    console['warn'](\n      'Something has shimmed the React DevTools global hook (__REACT_DEVTOOLS_GLOBAL_HOOK__). ' +\n        'Fast Refresh is not compatible with this shim and will be disabled.',\n    )\n    return\n  }\n\n  // Here, we just want to get a reference to scheduleRefresh.\n  const oldInject = hook.inject\n  hook.inject = function (injected) {\n    const id = oldInject.apply(this, arguments)\n    if (\n      typeof injected.scheduleRefresh === 'function' &&\n      typeof injected.setRefreshHandler === 'function'\n    ) {\n      // This version supports React Refresh.\n      helpersByRendererID.set(id, injected)\n    }\n    return id\n  }\n\n  // Do the same for any already injected roots.\n  // This is useful if ReactDOM has already been initialized.\n  // https://github.com/facebook/react/issues/17626\n  hook.renderers.forEach((injected, id) => {\n    if (\n      typeof injected.scheduleRefresh === 'function' &&\n      typeof injected.setRefreshHandler === 'function'\n    ) {\n      // This version supports React Refresh.\n      helpersByRendererID.set(id, injected)\n    }\n  })\n\n  // We also want to track currently mounted roots.\n  const oldOnCommitFiberRoot = hook.onCommitFiberRoot\n  const oldOnScheduleFiberRoot = hook.onScheduleFiberRoot || (() => {})\n  hook.onScheduleFiberRoot = function (id, root, children) {\n    if (!isPerformingRefresh) {\n      // If it was intentionally scheduled, don't attempt to restore.\n      // This includes intentionally scheduled unmounts.\n      failedRoots.delete(root)\n      if (rootElements !== null) {\n        rootElements.set(root, children)\n      }\n    }\n    return oldOnScheduleFiberRoot.apply(this, arguments)\n  }\n  hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {\n    const helpers = helpersByRendererID.get(id)\n    if (helpers !== undefined) {\n      helpersByRoot.set(root, helpers)\n\n      const current = root.current\n      const alternate = current.alternate\n\n      // We need to determine whether this root has just (un)mounted.\n      // This logic is copy-pasted from similar logic in the DevTools backend.\n      // If this breaks with some refactoring, you'll want to update DevTools too.\n\n      if (alternate !== null) {\n        const wasMounted =\n          alternate.memoizedState != null &&\n          alternate.memoizedState.element != null &&\n          mountedRoots.has(root)\n\n        const isMounted =\n          current.memoizedState != null && current.memoizedState.element != null\n\n        if (!wasMounted && isMounted) {\n          // Mount a new root.\n          mountedRoots.add(root)\n          failedRoots.delete(root)\n        } else if (wasMounted && isMounted) {\n          // Update an existing root.\n          // This doesn't affect our mounted root Set.\n        } else if (wasMounted && !isMounted) {\n          // Unmount an existing root.\n          mountedRoots.delete(root)\n          if (didError) {\n            // We'll remount it on future edits.\n            failedRoots.add(root)\n          } else {\n            helpersByRoot.delete(root)\n          }\n        } else if (!wasMounted && !isMounted) {\n          if (didError) {\n            // We'll remount it on future edits.\n            failedRoots.add(root)\n          }\n        }\n      } else {\n        // Mount a new root.\n        mountedRoots.add(root)\n      }\n    }\n\n    // Always call the decorated DevTools hook.\n    return oldOnCommitFiberRoot.apply(this, arguments)\n  }\n}\n\n// This is a wrapper over more primitive functions for setting signature.\n// Signatures let us decide whether the Hook order has changed on refresh.\n//\n// This function is intended to be used as a transform target, e.g.:\n// var _s = createSignatureFunctionForTransform()\n//\n// function Hello() {\n//   const [foo, setFoo] = useState(0);\n//   const value = useCustomHook();\n//   _s(); /* Call without arguments triggers collecting the custom Hook list.\n//          * This doesn't happen during the module evaluation because we\n//          * don't want to change the module order with inline requires.\n//          * Next calls are noops. */\n//   return <h1>Hi</h1>;\n// }\n//\n// /* Call with arguments attaches the signature to the type: */\n// _s(\n//   Hello,\n//   'useState{[foo, setFoo]}(0)',\n//   () => [useCustomHook], /* Lazy to avoid triggering inline requires */\n// );\nexport function createSignatureFunctionForTransform() {\n  let savedType\n  let hasCustomHooks\n  let didCollectHooks = false\n  return function (type, key, forceReset, getCustomHooks) {\n    if (typeof key === 'string') {\n      // We're in the initial phase that associates signatures\n      // with the functions. Note this may be called multiple times\n      // in HOC chains like _s(hoc1(_s(hoc2(_s(actualFunction))))).\n      if (!savedType) {\n        // We're in the innermost call, so this is the actual type.\n        // $FlowFixMe[escaped-generic] discovered when updating Flow\n        savedType = type\n        hasCustomHooks = typeof getCustomHooks === 'function'\n      }\n      // Set the signature for all types (even wrappers!) in case\n      // they have no signatures of their own. This is to prevent\n      // problems like https://github.com/facebook/react/issues/20417.\n      if (\n        type != null &&\n        (typeof type === 'function' || typeof type === 'object')\n      ) {\n        setSignature(type, key, forceReset, getCustomHooks)\n      }\n      return type\n    } else {\n      // We're in the _s() call without arguments, which means\n      // this is the time to collect custom Hook signatures.\n      // Only do this once. This path is hot and runs *inside* every render!\n      if (!didCollectHooks && hasCustomHooks) {\n        didCollectHooks = true\n        collectCustomHooksForSignature(savedType)\n      }\n    }\n  }\n}\n\nfunction isLikelyComponentType(type) {\n  switch (typeof type) {\n    case 'function': {\n      // First, deal with classes.\n      if (type.prototype != null) {\n        if (type.prototype.isReactComponent) {\n          // React class.\n          return true\n        }\n        const ownNames = Object.getOwnPropertyNames(type.prototype)\n        if (ownNames.length > 1 || ownNames[0] !== 'constructor') {\n          // This looks like a class.\n          return false\n        }\n\n        if (type.prototype.__proto__ !== Object.prototype) {\n          // It has a superclass.\n          return false\n        }\n        // Pass through.\n        // This looks like a regular function with empty prototype.\n      }\n      // For plain functions and arrows, use name as a heuristic.\n      const name = type.name || type.displayName\n      return typeof name === 'string' && /^[A-Z]/.test(name)\n    }\n    case 'object': {\n      if (type != null) {\n        switch (getProperty(type, '$$typeof')) {\n          case REACT_FORWARD_REF_TYPE:\n          case REACT_MEMO_TYPE:\n            // Definitely React components.\n            return true\n          default:\n            return false\n        }\n      }\n      return false\n    }\n    default: {\n      return false\n    }\n  }\n}\n\nfunction isCompoundComponent(type) {\n  if (!isPlainObject(type)) return false\n  for (const key in type) {\n    if (!isLikelyComponentType(type[key])) return false\n  }\n  return true\n}\n\nfunction isPlainObject(obj) {\n  return (\n    Object.prototype.toString.call(obj) === '[object Object]' &&\n    (obj.constructor === Object || obj.constructor === undefined)\n  )\n}\n\n/**\n * Plugin utils\n */\n\nexport function getRefreshReg(filename) {\n  return (type, id) => register(type, filename + ' ' + id)\n}\n\n// Taken from https://github.com/pmmmwh/react-refresh-webpack-plugin/blob/main/lib/runtime/RefreshUtils.js#L141\n// This allows to resister components not detected by SWC like styled component\nexport function registerExportsForReactRefresh(filename, moduleExports) {\n  for (const key in moduleExports) {\n    if (key === '__esModule') continue\n    const exportValue = moduleExports[key]\n    if (isLikelyComponentType(exportValue)) {\n      // 'export' is required to avoid key collision when renamed exports that\n      // shadow a local component name: https://github.com/vitejs/vite-plugin-react/issues/116\n      // The register function has an identity check to not register twice the same component,\n      // so this is safe to not used the same key here.\n      register(exportValue, filename + ' export ' + key)\n    } else if (isCompoundComponent(exportValue)) {\n      for (const subKey in exportValue) {\n        register(\n          exportValue[subKey],\n          filename + ' export ' + key + '-' + subKey,\n        )\n      }\n    }\n  }\n}\n\nfunction debounce(fn, delay) {\n  let handle\n  return () => {\n    clearTimeout(handle)\n    handle = setTimeout(fn, delay)\n  }\n}\n\nconst hooks = []\nwindow.__registerBeforePerformReactRefresh = (cb) => {\n  hooks.push(cb)\n}\nconst enqueueUpdate = debounce(async () => {\n  if (hooks.length) await Promise.all(hooks.map((cb) => cb()))\n  performReactRefresh()\n}, 16)\n\nexport function validateRefreshBoundaryAndEnqueueUpdate(\n  id,\n  prevExports,\n  nextExports,\n) {\n  const ignoredExports = window.__getReactRefreshIgnoredExports?.({ id }) ?? []\n  if (\n    predicateOnExport(\n      ignoredExports,\n      prevExports,\n      (key) => key in nextExports,\n    ) !== true\n  ) {\n    return 'Could not Fast Refresh (export removed)'\n  }\n  if (\n    predicateOnExport(\n      ignoredExports,\n      nextExports,\n      (key) => key in prevExports,\n    ) !== true\n  ) {\n    return 'Could not Fast Refresh (new export)'\n  }\n\n  let hasExports = false\n  const allExportsAreComponentsOrUnchanged = predicateOnExport(\n    ignoredExports,\n    nextExports,\n    (key, value) => {\n      hasExports = true\n      if (isLikelyComponentType(value)) return true\n      if (isCompoundComponent(value)) return true\n      return prevExports[key] === nextExports[key]\n    },\n  )\n  if (hasExports && allExportsAreComponentsOrUnchanged === true) {\n    enqueueUpdate()\n  } else {\n    return `Could not Fast Refresh (\"${allExportsAreComponentsOrUnchanged}\" export is incompatible). Learn more at https://github.com/vitejs/vite-plugin-react/tree/main/packages/plugin-react#consistent-components-exports`\n  }\n}\n\nfunction predicateOnExport(ignoredExports, moduleExports, predicate) {\n  for (const key in moduleExports) {\n    if (key === '__esModule') continue\n    if (ignoredExports.includes(key)) continue\n    const desc = Object.getOwnPropertyDescriptor(moduleExports, key)\n    if (desc && desc.get) return key\n    if (!predicate(key, moduleExports[key])) return key\n  }\n  return true\n}\n\n// Hides vite-ignored dynamic import so that Vite can skip analysis if no other\n// dynamic import is present (https://github.com/vitejs/vite/pull/12732)\nexport const __hmr_import = (module) => import(/* @vite-ignore */ __vite__injectQuery(module, 'import'))\n\n// For backwards compatibility with @vitejs/plugin-react.\nexport default { injectIntoGlobalHook }\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIkByZWFjdC1yZWZyZXNoIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluamVjdFF1ZXJ5IGFzIF9fdml0ZV9faW5qZWN0UXVlcnkgfSBmcm9tIFwiL0B2aXRlL2NsaWVudFwiOy8qIGdsb2JhbCB3aW5kb3cgKi9cbi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSwgcHJlZmVyLWNvbnN0LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cblxuLyohIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuICoqL1xuLyoqXG4gKiBUaGlzIGlzIHNpbXBsaWZpZWQgcHVyZS1qcyB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL21haW4vcGFja2FnZXMvcmVhY3QtcmVmcmVzaC9zcmMvUmVhY3RGcmVzaFJ1bnRpbWUuanNcbiAqIHdpdGhvdXQgSUUxMSBjb21wYXRpYmlsaXR5IGFuZCB2ZXJib3NlIGlzRGV2IGNoZWNrcy5cbiAqIFNvbWUgdXRpbHMgYXJlIGFwcGVuZGVkIGF0IHRoZSBib3R0b20gZm9yIEhNUiBpbnRlZ3JhdGlvbi5cbiAqL1xuXG5jb25zdCBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKVxuY29uc3QgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpXG5cbi8vIFdlIG5ldmVyIHJlbW92ZSB0aGVzZSBhc3NvY2lhdGlvbnMuXG4vLyBJdCdzIE9LIHRvIHJlZmVyZW5jZSBmYW1pbGllcywgYnV0IHVzZSBXZWFrTWFwL1NldCBmb3IgdHlwZXMuXG5sZXQgYWxsRmFtaWxpZXNCeUlEID0gbmV3IE1hcCgpXG5sZXQgYWxsRmFtaWxpZXNCeVR5cGUgPSBuZXcgV2Vha01hcCgpXG5sZXQgYWxsU2lnbmF0dXJlc0J5VHlwZSA9IG5ldyBXZWFrTWFwKClcblxuLy8gVGhpcyBXZWFrTWFwIGlzIHJlYWQgYnkgUmVhY3QsIHNvIHdlIG9ubHkgcHV0IGZhbWlsaWVzXG4vLyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBlZGl0ZWQgaGVyZS4gVGhpcyBrZWVwcyBjaGVja3MgZmFzdC5cbmNvbnN0IHVwZGF0ZWRGYW1pbGllc0J5VHlwZSA9IG5ldyBXZWFrTWFwKClcblxuLy8gVGhpcyBpcyBjbGVhcmVkIG9uIGV2ZXJ5IHBlcmZvcm1SZWFjdFJlZnJlc2goKSBjYWxsLlxuLy8gSXQgaXMgYW4gYXJyYXkgb2YgW0ZhbWlseSwgTmV4dFR5cGVdIHR1cGxlcy5cbmxldCBwZW5kaW5nVXBkYXRlcyA9IFtdXG5cbi8vIFRoaXMgaXMgaW5qZWN0ZWQgYnkgdGhlIHJlbmRlcmVyIHZpYSBEZXZUb29scyBnbG9iYWwgaG9vay5cbmNvbnN0IGhlbHBlcnNCeVJlbmRlcmVySUQgPSBuZXcgTWFwKClcblxuY29uc3QgaGVscGVyc0J5Um9vdCA9IG5ldyBNYXAoKVxuXG4vLyBXZSBrZWVwIHRyYWNrIG9mIG1vdW50ZWQgcm9vdHMgc28gd2UgY2FuIHNjaGVkdWxlIHVwZGF0ZXMuXG5jb25zdCBtb3VudGVkUm9vdHMgPSBuZXcgU2V0KClcbi8vIElmIGEgcm9vdCBjYXB0dXJlcyBhbiBlcnJvciwgd2UgcmVtZW1iZXIgaXQgc28gd2UgY2FuIHJldHJ5IG9uIGVkaXQuXG5jb25zdCBmYWlsZWRSb290cyA9IG5ldyBTZXQoKVxuXG4vLyBXZSBhbHNvIHJlbWVtYmVyIHRoZSBsYXN0IGVsZW1lbnQgZm9yIGV2ZXJ5IHJvb3QuXG4vLyBJdCBuZWVkcyB0byBiZSB3ZWFrIGJlY2F1c2Ugd2UgZG8gdGhpcyBldmVuIGZvciByb290cyB0aGF0IGZhaWxlZCB0byBtb3VudC5cbi8vIElmIHRoZXJlIGlzIG5vIFdlYWtNYXAsIHdlIHdvbid0IGF0dGVtcHQgdG8gZG8gcmV0cnlpbmcuXG5sZXQgcm9vdEVsZW1lbnRzID0gbmV3IFdlYWtNYXAoKVxubGV0IGlzUGVyZm9ybWluZ1JlZnJlc2ggPSBmYWxzZVxuXG5mdW5jdGlvbiBjb21wdXRlRnVsbEtleShzaWduYXR1cmUpIHtcbiAgaWYgKHNpZ25hdHVyZS5mdWxsS2V5ICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHNpZ25hdHVyZS5mdWxsS2V5XG4gIH1cblxuICBsZXQgZnVsbEtleSA9IHNpZ25hdHVyZS5vd25LZXlcbiAgbGV0IGhvb2tzXG4gIHRyeSB7XG4gICAgaG9va3MgPSBzaWduYXR1cmUuZ2V0Q3VzdG9tSG9va3MoKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gYW4gZWRnZSBjYXNlLCBlLmcuIGlmIGV4cHJlc3Npb24gbGlrZSBGb28udXNlU29tZXRoaW5nXG4gICAgLy8gZGVwZW5kcyBvbiBGb28gd2hpY2ggaXMgbGF6aWx5IGluaXRpYWxpemVkIGR1cmluZyByZW5kZXJpbmcuXG4gICAgLy8gSW4gdGhhdCBjYXNlIGp1c3QgYXNzdW1lIHdlJ2xsIGhhdmUgdG8gcmVtb3VudC5cbiAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWVcbiAgICBzaWduYXR1cmUuZnVsbEtleSA9IGZ1bGxLZXlcbiAgICByZXR1cm4gZnVsbEtleVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGhvb2sgPSBob29rc1tpXVxuICAgIGlmICh0eXBlb2YgaG9vayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gU29tZXRoaW5nJ3Mgd3JvbmcuIEFzc3VtZSB3ZSBuZWVkIHRvIHJlbW91bnQuXG4gICAgICBzaWduYXR1cmUuZm9yY2VSZXNldCA9IHRydWVcbiAgICAgIHNpZ25hdHVyZS5mdWxsS2V5ID0gZnVsbEtleVxuICAgICAgcmV0dXJuIGZ1bGxLZXlcbiAgICB9XG4gICAgY29uc3QgbmVzdGVkSG9va1NpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KGhvb2spXG4gICAgaWYgKG5lc3RlZEhvb2tTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTm8gc2lnbmF0dXJlIG1lYW5zIEhvb2sgd2Fzbid0IGluIHRoZSBzb3VyY2UgY29kZSwgZS5nLiBpbiBhIGxpYnJhcnkuXG4gICAgICAvLyBXZSdsbCBza2lwIGl0IGJlY2F1c2Ugd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBjaGFuZ2UgZHVyaW5nIHRoaXMgc2Vzc2lvbi5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGNvbnN0IG5lc3RlZEhvb2tLZXkgPSBjb21wdXRlRnVsbEtleShuZXN0ZWRIb29rU2lnbmF0dXJlKVxuICAgIGlmIChuZXN0ZWRIb29rU2lnbmF0dXJlLmZvcmNlUmVzZXQpIHtcbiAgICAgIHNpZ25hdHVyZS5mb3JjZVJlc2V0ID0gdHJ1ZVxuICAgIH1cbiAgICBmdWxsS2V5ICs9ICdcXG4tLS1cXG4nICsgbmVzdGVkSG9va0tleVxuICB9XG5cbiAgc2lnbmF0dXJlLmZ1bGxLZXkgPSBmdWxsS2V5XG4gIHJldHVybiBmdWxsS2V5XG59XG5cbmZ1bmN0aW9uIGhhdmVFcXVhbFNpZ25hdHVyZXMocHJldlR5cGUsIG5leHRUeXBlKSB7XG4gIGNvbnN0IHByZXZTaWduYXR1cmUgPSBhbGxTaWduYXR1cmVzQnlUeXBlLmdldChwcmV2VHlwZSlcbiAgY29uc3QgbmV4dFNpZ25hdHVyZSA9IGFsbFNpZ25hdHVyZXNCeVR5cGUuZ2V0KG5leHRUeXBlKVxuXG4gIGlmIChwcmV2U2lnbmF0dXJlID09PSB1bmRlZmluZWQgJiYgbmV4dFNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAocHJldlNpZ25hdHVyZSA9PT0gdW5kZWZpbmVkIHx8IG5leHRTaWduYXR1cmUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChjb21wdXRlRnVsbEtleShwcmV2U2lnbmF0dXJlKSAhPT0gY29tcHV0ZUZ1bGxLZXkobmV4dFNpZ25hdHVyZSkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBpZiAobmV4dFNpZ25hdHVyZS5mb3JjZVJlc2V0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc1JlYWN0Q2xhc3ModHlwZSkge1xuICByZXR1cm4gdHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudFxufVxuXG5mdW5jdGlvbiBjYW5QcmVzZXJ2ZVN0YXRlQmV0d2VlbihwcmV2VHlwZSwgbmV4dFR5cGUpIHtcbiAgaWYgKGlzUmVhY3RDbGFzcyhwcmV2VHlwZSkgfHwgaXNSZWFjdENsYXNzKG5leHRUeXBlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChoYXZlRXF1YWxTaWduYXR1cmVzKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiByZXNvbHZlRmFtaWx5KHR5cGUpIHtcbiAgLy8gT25seSBjaGVjayB1cGRhdGVkIHR5cGVzIHRvIGtlZXAgbG9va3VwcyBmYXN0LlxuICByZXR1cm4gdXBkYXRlZEZhbWlsaWVzQnlUeXBlLmdldCh0eXBlKVxufVxuXG4vLyBUaGlzIGlzIGEgc2FmZXR5IG1lY2hhbmlzbSB0byBwcm90ZWN0IGFnYWluc3Qgcm9ndWUgZ2V0dGVycyBhbmQgUHJveGllcy5cbmZ1bmN0aW9uIGdldFByb3BlcnR5KG9iamVjdCwgcHJvcGVydHkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqZWN0W3Byb3BlcnR5XVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZS5cbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVJlYWN0UmVmcmVzaCgpIHtcbiAgaWYgKHBlbmRpbmdVcGRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKGlzUGVyZm9ybWluZ1JlZnJlc2gpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgaXNQZXJmb3JtaW5nUmVmcmVzaCA9IHRydWVcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGFsZUZhbWlsaWVzID0gbmV3IFNldCgpXG4gICAgY29uc3QgdXBkYXRlZEZhbWlsaWVzID0gbmV3IFNldCgpXG5cbiAgICBjb25zdCB1cGRhdGVzID0gcGVuZGluZ1VwZGF0ZXNcbiAgICBwZW5kaW5nVXBkYXRlcyA9IFtdXG4gICAgdXBkYXRlcy5mb3JFYWNoKChbZmFtaWx5LCBuZXh0VHlwZV0pID0+IHtcbiAgICAgIC8vIE5vdyB0aGF0IHdlIGdvdCBhIHJlYWwgZWRpdCwgd2UgY2FuIGNyZWF0ZSBhc3NvY2lhdGlvbnNcbiAgICAgIC8vIHRoYXQgd2lsbCBiZSByZWFkIGJ5IHRoZSBSZWFjdCByZWNvbmNpbGVyLlxuICAgICAgY29uc3QgcHJldlR5cGUgPSBmYW1pbHkuY3VycmVudFxuICAgICAgdXBkYXRlZEZhbWlsaWVzQnlUeXBlLnNldChwcmV2VHlwZSwgZmFtaWx5KVxuICAgICAgdXBkYXRlZEZhbWlsaWVzQnlUeXBlLnNldChuZXh0VHlwZSwgZmFtaWx5KVxuICAgICAgZmFtaWx5LmN1cnJlbnQgPSBuZXh0VHlwZVxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGlzIHNob3VsZCBiZSBhIHJlLXJlbmRlciBvciBhIHJlLW1vdW50LlxuICAgICAgaWYgKGNhblByZXNlcnZlU3RhdGVCZXR3ZWVuKHByZXZUeXBlLCBuZXh0VHlwZSkpIHtcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzLmFkZChmYW1pbHkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFsZUZhbWlsaWVzLmFkZChmYW1pbHkpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFRPRE86IHJlbmFtZSB0aGVzZSBmaWVsZHMgdG8gc29tZXRoaW5nIG1vcmUgbWVhbmluZ2Z1bC5cbiAgICBjb25zdCB1cGRhdGUgPSB7XG4gICAgICB1cGRhdGVkRmFtaWxpZXMsIC8vIEZhbWlsaWVzIHRoYXQgd2lsbCByZS1yZW5kZXIgcHJlc2VydmluZyBzdGF0ZVxuICAgICAgc3RhbGVGYW1pbGllcywgLy8gRmFtaWxpZXMgdGhhdCB3aWxsIGJlIHJlbW91bnRlZFxuICAgIH1cblxuICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuZm9yRWFjaCgoaGVscGVycykgPT4ge1xuICAgICAgLy8gRXZlbiBpZiB0aGVyZSBhcmUgbm8gcm9vdHMsIHNldCB0aGUgaGFuZGxlciBvbiBmaXJzdCB1cGRhdGUuXG4gICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCBpZiAqbmV3KiByb290cyBhcmUgbW91bnRlZCwgdGhleSdsbCB1c2UgdGhlIHJlc29sdmUgaGFuZGxlci5cbiAgICAgIGhlbHBlcnMuc2V0UmVmcmVzaEhhbmRsZXIocmVzb2x2ZUZhbWlseSlcbiAgICB9KVxuXG4gICAgbGV0IGRpZEVycm9yID0gZmFsc2VcbiAgICBsZXQgZmlyc3RFcnJvciA9IG51bGxcblxuICAgIC8vIFdlIHNuYXBzaG90IG1hcHMgYW5kIHNldHMgdGhhdCBhcmUgbXV0YXRlZCBkdXJpbmcgY29tbWl0cy5cbiAgICAvLyBJZiB3ZSBkb24ndCBkbyB0aGlzLCB0aGVyZSBpcyBhIHJpc2sgdGhleSB3aWxsIGJlIG11dGF0ZWQgd2hpbGVcbiAgICAvLyB3ZSBpdGVyYXRlIG92ZXIgdGhlbS4gRm9yIGV4YW1wbGUsIHRyeWluZyB0byByZWNvdmVyIGEgZmFpbGVkIHJvb3RcbiAgICAvLyBtYXkgY2F1c2UgYW5vdGhlciByb290IHRvIGJlIGFkZGVkIHRvIHRoZSBmYWlsZWQgbGlzdCAtLSBhbiBpbmZpbml0ZSBsb29wLlxuICAgIGNvbnN0IGZhaWxlZFJvb3RzU25hcHNob3QgPSBuZXcgU2V0KGZhaWxlZFJvb3RzKVxuICAgIGNvbnN0IG1vdW50ZWRSb290c1NuYXBzaG90ID0gbmV3IFNldChtb3VudGVkUm9vdHMpXG4gICAgY29uc3QgaGVscGVyc0J5Um9vdFNuYXBzaG90ID0gbmV3IE1hcChoZWxwZXJzQnlSb290KVxuXG4gICAgZmFpbGVkUm9vdHNTbmFwc2hvdC5mb3JFYWNoKChyb290KSA9PiB7XG4gICAgICBjb25zdCBoZWxwZXJzID0gaGVscGVyc0J5Um9vdFNuYXBzaG90LmdldChyb290KVxuICAgICAgaWYgKGhlbHBlcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0NvdWxkIG5vdCBmaW5kIGhlbHBlcnMgZm9yIGEgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdCBSZWZyZXNoLicsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmICghZmFpbGVkUm9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgIC8vIE5vIGxvbmdlciBmYWlsZWQuXG4gICAgICB9XG4gICAgICBpZiAocm9vdEVsZW1lbnRzID09PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKCFyb290RWxlbWVudHMuaGFzKHJvb3QpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudCA9IHJvb3RFbGVtZW50cy5nZXQocm9vdClcbiAgICAgIHRyeSB7XG4gICAgICAgIGhlbHBlcnMuc2NoZWR1bGVSb290KHJvb3QsIGVsZW1lbnQpXG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFkaWRFcnJvcikge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZVxuICAgICAgICAgIGZpcnN0RXJyb3IgPSBlcnJcbiAgICAgICAgfVxuICAgICAgICAvLyBLZWVwIHRyeWluZyBvdGhlciByb290cy5cbiAgICAgIH1cbiAgICB9KVxuICAgIG1vdW50ZWRSb290c1NuYXBzaG90LmZvckVhY2goKHJvb3QpID0+IHtcbiAgICAgIGNvbnN0IGhlbHBlcnMgPSBoZWxwZXJzQnlSb290U25hcHNob3QuZ2V0KHJvb3QpXG4gICAgICBpZiAoaGVscGVycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnQ291bGQgbm90IGZpbmQgaGVscGVycyBmb3IgYSByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0IFJlZnJlc2guJyxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKCFtb3VudGVkUm9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgIC8vIE5vIGxvbmdlciBtb3VudGVkLlxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgaGVscGVycy5zY2hlZHVsZVJlZnJlc2gocm9vdCwgdXBkYXRlKVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZGlkRXJyb3IpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWVcbiAgICAgICAgICBmaXJzdEVycm9yID0gZXJyXG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCB0cnlpbmcgb3RoZXIgcm9vdHMuXG4gICAgICB9XG4gICAgfSlcbiAgICBpZiAoZGlkRXJyb3IpIHtcbiAgICAgIHRocm93IGZpcnN0RXJyb3JcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZVxuICB9IGZpbmFsbHkge1xuICAgIGlzUGVyZm9ybWluZ1JlZnJlc2ggPSBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyKHR5cGUsIGlkKSB7XG4gIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVyblxuICB9XG5cbiAgLy8gVGhpcyBjYW4gaGFwcGVuIGluIGFuIGVkZ2UgY2FzZSwgZS5nLiBpZiB3ZSByZWdpc3RlclxuICAvLyByZXR1cm4gdmFsdWUgb2YgYSBIT0MgYnV0IGl0IHJldHVybnMgYSBjYWNoZWQgY29tcG9uZW50LlxuICAvLyBJZ25vcmUgYW55dGhpbmcgYnV0IHRoZSBmaXJzdCByZWdpc3RyYXRpb24gZm9yIGVhY2ggdHlwZS5cbiAgaWYgKGFsbEZhbWlsaWVzQnlUeXBlLmhhcyh0eXBlKSkge1xuICAgIHJldHVyblxuICB9XG4gIC8vIENyZWF0ZSBmYW1pbHkgb3IgcmVtZW1iZXIgdG8gdXBkYXRlIGl0LlxuICAvLyBOb25lIG9mIHRoaXMgYm9va2tlZXBpbmcgYWZmZWN0cyByZWNvbmNpbGlhdGlvblxuICAvLyB1bnRpbCB0aGUgZmlyc3QgcGVyZm9ybVJlYWN0UmVmcmVzaCgpIGNhbGwgYWJvdmUuXG4gIGxldCBmYW1pbHkgPSBhbGxGYW1pbGllc0J5SUQuZ2V0KGlkKVxuICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICBmYW1pbHkgPSB7IGN1cnJlbnQ6IHR5cGUgfVxuICAgIGFsbEZhbWlsaWVzQnlJRC5zZXQoaWQsIGZhbWlseSlcbiAgfSBlbHNlIHtcbiAgICBwZW5kaW5nVXBkYXRlcy5wdXNoKFtmYW1pbHksIHR5cGVdKVxuICB9XG4gIGFsbEZhbWlsaWVzQnlUeXBlLnNldCh0eXBlLCBmYW1pbHkpXG5cbiAgLy8gVmlzaXQgaW5uZXIgdHlwZXMgYmVjYXVzZSB3ZSBtaWdodCBub3QgaGF2ZSByZWdpc3RlcmVkIHRoZW0uXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAoZ2V0UHJvcGVydHkodHlwZSwgJyQkdHlwZW9mJykpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmVnaXN0ZXIodHlwZS5yZW5kZXIsIGlkICsgJyRyZW5kZXInKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJlZ2lzdGVyKHR5cGUudHlwZSwgaWQgKyAnJHR5cGUnKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRTaWduYXR1cmUodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcykge1xuICBpZiAoIWFsbFNpZ25hdHVyZXNCeVR5cGUuaGFzKHR5cGUpKSB7XG4gICAgYWxsU2lnbmF0dXJlc0J5VHlwZS5zZXQodHlwZSwge1xuICAgICAgZm9yY2VSZXNldCxcbiAgICAgIG93bktleToga2V5LFxuICAgICAgZnVsbEtleTogbnVsbCxcbiAgICAgIGdldEN1c3RvbUhvb2tzOiBnZXRDdXN0b21Ib29rcyB8fCAoKCkgPT4gW10pLFxuICAgIH0pXG4gIH1cbiAgLy8gVmlzaXQgaW5uZXIgdHlwZXMgYmVjYXVzZSB3ZSBtaWdodCBub3QgaGF2ZSBzaWduZWQgdGhlbS5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICBzZXRTaWduYXR1cmUodHlwZS5yZW5kZXIsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpXG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUudHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcylcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBsYXppbHkgY2FsbGVkIGR1cmluZyBmaXJzdCByZW5kZXIgZm9yIGEgdHlwZS5cbi8vIEl0IGNhcHR1cmVzIEhvb2sgbGlzdCBhdCB0aGF0IHRpbWUgc28gaW5saW5lIHJlcXVpcmVzIGRvbid0IGJyZWFrIGNvbXBhcmlzb25zLlxuZnVuY3Rpb24gY29sbGVjdEN1c3RvbUhvb2tzRm9yU2lnbmF0dXJlKHR5cGUpIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYWxsU2lnbmF0dXJlc0J5VHlwZS5nZXQodHlwZSlcbiAgaWYgKHNpZ25hdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcHV0ZUZ1bGxLZXkoc2lnbmF0dXJlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpbmplY3RJbnRvR2xvYmFsSG9vayhnbG9iYWxPYmplY3QpIHtcbiAgLy8gRm9yIFJlYWN0IE5hdGl2ZSwgdGhlIGdsb2JhbCBob29rIHdpbGwgYmUgc2V0IHVwIGJ5IHJlcXVpcmUoJ3JlYWN0LWRldnRvb2xzLWNvcmUnKS5cbiAgLy8gVGhhdCBjb2RlIHdpbGwgcnVuIGJlZm9yZSB1cy4gU28gd2UgbmVlZCB0byBtb25rZXlwYXRjaCBmdW5jdGlvbnMgb24gZXhpc3RpbmcgaG9vay5cblxuICAvLyBGb3IgUmVhY3QgV2ViLCB0aGUgZ2xvYmFsIGhvb2sgd2lsbCBiZSBzZXQgdXAgYnkgdGhlIGV4dGVuc2lvbi5cbiAgLy8gVGhpcyB3aWxsIGFsc28gcnVuIGJlZm9yZSB1cy5cbiAgbGV0IGhvb2sgPSBnbG9iYWxPYmplY3QuX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fXG4gIGlmIChob29rID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBIb3dldmVyLCBpZiB0aGVyZSBpcyBubyBEZXZUb29scyBleHRlbnNpb24sIHdlJ2xsIG5lZWQgdG8gc2V0IHVwIHRoZSBnbG9iYWwgaG9vayBvdXJzZWx2ZXMuXG4gICAgLy8gTm90ZSB0aGF0IGluIHRoaXMgY2FzZSBpdCdzIGltcG9ydGFudCB0aGF0IHJlbmRlcmVyIGNvZGUgcnVucyAqYWZ0ZXIqIHRoaXMgbWV0aG9kIGNhbGwuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aGUgcmVuZGVyZXIgd2lsbCB0aGluayB0aGF0IHRoZXJlIGlzIG5vIGdsb2JhbCBob29rLCBhbmQgd29uJ3QgZG8gdGhlIGluamVjdGlvbi5cbiAgICBsZXQgbmV4dElEID0gMFxuICAgIGdsb2JhbE9iamVjdC5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPSBob29rID0ge1xuICAgICAgcmVuZGVyZXJzOiBuZXcgTWFwKCksXG4gICAgICBzdXBwb3J0c0ZpYmVyOiB0cnVlLFxuICAgICAgaW5qZWN0OiAoaW5qZWN0ZWQpID0+IG5leHRJRCsrLFxuICAgICAgb25TY2hlZHVsZUZpYmVyUm9vdDogKGlkLCByb290LCBjaGlsZHJlbikgPT4ge30sXG4gICAgICBvbkNvbW1pdEZpYmVyUm9vdDogKGlkLCByb290LCBtYXliZVByaW9yaXR5TGV2ZWwsIGRpZEVycm9yKSA9PiB7fSxcbiAgICAgIG9uQ29tbWl0RmliZXJVbm1vdW50KCkge30sXG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcbiAgICBjb25zb2xlWyd3YXJuJ10oXG4gICAgICAnU29tZXRoaW5nIGhhcyBzaGltbWVkIHRoZSBSZWFjdCBEZXZUb29scyBnbG9iYWwgaG9vayAoX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKS4gJyArXG4gICAgICAgICdGYXN0IFJlZnJlc2ggaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGlzIHNoaW0gYW5kIHdpbGwgYmUgZGlzYWJsZWQuJyxcbiAgICApXG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBIZXJlLCB3ZSBqdXN0IHdhbnQgdG8gZ2V0IGEgcmVmZXJlbmNlIHRvIHNjaGVkdWxlUmVmcmVzaC5cbiAgY29uc3Qgb2xkSW5qZWN0ID0gaG9vay5pbmplY3RcbiAgaG9vay5pbmplY3QgPSBmdW5jdGlvbiAoaW5qZWN0ZWQpIHtcbiAgICBjb25zdCBpZCA9IG9sZEluamVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGluamVjdGVkLnNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cbiAgICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuc2V0KGlkLCBpbmplY3RlZClcbiAgICB9XG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICAvLyBEbyB0aGUgc2FtZSBmb3IgYW55IGFscmVhZHkgaW5qZWN0ZWQgcm9vdHMuXG4gIC8vIFRoaXMgaXMgdXNlZnVsIGlmIFJlYWN0RE9NIGhhcyBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTc2MjZcbiAgaG9vay5yZW5kZXJlcnMuZm9yRWFjaCgoaW5qZWN0ZWQsIGlkKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGluamVjdGVkLnNjaGVkdWxlUmVmcmVzaCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIGluamVjdGVkLnNldFJlZnJlc2hIYW5kbGVyID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICAvLyBUaGlzIHZlcnNpb24gc3VwcG9ydHMgUmVhY3QgUmVmcmVzaC5cbiAgICAgIGhlbHBlcnNCeVJlbmRlcmVySUQuc2V0KGlkLCBpbmplY3RlZClcbiAgICB9XG4gIH0pXG5cbiAgLy8gV2UgYWxzbyB3YW50IHRvIHRyYWNrIGN1cnJlbnRseSBtb3VudGVkIHJvb3RzLlxuICBjb25zdCBvbGRPbkNvbW1pdEZpYmVyUm9vdCA9IGhvb2sub25Db21taXRGaWJlclJvb3RcbiAgY29uc3Qgb2xkT25TY2hlZHVsZUZpYmVyUm9vdCA9IGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCB8fCAoKCkgPT4ge30pXG4gIGhvb2sub25TY2hlZHVsZUZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgY2hpbGRyZW4pIHtcbiAgICBpZiAoIWlzUGVyZm9ybWluZ1JlZnJlc2gpIHtcbiAgICAgIC8vIElmIGl0IHdhcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCwgZG9uJ3QgYXR0ZW1wdCB0byByZXN0b3JlLlxuICAgICAgLy8gVGhpcyBpbmNsdWRlcyBpbnRlbnRpb25hbGx5IHNjaGVkdWxlZCB1bm1vdW50cy5cbiAgICAgIGZhaWxlZFJvb3RzLmRlbGV0ZShyb290KVxuICAgICAgaWYgKHJvb3RFbGVtZW50cyAhPT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudHMuc2V0KHJvb3QsIGNoaWxkcmVuKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2xkT25TY2hlZHVsZUZpYmVyUm9vdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbiAgaG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9IGZ1bmN0aW9uIChpZCwgcm9vdCwgbWF5YmVQcmlvcml0eUxldmVsLCBkaWRFcnJvcikge1xuICAgIGNvbnN0IGhlbHBlcnMgPSBoZWxwZXJzQnlSZW5kZXJlcklELmdldChpZClcbiAgICBpZiAoaGVscGVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBoZWxwZXJzQnlSb290LnNldChyb290LCBoZWxwZXJzKVxuXG4gICAgICBjb25zdCBjdXJyZW50ID0gcm9vdC5jdXJyZW50XG4gICAgICBjb25zdCBhbHRlcm5hdGUgPSBjdXJyZW50LmFsdGVybmF0ZVxuXG4gICAgICAvLyBXZSBuZWVkIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXMgcm9vdCBoYXMganVzdCAodW4pbW91bnRlZC5cbiAgICAgIC8vIFRoaXMgbG9naWMgaXMgY29weS1wYXN0ZWQgZnJvbSBzaW1pbGFyIGxvZ2ljIGluIHRoZSBEZXZUb29scyBiYWNrZW5kLlxuICAgICAgLy8gSWYgdGhpcyBicmVha3Mgd2l0aCBzb21lIHJlZmFjdG9yaW5nLCB5b3UnbGwgd2FudCB0byB1cGRhdGUgRGV2VG9vbHMgdG9vLlxuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHdhc01vdW50ZWQgPVxuICAgICAgICAgIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICE9IG51bGwgJiZcbiAgICAgICAgICBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5lbGVtZW50ICE9IG51bGwgJiZcbiAgICAgICAgICBtb3VudGVkUm9vdHMuaGFzKHJvb3QpXG5cbiAgICAgICAgY29uc3QgaXNNb3VudGVkID1cbiAgICAgICAgICBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsXG5cbiAgICAgICAgaWYgKCF3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgICAgbW91bnRlZFJvb3RzLmFkZChyb290KVxuICAgICAgICAgIGZhaWxlZFJvb3RzLmRlbGV0ZShyb290KVxuICAgICAgICB9IGVsc2UgaWYgKHdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIGFuIGV4aXN0aW5nIHJvb3QuXG4gICAgICAgICAgLy8gVGhpcyBkb2Vzbid0IGFmZmVjdCBvdXIgbW91bnRlZCByb290IFNldC5cbiAgICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmICFpc01vdW50ZWQpIHtcbiAgICAgICAgICAvLyBVbm1vdW50IGFuIGV4aXN0aW5nIHJvb3QuXG4gICAgICAgICAgbW91bnRlZFJvb3RzLmRlbGV0ZShyb290KVxuICAgICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXG4gICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVscGVyc0J5Um9vdC5kZWxldGUocm9vdClcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXdhc01vdW50ZWQgJiYgIWlzTW91bnRlZCkge1xuICAgICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgICAgLy8gV2UnbGwgcmVtb3VudCBpdCBvbiBmdXR1cmUgZWRpdHMuXG4gICAgICAgICAgICBmYWlsZWRSb290cy5hZGQocm9vdClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgIG1vdW50ZWRSb290cy5hZGQocm9vdClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBbHdheXMgY2FsbCB0aGUgZGVjb3JhdGVkIERldlRvb2xzIGhvb2suXG4gICAgcmV0dXJuIG9sZE9uQ29tbWl0RmliZXJSb290LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG4vLyBUaGlzIGlzIGEgd3JhcHBlciBvdmVyIG1vcmUgcHJpbWl0aXZlIGZ1bmN0aW9ucyBmb3Igc2V0dGluZyBzaWduYXR1cmUuXG4vLyBTaWduYXR1cmVzIGxldCB1cyBkZWNpZGUgd2hldGhlciB0aGUgSG9vayBvcmRlciBoYXMgY2hhbmdlZCBvbiByZWZyZXNoLlxuLy9cbi8vIFRoaXMgZnVuY3Rpb24gaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBhIHRyYW5zZm9ybSB0YXJnZXQsIGUuZy46XG4vLyB2YXIgX3MgPSBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpXG4vL1xuLy8gZnVuY3Rpb24gSGVsbG8oKSB7XG4vLyAgIGNvbnN0IFtmb28sIHNldEZvb10gPSB1c2VTdGF0ZSgwKTtcbi8vICAgY29uc3QgdmFsdWUgPSB1c2VDdXN0b21Ib29rKCk7XG4vLyAgIF9zKCk7IC8qIENhbGwgd2l0aG91dCBhcmd1bWVudHMgdHJpZ2dlcnMgY29sbGVjdGluZyB0aGUgY3VzdG9tIEhvb2sgbGlzdC5cbi8vICAgICAgICAgICogVGhpcyBkb2Vzbid0IGhhcHBlbiBkdXJpbmcgdGhlIG1vZHVsZSBldmFsdWF0aW9uIGJlY2F1c2Ugd2Vcbi8vICAgICAgICAgICogZG9uJ3Qgd2FudCB0byBjaGFuZ2UgdGhlIG1vZHVsZSBvcmRlciB3aXRoIGlubGluZSByZXF1aXJlcy5cbi8vICAgICAgICAgICogTmV4dCBjYWxscyBhcmUgbm9vcHMuICovXG4vLyAgIHJldHVybiA8aDE+SGk8L2gxPjtcbi8vIH1cbi8vXG4vLyAvKiBDYWxsIHdpdGggYXJndW1lbnRzIGF0dGFjaGVzIHRoZSBzaWduYXR1cmUgdG8gdGhlIHR5cGU6ICovXG4vLyBfcyhcbi8vICAgSGVsbG8sXG4vLyAgICd1c2VTdGF0ZXtbZm9vLCBzZXRGb29dfSgwKScsXG4vLyAgICgpID0+IFt1c2VDdXN0b21Ib29rXSwgLyogTGF6eSB0byBhdm9pZCB0cmlnZ2VyaW5nIGlubGluZSByZXF1aXJlcyAqL1xuLy8gKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTaWduYXR1cmVGdW5jdGlvbkZvclRyYW5zZm9ybSgpIHtcbiAgbGV0IHNhdmVkVHlwZVxuICBsZXQgaGFzQ3VzdG9tSG9va3NcbiAgbGV0IGRpZENvbGxlY3RIb29rcyA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAodHlwZSwga2V5LCBmb3JjZVJlc2V0LCBnZXRDdXN0b21Ib29rcykge1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gV2UncmUgaW4gdGhlIGluaXRpYWwgcGhhc2UgdGhhdCBhc3NvY2lhdGVzIHNpZ25hdHVyZXNcbiAgICAgIC8vIHdpdGggdGhlIGZ1bmN0aW9ucy4gTm90ZSB0aGlzIG1heSBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgIC8vIGluIEhPQyBjaGFpbnMgbGlrZSBfcyhob2MxKF9zKGhvYzIoX3MoYWN0dWFsRnVuY3Rpb24pKSkpKS5cbiAgICAgIGlmICghc2F2ZWRUeXBlKSB7XG4gICAgICAgIC8vIFdlJ3JlIGluIHRoZSBpbm5lcm1vc3QgY2FsbCwgc28gdGhpcyBpcyB0aGUgYWN0dWFsIHR5cGUuXG4gICAgICAgIC8vICRGbG93Rml4TWVbZXNjYXBlZC1nZW5lcmljXSBkaXNjb3ZlcmVkIHdoZW4gdXBkYXRpbmcgRmxvd1xuICAgICAgICBzYXZlZFR5cGUgPSB0eXBlXG4gICAgICAgIGhhc0N1c3RvbUhvb2tzID0gdHlwZW9mIGdldEN1c3RvbUhvb2tzID09PSAnZnVuY3Rpb24nXG4gICAgICB9XG4gICAgICAvLyBTZXQgdGhlIHNpZ25hdHVyZSBmb3IgYWxsIHR5cGVzIChldmVuIHdyYXBwZXJzISkgaW4gY2FzZVxuICAgICAgLy8gdGhleSBoYXZlIG5vIHNpZ25hdHVyZXMgb2YgdGhlaXIgb3duLiBUaGlzIGlzIHRvIHByZXZlbnRcbiAgICAgIC8vIHByb2JsZW1zIGxpa2UgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDQxNy5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZSAhPSBudWxsICYmXG4gICAgICAgICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpXG4gICAgICApIHtcbiAgICAgICAgc2V0U2lnbmF0dXJlKHR5cGUsIGtleSwgZm9yY2VSZXNldCwgZ2V0Q3VzdG9tSG9va3MpXG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSBpbiB0aGUgX3MoKSBjYWxsIHdpdGhvdXQgYXJndW1lbnRzLCB3aGljaCBtZWFuc1xuICAgICAgLy8gdGhpcyBpcyB0aGUgdGltZSB0byBjb2xsZWN0IGN1c3RvbSBIb29rIHNpZ25hdHVyZXMuXG4gICAgICAvLyBPbmx5IGRvIHRoaXMgb25jZS4gVGhpcyBwYXRoIGlzIGhvdCBhbmQgcnVucyAqaW5zaWRlKiBldmVyeSByZW5kZXIhXG4gICAgICBpZiAoIWRpZENvbGxlY3RIb29rcyAmJiBoYXNDdXN0b21Ib29rcykge1xuICAgICAgICBkaWRDb2xsZWN0SG9va3MgPSB0cnVlXG4gICAgICAgIGNvbGxlY3RDdXN0b21Ib29rc0ZvclNpZ25hdHVyZShzYXZlZFR5cGUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlrZWx5Q29tcG9uZW50VHlwZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHR5cGUpIHtcbiAgICBjYXNlICdmdW5jdGlvbic6IHtcbiAgICAgIC8vIEZpcnN0LCBkZWFsIHdpdGggY2xhc3Nlcy5cbiAgICAgIGlmICh0eXBlLnByb3RvdHlwZSAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0eXBlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KSB7XG4gICAgICAgICAgLy8gUmVhY3QgY2xhc3MuXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvd25OYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHR5cGUucHJvdG90eXBlKVxuICAgICAgICBpZiAob3duTmFtZXMubGVuZ3RoID4gMSB8fCBvd25OYW1lc1swXSAhPT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIC8vIFRoaXMgbG9va3MgbGlrZSBhIGNsYXNzLlxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlLl9fcHJvdG9fXyAhPT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgIC8vIEl0IGhhcyBhIHN1cGVyY2xhc3MuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFzcyB0aHJvdWdoLlxuICAgICAgICAvLyBUaGlzIGxvb2tzIGxpa2UgYSByZWd1bGFyIGZ1bmN0aW9uIHdpdGggZW1wdHkgcHJvdG90eXBlLlxuICAgICAgfVxuICAgICAgLy8gRm9yIHBsYWluIGZ1bmN0aW9ucyBhbmQgYXJyb3dzLCB1c2UgbmFtZSBhcyBhIGhldXJpc3RpYy5cbiAgICAgIGNvbnN0IG5hbWUgPSB0eXBlLm5hbWUgfHwgdHlwZS5kaXNwbGF5TmFtZVxuICAgICAgcmV0dXJuIHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJyAmJiAvXltBLVpdLy50ZXN0KG5hbWUpXG4gICAgfVxuICAgIGNhc2UgJ29iamVjdCc6IHtcbiAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChnZXRQcm9wZXJ0eSh0eXBlLCAnJCR0eXBlb2YnKSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIC8vIERlZmluaXRlbHkgUmVhY3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29tcG91bmRDb21wb25lbnQodHlwZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodHlwZSkpIHJldHVybiBmYWxzZVxuICBmb3IgKGNvbnN0IGtleSBpbiB0eXBlKSB7XG4gICAgaWYgKCFpc0xpa2VseUNvbXBvbmVudFR5cGUodHlwZVtrZXldKSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvYmopIHtcbiAgcmV0dXJuIChcbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgJiZcbiAgICAob2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQpXG4gIClcbn1cblxuLyoqXG4gKiBQbHVnaW4gdXRpbHNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVmcmVzaFJlZyhmaWxlbmFtZSkge1xuICByZXR1cm4gKHR5cGUsIGlkKSA9PiByZWdpc3Rlcih0eXBlLCBmaWxlbmFtZSArICcgJyArIGlkKVxufVxuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW1td2gvcmVhY3QtcmVmcmVzaC13ZWJwYWNrLXBsdWdpbi9ibG9iL21haW4vbGliL3J1bnRpbWUvUmVmcmVzaFV0aWxzLmpzI0wxNDFcbi8vIFRoaXMgYWxsb3dzIHRvIHJlc2lzdGVyIGNvbXBvbmVudHMgbm90IGRldGVjdGVkIGJ5IFNXQyBsaWtlIHN0eWxlZCBjb21wb25lbnRcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlckV4cG9ydHNGb3JSZWFjdFJlZnJlc2goZmlsZW5hbWUsIG1vZHVsZUV4cG9ydHMpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gbW9kdWxlRXhwb3J0cykge1xuICAgIGlmIChrZXkgPT09ICdfX2VzTW9kdWxlJykgY29udGludWVcbiAgICBjb25zdCBleHBvcnRWYWx1ZSA9IG1vZHVsZUV4cG9ydHNba2V5XVxuICAgIGlmIChpc0xpa2VseUNvbXBvbmVudFR5cGUoZXhwb3J0VmFsdWUpKSB7XG4gICAgICAvLyAnZXhwb3J0JyBpcyByZXF1aXJlZCB0byBhdm9pZCBrZXkgY29sbGlzaW9uIHdoZW4gcmVuYW1lZCBleHBvcnRzIHRoYXRcbiAgICAgIC8vIHNoYWRvdyBhIGxvY2FsIGNvbXBvbmVudCBuYW1lOiBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXJlYWN0L2lzc3Vlcy8xMTZcbiAgICAgIC8vIFRoZSByZWdpc3RlciBmdW5jdGlvbiBoYXMgYW4gaWRlbnRpdHkgY2hlY2sgdG8gbm90IHJlZ2lzdGVyIHR3aWNlIHRoZSBzYW1lIGNvbXBvbmVudCxcbiAgICAgIC8vIHNvIHRoaXMgaXMgc2FmZSB0byBub3QgdXNlZCB0aGUgc2FtZSBrZXkgaGVyZS5cbiAgICAgIHJlZ2lzdGVyKGV4cG9ydFZhbHVlLCBmaWxlbmFtZSArICcgZXhwb3J0ICcgKyBrZXkpXG4gICAgfSBlbHNlIGlmIChpc0NvbXBvdW5kQ29tcG9uZW50KGV4cG9ydFZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBzdWJLZXkgaW4gZXhwb3J0VmFsdWUpIHtcbiAgICAgICAgcmVnaXN0ZXIoXG4gICAgICAgICAgZXhwb3J0VmFsdWVbc3ViS2V5XSxcbiAgICAgICAgICBmaWxlbmFtZSArICcgZXhwb3J0ICcgKyBrZXkgKyAnLScgKyBzdWJLZXksXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIGRlbGF5KSB7XG4gIGxldCBoYW5kbGVcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjbGVhclRpbWVvdXQoaGFuZGxlKVxuICAgIGhhbmRsZSA9IHNldFRpbWVvdXQoZm4sIGRlbGF5KVxuICB9XG59XG5cbmNvbnN0IGhvb2tzID0gW11cbndpbmRvdy5fX3JlZ2lzdGVyQmVmb3JlUGVyZm9ybVJlYWN0UmVmcmVzaCA9IChjYikgPT4ge1xuICBob29rcy5wdXNoKGNiKVxufVxuY29uc3QgZW5xdWV1ZVVwZGF0ZSA9IGRlYm91bmNlKGFzeW5jICgpID0+IHtcbiAgaWYgKGhvb2tzLmxlbmd0aCkgYXdhaXQgUHJvbWlzZS5hbGwoaG9va3MubWFwKChjYikgPT4gY2IoKSkpXG4gIHBlcmZvcm1SZWFjdFJlZnJlc2goKVxufSwgMTYpXG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVJlZnJlc2hCb3VuZGFyeUFuZEVucXVldWVVcGRhdGUoXG4gIGlkLFxuICBwcmV2RXhwb3J0cyxcbiAgbmV4dEV4cG9ydHMsXG4pIHtcbiAgY29uc3QgaWdub3JlZEV4cG9ydHMgPSB3aW5kb3cuX19nZXRSZWFjdFJlZnJlc2hJZ25vcmVkRXhwb3J0cz8uKHsgaWQgfSkgPz8gW11cbiAgaWYgKFxuICAgIHByZWRpY2F0ZU9uRXhwb3J0KFxuICAgICAgaWdub3JlZEV4cG9ydHMsXG4gICAgICBwcmV2RXhwb3J0cyxcbiAgICAgIChrZXkpID0+IGtleSBpbiBuZXh0RXhwb3J0cyxcbiAgICApICE9PSB0cnVlXG4gICkge1xuICAgIHJldHVybiAnQ291bGQgbm90IEZhc3QgUmVmcmVzaCAoZXhwb3J0IHJlbW92ZWQpJ1xuICB9XG4gIGlmIChcbiAgICBwcmVkaWNhdGVPbkV4cG9ydChcbiAgICAgIGlnbm9yZWRFeHBvcnRzLFxuICAgICAgbmV4dEV4cG9ydHMsXG4gICAgICAoa2V5KSA9PiBrZXkgaW4gcHJldkV4cG9ydHMsXG4gICAgKSAhPT0gdHJ1ZVxuICApIHtcbiAgICByZXR1cm4gJ0NvdWxkIG5vdCBGYXN0IFJlZnJlc2ggKG5ldyBleHBvcnQpJ1xuICB9XG5cbiAgbGV0IGhhc0V4cG9ydHMgPSBmYWxzZVxuICBjb25zdCBhbGxFeHBvcnRzQXJlQ29tcG9uZW50c09yVW5jaGFuZ2VkID0gcHJlZGljYXRlT25FeHBvcnQoXG4gICAgaWdub3JlZEV4cG9ydHMsXG4gICAgbmV4dEV4cG9ydHMsXG4gICAgKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIGhhc0V4cG9ydHMgPSB0cnVlXG4gICAgICBpZiAoaXNMaWtlbHlDb21wb25lbnRUeXBlKHZhbHVlKSkgcmV0dXJuIHRydWVcbiAgICAgIGlmIChpc0NvbXBvdW5kQ29tcG9uZW50KHZhbHVlKSkgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiBwcmV2RXhwb3J0c1trZXldID09PSBuZXh0RXhwb3J0c1trZXldXG4gICAgfSxcbiAgKVxuICBpZiAoaGFzRXhwb3J0cyAmJiBhbGxFeHBvcnRzQXJlQ29tcG9uZW50c09yVW5jaGFuZ2VkID09PSB0cnVlKSB7XG4gICAgZW5xdWV1ZVVwZGF0ZSgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGBDb3VsZCBub3QgRmFzdCBSZWZyZXNoIChcIiR7YWxsRXhwb3J0c0FyZUNvbXBvbmVudHNPclVuY2hhbmdlZH1cIiBleHBvcnQgaXMgaW5jb21wYXRpYmxlKS4gTGVhcm4gbW9yZSBhdCBodHRwczovL2dpdGh1Yi5jb20vdml0ZWpzL3ZpdGUtcGx1Z2luLXJlYWN0L3RyZWUvbWFpbi9wYWNrYWdlcy9wbHVnaW4tcmVhY3QjY29uc2lzdGVudC1jb21wb25lbnRzLWV4cG9ydHNgXG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlZGljYXRlT25FeHBvcnQoaWdub3JlZEV4cG9ydHMsIG1vZHVsZUV4cG9ydHMsIHByZWRpY2F0ZSkge1xuICBmb3IgKGNvbnN0IGtleSBpbiBtb2R1bGVFeHBvcnRzKSB7XG4gICAgaWYgKGtleSA9PT0gJ19fZXNNb2R1bGUnKSBjb250aW51ZVxuICAgIGlmIChpZ25vcmVkRXhwb3J0cy5pbmNsdWRlcyhrZXkpKSBjb250aW51ZVxuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG1vZHVsZUV4cG9ydHMsIGtleSlcbiAgICBpZiAoZGVzYyAmJiBkZXNjLmdldCkgcmV0dXJuIGtleVxuICAgIGlmICghcHJlZGljYXRlKGtleSwgbW9kdWxlRXhwb3J0c1trZXldKSkgcmV0dXJuIGtleVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8vIEhpZGVzIHZpdGUtaWdub3JlZCBkeW5hbWljIGltcG9ydCBzbyB0aGF0IFZpdGUgY2FuIHNraXAgYW5hbHlzaXMgaWYgbm8gb3RoZXJcbi8vIGR5bmFtaWMgaW1wb3J0IGlzIHByZXNlbnQgKGh0dHBzOi8vZ2l0aHViLmNvbS92aXRlanMvdml0ZS9wdWxsLzEyNzMyKVxuZXhwb3J0IGNvbnN0IF9faG1yX2ltcG9ydCA9IChtb2R1bGUpID0+IGltcG9ydCgvKiBAdml0ZS1pZ25vcmUgKi8gX192aXRlX19pbmplY3RRdWVyeShtb2R1bGUsICdpbXBvcnQnKSlcblxuLy8gRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggQHZpdGVqcy9wbHVnaW4tcmVhY3QuXG5leHBvcnQgZGVmYXVsdCB7IGluamVjdEludG9HbG9iYWxIb29rIH1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDdEYsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUMvRTtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFO0FBQ3BJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUM7QUFDN0QsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM5RCxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hEO0FBQ0EsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQztBQUN0QyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDO0FBQ2hFLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUMvQixHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNyQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUN2QztBQUNBLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVE7QUFDekQsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDL0QsS0FBSyxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDM0M7QUFDQSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDdkQsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUMvQyxHQUFHLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkI7QUFDQSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDN0QsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckM7QUFDQSxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDL0I7QUFDQSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO0FBQzdELEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM5QixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO0FBQ3ZFLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUM3QjtBQUNBLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO0FBQ3BELENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztBQUM5RSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDO0FBQzNELEdBQUcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNoQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDL0I7QUFDQSxRQUFRLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ25DLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxPQUFPO0FBQzVCLENBQUMsQ0FBQyxDQUFDO0FBQ0g7QUFDQSxDQUFDLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU07QUFDaEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLO0FBQ1gsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN0QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVk7QUFDaEYsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUNuRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUN0RCxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUk7QUFDL0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPO0FBQy9CLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU87QUFDbEIsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDO0FBQ3RELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUk7QUFDakMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsT0FBTztBQUNqQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTztBQUNwQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDOUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7QUFDakYsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUTtBQUNkLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLG1CQUFtQixDQUFDO0FBQzdELENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQ2pDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWE7QUFDeEMsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxPQUFPO0FBQzdCLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTztBQUNoQixDQUFDO0FBQ0Q7QUFDQSxRQUFRLENBQUMsbUJBQW1CLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNsRCxDQUFDLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztBQUN6RCxDQUFDLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQztBQUN6RDtBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNuRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJO0FBQ2YsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDbkUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNoQixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hFLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUs7QUFDaEIsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7QUFDakMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNoQixDQUFDLENBQUMsQ0FBQztBQUNIO0FBQ0EsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJO0FBQ2IsQ0FBQztBQUNEO0FBQ0EsUUFBUSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzdCLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQjtBQUMxRCxDQUFDO0FBQ0Q7QUFDQSxRQUFRLENBQUMsdUJBQXVCLENBQUMsUUFBUSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUN0RCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDekQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNoQixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUNmLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLO0FBQ2QsQ0FBQztBQUNEO0FBQ0EsUUFBUSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQ25ELENBQUMsQ0FBQyxNQUFNLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUN4QyxDQUFDO0FBQ0Q7QUFDQSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztBQUMzRSxRQUFRLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDeEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDakIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDO0FBQzVCLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVM7QUFDcEIsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxRQUFRLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUk7QUFDZixDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUNmLENBQUMsQ0FBQyxDQUFDO0FBQ0g7QUFDQSxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLElBQUk7QUFDNUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckM7QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGNBQWM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxZQUFZO0FBQ2hFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUM7QUFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU87QUFDckMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDLE1BQU0sQ0FBQztBQUNqRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDO0FBQ2pELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVE7QUFDL0I7QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQztBQUNwRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDeEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO0FBQ25DLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNkLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQztBQUNqQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTjtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO0FBQzlELENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxLQUFLO0FBQ3ZFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxTQUFTO0FBQ3ZELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMO0FBQ0EsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDckUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztBQUN2RixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDO0FBQzlDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ047QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQ3pCO0FBQ0EsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7QUFDakUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsS0FBSztBQUN0RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUk7QUFDekUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ2pGLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQztBQUNwRCxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQUM7QUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO0FBQ3hEO0FBQ0EsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzNDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFDckQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDL0UsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU07QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTTtBQUNkLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNYLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxHQUFHO0FBQzFCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztBQUNuQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUNyRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUMvRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSTtBQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsR0FBRztBQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7QUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ25CLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU07QUFDakIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztBQUNiLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDL0IsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxRQUFRLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDN0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDdEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO0FBQ1YsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQy9ELENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTTtBQUNWLENBQUMsQ0FBQyxDQUFDO0FBQ0g7QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUTtBQUN6RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7QUFDOUQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO0FBQ1YsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO0FBQzVDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLGNBQWM7QUFDcEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0FBQ3RELENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUN0QyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNWLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDckM7QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO0FBQ2pFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ2xELENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzVDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM3QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztBQUNiLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7QUFDM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDekMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDYixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLFFBQVEsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztBQUM5RCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDcEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztBQUM3RCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNsRCxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsY0FBYyxDQUFDO0FBQ2xFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLO0FBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxjQUFjLENBQUM7QUFDaEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDYixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztBQUN4RCxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDO0FBQ2pGLFFBQVEsQ0FBQyw4QkFBOEIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQy9DLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0FBQ2pELENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ2hDLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQztBQUM3QixDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLE1BQU0sQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN4RixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQztBQUN4RjtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQztBQUNwRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7QUFDbEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyw4QkFBOEI7QUFDeEQsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDM0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztBQUNsRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDOUYsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQztBQUNuRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsOEJBQThCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMxRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUMzQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFDMUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN4RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUc7QUFDM0UsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0FBQ2hFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU07QUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3BCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLDhCQUE4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNqRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDOUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNO0FBQ1YsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLGVBQWUsQ0FBQztBQUM5RCxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU07QUFDL0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUMvQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ1IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxFQUFFO0FBQ2IsQ0FBQyxDQUFDLENBQUM7QUFDSDtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO0FBQ2hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztBQUM3RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEtBQUs7QUFDbkQsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ1IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7QUFDdEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0o7QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztBQUNuRCxDQUFDLENBQUMsS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCO0FBQ3JELENBQUMsQ0FBQyxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZFLENBQUMsQ0FBQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDNUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUNyRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDO0FBQ3hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQ3hDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ3hELENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsa0JBQWtCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQzlFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsbUJBQW1CLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQztBQUMvQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDaEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUM7QUFDdEM7QUFDQSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsU0FBUztBQUN6QztBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQztBQUNyRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztBQUM5RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQztBQUNsRjtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUNoQztBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUM7QUFDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQ2hGO0FBQ0EsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDdkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFDOUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUNoQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDO0FBQ2xDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ3JDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztBQUN0RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQzlDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUNqQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQztBQUN0QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUNqQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNkLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7QUFDNUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTDtBQUNBLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7QUFDL0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQztBQUN0RCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUM7QUFDekUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUM7QUFDMUUsQ0FBQyxDQUFDO0FBQ0YsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDO0FBQ2pELENBQUMsQ0FBQztBQUNGLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDdkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDbkMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUM5RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsRUFBRTtBQUN6RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztBQUN6RSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNKLENBQUMsQ0FBQztBQUNGLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDWCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDMUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsTUFBTSxDQUFDLFFBQVEsQ0FBQyxtQ0FBbUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RCxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVM7QUFDZixDQUFDLENBQUMsR0FBRyxDQUFDLGNBQWM7QUFDcEIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDN0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO0FBQzNELENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsVUFBVTtBQUM5RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUs7QUFDbkUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDdkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDbkUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJO0FBQ3BFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUk7QUFDeEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQzdELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQ2pFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLE9BQU87QUFDakUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDO0FBQ3RFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ1YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3ZCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2hFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxjQUFjLENBQUM7QUFDM0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSztBQUM5RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztBQUM1RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUM7QUFDNUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztBQUMvQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyw4QkFBOEIsQ0FBQyxTQUFTLENBQUM7QUFDakQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNQLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsUUFBUSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDdEMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQ2xDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUNuQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7QUFDOUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUk7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDbkUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDckMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNUO0FBQ0EsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDNUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7QUFDakMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQztBQUNuRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7QUFDakUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVztBQUNoRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztBQUM1RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN6QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDO0FBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQztBQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUN2QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNULENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLO0FBQ3hDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzNCLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLO0FBQ3ZELENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJO0FBQ2IsQ0FBQztBQUNEO0FBQ0EsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzdCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNWLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0FBQ2pFLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSztBQUNmLENBQUMsQ0FBQyxDQUFDO0FBQ0g7QUFDQSxNQUFNLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDMUQsQ0FBQztBQUNEO0FBQ0EsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQyxJQUFJO0FBQy9HLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUztBQUMvRSxNQUFNLENBQUMsUUFBUSxDQUFDLDhCQUE4QixDQUFDLFFBQVEsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDekUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUTtBQUN0QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUM7QUFDMUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDN0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJO0FBQzlFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHO0FBQzlGLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7QUFDOUYsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztBQUN2RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQ3hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbEQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUN6QyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDO0FBQ2pCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQzlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFDckQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDVCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFDOUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNO0FBQ1osQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2hCLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQztBQUN4QixDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQixNQUFNLENBQUMsbUNBQW1DLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0RCxDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUM7QUFDaEIsQ0FBQztBQUNELEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM1QyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDOUQsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDdkIsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0FBQ047QUFDQSxNQUFNLENBQUMsUUFBUSxDQUFDLHVDQUF1QyxDQUFDO0FBQ3hELENBQUMsQ0FBQyxFQUFFLENBQUM7QUFDTCxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ2QsQ0FBQyxDQUFDLFdBQVcsQ0FBQztBQUNkLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQywrQkFBK0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDL0UsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQztBQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO0FBQ2xCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxXQUFXLENBQUM7QUFDbEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQ2QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDcEQsQ0FBQyxDQUFDLENBQUM7QUFDSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQztBQUNyQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFDbEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLFdBQVcsQ0FBQztBQUNsQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7QUFDZCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUNoRCxDQUFDLENBQUMsQ0FBQztBQUNIO0FBQ0EsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEtBQUs7QUFDeEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUM7QUFDL0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxjQUFjLENBQUM7QUFDbkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7QUFDaEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDckIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJO0FBQ3ZCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUk7QUFDbkQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUNqRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQztBQUNsRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDbEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUNuQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ1YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQztBQUM3TixDQUFDLENBQUMsQ0FBQztBQUNILENBQUM7QUFDRDtBQUNBLFFBQVEsQ0FBQyxpQkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDO0FBQ3RFLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO0FBQ3BDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLFFBQVE7QUFDdEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsUUFBUTtBQUM5QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyx3QkFBd0IsQ0FBQyxhQUFhLENBQUMsQ0FBQyxHQUFHLENBQUM7QUFDcEUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxHQUFHO0FBQ3BDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsR0FBRztBQUN2RCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxNQUFNLENBQUMsSUFBSTtBQUNiLENBQUM7QUFDRDtBQUNBLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxLQUFLO0FBQy9FLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7QUFDeEUsTUFBTSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDeEc7QUFDQSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztBQUN6RCxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDOyJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.676Z",
        "time": 10.029999997641426,
        "timings": {
          "blocked": 3.526999999787891,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.10699999999999998,
          "wait": 4.890000000973698,
          "receive": 1.5059999968798365,
          "_blocked_queueing": 3.1909999997878913,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 0
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "37087"
            },
            {
              "name": "Etag",
              "value": "W/\"90df-GkrVBYzH0OVKkCLLyen3Ujduao8\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 37087,
            "mimeType": "text/javascript",
            "text": "import {\n  require_react\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-RLJ2RCJQ.js?v=2a7591ed\";\nimport {\n  __commonJS\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/react/cjs/react-jsx-dev-runtime.development.js\nvar require_react_jsx_dev_runtime_development = __commonJS({\n  \"node_modules/react/cjs/react-jsx-dev-runtime.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var React = require_react();\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var enableScopeAPI = false;\n        var enableCacheElement = false;\n        var enableTransitionTracing = false;\n        var enableLegacyHidden = false;\n        var enableDebugTracing = false;\n        var REACT_MODULE_REFERENCE;\n        {\n          REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n            // types supported by any Flight configuration anywhere since\n            // we don't know which Flight build this will end up being used\n            // with.\n            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        var assign = Object.assign;\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n          didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n          {\n            if (hasOwnProperty.call(config, \"ref\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.ref !== void 0;\n        }\n        function hasValidKey(config) {\n          {\n            if (hasOwnProperty.call(config, \"key\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.key !== void 0;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n          {\n            if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n              if (!didWarnAboutStringRefs[componentName]) {\n                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n          {\n            var warnAboutAccessingKey = function() {\n              if (!specialPropKeyWarningShown) {\n                specialPropKeyWarningShown = true;\n                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            };\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n              get: warnAboutAccessingKey,\n              configurable: true\n            });\n          }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n          {\n            var warnAboutAccessingRef = function() {\n              if (!specialPropRefWarningShown) {\n                specialPropRefWarningShown = true;\n                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            };\n            warnAboutAccessingRef.isReactWarning = true;\n            Object.defineProperty(props, \"ref\", {\n              get: warnAboutAccessingRef,\n              configurable: true\n            });\n          }\n        }\n        var ReactElement = function(type, key, ref, self, source, owner, props) {\n          var element = {\n            // This tag allows us to uniquely identify this as a React Element\n            $$typeof: REACT_ELEMENT_TYPE,\n            // Built-in properties that belong on the element\n            type,\n            key,\n            ref,\n            props,\n            // Record the component responsible for creating this element.\n            _owner: owner\n          };\n          {\n            element._store = {};\n            Object.defineProperty(element._store, \"validated\", {\n              configurable: false,\n              enumerable: false,\n              writable: true,\n              value: false\n            });\n            Object.defineProperty(element, \"_self\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: self\n            });\n            Object.defineProperty(element, \"_source\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: source\n            });\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n          return element;\n        };\n        function jsxDEV(type, config, maybeKey, source, self) {\n          {\n            var propName;\n            var props = {};\n            var key = null;\n            var ref = null;\n            if (maybeKey !== void 0) {\n              {\n                checkKeyStringCoercion(maybeKey);\n              }\n              key = \"\" + maybeKey;\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              warnIfStringRefCannotBeAutoConverted(config, self);\n            }\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n            if (type && type.defaultProps) {\n              var defaultProps = type.defaultProps;\n              for (propName in defaultProps) {\n                if (props[propName] === void 0) {\n                  props[propName] = defaultProps[propName];\n                }\n              }\n            }\n            if (key || ref) {\n              var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n              if (key) {\n                defineKeyPropWarningGetter(props, displayName);\n              }\n              if (ref) {\n                defineRefPropWarningGetter(props, displayName);\n              }\n            }\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n          }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        var propTypesMisspellWarningShown;\n        {\n          propTypesMisspellWarningShown = false;\n        }\n        function isValidElement(object) {\n          {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n          }\n        }\n        function getDeclarationErrorAddendum() {\n          {\n            if (ReactCurrentOwner$1.current) {\n              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n              if (name) {\n                return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n              }\n            }\n            return \"\";\n          }\n        }\n        function getSourceInfoErrorAddendum(source) {\n          {\n            if (source !== void 0) {\n              var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n              var lineNumber = source.lineNumber;\n              return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n            }\n            return \"\";\n          }\n        }\n        var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n          {\n            var info = getDeclarationErrorAddendum();\n            if (!info) {\n              var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n              if (parentName) {\n                info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n              }\n            }\n            return info;\n          }\n        }\n        function validateExplicitKey(element, parentType) {\n          {\n            if (!element._store || element._store.validated || element.key != null) {\n              return;\n            }\n            element._store.validated = true;\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n              return;\n            }\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n            var childOwner = \"\";\n            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n              childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n            }\n            setCurrentlyValidatingElement$1(element);\n            error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n        function validateChildKeys(node, parentType) {\n          {\n            if (typeof node !== \"object\") {\n              return;\n            }\n            if (isArray(node)) {\n              for (var i = 0; i < node.length; i++) {\n                var child = node[i];\n                if (isValidElement(child)) {\n                  validateExplicitKey(child, parentType);\n                }\n              }\n            } else if (isValidElement(node)) {\n              if (node._store) {\n                node._store.validated = true;\n              }\n            } else if (node) {\n              var iteratorFn = getIteratorFn(node);\n              if (typeof iteratorFn === \"function\") {\n                if (iteratorFn !== node.entries) {\n                  var iterator = iteratorFn.call(node);\n                  var step;\n                  while (!(step = iterator.next()).done) {\n                    if (isValidElement(step.value)) {\n                      validateExplicitKey(step.value, parentType);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        function validatePropTypes(element) {\n          {\n            var type = element.type;\n            if (type === null || type === void 0 || typeof type === \"string\") {\n              return;\n            }\n            var propTypes;\n            if (typeof type === \"function\") {\n              propTypes = type.propTypes;\n            } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n            // Inner props are checked in the reconciler.\n            type.$$typeof === REACT_MEMO_TYPE)) {\n              propTypes = type.propTypes;\n            } else {\n              return;\n            }\n            if (propTypes) {\n              var name = getComponentNameFromType(type);\n              checkPropTypes(propTypes, element.props, \"prop\", name, element);\n            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n              propTypesMisspellWarningShown = true;\n              var _name = getComponentNameFromType(type);\n              error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n            }\n            if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n            }\n          }\n        }\n        function validateFragmentProps(fragment) {\n          {\n            var keys = Object.keys(fragment.props);\n            for (var i = 0; i < keys.length; i++) {\n              var key = keys[i];\n              if (key !== \"children\" && key !== \"key\") {\n                setCurrentlyValidatingElement$1(fragment);\n                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n                setCurrentlyValidatingElement$1(null);\n                break;\n              }\n            }\n            if (fragment.ref !== null) {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n              setCurrentlyValidatingElement$1(null);\n            }\n          }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n          {\n            var validType = isValidElementType(type);\n            if (!validType) {\n              var info = \"\";\n              if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n              }\n              var sourceInfo = getSourceInfoErrorAddendum(source);\n              if (sourceInfo) {\n                info += sourceInfo;\n              } else {\n                info += getDeclarationErrorAddendum();\n              }\n              var typeString;\n              if (type === null) {\n                typeString = \"null\";\n              } else if (isArray(type)) {\n                typeString = \"array\";\n              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n                typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                info = \" Did you accidentally export a JSX literal instead of a component?\";\n              } else {\n                typeString = typeof type;\n              }\n              error(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n            }\n            var element = jsxDEV(type, props, key, source, self);\n            if (element == null) {\n              return element;\n            }\n            if (validType) {\n              var children = props.children;\n              if (children !== void 0) {\n                if (isStaticChildren) {\n                  if (isArray(children)) {\n                    for (var i = 0; i < children.length; i++) {\n                      validateChildKeys(children[i], type);\n                    }\n                    if (Object.freeze) {\n                      Object.freeze(children);\n                    }\n                  } else {\n                    error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n                  }\n                } else {\n                  validateChildKeys(children, type);\n                }\n              }\n            }\n            {\n              if (hasOwnProperty.call(props, \"key\")) {\n                var componentName = getComponentNameFromType(type);\n                var keys = Object.keys(props).filter(function(k) {\n                  return k !== \"key\";\n                });\n                var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                  var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                  error('A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n                  didWarnAboutKeySpread[componentName + beforeExample] = true;\n                }\n              }\n            }\n            if (type === REACT_FRAGMENT_TYPE) {\n              validateFragmentProps(element);\n            } else {\n              validatePropTypes(element);\n            }\n            return element;\n          }\n        }\n        var jsxDEV$1 = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV$1;\n      })();\n    }\n  }\n});\n\n// node_modules/react/jsx-dev-runtime.js\nvar require_jsx_dev_runtime = __commonJS({\n  \"node_modules/react/jsx-dev-runtime.js\"(exports, module) {\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_react_jsx_dev_runtime_development();\n    }\n  }\n});\nexport default require_jsx_dev_runtime();\n/*! Bundled license information:\n\nreact/cjs/react-jsx-dev-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-dev-runtime.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n//# sourceMappingURL=react_jsx-dev-runtime.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 2.4389999998675194,
        "timings": {
          "blocked": 1.8330000018167776,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.14599999875738284,
          "receive": 0.459999999293359,
          "_blocked_queueing": 1.7570000018167775,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 1
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "271"
            },
            {
              "name": "Etag",
              "value": "W/\"10f-dsN0Fi3zvjoKDpm6N5bW5uAfYLc\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 271,
            "mimeType": "text/javascript",
            "text": "import {\n  require_react\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-RLJ2RCJQ.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\nexport default require_react();\n//# sourceMappingURL=react.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 3.9819999983592425,
        "timings": {
          "blocked": 2.110000000245869,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.7720000004358589,
          "receive": 1.0999999976775143,
          "_blocked_queueing": 2.064000000245869,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 2
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-dom_client.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "1196"
            },
            {
              "name": "Etag",
              "value": "W/\"4ac-OoS9K9k9edMjcSeu2oJ0/76jJfk\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 1196,
            "mimeType": "text/javascript",
            "text": "import {\n  require_react_dom\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-RLJ2RCJQ.js?v=2a7591ed\";\nimport {\n  __commonJS\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/react-dom/client.js\nvar require_client = __commonJS({\n  \"node_modules/react-dom/client.js\"(exports) {\n    var m = require_react_dom();\n    if (false) {\n      exports.createRoot = m.createRoot;\n      exports.hydrateRoot = m.hydrateRoot;\n    } else {\n      i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n      exports.createRoot = function(c, o) {\n        i.usingClientEntryPoint = true;\n        try {\n          return m.createRoot(c, o);\n        } finally {\n          i.usingClientEntryPoint = false;\n        }\n      };\n      exports.hydrateRoot = function(c, h, o) {\n        i.usingClientEntryPoint = true;\n        try {\n          return m.hydrateRoot(c, h, o);\n        } finally {\n          i.usingClientEntryPoint = false;\n        }\n      };\n    }\n    var i;\n  }\n});\nexport default require_client();\n//# sourceMappingURL=react-dom_client.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 4.935000000841683,
        "timings": {
          "blocked": 2.142999998982763,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.886000000532018,
          "receive": 1.9060000013269018,
          "_blocked_queueing": 2.113999998982763,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184618",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 3
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/App.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"48d5-n1moDxRB1Ur074Hec7oO2Ni8JDg\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 518,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 41624,
            "mimeType": "text/javascript",
            "text": "aW1wb3J0IHsgY3JlYXRlSG90Q29udGV4dCBhcyBfX3ZpdGVfX2NyZWF0ZUhvdENvbnRleHQgfSBmcm9tICIvQHZpdGUvY2xpZW50IjtpbXBvcnQubWV0YS5ob3QgPSBfX3ZpdGVfX2NyZWF0ZUhvdENvbnRleHQoIi9BcHAudHN4Iik7aW1wb3J0IF9fdml0ZV9fY2pzSW1wb3J0MF9yZWFjdF9qc3hEZXZSdW50aW1lIGZyb20gIi9AZnMvaG9tZS9qYW5vL0RFVl9XU0wvTExNL25vZGVfbW9kdWxlcy8udml0ZS9kZXBzL3JlYWN0X2pzeC1kZXYtcnVudGltZS5qcz92PTJhNzU5MWVkIjsgY29uc3QganN4REVWID0gX192aXRlX19janNJbXBvcnQwX3JlYWN0X2pzeERldlJ1bnRpbWVbImpzeERFViJdOwppbXBvcnQgKiBhcyBSZWZyZXNoUnVudGltZSBmcm9tICIvQHJlYWN0LXJlZnJlc2giOwpjb25zdCBpbldlYldvcmtlciA9IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSAhPT0gInVuZGVmaW5lZCIgJiYgc2VsZiBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlOwpsZXQgcHJldlJlZnJlc2hSZWc7CmxldCBwcmV2UmVmcmVzaFNpZzsKaWYgKGltcG9ydC5tZXRhLmhvdCAmJiAhaW5XZWJXb3JrZXIpIHsKICBpZiAoIXdpbmRvdy4kUmVmcmVzaFJlZyQpIHsKICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgIkB2aXRlanMvcGx1Z2luLXJlYWN0IGNhbid0IGRldGVjdCBwcmVhbWJsZS4gU29tZXRoaW5nIGlzIHdyb25nLiIKICAgICk7CiAgfQogIHByZXZSZWZyZXNoUmVnID0gd2luZG93LiRSZWZyZXNoUmVnJDsKICBwcmV2UmVmcmVzaFNpZyA9IHdpbmRvdy4kUmVmcmVzaFNpZyQ7CiAgd2luZG93LiRSZWZyZXNoUmVnJCA9IFJlZnJlc2hSdW50aW1lLmdldFJlZnJlc2hSZWcoIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giKTsKICB3aW5kb3cuJFJlZnJlc2hTaWckID0gUmVmcmVzaFJ1bnRpbWUuY3JlYXRlU2lnbmF0dXJlRnVuY3Rpb25Gb3JUcmFuc2Zvcm07Cn0KdmFyIF9zID0gJFJlZnJlc2hTaWckKCk7CmltcG9ydCBfX3ZpdGVfX2Nqc0ltcG9ydDNfcmVhY3QgZnJvbSAiL0Bmcy9ob21lL2phbm8vREVWX1dTTC9MTE0vbm9kZV9tb2R1bGVzLy52aXRlL2RlcHMvcmVhY3QuanM/dj0yYTc1OTFlZCI7IGNvbnN0IHVzZVN0YXRlID0gX192aXRlX19janNJbXBvcnQzX3JlYWN0WyJ1c2VTdGF0ZSJdOwppbXBvcnQgSGVhZGVyIGZyb20gIi9jb21wb25lbnRzL0hlYWRlci50c3giOwppbXBvcnQgTW9kYWwgZnJvbSAiL2NvbXBvbmVudHMvTW9kYWwudHN4IjsKaW1wb3J0IFByb21wdElucHV0IGZyb20gIi9jb21wb25lbnRzL1Byb21wdElucHV0LnRzeCI7CmltcG9ydCBMTE1SZXNwb25zZUJveCBmcm9tICIvY29tcG9uZW50cy9MTE1SZXNwb25zZUJveC50c3giOwppbXBvcnQgeyB1c2VTdGF0aXN0aWNzIH0gZnJvbSAiL2hvb2tzL3VzZVN0YXRpc3RpY3MudHMiOwppbXBvcnQgeyB1c2VNb2RlbHMgfSBmcm9tICIvaG9va3MvdXNlTW9kZWxzLnRzIjsKaW1wb3J0IHsgYXBpIH0gZnJvbSAiL3NlcnZpY2VzL2FwaS50cyI7CmltcG9ydCB7IGZpbGVBUEkgfSBmcm9tICIvc2VydmljZXMvZmlsZS5hcGkudHMiOwpmdW5jdGlvbiBBcHAoKSB7CiAgX3MoKTsKICBjb25zdCBbc2hvd0Fib3V0TW9kYWwsIHNldFNob3dBYm91dE1vZGFsXSA9IHVzZVN0YXRlKGZhbHNlKTsKICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7CiAgY29uc3QgW3Jlc3BvbnNlcywgc2V0UmVzcG9uc2VzXSA9IHVzZVN0YXRlKG51bGwpOwogIGNvbnN0IFtzdHJlYW1pbmdSZXNwb25zZXMsIHNldFN0cmVhbWluZ1Jlc3BvbnNlc10gPSB1c2VTdGF0ZSh7IG9wZW5haTogIiIsIGFudGhyb3BpYzogIiIgfSk7CiAgY29uc3QgW3VwbG9hZGVkRmlsZXMsIHNldFVwbG9hZGVkRmlsZXNdID0gdXNlU3RhdGUoW10pOwogIGNvbnN0IFtmaWxlV2FybmluZ3MsIHNldEZpbGVXYXJuaW5nc10gPSB1c2VTdGF0ZShbXSk7CiAgY29uc3QgdXNlU3RyZWFtaW5nID0gdHJ1ZTsKICBjb25zdCBbb3BlbmFpTW9kZWwsIHNldE9wZW5haU1vZGVsXSA9IHVzZVN0YXRlKCJncHQtNG8tbWluaS0yMDI0LTA3LTE4Iik7CiAgY29uc3QgW2FudGhyb3BpY01vZGVsLCBzZXRBbnRocm9waWNNb2RlbF0gPSB1c2VTdGF0ZSgiY2xhdWRlLTMtNS1oYWlrdS1sYXRlc3QiKTsKICBjb25zdCBbb3BlbmFpVGVtcGVyYXR1cmUsIHNldE9wZW5haVRlbXBlcmF0dXJlXSA9IHVzZVN0YXRlKDAuNyk7CiAgY29uc3QgW2FudGhyb3BpY1RlbXBlcmF0dXJlLCBzZXRBbnRocm9waWNUZW1wZXJhdHVyZV0gPSB1c2VTdGF0ZSgwLjcpOwogIGNvbnN0IHsgc3RhdGlzdGljcywgcmVmZXRjaDogcmVmZXRjaFN0YXRpc3RpY3MgfSA9IHVzZVN0YXRpc3RpY3MoKTsKICBjb25zdCB7IG9wZW5haU1vZGVscywgYW50aHJvcGljTW9kZWxzIH0gPSB1c2VNb2RlbHMoKTsKICBjb25zdCBoYW5kbGVQcm9tcHRTdWJtaXQgPSBhc3luYyAocHJvbXB0LCBmaWxlcykgPT4gewogICAgc2V0TG9hZGluZyh0cnVlKTsKICAgIHNldFJlc3BvbnNlcyhudWxsKTsKICAgIHNldFN0cmVhbWluZ1Jlc3BvbnNlcyh7IG9wZW5haTogIiIsIGFudGhyb3BpYzogIiIgfSk7CiAgICBzZXRGaWxlV2FybmluZ3MoW10pOwogICAgbGV0IGZpbGVJZHMgPSBbXTsKICAgIGlmIChmaWxlcyAmJiBmaWxlcy5sZW5ndGggPiAwKSB7CiAgICAgIHRyeSB7CiAgICAgICAgY29uc3QgdXBsb2FkUmVzcG9uc2UgPSBhd2FpdCBmaWxlQVBJLnVwbG9hZEZpbGVzKGZpbGVzKTsKICAgICAgICBpZiAodXBsb2FkUmVzcG9uc2Uuc3VjY2VzcyAmJiB1cGxvYWRSZXNwb25zZS5kYXRhKSB7CiAgICAgICAgICBzZXRVcGxvYWRlZEZpbGVzKHVwbG9hZFJlc3BvbnNlLmRhdGEuZmlsZXMpOwogICAgICAgICAgZmlsZUlkcyA9IHVwbG9hZFJlc3BvbnNlLmRhdGEuZmlsZXMubWFwKChmKSA9PiBmLmlkKTsKICAgICAgICAgIGlmICh1cGxvYWRSZXNwb25zZS5kYXRhLmVycm9ycyAmJiB1cGxvYWRSZXNwb25zZS5kYXRhLmVycm9ycy5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZXMgPSB1cGxvYWRSZXNwb25zZS5kYXRhLmVycm9ycy5tYXAoKGUpID0+IGAke2UuZmlsZX06ICR7ZS5lcnJvcn1gKTsKICAgICAgICAgICAgc2V0RmlsZVdhcm5pbmdzKGVycm9yTWVzc2FnZXMpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBzZXRGaWxlV2FybmluZ3MoW3VwbG9hZFJlc3BvbnNlLmVycm9yIHx8ICJFcnJvciBhbCBzdWJpciBhcmNoaXZvcyJdKTsKICAgICAgICB9CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgY29uc29sZS5lcnJvcigiRmlsZSB1cGxvYWQgZXJyb3I6IiwgZXJyb3IpOwogICAgICAgIHNldEZpbGVXYXJuaW5ncyhbIkVycm9yIGFsIHN1YmlyIGFyY2hpdm9zIl0pOwogICAgICB9CiAgICB9CiAgICB0cnkgewogICAgICBpZiAodXNlU3RyZWFtaW5nKSB7CiAgICAgICAgYXdhaXQgYXBpLnN0cmVhbVJlc3BvbnNlKAogICAgICAgICAgewogICAgICAgICAgICBwcm9tcHQsCiAgICAgICAgICAgIHByb3ZpZGVyOiAiZHVhbCIsCiAgICAgICAgICAgIG9wZW5haU1vZGVsLAogICAgICAgICAgICBhbnRocm9waWNNb2RlbCwKICAgICAgICAgICAgb3BlbmFpVGVtcGVyYXR1cmUsCiAgICAgICAgICAgIGFudGhyb3BpY1RlbXBlcmF0dXJlLAogICAgICAgICAgICBmaWxlSWRzOiBmaWxlSWRzLmxlbmd0aCA+IDAgPyBmaWxlSWRzIDogdm9pZCAwCiAgICAgICAgICB9LAogICAgICAgICAgewogICAgICAgICAgICBvbk9wZW5BSUNodW5rOiAoY2h1bmspID0+IHsKICAgICAgICAgICAgICBzZXRTdHJlYW1pbmdSZXNwb25zZXMoKHByZXYpID0+ICh7IC4uLnByZXYsIG9wZW5haTogcHJldi5vcGVuYWkgKyBjaHVuayB9KSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uQW50aHJvcGljQ2h1bms6IChjaHVuaykgPT4gewogICAgICAgICAgICAgIHNldFN0cmVhbWluZ1Jlc3BvbnNlcygocHJldikgPT4gKHsgLi4ucHJldiwgYW50aHJvcGljOiBwcmV2LmFudGhyb3BpYyArIGNodW5rIH0pKTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgb25FcnJvcjogKGVycm9yKSA9PiB7CiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigiU3RyZWFtaW5nIGVycm9yOiIsIGVycm9yKTsKICAgICAgICAgICAgICBzZXRSZXNwb25zZXMoewogICAgICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsCiAgICAgICAgICAgICAgICBlcnJvcjogYEVycm9yIGVuIHN0cmVhbWluZzogJHtlcnJvcn1gCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHsKICAgICAgICAgICAgICByZWZldGNoU3RhdGlzdGljcygpOwogICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0TG9hZGluZyhmYWxzZSksIDUwMCk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICApOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXBpLmdlbmVyYXRlRHVhbFJlc3BvbnNlKHsKICAgICAgICAgIHByb21wdCwKICAgICAgICAgIG9wZW5haU1vZGVsLAogICAgICAgICAgYW50aHJvcGljTW9kZWwsCiAgICAgICAgICBvcGVuYWlUZW1wZXJhdHVyZSwKICAgICAgICAgIGFudGhyb3BpY1RlbXBlcmF0dXJlLAogICAgICAgICAgZmlsZUlkczogZmlsZUlkcy5sZW5ndGggPiAwID8gZmlsZUlkcyA6IHZvaWQgMAogICAgICAgIH0pOwogICAgICAgIHNldFJlc3BvbnNlcyhyZXNwb25zZSk7CiAgICAgICAgcmVmZXRjaFN0YXRpc3RpY3MoKTsKICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTsKICAgICAgfQogICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgY29uc29sZS5lcnJvcigiRXJyb3IgZ2VuZXJhdGluZyByZXNwb25zZXM6IiwgZXJyb3IpOwogICAgICBzZXRSZXNwb25zZXMoewogICAgICAgIHN1Y2Nlc3M6IGZhbHNlLAogICAgICAgIGVycm9yOiAiRXJyb3IgYWwgZ2VuZXJhciBsYXMgcmVzcHVlc3Rhcy4gUG9yIGZhdm9yLCBpbnRlbnRhIGRlIG51ZXZvLiIKICAgICAgfSk7CiAgICAgIHNldExvYWRpbmcoZmFsc2UpOwogICAgfQogIH07CiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImRpdiIsIHsgY2xhc3NOYW1lOiAiYXBwIiwgY2hpbGRyZW46IFsKICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoCiAgICAgIEhlYWRlciwKICAgICAgewogICAgICAgIHN0YXRpc3RpY3MsCiAgICAgICAgb25TaG93QWJvdXRNb2RhbDogKCkgPT4gc2V0U2hvd0Fib3V0TW9kYWwodHJ1ZSkKICAgICAgfSwKICAgICAgdm9pZCAwLAogICAgICBmYWxzZSwKICAgICAgewogICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgbGluZU51bWJlcjogMTM5LAogICAgICAgIGNvbHVtbk51bWJlcjogNwogICAgICB9LAogICAgICB0aGlzCiAgICApLAogICAgLyogQF9fUFVSRV9fICovIGpzeERFVigibWFpbiIsIHsgY2xhc3NOYW1lOiAibWFpbi1jb250ZW50IiwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImRpdiIsIHsgY2xhc3NOYW1lOiAiY29udGFpbmVyIiwgY2hpbGRyZW46IFsKICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigKICAgICAgICBQcm9tcHRJbnB1dCwKICAgICAgICB7CiAgICAgICAgICBvblN1Ym1pdDogaGFuZGxlUHJvbXB0U3VibWl0LAogICAgICAgICAgbG9hZGluZwogICAgICAgIH0sCiAgICAgICAgdm9pZCAwLAogICAgICAgIGZhbHNlLAogICAgICAgIHsKICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICBsaW5lTnVtYmVyOiAxNDYsCiAgICAgICAgICBjb2x1bW5OdW1iZXI6IDExCiAgICAgICAgfSwKICAgICAgICB0aGlzCiAgICAgICksCiAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImRpdiIsIHsgY2xhc3NOYW1lOiAicmVzcG9uc2VzLWdyaWQiLCBjaGlsZHJlbjogWwogICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoCiAgICAgICAgICBMTE1SZXNwb25zZUJveCwKICAgICAgICAgIHsKICAgICAgICAgICAgdGl0bGU6ICJPcGVuQUkiLAogICAgICAgICAgICBwcm92aWRlcjogIm9wZW5haSIsCiAgICAgICAgICAgIHJlc3BvbnNlOiB1c2VTdHJlYW1pbmcgPyBzdHJlYW1pbmdSZXNwb25zZXMub3BlbmFpIDogcmVzcG9uc2VzPy5kYXRhPy5vcGVuYWkucmVzcG9uc2UgfHwgIiIsCiAgICAgICAgICAgIG1vZGVsOiBvcGVuYWlNb2RlbCwKICAgICAgICAgICAgdGVtcGVyYXR1cmU6IG9wZW5haVRlbXBlcmF0dXJlLAogICAgICAgICAgICBtb2RlbHM6IG9wZW5haU1vZGVscywKICAgICAgICAgICAgbG9hZGluZywKICAgICAgICAgICAgb25Nb2RlbENoYW5nZTogc2V0T3BlbmFpTW9kZWwsCiAgICAgICAgICAgIG9uVGVtcGVyYXR1cmVDaGFuZ2U6IHNldE9wZW5haVRlbXBlcmF0dXJlCiAgICAgICAgICB9LAogICAgICAgICAgdm9pZCAwLAogICAgICAgICAgZmFsc2UsCiAgICAgICAgICB7CiAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDE1MiwKICAgICAgICAgICAgY29sdW1uTnVtYmVyOiAxMwogICAgICAgICAgfSwKICAgICAgICAgIHRoaXMKICAgICAgICApLAogICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoCiAgICAgICAgICBMTE1SZXNwb25zZUJveCwKICAgICAgICAgIHsKICAgICAgICAgICAgdGl0bGU6ICJBbnRocm9waWMiLAogICAgICAgICAgICBwcm92aWRlcjogImFudGhyb3BpYyIsCiAgICAgICAgICAgIHJlc3BvbnNlOiB1c2VTdHJlYW1pbmcgPyBzdHJlYW1pbmdSZXNwb25zZXMuYW50aHJvcGljIDogcmVzcG9uc2VzPy5kYXRhPy5hbnRocm9waWMucmVzcG9uc2UgfHwgIiIsCiAgICAgICAgICAgIG1vZGVsOiBhbnRocm9waWNNb2RlbCwKICAgICAgICAgICAgdGVtcGVyYXR1cmU6IGFudGhyb3BpY1RlbXBlcmF0dXJlLAogICAgICAgICAgICBtb2RlbHM6IGFudGhyb3BpY01vZGVscywKICAgICAgICAgICAgbG9hZGluZywKICAgICAgICAgICAgb25Nb2RlbENoYW5nZTogc2V0QW50aHJvcGljTW9kZWwsCiAgICAgICAgICAgIG9uVGVtcGVyYXR1cmVDaGFuZ2U6IHNldEFudGhyb3BpY1RlbXBlcmF0dXJlCiAgICAgICAgICB9LAogICAgICAgICAgdm9pZCAwLAogICAgICAgICAgZmFsc2UsCiAgICAgICAgICB7CiAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDE2NCwKICAgICAgICAgICAgY29sdW1uTnVtYmVyOiAxMwogICAgICAgICAgfSwKICAgICAgICAgIHRoaXMKICAgICAgICApCiAgICAgIF0gfSwgdm9pZCAwLCB0cnVlLCB7CiAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICBsaW5lTnVtYmVyOiAxNTEsCiAgICAgICAgY29sdW1uTnVtYmVyOiAxMQogICAgICB9LCB0aGlzKSwKICAgICAgZmlsZVdhcm5pbmdzLmxlbmd0aCA+IDAgJiYgLyogQF9fUFVSRV9fICovIGpzeERFVigiZGl2IiwgeyBjbGFzc05hbWU6ICJmaWxlLXN0YXR1cy1tZXNzYWdlIGZpbGUtc3RhdHVzLXdhcm5pbmciLCBjaGlsZHJlbjogWwogICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInN0cm9uZyIsIHsgY2hpbGRyZW46ICJBZHZlcnRlbmNpYXMgZGUgYXJjaGl2b3M6IiB9LCB2b2lkIDAsIGZhbHNlLCB7CiAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgbGluZU51bWJlcjogMTc5LAogICAgICAgICAgY29sdW1uTnVtYmVyOiAxNQogICAgICAgIH0sIHRoaXMpLAogICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInVsIiwgeyBzdHlsZTogeyBtYXJnaW5Ub3A6ICIwLjVyZW0iLCBtYXJnaW5MZWZ0OiAiMXJlbSIgfSwgY2hpbGRyZW46IGZpbGVXYXJuaW5ncy5tYXAoCiAgICAgICAgICAod2FybmluZywgaW5kZXgpID0+IC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImxpIiwgeyBjaGlsZHJlbjogd2FybmluZyB9LCBpbmRleCwgZmFsc2UsIHsKICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgbGluZU51bWJlcjogMTgyLAogICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDE1CiAgICAgICAgICB9LCB0aGlzKQogICAgICAgICkgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgIGxpbmVOdW1iZXI6IDE4MCwKICAgICAgICAgIGNvbHVtbk51bWJlcjogMTUKICAgICAgICB9LCB0aGlzKQogICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgbGluZU51bWJlcjogMTc4LAogICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgfSwgdGhpcyksCiAgICAgIHJlc3BvbnNlcz8uZXJyb3IgJiYgLyogQF9fUFVSRV9fICovIGpzeERFVigiZGl2IiwgeyBjbGFzc05hbWU6ICJlcnJvci1tZXNzYWdlIiwgY2hpbGRyZW46IFsKICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJzdmciLCB7IGNsYXNzTmFtZTogInctNSBoLTUgbXItMiIsIGZpbGw6ICJub25lIiwgc3Ryb2tlOiAiY3VycmVudENvbG9yIiwgdmlld0JveDogIjAgMCAyNCAyNCIsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4REVWKAogICAgICAgICAgInBhdGgiLAogICAgICAgICAgewogICAgICAgICAgICBzdHJva2VMaW5lY2FwOiAicm91bmQiLAogICAgICAgICAgICBzdHJva2VMaW5lam9pbjogInJvdW5kIiwKICAgICAgICAgICAgc3Ryb2tlV2lkdGg6ICIyIiwKICAgICAgICAgICAgZDogIk0xMiA4djRtMCA0aC4wMU0yMSAxMmE5IDkgMCAxMS0xOCAwIDkgOSAwIDAxMTggMHoiCiAgICAgICAgICB9LAogICAgICAgICAgdm9pZCAwLAogICAgICAgICAgZmFsc2UsCiAgICAgICAgICB7CiAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDE5MSwKICAgICAgICAgICAgY29sdW1uTnVtYmVyOiAxNwogICAgICAgICAgfSwKICAgICAgICAgIHRoaXMKICAgICAgICApIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICBsaW5lTnVtYmVyOiAxOTAsCiAgICAgICAgICBjb2x1bW5OdW1iZXI6IDE1CiAgICAgICAgfSwgdGhpcyksCiAgICAgICAgcmVzcG9uc2VzLmVycm9yCiAgICAgIF0gfSwgdm9pZCAwLCB0cnVlLCB7CiAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICBsaW5lTnVtYmVyOiAxODksCiAgICAgICAgY29sdW1uTnVtYmVyOiAxMQogICAgICB9LCB0aGlzKQogICAgXSB9LCB2b2lkIDAsIHRydWUsIHsKICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgbGluZU51bWJlcjogMTQ1LAogICAgICBjb2x1bW5OdW1iZXI6IDkKICAgIH0sIHRoaXMpIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgbGluZU51bWJlcjogMTQ0LAogICAgICBjb2x1bW5OdW1iZXI6IDcKICAgIH0sIHRoaXMpLAogICAgLyogQF9fUFVSRV9fICovIGpzeERFVigKICAgICAgTW9kYWwsCiAgICAgIHsKICAgICAgICBpc09wZW46IHNob3dBYm91dE1vZGFsLAogICAgICAgIG9uQ2xvc2U6ICgpID0+IHNldFNob3dBYm91dE1vZGFsKGZhbHNlKSwKICAgICAgICB0aXRsZTogIkdyYW5kZXMgTW9kZWxvcyBkZSBMZW5ndWFqZSAoSW5mb21lZC1HVVJVKSIsCiAgICAgICAgY2hpbGRyZW46IFsKICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImRpdiIsIHsgY2xhc3NOYW1lOiAibW9kYWwtdGV4dCIsIGNoaWxkcmVuOiBbCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImgzIiwgeyBzdHlsZTogeyBmb250U2l6ZTogIjEuMXJlbSIsIG1hcmdpbkJvdHRvbTogIjAuNzVyZW0iLCBjb2xvcjogIiMxMTE4MjciIH0sIGNoaWxkcmVuOiAi8J+TiyBUZWNub2xvZ8OtYSIgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgbGluZU51bWJlcjogMjA2LAogICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInAiLCB7IHN0eWxlOiB7IG1hcmdpbkxlZnQ6ICIwLjVyZW0iIH0sIGNoaWxkcmVuOiAiQXBsaWNhY2nDs24gd2ViIHF1ZSBwZXJtaXRlIGNvbXBhcmFyIHJlc3B1ZXN0YXMgZGUgZGlmZXJlbnRlcyBtb2RlbG9zIGRlIGxlbmd1YWplIGVuIHRpZW1wbyByZWFsLiIgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgbGluZU51bWJlcjogMjA3LAogICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgICAgICAgfSwgdGhpcykKICAgICAgICAgIF0gfSwgdm9pZCAwLCB0cnVlLCB7CiAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIwNSwKICAgICAgICAgICAgY29sdW1uTnVtYmVyOiA5CiAgICAgICAgICB9LCB0aGlzKSwKICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImRpdiIsIHsgY2xhc3NOYW1lOiAibW9kYWwtdGV4dCIsIGNoaWxkcmVuOiBbCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImgzIiwgeyBzdHlsZTogeyBmb250U2l6ZTogIjEuMXJlbSIsIG1hcmdpbkJvdHRvbTogIjAuNzVyZW0iLCBjb2xvcjogIiMxMTE4MjciIH0sIGNoaWxkcmVuOiAi8J+kliBNb2RlbG9zIGRpc3BvbmlibGVzIiB9LCB2b2lkIDAsIGZhbHNlLCB7CiAgICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMTEsCiAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiAxMQogICAgICAgICAgICB9LCB0aGlzKSwKICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigidWwiLCB7IHN0eWxlOiB7IG1hcmdpbkxlZnQ6ICIxLjVyZW0iIH0sIGNoaWxkcmVuOiBbCiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigibGkiLCB7IGNoaWxkcmVuOiBbCiAgICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJzdHJvbmciLCB7IGNoaWxkcmVuOiAiT3BlbkFJOiIgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMTMsCiAgICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTcKICAgICAgICAgICAgICAgIH0sIHRoaXMpLAogICAgICAgICAgICAgICAgIiBHUFQtNCBNaW5pIHkgR1BULTMuNSBUdXJibyIKICAgICAgICAgICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIxMywKICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTMKICAgICAgICAgICAgICB9LCB0aGlzKSwKICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJsaSIsIHsgY2hpbGRyZW46IFsKICAgICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInN0cm9uZyIsIHsgY2hpbGRyZW46ICJBbnRocm9waWM6IiB9LCB2b2lkIDAsIGZhbHNlLCB7CiAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIxNCwKICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiAxNwogICAgICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgICAgICAiIENsYXVkZSAzLjUgSGFpa3UgeSBDbGF1ZGUgMy41IFNvbm5ldCIKICAgICAgICAgICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIxNCwKICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTMKICAgICAgICAgICAgICB9LCB0aGlzKQogICAgICAgICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgbGluZU51bWJlcjogMjEyLAogICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgICAgICAgfSwgdGhpcykKICAgICAgICAgIF0gfSwgdm9pZCAwLCB0cnVlLCB7CiAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIxMCwKICAgICAgICAgICAgY29sdW1uTnVtYmVyOiA5CiAgICAgICAgICB9LCB0aGlzKSwKICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImRpdiIsIHsgY2xhc3NOYW1lOiAibW9kYWwtdGV4dCIsIGNoaWxkcmVuOiBbCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImgzIiwgeyBzdHlsZTogeyBmb250U2l6ZTogIjEuMXJlbSIsIG1hcmdpbkJvdHRvbTogIjAuNzVyZW0iLCBjb2xvcjogIiMxMTE4MjciIH0sIGNoaWxkcmVuOiAi4pyoIEZ1bmNpb25hbGlkYWRlcyIgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgbGluZU51bWJlcjogMjE5LAogICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInVsIiwgeyBzdHlsZTogeyBtYXJnaW5MZWZ0OiAiMS41cmVtIiB9LCBjaGlsZHJlbjogWwogICAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoImxpIiwgeyBjaGlsZHJlbjogIkNvbXBhcmFjacOzbiBzaW11bHTDoW5lYSBkZSByZXNwdWVzdGFzIGRlIGRvcyBMTE0iIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMjEsCiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDEzCiAgICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigibGkiLCB7IGNoaWxkcmVuOiAiU2VsZWNjacOzbiBkaW7DoW1pY2EgZGUgbW9kZWxvcyIgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIyMiwKICAgICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTMKICAgICAgICAgICAgICB9LCB0aGlzKSwKICAgICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJsaSIsIHsgY2hpbGRyZW46ICJBanVzdGUgZGUgdGVtcGVyYXR1cmEgcGFyYSBjb250cm9sYXIgbGEgY3JlYXRpdmlkYWQiIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMjMsCiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDEzCiAgICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigibGkiLCB7IGNoaWxkcmVuOiAiQ29udGFkb3IgZGUgcHJvbXB0cyBnZW5lcmFkb3MiIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMjQsCiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDEzCiAgICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigibGkiLCB7IGNoaWxkcmVuOiAiSW50ZXJmYXogYmlsaW5nw7xlIG9wdGltaXphZGEiIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMjUsCiAgICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDEzCiAgICAgICAgICAgICAgfSwgdGhpcykKICAgICAgICAgICAgXSB9LCB2b2lkIDAsIHRydWUsIHsKICAgICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIyMCwKICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDExCiAgICAgICAgICAgIH0sIHRoaXMpCiAgICAgICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICBsaW5lTnVtYmVyOiAyMTgsCiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogOQogICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJkaXYiLCB7IGNsYXNzTmFtZTogIm1vZGFsLXRleHQiLCBjaGlsZHJlbjogWwogICAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJoMyIsIHsgc3R5bGU6IHsgZm9udFNpemU6ICIxLjFyZW0iLCBtYXJnaW5Cb3R0b206ICIwLjc1cmVtIiwgY29sb3I6ICIjMTExODI3IiB9LCBjaGlsZHJlbjogIuKame+4jyBDb25maWd1cmFjacOzbiIgfSwgdm9pZCAwLCBmYWxzZSwgewogICAgICAgICAgICAgIGZpbGVOYW1lOiAiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsCiAgICAgICAgICAgICAgbGluZU51bWJlcjogMjMwLAogICAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInAiLCB7IHN0eWxlOiB7IG1hcmdpbkxlZnQ6ICIwLjVyZW0iIH0sIGNoaWxkcmVuOiAiTGEgdGVtcGVyYXR1cmEgY29udHJvbGEgbGEgYWxlYXRvcmllZGFkIGRlIGxhcyByZXNwdWVzdGFzICgwID0gbcOhcyBkZXRlcm1pbmlzdGEsIDEgPSBtw6FzIGNyZWF0aXZvKS4iIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIzMSwKICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDExCiAgICAgICAgICAgIH0sIHRoaXMpCiAgICAgICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICBsaW5lTnVtYmVyOiAyMjksCiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogOQogICAgICAgICAgfSwgdGhpcyksCiAgICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4REVWKCJkaXYiLCB7IGNsYXNzTmFtZTogIm1vZGFsLXRleHQiLCBzdHlsZTogeyBib3JkZXJUb3A6ICIxcHggc29saWQgI2U1ZTdlYiIsIHBhZGRpbmdUb3A6ICIxcmVtIiwgbWFyZ2luVG9wOiAiMXJlbSIgfSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInAiLCB7IHN0eWxlOiB7IHRleHRBbGlnbjogImNlbnRlciIsIGZvbnRTdHlsZTogIml0YWxpYyIsIGNvbG9yOiAiIzZiNzI4MCIgfSwgY2hpbGRyZW46IFsKICAgICAgICAgICAgIkNyZWFkbyBwb3IgIiwKICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIGpzeERFVigic3Ryb25nIiwgeyBzdHlsZTogeyBjb2xvcjogIiMxMTE4MjciIH0sIGNoaWxkcmVuOiAiQWxlamFuZHJvIE1hdXJvIiB9LCB2b2lkIDAsIGZhbHNlLCB7CiAgICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgICBsaW5lTnVtYmVyOiAyMzYsCiAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiAyNAogICAgICAgICAgICB9LCB0aGlzKSwKICAgICAgICAgICAgIiB1dGlsaXphbmRvICIsCiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBqc3hERVYoInN0cm9uZyIsIHsgc3R5bGU6IHsgY29sb3I6ICIjMjU2M2ViIiB9LCBjaGlsZHJlbjogIlZpYmVjb2RpbmciIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICAgIGxpbmVOdW1iZXI6IDIzNiwKICAgICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDk3CiAgICAgICAgICAgIH0sIHRoaXMpCiAgICAgICAgICBdIH0sIHZvaWQgMCwgdHJ1ZSwgewogICAgICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgICAgICBsaW5lTnVtYmVyOiAyMzUsCiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogMTEKICAgICAgICAgIH0sIHRoaXMpIH0sIHZvaWQgMCwgZmFsc2UsIHsKICAgICAgICAgICAgZmlsZU5hbWU6ICIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwKICAgICAgICAgICAgbGluZU51bWJlcjogMjM0LAogICAgICAgICAgICBjb2x1bW5OdW1iZXI6IDkKICAgICAgICAgIH0sIHRoaXMpCiAgICAgICAgXQogICAgICB9LAogICAgICB2b2lkIDAsCiAgICAgIHRydWUsCiAgICAgIHsKICAgICAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgICAgIGxpbmVOdW1iZXI6IDIwMCwKICAgICAgICBjb2x1bW5OdW1iZXI6IDcKICAgICAgfSwKICAgICAgdGhpcwogICAgKQogIF0gfSwgdm9pZCAwLCB0cnVlLCB7CiAgICBmaWxlTmFtZTogIi9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL0FwcC50c3giLAogICAgbGluZU51bWJlcjogMTM4LAogICAgY29sdW1uTnVtYmVyOiA1CiAgfSwgdGhpcyk7Cn0KX3MoQXBwLCAiYlFGRkxBa2lSRWRPeEcrUTZzUXhrZmFnOTRZPSIsIGZhbHNlLCBmdW5jdGlvbigpIHsKICByZXR1cm4gW3VzZVN0YXRpc3RpY3MsIHVzZU1vZGVsc107Cn0pOwpfYyA9IEFwcDsKZXhwb3J0IGRlZmF1bHQgQXBwOwp2YXIgX2M7CiRSZWZyZXNoUmVnJChfYywgIkFwcCIpOwppZiAoaW1wb3J0Lm1ldGEuaG90ICYmICFpbldlYldvcmtlcikgewogIHdpbmRvdy4kUmVmcmVzaFJlZyQgPSBwcmV2UmVmcmVzaFJlZzsKICB3aW5kb3cuJFJlZnJlc2hTaWckID0gcHJldlJlZnJlc2hTaWc7Cn0KaWYgKGltcG9ydC5tZXRhLmhvdCAmJiAhaW5XZWJXb3JrZXIpIHsKICBSZWZyZXNoUnVudGltZS5fX2htcl9pbXBvcnQoaW1wb3J0Lm1ldGEudXJsKS50aGVuKChjdXJyZW50RXhwb3J0cykgPT4gewogICAgUmVmcmVzaFJ1bnRpbWUucmVnaXN0ZXJFeHBvcnRzRm9yUmVhY3RSZWZyZXNoKCIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9BcHAudHN4IiwgY3VycmVudEV4cG9ydHMpOwogICAgaW1wb3J0Lm1ldGEuaG90LmFjY2VwdCgobmV4dEV4cG9ydHMpID0+IHsKICAgICAgaWYgKCFuZXh0RXhwb3J0cykgcmV0dXJuOwogICAgICBjb25zdCBpbnZhbGlkYXRlTWVzc2FnZSA9IFJlZnJlc2hSdW50aW1lLnZhbGlkYXRlUmVmcmVzaEJvdW5kYXJ5QW5kRW5xdWV1ZVVwZGF0ZSgiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvQXBwLnRzeCIsIGN1cnJlbnRFeHBvcnRzLCBuZXh0RXhwb3J0cyk7CiAgICAgIGlmIChpbnZhbGlkYXRlTWVzc2FnZSkgaW1wb3J0Lm1ldGEuaG90LmludmFsaWRhdGUoaW52YWxpZGF0ZU1lc3NhZ2UpOwogICAgfSk7CiAgfSk7Cn0KCi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnRZWEJ3YVc1bmN5STZJa0ZCZFVoTk96czdPenM3T3pzN096czdPenM3T3p0QlFYWklUaXhUUVVGblFrRXNaMEpCUVdkQ08wRkJRMmhETEU5QlFVOURMRmxCUVZrN1FVRkRia0lzVDBGQlQwTXNWMEZCVnp0QlFVTnNRaXhQUVVGUFF5eHBRa0ZCYVVJN1FVRkRlRUlzVDBGQlQwTXNiMEpCUVc5Q08wRkJRek5DTEZOQlFWTkRMSEZDUVVGeFFqdEJRVU01UWl4VFFVRlRReXhwUWtGQmFVSTdRVUZETVVJc1UwRkJVME1zVjBGQlZ6dEJRVU53UWl4VFFVRlRReXhsUVVFMlFqdEJRVWQwUXl4VFFVRlRReXhOUVVGTk8wRkJRVUZETEV0QlFVRTdRVUZEWWl4UlFVRk5MRU5CUVVORExHZENRVUZuUWtNc2FVSkJRV2xDTEVsQlFVbGFMRk5CUVZNc1MwRkJTenRCUVVNeFJDeFJRVUZOTEVOQlFVTmhMRk5CUVZORExGVkJRVlVzU1VGQlNXUXNVMEZCVXl4TFFVRkxPMEZCUXpWRExGRkJRVTBzUTBGQlEyVXNWMEZCVjBNc1dVRkJXU3hKUVVGSmFFSXNVMEZCYVVNc1NVRkJTVHRCUVVOMlJTeFJRVUZOTEVOQlFVTnBRaXh2UWtGQmIwSkRMSEZDUVVGeFFpeEpRVUZKYkVJc1UwRkJaMFFzUlVGQlJXMUNMRkZCUVZFc1NVRkJTVU1zVjBGQlZ5eEhRVUZITEVOQlFVTTdRVUZEYWtrc1VVRkJUU3hEUVVGRFF5eGxRVUZsUXl4blFrRkJaMElzU1VGQlNYUkNMRk5CUVhsQ0xFVkJRVVU3UVVGRGNrVXNVVUZCVFN4RFFVRkRkVUlzWTBGQlkwTXNaVUZCWlN4SlFVRkplRUlzVTBGQmJVSXNSVUZCUlR0QlFVTTNSQ3hSUVVGTmVVSXNaVUZCWlR0QlFVZHlRaXhSUVVGTkxFTkJRVU5ETEdGQlFXRkRMR05CUVdNc1NVRkJTVE5DTEZOQlFWTXNkMEpCUVhkQ08wRkJRM1pGTEZGQlFVMHNRMEZCUXpSQ0xHZENRVUZuUWtNc2FVSkJRV2xDTEVsQlFVazNRaXhUUVVGVExIbENRVUY1UWp0QlFVTTVSU3hSUVVGTkxFTkJRVU00UWl4dFFrRkJiVUpETEc5Q1FVRnZRaXhKUVVGSkwwSXNVMEZCVXl4SFFVRkhPMEZCUXpsRUxGRkJRVTBzUTBGQlEyZERMSE5DUVVGelFrTXNkVUpCUVhWQ0xFbEJRVWxxUXl4VFFVRlRMRWRCUVVjN1FVRkZjRVVzVVVGQlRTeEZRVUZGYTBNc1dVRkJXVU1zVTBGQlUwTXNhMEpCUVd0Q0xFbEJRVWt2UWl4alFVRmpPMEZCUTJwRkxGRkJRVTBzUlVGQlJXZERMR05CUVdORExHZENRVUZuUWl4SlFVRkphRU1zVlVGQlZUdEJRVVZ3UkN4UlFVRk5hVU1zY1VKQlFYRkNMRTlCUVU5RExGRkJRV2RDUXl4VlFVRnRRanRCUVVOdVJUTkNMR1ZCUVZjc1NVRkJTVHRCUVVObVJTeHBRa0ZCWVN4SlFVRkpPMEZCUTJwQ1JTd3dRa0ZCYzBJc1JVRkJSVU1zVVVGQlVTeEpRVUZKUXl4WFFVRlhMRWRCUVVjc1EwRkJRenRCUVVOdVJFa3NiMEpCUVdkQ0xFVkJRVVU3UVVGRmJFSXNVVUZCU1d0Q0xGVkJRVzlDTzBGQlIzaENMRkZCUVVsRUxGTkJRVk5CTEUxQlFVMUZMRk5CUVZNc1IwRkJSenRCUVVNM1FpeFZRVUZKTzBGQlEwWXNZMEZCVFVNc2FVSkJRV2xDTEUxQlFVMXdReXhSUVVGUmNVTXNXVUZCV1Vvc1MwRkJTenRCUVVOMFJDeFpRVUZKUnl4bFFVRmxSU3hYUVVGWFJpeGxRVUZsUnl4TlFVRk5PMEZCUTJwRWVrSXNNa0pCUVdsQ2MwSXNaVUZCWlVjc1MwRkJTMDRzUzBGQlN6dEJRVU14UTBNc2IwSkJRVlZGTEdWQlFXVkhMRXRCUVV0T0xFMUJRVTFQTEVsQlFVa3NRMEZCUVVNc1RVRkJTMEVzUlVGQlJVTXNSVUZCUlR0QlFVVnFSQ3hqUVVGSlRpeGxRVUZsUnl4TFFVRkxTU3hWUVVGVlVDeGxRVUZsUnl4TFFVRkxTU3hQUVVGUFVpeFRRVUZUTEVkQlFVYzdRVUZEZGtVc2EwSkJRVTFUTEdkQ1FVRm5RbElzWlVGQlpVY3NTMEZCUzBrc1QwRkJUMGdzU1VGQlNTeERRVUZCU3l4TlFVRkxMRWRCUVVkQkxFVkJRVVZETEVsQlFVa3NTMEZCUzBRc1JVRkJSVVVzUzBGQlN5eEZRVUZGTzBGQlEycEdMMElzTkVKQlFXZENORUlzWVVGQllUdEJRVUZCTEZWQlF5OUNPMEZCUVVFc1VVRkRSaXhQUVVGUE8wRkJRMHcxUWl3d1FrRkJaMElzUTBGQlEyOUNMR1ZCUVdWWExGTkJRVk1zZVVKQlFYbENMRU5CUVVNN1FVRkJRU3hSUVVOeVJUdEJRVUZCTEUxQlEwWXNVMEZCVTBFc1QwRkJXVHRCUVVOdVFrTXNaMEpCUVZGRUxFMUJRVTBzYzBKQlFYTkNRU3hMUVVGTE8wRkJRM3BETDBJc2QwSkJRV2RDTEVOQlFVTXNlVUpCUVhsQ0xFTkJRVU03UVVGQlFTeE5RVU0zUXp0QlFVRkJMRWxCUTBZN1FVRkZRU3hSUVVGSk8wRkJRMFlzVlVGQlNVTXNZMEZCWXp0QlFVVm9RaXhqUVVGTmJFSXNTVUZCU1d0RU8wRkJRVUZCTEZWQlExSTdRVUZCUVN4WlFVTkZha0k3UVVGQlFVRXNXVUZEUVd0Q0xGVkJRVlU3UVVGQlFTeFpRVU5XYUVNN1FVRkJRVUVzV1VGRFFVVTdRVUZCUVVFc1dVRkRRVVU3UVVGQlFVRXNXVUZEUVVVN1FVRkJRVUVzV1VGRFFWVXNVMEZCVTBFc1VVRkJVVU1zVTBGQlV5eEpRVUZKUkN4VlFVRlZhVUk3UVVGQlFVRXNWVUZETVVNN1FVRkJRU3hWUVVOQk8wRkJRVUVzV1VGRFJVTXNaVUZCWlVFc1EwRkJRME1zVlVGQlZUdEJRVU40UWpORExHOURRVUZ6UWl4RFFVRkJORU1zVlVGQlV5eEZRVUZGTEVkQlFVZEJMRTFCUVUwelF5eFJRVUZSTWtNc1MwRkJTek5ETEZOQlFWTXdReXhOUVVGTkxFVkJRVVU3UVVGQlFTeFpRVU14UlR0QlFVRkJMRmxCUTBGRkxHdENRVUZyUWtFc1EwRkJRMFlzVlVGQlZUdEJRVU16UWpORExHOURRVUZ6UWl4RFFVRkJORU1zVlVGQlV5eEZRVUZGTEVkQlFVZEJMRTFCUVUweFF5eFhRVUZYTUVNc1MwRkJTekZETEZsQlFWbDVReXhOUVVGTkxFVkJRVVU3UVVGQlFTeFpRVU5vUmp0QlFVRkJMRmxCUTBGSExGTkJRVk5CTEVOQlFVTlVMRlZCUVZVN1FVRkRiRUpETEhOQ1FVRlJSQ3hOUVVGTkxHOUNRVUZ2UWtFc1MwRkJTenRCUVVOMlEzWkRMREpDUVVGaE8wRkJRVUVzWjBKQlExZzRRaXhUUVVGVE8wRkJRVUVzWjBKQlExUlRMRTlCUVU4c2RVSkJRWFZDUVN4TFFVRkxPMEZCUVVFc1kwRkRja01zUTBGQlF6dEJRVUZCTEZsQlEwZzdRVUZCUVN4WlFVTkJWU3haUVVGWlFTeE5RVUZOTzBGQlEyaENOMElzWjBOQlFXdENPMEZCUld4Q09FSXNlVUpCUVZjc1RVRkJUWEJFTEZkQlFWY3NTMEZCU3l4SFFVRkhMRWRCUVVjN1FVRkJRU3haUVVONlF6dEJRVUZCTEZWQlEwWTdRVUZCUVN4UlFVTkdPMEZCUVVFc1RVRkRSaXhQUVVGUE8wRkJSVXdzWTBGQlRYRkVMRmRCUVZjc1RVRkJUVFZFTEVsQlFVazJSQ3h4UWtGQmNVSTdRVUZCUVN4VlFVTTVRelZDTzBGQlFVRkJMRlZCUTBGa08wRkJRVUZCTEZWQlEwRkZPMEZCUVVGQkxGVkJRMEZGTzBGQlFVRkJMRlZCUTBGRk8wRkJRVUZCTEZWQlEwRlZMRk5CUVZOQkxGRkJRVkZETEZOQlFWTXNTVUZCU1VRc1ZVRkJWV2xDTzBGQlFVRkJMRkZCUXpGRExFTkJRVU03UVVGRlJETkRMSEZDUVVGaGJVUXNVVUZCVVR0QlFVTnlRaTlDTERCQ1FVRnJRanRCUVVOc1FuUkNMRzFDUVVGWExFdEJRVXM3UVVGQlFTeE5RVU5zUWp0QlFVRkJMRWxCUTBZc1UwRkJVM2xETEU5QlFVODdRVUZEWkVNc1kwRkJVVVFzVFVGQlRTd3JRa0ZCSzBKQkxFdEJRVXM3UVVGRGJFUjJReXh0UWtGQllUdEJRVUZCTEZGQlExZzRRaXhUUVVGVE8wRkJRVUVzVVVGRFZGTXNUMEZCVHp0QlFVRkJMRTFCUTFRc1EwRkJRenRCUVVORWVrTXNhVUpCUVZjc1MwRkJTenRCUVVGQkxFbEJRMnhDTzBGQlFVRXNSVUZEUmp0QlFVVkJMRk5CUTBVc2RVSkJRVU1zVTBGQlNTeFhRVUZWTEU5QlEySTdRVUZCUVR0QlFVRkJMRTFCUVVNN1FVRkJRVHRCUVVGQkxGRkJRME03UVVGQlFTeFJRVU5CTEd0Q1FVRnJRaXhOUVVGTlJpeHJRa0ZCYTBJc1NVRkJTVHRCUVVGQk8wRkJRVUVzVFVGR2FFUTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEVsQlJXdEVPMEZCUVVFc1NVRkhiRVFzZFVKQlFVTXNWVUZCU3l4WFFVRlZMR2RDUVVOa0xHbERRVUZETEZOQlFVa3NWMEZCVlN4aFFVTmlPMEZCUVVFN1FVRkJRU3hSUVVGRE8wRkJRVUU3UVVGQlFTeFZRVU5ETEZWQlFWVXlRanRCUVVGQlFTeFZRVU5XTzBGQlFVRTdRVUZCUVN4UlFVWkdPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVN4TlFVVnRRanRCUVVGQkxFMUJSMjVDTEhWQ1FVRkRMRk5CUVVrc1YwRkJWU3hyUWtGRFlqdEJRVUZCTzBGQlFVRXNWVUZCUXp0QlFVRkJPMEZCUVVFc1dVRkRReXhQUVVGTk8wRkJRVUVzV1VGRFRpeFZRVUZUTzBGQlFVRXNXVUZEVkN4VlFVRlZaQ3hsUVVGbFVpeHRRa0ZCYlVKRkxGTkJRVlZLTEZkQlFWZG5ReXhOUVVGTk5VSXNUMEZCVDJkRUxGbEJRVms3UVVGQlFTeFpRVU14Uml4UFFVRlBla003UVVGQlFVRXNXVUZEVUN4aFFVRmhTVHRCUVVGQlFTeFpRVU5pTEZGQlFWRlBPMEZCUVVGQkxGbEJRMUk3UVVGQlFTeFpRVU5CTEdWQlFXVldPMEZCUVVGQkxGbEJRMllzY1VKQlFYRkNTVHRCUVVGQlFUdEJRVUZCUVN4VlFWUjJRanRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc1VVRlRORU03UVVGQlFTeFJRVWMxUXp0QlFVRkJMRlZCUVVNN1FVRkJRVHRCUVVGQkxGbEJRME1zVDBGQlRUdEJRVUZCTEZsQlEwNHNWVUZCVXp0QlFVRkJMRmxCUTFRc1ZVRkJWVTRzWlVGQlpWSXNiVUpCUVcxQ1J5eFpRVUZoVEN4WFFVRlhaME1zVFVGQlRUTkNMRlZCUVZVclF5eFpRVUZaTzBGQlFVRXNXVUZEYUVjc1QwRkJUM1pETzBGQlFVRkJMRmxCUTFBc1lVRkJZVWs3UVVGQlFVRXNXVUZEWWl4UlFVRlJUVHRCUVVGQlFTeFpRVU5TTzBGQlFVRXNXVUZEUVN4bFFVRmxWRHRCUVVGQlFTeFpRVU5tTEhGQ1FVRnhRa2s3UVVGQlFVRTdRVUZCUVVFc1ZVRlVka0k3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQkxGRkJVeXRETzBGQlFVRXNWMEYwUW1wRU8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNZVUYzUWtFN1FVRkJRU3hOUVVWRFZpeGhRVUZoYjBJc1UwRkJVeXhMUVVOeVFpeDFRa0ZCUXl4VFFVRkpMRmRCUVZVc01rTkJRMkk3UVVGQlFTd3JRa0ZCUXl4WlFVRlBMSGxEUVVGU08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNaVUZCYVVNN1FVRkJRU3hSUVVOcVF5eDFRa0ZCUXl4UlFVRkhMRTlCUVU4c1JVRkJSVEJDTEZkQlFWY3NWVUZCVlVNc1dVRkJXU3hQUVVGUExFZEJRMnhFTDBNc2RVSkJRV0Y1UWp0QlFVRkJRU3hWUVVGSkxFTkJRVU4xUWl4VFFVRlRReXhWUVVNeFFpeDFRa0ZCUXl4UlFVRm5Ra1FzY1VKQlFWSkRMRTlCUVZRN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTeHBRa0ZCZVVJN1FVRkJRU3hSUVVNeFFpeExRVWhJTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc1pVRkpRVHRCUVVGQkxGZEJUa1k3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVN4aFFVOUJPMEZCUVVFc1RVRkhSSHBFTEZkQlFWZDNReXhUUVVOV0xIVkNRVUZETEZOQlFVa3NWMEZCVlN4cFFrRkRZanRCUVVGQkxDdENRVUZETEZOQlFVa3NWMEZCVlN4blFrRkJaU3hOUVVGTExGRkJRVThzVVVGQlR5eG5Ra0ZCWlN4VFFVRlJMR0ZCUTNSRk8wRkJRVUVzVlVGQlF6dEJRVUZCTzBGQlFVRXNXVUZCU3l4bFFVRmpPMEZCUVVFc1dVRkJVU3huUWtGQlpUdEJRVUZCTEZsQlFWRXNZVUZCV1R0QlFVRkJMRmxCUXpkRUxFZEJRVVU3UVVGQlFUdEJRVUZCTEZWQlJFbzdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEZGQlEzVkVMRXRCUm5wRU8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNaVUZIUVR0QlFVRkJMRkZCUTBONFF5eFZRVUZWZDBNN1FVRkJRVUVzVjBGTVlqdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMR0ZCVFVFN1FVRkJRU3hUUVd4RVNqdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMRmRCYjBSQkxFdEJja1JHTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc1YwRnpSRUU3UVVGQlFTeEpRVVZCTzBGQlFVRXNUVUZCUXp0QlFVRkJPMEZCUVVFc1VVRkRReXhSUVVGUk5VTTdRVUZCUVVFc1VVRkRVaXhUUVVGVExFMUJRVTFETEd0Q1FVRnJRaXhMUVVGTE8wRkJRVUVzVVVGRGRFTXNUMEZCVFR0QlFVRkJMRkZCUlU0N1FVRkJRU3hwUTBGQlF5eFRRVUZKTEZkQlFWVXNZMEZEWWp0QlFVRkJMRzFEUVVGRExGRkJRVWNzVDBGQlR5eEZRVUZGTmtRc1ZVRkJWU3hWUVVGVlF5eGpRVUZqTEZkQlFWZERMRTlCUVU4c1ZVRkJWU3hIUVVGSExEWkNRVUU1UlR0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQkxHMUNRVUV5Ump0QlFVRkJMRmxCUXpOR0xIVkNRVUZETEU5QlFVVXNUMEZCVHl4RlFVRkZUQ3haUVVGWkxGTkJRVk1zUjBGQlJ5eG5TRUZCY0VNN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTeHRRa0ZCYjBrN1FVRkJRU3hsUVVaMFNUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMR2xDUVVkQk8wRkJRVUVzVlVGRlFTeDFRa0ZCUXl4VFFVRkpMRmRCUVZVc1kwRkRZanRCUVVGQkxHMURRVUZETEZGQlFVY3NUMEZCVHl4RlFVRkZSeXhWUVVGVkxGVkJRVlZETEdOQlFXTXNWMEZCVjBNc1QwRkJUeXhWUVVGVkxFZEJRVWNzYzBOQlFUbEZPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzYlVKQlFXOUhPMEZCUVVFc1dVRkRjRWNzZFVKQlFVTXNVVUZCUnl4UFFVRlBMRVZCUVVWTUxGbEJRVmtzVTBGQlV5eEhRVU5vUXp0QlFVRkJMSEZEUVVGRExGRkJRVWM3UVVGQlFTeDFRMEZCUXl4WlFVRlBMSFZDUVVGU08wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNkVUpCUVdVN1FVRkJRU3huUWtGQlV6dEJRVUZCTEcxQ1FVRTFRanRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEhGQ1FVRjFSRHRCUVVGQkxHTkJRM1pFTEhWQ1FVRkRMRkZCUVVjN1FVRkJRU3gxUTBGQlF5eFpRVUZQTERCQ1FVRlNPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzZFVKQlFXdENPMEZCUVVFc1owSkJRVk03UVVGQlFTeHRRa0ZCTDBJN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTeHhRa0ZCYjBVN1FVRkJRU3hwUWtGR2RFVTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3h0UWtGSFFUdEJRVUZCTEdWQlRFWTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3hwUWtGTlFUdEJRVUZCTEZWQlJVRXNkVUpCUVVNc1UwRkJTU3hYUVVGVkxHTkJRMkk3UVVGQlFTeHRRMEZCUXl4UlFVRkhMRTlCUVU4c1JVRkJSVWNzVlVGQlZTeFZRVUZWUXl4alFVRmpMRmRCUVZkRExFOUJRVThzVlVGQlZTeEhRVUZITEdsRFFVRTVSVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEcxQ1FVRXJSanRCUVVGQkxGbEJReTlHTEhWQ1FVRkRMRkZCUVVjc1QwRkJUeXhGUVVGRlRDeFpRVUZaTEZOQlFWTXNSMEZEYUVNN1FVRkJRU3h4UTBGQlF5eFJRVUZITEN0RVFVRktPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzY1VKQlFXMUVPMEZCUVVFc1kwRkRia1FzZFVKQlFVTXNVVUZCUnl3MlEwRkJTanRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEhGQ1FVRnBRenRCUVVGQkxHTkJRMnBETEhWQ1FVRkRMRkZCUVVjc2JVVkJRVW83UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVN4eFFrRkJkVVE3UVVGQlFTeGpRVU4yUkN4MVFrRkJReXhSUVVGSExEWkRRVUZLTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc2NVSkJRV2xETzBGQlFVRXNZMEZEYWtNc2RVSkJRVU1zVVVGQlJ5dzBRMEZCU2p0QlFVRkJPMEZCUVVFN1FVRkJRVHRCUVVGQkxIRkNRVUZuUXp0QlFVRkJMR2xDUVV4c1F6dEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMRzFDUVUxQk8wRkJRVUVzWlVGU1JqdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMR2xDUVZOQk8wRkJRVUVzVlVGRlFTeDFRa0ZCUXl4VFFVRkpMRmRCUVZVc1kwRkRZanRCUVVGQkxHMURRVUZETEZGQlFVY3NUMEZCVHl4RlFVRkZSeXhWUVVGVkxGVkJRVlZETEdOQlFXTXNWMEZCVjBNc1QwRkJUeXhWUVVGVkxFZEJRVWNzWjBOQlFUbEZPMEZCUVVFN1FVRkJRVHRCUVVGQk8wRkJRVUVzYlVKQlFUaEdPMEZCUVVFc1dVRkRPVVlzZFVKQlFVTXNUMEZCUlN4UFFVRlBMRVZCUVVWTUxGbEJRVmtzVTBGQlV5eEhRVUZITEcxSVFVRndRenRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTEcxQ1FVRjFTVHRCUVVGQkxHVkJSbnBKTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc2FVSkJSMEU3UVVGQlFTeFZRVVZCTEhWQ1FVRkRMRk5CUVVrc1YwRkJWU3hqUVVGaExFOUJRVThzUlVGQlJVMHNWMEZCVnl4eFFrRkJjVUpETEZsQlFWa3NVVUZCVVZJc1YwRkJWeXhQUVVGUExFZEJRM3BITEdsRFFVRkRMRTlCUVVVc1QwRkJUeXhGUVVGRlV5eFhRVUZYTEZWQlFWVkRMRmRCUVZjc1ZVRkJWVW9zVDBGQlR5eFZRVUZWTEVkQlFVYzdRVUZCUVR0QlFVRkJMRmxCUXpkRUxIVkNRVUZETEZsQlFVOHNUMEZCVHl4RlFVRkZRU3hQUVVGUExGVkJRVlVzUjBGQlJ5d3JRa0ZCY2tNN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFTeHRRa0ZCYjBRN1FVRkJRU3haUVVGVE8wRkJRVUVzV1VGQldTeDFRa0ZCUXl4WlFVRlBMRTlCUVU4c1JVRkJSVUVzVDBGQlR5eFZRVUZWTEVkQlFVY3NNRUpCUVhKRE8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNiVUpCUVN0RE8wRkJRVUVzWlVGRWNrazdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3hwUWtGRlFTeExRVWhHTzBGQlFVRTdRVUZCUVR0QlFVRkJPMEZCUVVFc2FVSkJTVUU3UVVGQlFUdEJRVUZCTzBGQlFVRXNUVUYwUTBZN1FVRkJRVHRCUVVGQk8wRkJRVUU3UVVGQlFUdEJRVUZCTzBGQlFVRTdRVUZCUVR0QlFVRkJMRWxCZFVOQk8wRkJRVUVzVDBGeVIwWTdRVUZCUVR0QlFVRkJPMEZCUVVFN1FVRkJRU3hUUVhOSFFUdEJRVVZLTzBGQlFVTnFSU3hIUVc1T1VVUXNTMEZCUnp0QlFVRkJMRlZCWlhsRFNpeGxRVU5VUXl4VFFVRlRPMEZCUVVFN1FVRkJRVEJGTEV0QmFFSTFRM1pGTzBGQmNVNVVMR1ZCUVdWQk8wRkJRVWtzU1VGQlFYVkZPMEZCUVVGRExHRkJRVUZFTEVsQlFVRWlMQ0p1WVcxbGN5STZXeUoxYzJWVGRHRjBaU0lzSWtobFlXUmxjaUlzSWsxdlpHRnNJaXdpVUhKdmJYQjBTVzV3ZFhRaUxDSk1URTFTWlhOd2IyNXpaVUp2ZUNJc0luVnpaVk4wWVhScGMzUnBZM01pTENKMWMyVk5iMlJsYkhNaUxDSmhjR2tpTENKbWFXeGxRVkJKSWl3aVFYQndJaXdpWDNNaUxDSnphRzkzUVdKdmRYUk5iMlJoYkNJc0luTmxkRk5vYjNkQlltOTFkRTF2WkdGc0lpd2liRzloWkdsdVp5SXNJbk5sZEV4dllXUnBibWNpTENKeVpYTndiMjV6WlhNaUxDSnpaWFJTWlhOd2IyNXpaWE1pTENKemRISmxZVzFwYm1kU1pYTndiMjV6WlhNaUxDSnpaWFJUZEhKbFlXMXBibWRTWlhOd2IyNXpaWE1pTENKdmNHVnVZV2tpTENKaGJuUm9jbTl3YVdNaUxDSjFjR3h2WVdSbFpFWnBiR1Z6SWl3aWMyVjBWWEJzYjJGa1pXUkdhV3hsY3lJc0ltWnBiR1ZYWVhKdWFXNW5jeUlzSW5ObGRFWnBiR1ZYWVhKdWFXNW5jeUlzSW5WelpWTjBjbVZoYldsdVp5SXNJbTl3Wlc1aGFVMXZaR1ZzSWl3aWMyVjBUM0JsYm1GcFRXOWtaV3dpTENKaGJuUm9jbTl3YVdOTmIyUmxiQ0lzSW5ObGRFRnVkR2h5YjNCcFkwMXZaR1ZzSWl3aWIzQmxibUZwVkdWdGNHVnlZWFIxY21VaUxDSnpaWFJQY0dWdVlXbFVaVzF3WlhKaGRIVnlaU0lzSW1GdWRHaHliM0JwWTFSbGJYQmxjbUYwZFhKbElpd2ljMlYwUVc1MGFISnZjR2xqVkdWdGNHVnlZWFIxY21VaUxDSnpkR0YwYVhOMGFXTnpJaXdpY21WbVpYUmphQ0lzSW5KbFptVjBZMmhUZEdGMGFYTjBhV056SWl3aWIzQmxibUZwVFc5a1pXeHpJaXdpWVc1MGFISnZjR2xqVFc5a1pXeHpJaXdpYUdGdVpHeGxVSEp2YlhCMFUzVmliV2wwSWl3aWNISnZiWEIwSWl3aVptbHNaWE1pTENKbWFXeGxTV1J6SWl3aWJHVnVaM1JvSWl3aWRYQnNiMkZrVW1WemNHOXVjMlVpTENKMWNHeHZZV1JHYVd4bGN5SXNJbk4xWTJObGMzTWlMQ0prWVhSaElpd2liV0Z3SWl3aVppSXNJbWxrSWl3aVpYSnliM0p6SWl3aVpYSnliM0pOWlhOellXZGxjeUlzSW1VaUxDSm1hV3hsSWl3aVpYSnliM0lpTENKamIyNXpiMnhsSWl3aWMzUnlaV0Z0VW1WemNHOXVjMlVpTENKd2NtOTJhV1JsY2lJc0luVnVaR1ZtYVc1bFpDSXNJbTl1VDNCbGJrRkpRMmgxYm1zaUxDSmphSFZ1YXlJc0luQnlaWFlpTENKdmJrRnVkR2h5YjNCcFkwTm9kVzVySWl3aWIyNUZjbkp2Y2lJc0ltOXVRMjl0Y0d4bGRHVWlMQ0p6WlhSVWFXMWxiM1YwSWl3aWNtVnpjRzl1YzJVaUxDSm5aVzVsY21GMFpVUjFZV3hTWlhOd2IyNXpaU0lzSW0xaGNtZHBibFJ2Y0NJc0ltMWhjbWRwYmt4bFpuUWlMQ0ozWVhKdWFXNW5JaXdpYVc1a1pYZ2lMQ0ptYjI1MFUybDZaU0lzSW0xaGNtZHBia0p2ZEhSdmJTSXNJbU52Ykc5eUlpd2lZbTl5WkdWeVZHOXdJaXdpY0dGa1pHbHVaMVJ2Y0NJc0luUmxlSFJCYkdsbmJpSXNJbVp2Ym5SVGRIbHNaU0lzSWw5aklpd2lKRkpsWm5KbGMyaFNaV2NrSWwwc0ltbG5ibTl5WlV4cGMzUWlPbHRkTENKemIzVnlZMlZ6SWpwYklrRndjQzUwYzNnaVhTd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElGSmxZV04wTENCN0lIVnpaVk4wWVhSbElIMGdabkp2YlNBbmNtVmhZM1FuTzF4eVhHNXBiWEJ2Y25RZ1NHVmhaR1Z5SUdaeWIyMGdKeTR2WTI5dGNHOXVaVzUwY3k5SVpXRmtaWEluTzF4eVhHNXBiWEJ2Y25RZ1RXOWtZV3dnWm5KdmJTQW5MaTlqYjIxd2IyNWxiblJ6TDAxdlpHRnNKenRjY2x4dWFXMXdiM0owSUZCeWIyMXdkRWx1Y0hWMElHWnliMjBnSnk0dlkyOXRjRzl1Wlc1MGN5OVFjbTl0Y0hSSmJuQjFkQ2M3WEhKY2JtbHRjRzl5ZENCTVRFMVNaWE53YjI1elpVSnZlQ0JtY205dElDY3VMMk52YlhCdmJtVnVkSE12VEV4TlVtVnpjRzl1YzJWQ2IzZ25PMXh5WEc1cGJYQnZjblFnZXlCMWMyVlRkR0YwYVhOMGFXTnpJSDBnWm5KdmJTQW5MaTlvYjI5cmN5OTFjMlZUZEdGMGFYTjBhV056Snp0Y2NseHVhVzF3YjNKMElIc2dkWE5sVFc5a1pXeHpJSDBnWm5KdmJTQW5MaTlvYjI5cmN5OTFjMlZOYjJSbGJITW5PMXh5WEc1cGJYQnZjblFnZXlCaGNHa2dmU0JtY205dElDY3VMM05sY25acFkyVnpMMkZ3YVNjN1hISmNibWx0Y0c5eWRDQjdJR1pwYkdWQlVFa3NJRlZ3Ykc5aFpHVmtSbWxzWlNCOUlHWnliMjBnSnk0dmMyVnlkbWxqWlhNdlptbHNaUzVoY0drbk8xeHlYRzVwYlhCdmNuUWdleUJFZFdGc1RFeE5VbVZ6Y0c5dWMyVWdmU0JtY205dElDY3VMM1I1Y0dWekp6dGNjbHh1WEhKY2JtWjFibU4wYVc5dUlFRndjQ2dwSUh0Y2NseHVJQ0JqYjI1emRDQmJjMmh2ZDBGaWIzVjBUVzlrWVd3c0lITmxkRk5vYjNkQlltOTFkRTF2WkdGc1hTQTlJSFZ6WlZOMFlYUmxLR1poYkhObEtUdGNjbHh1SUNCamIyNXpkQ0JiYkc5aFpHbHVaeXdnYzJWMFRHOWhaR2x1WjEwZ1BTQjFjMlZUZEdGMFpTaG1ZV3h6WlNrN1hISmNiaUFnWTI5dWMzUWdXM0psYzNCdmJuTmxjeXdnYzJWMFVtVnpjRzl1YzJWelhTQTlJSFZ6WlZOMFlYUmxQRVIxWVd4TVRFMVNaWE53YjI1elpTQjhJRzUxYkd3K0tHNTFiR3dwTzF4eVhHNGdJR052Ym5OMElGdHpkSEpsWVcxcGJtZFNaWE53YjI1elpYTXNJSE5sZEZOMGNtVmhiV2x1WjFKbGMzQnZibk5sYzEwZ1BTQjFjMlZUZEdGMFpUeDdJRzl3Wlc1aGFUb2djM1J5YVc1bk95QmhiblJvY205d2FXTTZJSE4wY21sdVp5QjlQaWg3SUc5d1pXNWhhVG9nSnljc0lHRnVkR2h5YjNCcFl6b2dKeWNnZlNrN1hISmNiaUFnWTI5dWMzUWdXM1Z3Ykc5aFpHVmtSbWxzWlhNc0lITmxkRlZ3Ykc5aFpHVmtSbWxzWlhOZElEMGdkWE5sVTNSaGRHVThWWEJzYjJGa1pXUkdhV3hsVzEwK0tGdGRLVHRjY2x4dUlDQmpiMjV6ZENCYlptbHNaVmRoY201cGJtZHpMQ0J6WlhSR2FXeGxWMkZ5Ym1sdVozTmRJRDBnZFhObFUzUmhkR1U4YzNSeWFXNW5XMTArS0Z0ZEtUdGNjbHh1SUNCamIyNXpkQ0IxYzJWVGRISmxZVzFwYm1jZ1BTQjBjblZsT3lBdkx5QkJiSGRoZVhNZ2RYTmxJSE4wY21WaGJXbHVaMXh5WEc0Z0lGeHlYRzRnSUM4dklFTnZibVpwWjNWeVlXTnB3N051SUdSbElHMXZaR1ZzYjNNZ2VTQjBaVzF3WlhKaGRIVnlZWE5jY2x4dUlDQmpiMjV6ZENCYmIzQmxibUZwVFc5a1pXd3NJSE5sZEU5d1pXNWhhVTF2WkdWc1hTQTlJSFZ6WlZOMFlYUmxLQ2RuY0hRdE5HOHRiV2x1YVMweU1ESTBMVEEzTFRFNEp5azdYSEpjYmlBZ1kyOXVjM1FnVzJGdWRHaHliM0JwWTAxdlpHVnNMQ0J6WlhSQmJuUm9jbTl3YVdOTmIyUmxiRjBnUFNCMWMyVlRkR0YwWlNnblkyeGhkV1JsTFRNdE5TMW9ZV2xyZFMxc1lYUmxjM1FuS1R0Y2NseHVJQ0JqYjI1emRDQmJiM0JsYm1GcFZHVnRjR1Z5WVhSMWNtVXNJSE5sZEU5d1pXNWhhVlJsYlhCbGNtRjBkWEpsWFNBOUlIVnpaVk4wWVhSbEtEQXVOeWs3WEhKY2JpQWdZMjl1YzNRZ1cyRnVkR2h5YjNCcFkxUmxiWEJsY21GMGRYSmxMQ0J6WlhSQmJuUm9jbTl3YVdOVVpXMXdaWEpoZEhWeVpWMGdQU0IxYzJWVGRHRjBaU2d3TGpjcE8xeHlYRzVjY2x4dUlDQmpiMjV6ZENCN0lITjBZWFJwYzNScFkzTXNJSEpsWm1WMFkyZzZJSEpsWm1WMFkyaFRkR0YwYVhOMGFXTnpJSDBnUFNCMWMyVlRkR0YwYVhOMGFXTnpLQ2s3WEhKY2JpQWdZMjl1YzNRZ2V5QnZjR1Z1WVdsTmIyUmxiSE1zSUdGdWRHaHliM0JwWTAxdlpHVnNjeUI5SUQwZ2RYTmxUVzlrWld4ektDazdYSEpjYmx4eVhHNGdJR052Ym5OMElHaGhibVJzWlZCeWIyMXdkRk4xWW0xcGRDQTlJR0Z6ZVc1aklDaHdjbTl0Y0hRNklITjBjbWx1Wnl3Z1ptbHNaWE0vT2lCR2FXeGxXMTBwSUQwK0lIdGNjbHh1SUNBZ0lITmxkRXh2WVdScGJtY29kSEoxWlNrN1hISmNiaUFnSUNCelpYUlNaWE53YjI1elpYTW9iblZzYkNrN1hISmNiaUFnSUNCelpYUlRkSEpsWVcxcGJtZFNaWE53YjI1elpYTW9leUJ2Y0dWdVlXazZJQ2NuTENCaGJuUm9jbTl3YVdNNklDY25JSDBwTzF4eVhHNGdJQ0FnYzJWMFJtbHNaVmRoY201cGJtZHpLRnRkS1R0Y2NseHVJQ0FnSUZ4eVhHNGdJQ0FnYkdWMElHWnBiR1ZKWkhNNklITjBjbWx1WjF0ZElEMGdXMTA3WEhKY2JpQWdJQ0JjY2x4dUlDQWdJQzh2SUZWd2JHOWhaQ0JtYVd4bGN5QnBaaUJ3Y205MmFXUmxaRnh5WEc0Z0lDQWdhV1lnS0dacGJHVnpJQ1ltSUdacGJHVnpMbXhsYm1kMGFDQStJREFwSUh0Y2NseHVJQ0FnSUNBZ2RISjVJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpkQ0IxY0d4dllXUlNaWE53YjI1elpTQTlJR0YzWVdsMElHWnBiR1ZCVUVrdWRYQnNiMkZrUm1sc1pYTW9abWxzWlhNcE8xeHlYRzRnSUNBZ0lDQWdJR2xtSUNoMWNHeHZZV1JTWlhOd2IyNXpaUzV6ZFdOalpYTnpJQ1ltSUhWd2JHOWhaRkpsYzNCdmJuTmxMbVJoZEdFcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUhObGRGVndiRzloWkdWa1JtbHNaWE1vZFhCc2IyRmtVbVZ6Y0c5dWMyVXVaR0YwWVM1bWFXeGxjeWs3WEhKY2JpQWdJQ0FnSUNBZ0lDQm1hV3hsU1dSeklEMGdkWEJzYjJGa1VtVnpjRzl1YzJVdVpHRjBZUzVtYVd4bGN5NXRZWEFvWmlBOVBpQm1MbWxrS1R0Y2NseHVJQ0FnSUNBZ0lDQWdJRnh5WEc0Z0lDQWdJQ0FnSUNBZ2FXWWdLSFZ3Ykc5aFpGSmxjM0J2Ym5ObExtUmhkR0V1WlhKeWIzSnpJQ1ltSUhWd2JHOWhaRkpsYzNCdmJuTmxMbVJoZEdFdVpYSnliM0p6TG14bGJtZDBhQ0ErSURBcElIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1kyOXVjM1FnWlhKeWIzSk5aWE56WVdkbGN5QTlJSFZ3Ykc5aFpGSmxjM0J2Ym5ObExtUmhkR0V1WlhKeWIzSnpMbTFoY0NobElEMCtJR0FrZTJVdVptbHNaWDA2SUNSN1pTNWxjbkp2Y24xZ0tUdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ2MyVjBSbWxzWlZkaGNtNXBibWR6S0dWeWNtOXlUV1Z6YzJGblpYTXBPMXh5WEc0Z0lDQWdJQ0FnSUNBZ2ZWeHlYRzRnSUNBZ0lDQWdJSDBnWld4elpTQjdYSEpjYmlBZ0lDQWdJQ0FnSUNCelpYUkdhV3hsVjJGeWJtbHVaM01vVzNWd2JHOWhaRkpsYzNCdmJuTmxMbVZ5Y205eUlIeDhJQ2RGY25KdmNpQmhiQ0J6ZFdKcGNpQmhjbU5vYVhadmN5ZGRLVHRjY2x4dUlDQWdJQ0FnSUNCOVhISmNiaUFnSUNBZ0lIMGdZMkYwWTJnZ0tHVnljbTl5T2lCaGJua3BJSHRjY2x4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG1WeWNtOXlLQ2RHYVd4bElIVndiRzloWkNCbGNuSnZjam9uTENCbGNuSnZjaWs3WEhKY2JpQWdJQ0FnSUNBZ2MyVjBSbWxzWlZkaGNtNXBibWR6S0ZzblJYSnliM0lnWVd3Z2MzVmlhWElnWVhKamFHbDJiM01uWFNrN1hISmNiaUFnSUNBZ0lIMWNjbHh1SUNBZ0lIMWNjbHh1SUNBZ0lGeHlYRzRnSUNBZ2RISjVJSHRjY2x4dUlDQWdJQ0FnYVdZZ0tIVnpaVk4wY21WaGJXbHVaeWtnZTF4eVhHNGdJQ0FnSUNBZ0lDOHZJRTF2Wkc4Z2MzUnlaV0Z0YVc1blhISmNiaUFnSUNBZ0lDQWdZWGRoYVhRZ1lYQnBMbk4wY21WaGJWSmxjM0J2Ym5ObEtGeHlYRzRnSUNBZ0lDQWdJQ0FnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0J3Y205dGNIUXNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lIQnliM1pwWkdWeU9pQW5aSFZoYkNjc1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUc5d1pXNWhhVTF2WkdWc0xGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCaGJuUm9jbTl3YVdOTmIyUmxiQ3hjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdiM0JsYm1GcFZHVnRjR1Z5WVhSMWNtVXNYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lHRnVkR2h5YjNCcFkxUmxiWEJsY21GMGRYSmxMRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQm1hV3hsU1dSek9pQm1hV3hsU1dSekxteGxibWQwYUNBK0lEQWdQeUJtYVd4bFNXUnpJRG9nZFc1a1pXWnBibVZrWEhKY2JpQWdJQ0FnSUNBZ0lDQjlMRnh5WEc0Z0lDQWdJQ0FnSUNBZ2UxeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCdmJrOXdaVzVCU1VOb2RXNXJPaUFvWTJoMWJtc3BJRDArSUh0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCelpYUlRkSEpsWVcxcGJtZFNaWE53YjI1elpYTW9jSEpsZGlBOVBpQW9leUF1TGk1d2NtVjJMQ0J2Y0dWdVlXazZJSEJ5WlhZdWIzQmxibUZwSUNzZ1kyaDFibXNnZlNrcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOUxGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCdmJrRnVkR2h5YjNCcFkwTm9kVzVyT2lBb1kyaDFibXNwSUQwK0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnpaWFJUZEhKbFlXMXBibWRTWlhOd2IyNXpaWE1vY0hKbGRpQTlQaUFvZXlBdUxpNXdjbVYyTENCaGJuUm9jbTl3YVdNNklIQnlaWFl1WVc1MGFISnZjR2xqSUNzZ1kyaDFibXNnZlNrcE8xeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCOUxGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNCdmJrVnljbTl5T2lBb1pYSnliM0lwSUQwK0lIdGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQmpiMjV6YjJ4bExtVnljbTl5S0NkVGRISmxZVzFwYm1jZ1pYSnliM0k2Snl3Z1pYSnliM0lwTzF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhObGRGSmxjM0J2Ym5ObGN5aDdYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ0J6ZFdOalpYTnpPaUJtWVd4elpTeGNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1Z5Y205eU9pQmdSWEp5YjNJZ1pXNGdjM1J5WldGdGFXNW5PaUFrZTJWeWNtOXlmV0JjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I5S1R0Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnZlN4Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnYjI1RGIyMXdiR1YwWlRvZ0tDa2dQVDRnZTF4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUhKbFptVjBZMmhUZEdGMGFYTjBhV056S0NrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0x5OGdVR1Z4ZFdYRHNXOGdaR1ZzWVhrZ2NHRnlZU0J0YjNOMGNtRnlJR1ZzSUdOMWNuTnZjaUJoYkNCbWFXNWhiRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJSE5sZEZScGJXVnZkWFFvS0NrZ1BUNGdjMlYwVEc5aFpHbHVaeWhtWVd4elpTa3NJRFV3TUNrN1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUgxY2NseHVJQ0FnSUNBZ0lDQWdJSDFjY2x4dUlDQWdJQ0FnSUNBcE8xeHlYRzRnSUNBZ0lDQjlJR1ZzYzJVZ2UxeHlYRzRnSUNBZ0lDQWdJQzh2SUUxdlpHOGdibTl5YldGc0lDaHphVzRnYzNSeVpXRnRhVzVuS1Z4eVhHNGdJQ0FnSUNBZ0lHTnZibk4wSUhKbGMzQnZibk5sSUQwZ1lYZGhhWFFnWVhCcExtZGxibVZ5WVhSbFJIVmhiRkpsYzNCdmJuTmxLSHRjY2x4dUlDQWdJQ0FnSUNBZ0lIQnliMjF3ZEN4Y2NseHVJQ0FnSUNBZ0lDQWdJRzl3Wlc1aGFVMXZaR1ZzTEZ4eVhHNGdJQ0FnSUNBZ0lDQWdZVzUwYUhKdmNHbGpUVzlrWld3c1hISmNiaUFnSUNBZ0lDQWdJQ0J2Y0dWdVlXbFVaVzF3WlhKaGRIVnlaU3hjY2x4dUlDQWdJQ0FnSUNBZ0lHRnVkR2h5YjNCcFkxUmxiWEJsY21GMGRYSmxMRnh5WEc0Z0lDQWdJQ0FnSUNBZ1ptbHNaVWxrY3pvZ1ptbHNaVWxrY3k1c1pXNW5kR2dnUGlBd0lEOGdabWxzWlVsa2N5QTZJSFZ1WkdWbWFXNWxaRnh5WEc0Z0lDQWdJQ0FnSUgwcE8xeHlYRzRnSUNBZ0lDQWdJRnh5WEc0Z0lDQWdJQ0FnSUhObGRGSmxjM0J2Ym5ObGN5aHlaWE53YjI1elpTazdYSEpjYmlBZ0lDQWdJQ0FnY21WbVpYUmphRk4wWVhScGMzUnBZM01vS1R0Y2NseHVJQ0FnSUNBZ0lDQnpaWFJNYjJGa2FXNW5LR1poYkhObEtUdGNjbHh1SUNBZ0lDQWdmVnh5WEc0Z0lDQWdmU0JqWVhSamFDQW9aWEp5YjNJcElIdGNjbHh1SUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2lnblJYSnliM0lnWjJWdVpYSmhkR2x1WnlCeVpYTndiMjV6WlhNNkp5d2daWEp5YjNJcE8xeHlYRzRnSUNBZ0lDQnpaWFJTWlhOd2IyNXpaWE1vZTF4eVhHNGdJQ0FnSUNBZ0lITjFZMk5sYzNNNklHWmhiSE5sTEZ4eVhHNGdJQ0FnSUNBZ0lHVnljbTl5T2lBblJYSnliM0lnWVd3Z1oyVnVaWEpoY2lCc1lYTWdjbVZ6Y0hWbGMzUmhjeTRnVUc5eUlHWmhkbTl5TENCcGJuUmxiblJoSUdSbElHNTFaWFp2TGlkY2NseHVJQ0FnSUNBZ2ZTazdYSEpjYmlBZ0lDQWdJSE5sZEV4dllXUnBibWNvWm1Gc2MyVXBPMXh5WEc0Z0lDQWdmVnh5WEc0Z0lIMDdYSEpjYmx4eVhHNGdJSEpsZEhWeWJpQW9YSEpjYmlBZ0lDQThaR2wySUdOc1lYTnpUbUZ0WlQxY0ltRndjRndpUGx4eVhHNGdJQ0FnSUNBOFNHVmhaR1Z5SUZ4eVhHNGdJQ0FnSUNBZ0lITjBZWFJwYzNScFkzTTllM04wWVhScGMzUnBZM045WEhKY2JpQWdJQ0FnSUNBZ2IyNVRhRzkzUVdKdmRYUk5iMlJoYkQxN0tDa2dQVDRnYzJWMFUyaHZkMEZpYjNWMFRXOWtZV3dvZEhKMVpTbDlYSEpjYmlBZ0lDQWdJQzgrWEhKY2JseHlYRzRnSUNBZ0lDQThiV0ZwYmlCamJHRnpjMDVoYldVOVhDSnRZV2x1TFdOdmJuUmxiblJjSWo1Y2NseHVJQ0FnSUNBZ0lDQThaR2wySUdOc1lYTnpUbUZ0WlQxY0ltTnZiblJoYVc1bGNsd2lQbHh5WEc0Z0lDQWdJQ0FnSUNBZ1BGQnliMjF3ZEVsdWNIVjBJRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnZibE4xWW0xcGREMTdhR0Z1Wkd4bFVISnZiWEIwVTNWaWJXbDBmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQnNiMkZrYVc1blBYdHNiMkZrYVc1bmZWeHlYRzRnSUNBZ0lDQWdJQ0FnTHo1Y2NseHVYSEpjYmlBZ0lDQWdJQ0FnSUNBOFpHbDJJR05zWVhOelRtRnRaVDFjSW5KbGMzQnZibk5sY3kxbmNtbGtYQ0krWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJRHhNVEUxU1pYTndiMjV6WlVKdmVGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnBkR3hsUFZ3aVQzQmxia0ZKWENKY2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNCd2NtOTJhV1JsY2oxY0ltOXdaVzVoYVZ3aVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2NtVnpjRzl1YzJVOWUzVnpaVk4wY21WaGJXbHVaeUEvSUhOMGNtVmhiV2x1WjFKbGMzQnZibk5sY3k1dmNHVnVZV2tnT2lBb2NtVnpjRzl1YzJWelB5NWtZWFJoUHk1dmNHVnVZV2t1Y21WemNHOXVjMlVnZkh3Z0p5Y3BmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRzF2WkdWc1BYdHZjR1Z1WVdsTmIyUmxiSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0IwWlcxd1pYSmhkSFZ5WlQxN2IzQmxibUZwVkdWdGNHVnlZWFIxY21WOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2JXOWtaV3h6UFh0dmNHVnVZV2xOYjJSbGJITjlYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lDQWdiRzloWkdsdVp6MTdiRzloWkdsdVozMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnZiazF2WkdWc1EyaGhibWRsUFh0elpYUlBjR1Z1WVdsTmIyUmxiSDFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J2YmxSbGJYQmxjbUYwZFhKbFEyaGhibWRsUFh0elpYUlBjR1Z1WVdsVVpXMXdaWEpoZEhWeVpYMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x6NWNjbHh1WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJRHhNVEUxU1pYTndiMjV6WlVKdmVGeHlYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lIUnBkR3hsUFZ3aVFXNTBhSEp2Y0dsalhDSmNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQndjbTkyYVdSbGNqMWNJbUZ1ZEdoeWIzQnBZMXdpWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnY21WemNHOXVjMlU5ZTNWelpWTjBjbVZoYldsdVp5QS9JSE4wY21WaGJXbHVaMUpsYzNCdmJuTmxjeTVoYm5Sb2NtOXdhV01nT2lBb2NtVnpjRzl1YzJWelB5NWtZWFJoUHk1aGJuUm9jbTl3YVdNdWNtVnpjRzl1YzJVZ2ZId2dKeWNwZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUcxdlpHVnNQWHRoYm5Sb2NtOXdhV05OYjJSbGJIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQjBaVzF3WlhKaGRIVnlaVDE3WVc1MGFISnZjR2xqVkdWdGNHVnlZWFIxY21WOVhISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ2JXOWtaV3h6UFh0aGJuUm9jbTl3YVdOTmIyUmxiSE45WEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnYkc5aFpHbHVaejE3Ykc5aFpHbHVaMzFjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0J2YmsxdlpHVnNRMmhoYm1kbFBYdHpaWFJCYm5Sb2NtOXdhV05OYjJSbGJIMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQnZibFJsYlhCbGNtRjBkWEpsUTJoaGJtZGxQWHR6WlhSQmJuUm9jbTl3YVdOVVpXMXdaWEpoZEhWeVpYMWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0x6NWNjbHh1SUNBZ0lDQWdJQ0FnSUR3dlpHbDJQbHh5WEc1Y2NseHVJQ0FnSUNBZ0lDQWdJSHRtYVd4bFYyRnlibWx1WjNNdWJHVnVaM1JvSUQ0Z01DQW1KaUFvWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJRHhrYVhZZ1kyeGhjM05PWVcxbFBWd2labWxzWlMxemRHRjBkWE10YldWemMyRm5aU0JtYVd4bExYTjBZWFIxY3kxM1lYSnVhVzVuWENJK1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ1BITjBjbTl1Wno1QlpIWmxjblJsYm1OcFlYTWdaR1VnWVhKamFHbDJiM002UEM5emRISnZibWMrWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnUEhWc0lITjBlV3hsUFh0N0lHMWhjbWRwYmxSdmNEb2dKekF1TlhKbGJTY3NJRzFoY21kcGJreGxablE2SUNjeGNtVnRKeUI5ZlQ1Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ0lIdG1hV3hsVjJGeWJtbHVaM011YldGd0tDaDNZWEp1YVc1bkxDQnBibVJsZUNrZ1BUNGdLRnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGJHa2dhMlY1UFh0cGJtUmxlSDArZTNkaGNtNXBibWQ5UEM5c2FUNWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJQ2twZlZ4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUR3dmRXdytYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lEd3ZaR2wyUGx4eVhHNGdJQ0FnSUNBZ0lDQWdLWDFjY2x4dVhISmNiaUFnSUNBZ0lDQWdJQ0I3Y21WemNHOXVjMlZ6UHk1bGNuSnZjaUFtSmlBb1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUR4a2FYWWdZMnhoYzNOT1lXMWxQVndpWlhKeWIzSXRiV1Z6YzJGblpWd2lQbHh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJRHh6ZG1jZ1kyeGhjM05PWVcxbFBWd2lkeTAxSUdndE5TQnRjaTB5WENJZ1ptbHNiRDFjSW01dmJtVmNJaUJ6ZEhKdmEyVTlYQ0pqZFhKeVpXNTBRMjlzYjNKY0lpQjJhV1YzUW05NFBWd2lNQ0F3SURJMElESTBYQ0krWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJQ0FnSUNBOGNHRjBhQ0J6ZEhKdmEyVk1hVzVsWTJGd1BWd2ljbTkxYm1SY0lpQnpkSEp2YTJWTWFXNWxhbTlwYmoxY0luSnZkVzVrWENJZ2MzUnliMnRsVjJsa2RHZzlYQ0l5WENJZ1hISmNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJR1E5WENKTk1USWdPSFkwYlRBZ05HZ3VNREZOTWpFZ01USmhPU0E1SURBZ01URXRNVGdnTUNBNUlEa2dNQ0F3TVRFNElEQjZYQ0lnTHo1Y2NseHVJQ0FnSUNBZ0lDQWdJQ0FnSUNBOEwzTjJaejVjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0I3Y21WemNHOXVjMlZ6TG1WeWNtOXlmVnh5WEc0Z0lDQWdJQ0FnSUNBZ0lDQThMMlJwZGo1Y2NseHVJQ0FnSUNBZ0lDQWdJQ2w5WEhKY2JpQWdJQ0FnSUNBZ1BDOWthWFkrWEhKY2JpQWdJQ0FnSUR3dmJXRnBiajVjY2x4dVhISmNiaUFnSUNBZ0lEeE5iMlJoYkNCY2NseHVJQ0FnSUNBZ0lDQnBjMDl3Wlc0OWUzTm9iM2RCWW05MWRFMXZaR0ZzZlNCY2NseHVJQ0FnSUNBZ0lDQnZia05zYjNObFBYc29LU0E5UGlCelpYUlRhRzkzUVdKdmRYUk5iMlJoYkNobVlXeHpaU2w5SUZ4eVhHNGdJQ0FnSUNBZ0lIUnBkR3hsUFZ3aVIzSmhibVJsY3lCTmIyUmxiRzl6SUdSbElFeGxibWQxWVdwbElDaEpibVp2YldWa0xVZFZVbFVwWENKY2NseHVJQ0FnSUNBZ1BseHlYRzRnSUNBZ0lDQWdJRHhrYVhZZ1kyeGhjM05PWVcxbFBWd2liVzlrWVd3dGRHVjRkRndpUGx4eVhHNGdJQ0FnSUNBZ0lDQWdQR2d6SUhOMGVXeGxQWHQ3SUdadmJuUlRhWHBsT2lBbk1TNHhjbVZ0Snl3Z2JXRnlaMmx1UW05MGRHOXRPaUFuTUM0M05YSmxiU2NzSUdOdmJHOXlPaUFuSXpFeE1UZ3lOeWNnZlgwKzhKK1RpeUJVWldOdWIyeHZaOE90WVR3dmFETStYSEpjYmlBZ0lDQWdJQ0FnSUNBOGNDQnpkSGxzWlQxN2V5QnRZWEpuYVc1TVpXWjBPaUFuTUM0MWNtVnRKeUI5ZlQ1QmNHeHBZMkZqYWNPemJpQjNaV0lnY1hWbElIQmxjbTFwZEdVZ1kyOXRjR0Z5WVhJZ2NtVnpjSFZsYzNSaGN5QmtaU0JrYVdabGNtVnVkR1Z6SUcxdlpHVnNiM01nWkdVZ2JHVnVaM1ZoYW1VZ1pXNGdkR2xsYlhCdklISmxZV3d1UEM5d1BseHlYRzRnSUNBZ0lDQWdJRHd2WkdsMlBseHlYRzRnSUNBZ0lDQWdJRnh5WEc0Z0lDQWdJQ0FnSUR4a2FYWWdZMnhoYzNOT1lXMWxQVndpYlc5a1lXd3RkR1Y0ZEZ3aVBseHlYRzRnSUNBZ0lDQWdJQ0FnUEdneklITjBlV3hsUFh0N0lHWnZiblJUYVhwbE9pQW5NUzR4Y21WdEp5d2diV0Z5WjJsdVFtOTBkRzl0T2lBbk1DNDNOWEpsYlNjc0lHTnZiRzl5T2lBbkl6RXhNVGd5TnljZ2ZYMCs4SitrbGlCTmIyUmxiRzl6SUdScGMzQnZibWxpYkdWelBDOW9NejVjY2x4dUlDQWdJQ0FnSUNBZ0lEeDFiQ0J6ZEhsc1pUMTdleUJ0WVhKbmFXNU1aV1owT2lBbk1TNDFjbVZ0SnlCOWZUNWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1BHeHBQanh6ZEhKdmJtYytUM0JsYmtGSk9qd3ZjM1J5YjI1blBpQkhVRlF0TkNCTmFXNXBJSGtnUjFCVUxUTXVOU0JVZFhKaWJ6d3ZiR2srWEhKY2JpQWdJQ0FnSUNBZ0lDQWdJRHhzYVQ0OGMzUnliMjVuUGtGdWRHaHliM0JwWXpvOEwzTjBjbTl1Wno0Z1EyeGhkV1JsSURNdU5TQklZV2xyZFNCNUlFTnNZWFZrWlNBekxqVWdVMjl1Ym1WMFBDOXNhVDVjY2x4dUlDQWdJQ0FnSUNBZ0lEd3ZkV3crWEhKY2JpQWdJQ0FnSUNBZ1BDOWthWFkrWEhKY2JseHlYRzRnSUNBZ0lDQWdJRHhrYVhZZ1kyeGhjM05PWVcxbFBWd2liVzlrWVd3dGRHVjRkRndpUGx4eVhHNGdJQ0FnSUNBZ0lDQWdQR2d6SUhOMGVXeGxQWHQ3SUdadmJuUlRhWHBsT2lBbk1TNHhjbVZ0Snl3Z2JXRnlaMmx1UW05MGRHOXRPaUFuTUM0M05YSmxiU2NzSUdOdmJHOXlPaUFuSXpFeE1UZ3lOeWNnZlgwKzRweW9JRVoxYm1OcGIyNWhiR2xrWVdSbGN6d3ZhRE0rWEhKY2JpQWdJQ0FnSUNBZ0lDQThkV3dnYzNSNWJHVTllM3NnYldGeVoybHVUR1ZtZERvZ0p6RXVOWEpsYlNjZ2ZYMCtYSEpjYmlBZ0lDQWdJQ0FnSUNBZ0lEeHNhVDVEYjIxd1lYSmhZMm5EczI0Z2MybHRkV3gwdzZGdVpXRWdaR1VnY21WemNIVmxjM1JoY3lCa1pTQmtiM01nVEV4TlBDOXNhVDVjY2x4dUlDQWdJQ0FnSUNBZ0lDQWdQR3hwUGxObGJHVmpZMm5EczI0Z1pHbHV3NkZ0YVdOaElHUmxJRzF2WkdWc2IzTThMMnhwUGx4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0E4YkdrK1FXcDFjM1JsSUdSbElIUmxiWEJsY21GMGRYSmhJSEJoY21FZ1kyOXVkSEp2YkdGeUlHeGhJR055WldGMGFYWnBaR0ZrUEM5c2FUNWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1BHeHBQa052Ym5SaFpHOXlJR1JsSUhCeWIyMXdkSE1nWjJWdVpYSmhaRzl6UEM5c2FUNWNjbHh1SUNBZ0lDQWdJQ0FnSUNBZ1BHeHBQa2x1ZEdWeVptRjZJR0pwYkdsdVo4TzhaU0J2Y0hScGJXbDZZV1JoUEM5c2FUNWNjbHh1SUNBZ0lDQWdJQ0FnSUR3dmRXdytYSEpjYmlBZ0lDQWdJQ0FnUEM5a2FYWStYSEpjYmx4eVhHNGdJQ0FnSUNBZ0lEeGthWFlnWTJ4aGMzTk9ZVzFsUFZ3aWJXOWtZV3d0ZEdWNGRGd2lQbHh5WEc0Z0lDQWdJQ0FnSUNBZ1BHZ3pJSE4wZVd4bFBYdDdJR1p2Ym5SVGFYcGxPaUFuTVM0eGNtVnRKeXdnYldGeVoybHVRbTkwZEc5dE9pQW5NQzQzTlhKbGJTY3NJR052Ykc5eU9pQW5JekV4TVRneU55Y2dmWDArNHBxWjc3aVBJRU52Ym1acFozVnlZV05wdzdOdVBDOW9NejVjY2x4dUlDQWdJQ0FnSUNBZ0lEeHdJSE4wZVd4bFBYdDdJRzFoY21kcGJreGxablE2SUNjd0xqVnlaVzBuSUgxOVBreGhJSFJsYlhCbGNtRjBkWEpoSUdOdmJuUnliMnhoSUd4aElHRnNaV0YwYjNKcFpXUmhaQ0JrWlNCc1lYTWdjbVZ6Y0hWbGMzUmhjeUFvTUNBOUlHM0RvWE1nWkdWMFpYSnRhVzVwYzNSaExDQXhJRDBnYmNPaGN5QmpjbVZoZEdsMmJ5a3VQQzl3UGx4eVhHNGdJQ0FnSUNBZ0lEd3ZaR2wyUGx4eVhHNWNjbHh1SUNBZ0lDQWdJQ0E4WkdsMklHTnNZWE56VG1GdFpUMWNJbTF2WkdGc0xYUmxlSFJjSWlCemRIbHNaVDE3ZXlCaWIzSmtaWEpVYjNBNklDY3hjSGdnYzI5c2FXUWdJMlUxWlRkbFlpY3NJSEJoWkdScGJtZFViM0E2SUNjeGNtVnRKeXdnYldGeVoybHVWRzl3T2lBbk1YSmxiU2NnZlgwK1hISmNiaUFnSUNBZ0lDQWdJQ0E4Y0NCemRIbHNaVDE3ZXlCMFpYaDBRV3hwWjI0NklDZGpaVzUwWlhJbkxDQm1iMjUwVTNSNWJHVTZJQ2RwZEdGc2FXTW5MQ0JqYjJ4dmNqb2dKeU0yWWpjeU9EQW5JSDE5UGx4eVhHNGdJQ0FnSUNBZ0lDQWdJQ0JEY21WaFpHOGdjRzl5SUR4emRISnZibWNnYzNSNWJHVTllM3NnWTI5c2IzSTZJQ2NqTVRFeE9ESTNKeUI5ZlQ1QmJHVnFZVzVrY204Z1RXRjFjbTg4TDNOMGNtOXVaejRnZFhScGJHbDZZVzVrYnlBOGMzUnliMjVuSUhOMGVXeGxQWHQ3SUdOdmJHOXlPaUFuSXpJMU5qTmxZaWNnZlgwK1ZtbGlaV052WkdsdVp6d3ZjM1J5YjI1blBseHlYRzRnSUNBZ0lDQWdJQ0FnUEM5d1BseHlYRzRnSUNBZ0lDQWdJRHd2WkdsMlBseHlYRzRnSUNBZ0lDQThMMDF2WkdGc1BseHlYRzRnSUNBZ1BDOWthWFkrWEhKY2JpQWdLVHRjY2x4dWZWeHlYRzVjY2x4dVpYaHdiM0owSUdSbFptRjFiSFFnUVhCd095SmRMQ0ptYVd4bElqb2lMMmh2YldVdmFtRnVieTlFUlZaZlYxTk1MMHhNVFM5emNtTXZabkp2Ym5SbGJtUXZRWEJ3TG5SemVDSjk=",
            "encoding": "base64"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 8.163999998942018,
        "timings": {
          "blocked": 4.03999999805307,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.15400000000000014,
          "wait": 3.1909999991040676,
          "receive": 0.7790000017848797,
          "_blocked_queueing": 2.12199999805307,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184573",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 4
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/styles/index.css",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"3abf-RehtR8MEqRhbHcrxVNS4cRGMuV4\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 527,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 15039,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/styles/index.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/jano/DEV_WSL/LLM/src/frontend/styles/index.css\"\nconst __vite__css = \"/* Reset y estilos base */\\r\\n* {\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n  box-sizing: border-box;\\r\\n}\\r\\n\\r\\nbody {\\r\\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\\r\\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\\r\\n  -webkit-font-smoothing: antialiased;\\r\\n  -moz-osx-font-smoothing: grayscale;\\r\\n  background-color: #ffffff;\\r\\n  color: #111827;\\r\\n}\\r\\n\\r\\n/* App Container */\\r\\n.app {\\r\\n  min-height: 100vh;\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n}\\r\\n\\r\\n/* Header */\\r\\n.header {\\r\\n  background-color: #ffffff;\\r\\n  border-bottom: 1px solid #e5e7eb;\\r\\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);\\r\\n}\\r\\n\\r\\n.header-content {\\r\\n  max-width: 1280px;\\r\\n  margin: 0 auto;\\r\\n  padding: 1rem 2rem;\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.header-left {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  gap: 1rem;\\r\\n}\\r\\n\\r\\n.header-logo {\\r\\n  height: 40px;\\r\\n  width: auto;\\r\\n}\\r\\n\\r\\n.header-title {\\r\\n  font-size: 1.5rem;\\r\\n  font-weight: 700;\\r\\n  color: #111827;\\r\\n}\\r\\n\\r\\n.header-center {\\r\\n  flex: 1;\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.statistics-counter {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  gap: 0.5rem;\\r\\n  padding: 0.5rem 1rem;\\r\\n  background-color: #f9fafb;\\r\\n  border-radius: 0.5rem;\\r\\n}\\r\\n\\r\\n.statistics-label {\\r\\n  color: #6b7280;\\r\\n  font-size: 0.875rem;\\r\\n}\\r\\n\\r\\n.statistics-value {\\r\\n  font-weight: 600;\\r\\n  color: #2563eb;\\r\\n  font-size: 1.125rem;\\r\\n}\\r\\n\\r\\n.header-right {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n}\\r\\n\\r\\n.about-button {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  gap: 0.5rem;\\r\\n  padding: 0.5rem 1rem;\\r\\n  background-color: #f9fafb;\\r\\n  border: 1px solid #e5e7eb;\\r\\n  border-radius: 0.375rem;\\r\\n  color: #111827;\\r\\n  font-size: 0.875rem;\\r\\n  font-weight: 500;\\r\\n  cursor: pointer;\\r\\n  transition: all 0.2s;\\r\\n}\\r\\n\\r\\n.about-button:hover {\\r\\n  background-color: #e5e7eb;\\r\\n}\\r\\n\\r\\n/* Main Content */\\r\\n.main-content {\\r\\n  flex: 1;\\r\\n  padding: 2rem 0;\\r\\n}\\r\\n\\r\\n.container {\\r\\n  max-width: 1280px;\\r\\n  margin: 0 auto;\\r\\n  padding: 0 2rem;\\r\\n}\\r\\n\\r\\n.intro-section {\\r\\n  text-align: center;\\r\\n  margin-bottom: 2rem;\\r\\n}\\r\\n\\r\\n.intro-title {\\r\\n  font-size: 1.875rem;\\r\\n  font-weight: 600;\\r\\n  color: #111827;\\r\\n  margin-bottom: 0.5rem;\\r\\n}\\r\\n\\r\\n.intro-description {\\r\\n  color: #6b7280;\\r\\n  font-size: 1rem;\\r\\n  max-width: 600px;\\r\\n  margin: 0 auto;\\r\\n}\\r\\n\\r\\n/* Prompt Input */\\r\\n.prompt-input-container {\\r\\n  background-color: #ffffff;\\r\\n  border: 1px solid #e5e7eb;\\r\\n  border-radius: 0.5rem;\\r\\n  padding: 1.5rem;\\r\\n  margin-bottom: 2rem;\\r\\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);\\r\\n}\\r\\n\\r\\n.prompt-label {\\r\\n  display: block;\\r\\n  font-weight: 500;\\r\\n  color: #111827;\\r\\n  margin-bottom: 0.5rem;\\r\\n}\\r\\n\\r\\n.prompt-textarea {\\r\\n  width: 100%;\\r\\n  padding: 0.75rem;\\r\\n  border: 1px solid #e5e7eb;\\r\\n  border-radius: 0.375rem;\\r\\n  font-size: 1rem;\\r\\n  resize: vertical;\\r\\n  transition: border-color 0.2s;\\r\\n}\\r\\n\\r\\n.prompt-textarea:focus {\\r\\n  outline: none;\\r\\n  border-color: #2563eb;\\r\\n  box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);\\r\\n}\\r\\n\\r\\n.prompt-textarea:disabled {\\r\\n  background-color: #f9fafb;\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n\\r\\n.prompt-actions {\\r\\n  display: flex;\\r\\n  gap: 1rem;\\r\\n  margin-top: 1rem;\\r\\n}\\r\\n\\r\\n.submit-button {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  padding: 0.75rem 1.5rem;\\r\\n  background-color: #2563eb;\\r\\n  color: white;\\r\\n  border: none;\\r\\n  border-radius: 0.375rem;\\r\\n  font-size: 1rem;\\r\\n  font-weight: 500;\\r\\n  cursor: pointer;\\r\\n  transition: background-color 0.2s;\\r\\n}\\r\\n\\r\\n.submit-button:hover:not(:disabled) {\\r\\n  background-color: #1d4ed8;\\r\\n}\\r\\n\\r\\n.submit-button:disabled {\\r\\n  background-color: #9ca3af;\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n\\r\\n.clear-button {\\r\\n  padding: 0.75rem 1.5rem;\\r\\n  background-color: #f9fafb;\\r\\n  color: #111827;\\r\\n  border: 1px solid #e5e7eb;\\r\\n  border-radius: 0.375rem;\\r\\n  font-size: 1rem;\\r\\n  font-weight: 500;\\r\\n  cursor: pointer;\\r\\n  transition: background-color 0.2s;\\r\\n}\\r\\n\\r\\n.clear-button:hover:not(:disabled) {\\r\\n  background-color: #e5e7eb;\\r\\n}\\r\\n\\r\\n.clear-button:disabled {\\r\\n  opacity: 0.5;\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n\\r\\n.prompt-hint {\\r\\n  margin-top: 0.5rem;\\r\\n  font-size: 0.75rem;\\r\\n  color: #9ca3af;\\r\\n}\\r\\n\\r\\n/* Responses Grid */\\r\\n.responses-grid {\\r\\n  display: grid;\\r\\n  grid-template-columns: 1fr 1fr;\\r\\n  gap: 1.5rem;\\r\\n  margin-bottom: 2rem;\\r\\n}\\r\\n\\r\\n@media (max-width: 768px) {\\r\\n  .responses-grid {\\r\\n    grid-template-columns: 1fr;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* LLM Response Box */\\r\\n.llm-response-box {\\r\\n  background-color: #ffffff;\\r\\n  border: 2px solid #e5e7eb;\\r\\n  border-radius: 0.5rem;\\r\\n  overflow: hidden;\\r\\n  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);\\r\\n}\\r\\n\\r\\n.llm-response-box.border-green-500 {\\r\\n  border-color: #10b981;\\r\\n}\\r\\n\\r\\n.llm-response-box.border-orange-500 {\\r\\n  border-color: #f97316;\\r\\n}\\r\\n\\r\\n.llm-response-header {\\r\\n  padding: 1rem;\\r\\n  border-bottom: 1px solid #e5e7eb;\\r\\n}\\r\\n\\r\\n.llm-response-header.bg-green-50 {\\r\\n  background-color: rgba(16, 185, 129, 0.05);\\r\\n}\\r\\n\\r\\n.llm-response-header.bg-orange-50 {\\r\\n  background-color: rgba(249, 115, 22, 0.05);\\r\\n}\\r\\n\\r\\n.llm-response-title {\\r\\n  font-size: 1.125rem;\\r\\n  font-weight: 600;\\r\\n  color: #111827;\\r\\n  margin-bottom: 1rem;\\r\\n}\\r\\n\\r\\n.llm-controls {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  gap: 0.75rem;\\r\\n}\\r\\n\\r\\n.control-group {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  gap: 0.5rem;\\r\\n}\\r\\n\\r\\n.control-label {\\r\\n  font-size: 0.875rem;\\r\\n  color: #6b7280;\\r\\n  min-width: 100px;\\r\\n}\\r\\n\\r\\n.model-select {\\r\\n  flex: 1;\\r\\n  padding: 0.375rem 0.5rem;\\r\\n  border: 1px solid #e5e7eb;\\r\\n  border-radius: 0.25rem;\\r\\n  font-size: 0.875rem;\\r\\n  background-color: #ffffff;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.model-select:focus {\\r\\n  outline: none;\\r\\n  border-color: #2563eb;\\r\\n}\\r\\n\\r\\n.temperature-slider {\\r\\n  flex: 1;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.llm-response-content {\\r\\n  padding: 1.5rem;\\r\\n  min-height: 200px;\\r\\n  max-height: 500px;\\r\\n  overflow-y: auto;\\r\\n}\\r\\n\\r\\n.loading-container {\\r\\n  display: flex;\\r\\n  flex-direction: column;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  min-height: 200px;\\r\\n  color: #6b7280;\\r\\n}\\r\\n\\r\\n.loading-spinner {\\r\\n  width: 2rem;\\r\\n  height: 2rem;\\r\\n  border: 3px solid #e5e7eb;\\r\\n  border-top-color: #2563eb;\\r\\n  border-radius: 50%;\\r\\n  animation: spin 0.8s linear infinite;\\r\\n  margin-bottom: 1rem;\\r\\n}\\r\\n\\r\\n@keyframes spin {\\r\\n  to {\\r\\n    transform: rotate(360deg);\\r\\n  }\\r\\n}\\r\\n\\r\\n.response-text {\\r\\n  white-space: pre-wrap;\\r\\n  line-height: 1.6;\\r\\n  color: #111827;\\r\\n}\\r\\n\\r\\n.empty-response {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  min-height: 200px;\\r\\n  color: #9ca3af;\\r\\n  font-style: italic;\\r\\n}\\r\\n\\r\\n/* Error Message */\\r\\n.error-message {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  padding: 1rem;\\r\\n  background-color: #fee2e2;\\r\\n  border: 1px solid #fecaca;\\r\\n  border-radius: 0.375rem;\\r\\n  color: #991b1b;\\r\\n  margin-top: 1rem;\\r\\n}\\r\\n\\r\\n/* Modal */\\r\\n.modal-overlay {\\r\\n  position: fixed;\\r\\n  top: 0;\\r\\n  left: 0;\\r\\n  right: 0;\\r\\n  bottom: 0;\\r\\n  background-color: rgba(0, 0, 0, 0.5);\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  z-index: 1000;\\r\\n}\\r\\n\\r\\n.modal-content {\\r\\n  background-color: #ffffff;\\r\\n  border-radius: 0.5rem;\\r\\n  max-width: 600px;\\r\\n  width: 90%;\\r\\n  max-height: 80vh;\\r\\n  overflow: hidden;\\r\\n  box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);\\r\\n}\\r\\n\\r\\n.modal-header {\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  align-items: center;\\r\\n  padding: 1.5rem;\\r\\n  border-bottom: 1px solid #e5e7eb;\\r\\n}\\r\\n\\r\\n.modal-title {\\r\\n  font-size: 1.25rem;\\r\\n  font-weight: 600;\\r\\n  color: #111827;\\r\\n}\\r\\n\\r\\n.modal-close {\\r\\n  padding: 0.25rem;\\r\\n  background: none;\\r\\n  border: none;\\r\\n  color: #6b7280;\\r\\n  cursor: pointer;\\r\\n  transition: color 0.2s;\\r\\n}\\r\\n\\r\\n.modal-close:hover {\\r\\n  color: #111827;\\r\\n}\\r\\n\\r\\n.modal-body {\\r\\n  padding: 1.5rem;\\r\\n  max-height: calc(80vh - 80px);\\r\\n  overflow-y: auto;\\r\\n}\\r\\n\\r\\n.modal-text {\\r\\n  margin-bottom: 1rem;\\r\\n  line-height: 1.6;\\r\\n}\\r\\n\\r\\n.modal-text:last-child {\\r\\n  margin-bottom: 0;\\r\\n}\\r\\n\\r\\n.modal-text p {\\r\\n  margin-bottom: 0.5rem;\\r\\n}\\r\\n\\r\\n.modal-text ul {\\r\\n  list-style-type: disc;\\r\\n  margin-left: 1.5rem;\\r\\n  margin-top: 0.5rem;\\r\\n}\\r\\n\\r\\n.modal-text li {\\r\\n  margin-bottom: 0.25rem;\\r\\n}\\r\\n\\r\\n/* Markdown Response Integration */\\r\\n.response-markdown {\\r\\n  max-width: none;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\n\\r\\n.response-markdown .markdown-renderer {\\r\\n  font-size: 0.95rem;\\r\\n  line-height: 1.5;\\r\\n}\\r\\n\\r\\n.response-markdown .markdown-renderer h1:first-child,\\r\\n.response-markdown .markdown-renderer h2:first-child,\\r\\n.response-markdown .markdown-renderer h3:first-child,\\r\\n.response-markdown .markdown-renderer h4:first-child,\\r\\n.response-markdown .markdown-renderer h5:first-child,\\r\\n.response-markdown .markdown-renderer h6:first-child,\\r\\n.response-markdown .markdown-renderer p:first-child {\\r\\n  margin-top: 0;\\r\\n}\\r\\n\\r\\n.response-markdown .markdown-renderer p:last-child,\\r\\n.response-markdown .markdown-renderer ul:last-child,\\r\\n.response-markdown .markdown-renderer ol:last-child,\\r\\n.response-markdown .markdown-renderer blockquote:last-child,\\r\\n.response-markdown .markdown-renderer pre:last-child {\\r\\n  margin-bottom: 0;\\r\\n}\\r\\n\\r\\n/* Utilities */\\r\\n.w-5 {\\r\\n  width: 1.25rem;\\r\\n}\\r\\n\\r\\n.h-5 {\\r\\n  height: 1.25rem;\\r\\n}\\r\\n\\r\\n.w-6 {\\r\\n  width: 1.5rem;\\r\\n}\\r\\n\\r\\n.h-6 {\\r\\n  height: 1.5rem;\\r\\n}\\r\\n\\r\\n.mr-2 {\\r\\n  margin-right: 0.5rem;\\r\\n}\\r\\n\\r\\n.animate-spin {\\r\\n  animation: spin 1s linear infinite;\\r\\n}\\r\\n\\r\\n/* Streaming Toggle */\\r\\n.prompt-section {\\r\\n  width: 100%;\\r\\n}\\r\\n\\r\\n.streaming-toggle {\\r\\n  margin-bottom: 1rem;\\r\\n  display: flex;\\r\\n  justify-content: center;\\r\\n}\\r\\n\\r\\n.toggle-label {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  gap: 0.5rem;\\r\\n  cursor: pointer;\\r\\n  font-size: 0.95rem;\\r\\n  color: var(--text-color);\\r\\n  user-select: none;\\r\\n}\\r\\n\\r\\n.toggle-label input[type=\\\"checkbox\\\"] {\\r\\n  width: 1.25rem;\\r\\n  height: 1.25rem;\\r\\n  cursor: pointer;\\r\\n}\\r\\n\\r\\n.toggle-label input[type=\\\"checkbox\\\"]:disabled {\\r\\n  cursor: not-allowed;\\r\\n  opacity: 0.5;\\r\\n}\\r\\n\\r\\n.toggle-label span {\\r\\n  font-weight: 500;\\r\\n}\\r\\n\\r\\n/* Typing Cursor Animation */\\r\\n.typing-cursor {\\r\\n  display: inline-block;\\r\\n  animation: blink 1s infinite;\\r\\n  color: var(--primary-color);\\r\\n  font-weight: normal;\\r\\n  margin-left: 2px;\\r\\n}\\r\\n\\r\\n@keyframes blink {\\r\\n  0%, 50% {\\r\\n    opacity: 1;\\r\\n  }\\r\\n  51%, 100% {\\r\\n    opacity: 0;\\r\\n  }\\r\\n}\\r\\n\\r\\n/* Remove old loading styles */\\r\\n.loading-container {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n.loading-spinner {\\r\\n  display: none;\\r\\n}\\r\\n\\r\\n/* Optimized Prompt Input Layout */\\r\\n.prompt-input-row {\\r\\n  display: flex;\\r\\n  align-items: flex-start;\\r\\n  gap: 1rem;\\r\\n  margin-bottom: 1rem;\\r\\n}\\r\\n\\r\\n.prompt-input-row .prompt-label {\\r\\n  font-weight: 600;\\r\\n  font-size: 1rem;\\r\\n  color: var(--text-color);\\r\\n  white-space: nowrap;\\r\\n  padding-top: 0.75rem;\\r\\n  min-width: 60px;\\r\\n}\\r\\n\\r\\n.prompt-input-row .prompt-textarea {\\r\\n  flex: 1;\\r\\n  padding: 0.75rem;\\r\\n  border: 2px solid var(--border-color);\\r\\n  border-radius: 8px;\\r\\n  font-size: 1rem;\\r\\n  font-family: inherit;\\r\\n  line-height: 1.4;\\r\\n  resize: vertical;\\r\\n  min-height: 80px;\\r\\n  transition: all 0.2s ease;\\r\\n}\\r\\n\\r\\n.prompt-actions {\\r\\n  display: flex;\\r\\n  gap: 0.75rem !important;\\r\\n  align-items: center;\\r\\n  flex-wrap: wrap;\\r\\n  margin-top: 0.5rem !important;\\r\\n}\\r\\n\\r\\n.prompt-actions .submit-button, \\r\\n.prompt-actions .clear-button {\\r\\n  padding: 0.5rem 1rem !important;\\r\\n  font-size: 0.9rem !important;\\r\\n  min-width: auto !important;\\r\\n}\\r\\n\\r\\n.prompt-actions .submit-button {\\r\\n  min-width: 100px !important;\\r\\n}\\r\\n\\r\\n.prompt-actions .clear-button {\\r\\n  min-width: 80px !important;\\r\\n}\\r\\n\\r\\n.file-button {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  padding: 0.5rem 1rem !important;\\r\\n  background-color: #f3f4f6;\\r\\n  color: #374151;\\r\\n  border: 1px solid #d1d5db;\\r\\n  border-radius: 0.375rem;\\r\\n  font-size: 0.9rem !important;\\r\\n  font-weight: 500;\\r\\n  cursor: pointer;\\r\\n  transition: all 0.2s;\\r\\n  min-width: 90px !important;\\r\\n}\\r\\n\\r\\n.file-button:hover:not(:disabled) {\\r\\n  background-color: #e5e7eb;\\r\\n  color: #111827;\\r\\n}\\r\\n\\r\\n.file-button:disabled {\\r\\n  opacity: 0.5;\\r\\n  cursor: not-allowed;\\r\\n}\\r\\n\\r\\n.prompt-input-with-files {\\r\\n  position: relative;\\r\\n  flex: 1;\\r\\n}\\r\\n\\r\\n.prompt-input-with-files .files-attached-indicator {\\r\\n  position: absolute;\\r\\n  top: 0.5rem;\\r\\n  right: 0.5rem;\\r\\n  z-index: 10;\\r\\n}\\r\\n\\r\\n.prompt-actions .prompt-hint {\\r\\n  font-size: 0.8rem !important;\\r\\n  margin-left: auto;\\r\\n}\\r\\n\\r\\n/* Compact Header Layout */\\r\\n.header-top-row {\\r\\n  display: flex;\\r\\n  justify-content: space-between;\\r\\n  align-items: center;\\r\\n  margin-bottom: 0.75rem;\\r\\n}\\r\\n\\r\\n.header-actions {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  gap: 0.5rem;\\r\\n}\\r\\n\\r\\n.char-count-compact {\\r\\n  font-size: 0.75rem;\\r\\n  color: #6b7280;\\r\\n  font-weight: 500;\\r\\n  font-variant-numeric: tabular-nums;\\r\\n  background-color: rgba(255, 255, 255, 0.7);\\r\\n  padding: 0.25rem 0.5rem;\\r\\n  border-radius: 4px;\\r\\n  border: 1px solid rgba(0, 0, 0, 0.1);\\r\\n  min-width: 40px;\\r\\n  text-align: center;\\r\\n}\\r\\n\\r\\n.copy-button-compact {\\r\\n  display: flex;\\r\\n  align-items: center;\\r\\n  justify-content: center;\\r\\n  width: 24px;\\r\\n  height: 24px;\\r\\n  background-color: rgba(37, 99, 235, 0.8);\\r\\n  color: white;\\r\\n  border: none;\\r\\n  border-radius: 4px;\\r\\n  cursor: pointer;\\r\\n  transition: all 0.2s ease;\\r\\n  flex-shrink: 0;\\r\\n}\\r\\n\\r\\n.copy-button-compact:hover:not(:disabled) {\\r\\n  background-color: var(--primary-color);\\r\\n  transform: scale(1.05);\\r\\n  box-shadow: 0 2px 6px rgba(37, 99, 235, 0.4);\\r\\n}\\r\\n\\r\\n.copy-button-compact:disabled {\\r\\n  background-color: #9ca3af;\\r\\n  cursor: not-allowed;\\r\\n  transform: none;\\r\\n  box-shadow: none;\\r\\n}\\r\\n\\r\\n.copy-button-compact svg {\\r\\n  flex-shrink: 0;\\r\\n}\"\n__vite__updateStyle(__vite__id, __vite__css)\nimport.meta.hot.accept()\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 8.333000001584878,
        "timings": {
          "blocked": 4.642000002636109,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.07900000000000018,
          "wait": 3.1699999984730964,
          "receive": 0.442000000475673,
          "_blocked_queueing": 2.2430000026361085,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 5
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/styles/markdown.css",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"1ec1-D850TeUO5SHoERdkt22M4v/lsb0\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 530,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 7873,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/styles/markdown.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/jano/DEV_WSL/LLM/src/frontend/styles/markdown.css\"\nconst __vite__css = \"/* Markdown Renderer Styles */\\n.markdown-renderer {\\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',\\n    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;\\n  line-height: 1.6;\\n  color: #111827;\\n  word-wrap: break-word;\\n}\\n\\n/* Streaming Animation */\\n.markdown-renderer.streaming {\\n  animation: fadeIn 0.3s ease-in;\\n}\\n\\n@keyframes fadeIn {\\n  from { opacity: 0.8; }\\n  to { opacity: 1; }\\n}\\n\\n.streaming-cursor {\\n  display: inline-block;\\n  animation: blink 1s infinite;\\n  color: #2563eb;\\n  font-weight: bold;\\n  margin-left: 2px;\\n}\\n\\n@keyframes blink {\\n  0%, 50% { opacity: 1; }\\n  51%, 100% { opacity: 0; }\\n}\\n\\n/* Headings */\\n.markdown-renderer h1,\\n.markdown-renderer h2,\\n.markdown-renderer h3,\\n.markdown-renderer h4,\\n.markdown-renderer h5,\\n.markdown-renderer h6 {\\n  margin-top: 1.5rem;\\n  margin-bottom: 0.5rem;\\n  font-weight: 600;\\n  line-height: 1.25;\\n  color: #111827;\\n}\\n\\n.markdown-renderer h1 {\\n  font-size: 1.875rem;\\n  border-bottom: 2px solid #e5e7eb;\\n  padding-bottom: 0.5rem;\\n}\\n\\n.markdown-renderer h2 {\\n  font-size: 1.5rem;\\n  border-bottom: 1px solid #e5e7eb;\\n  padding-bottom: 0.25rem;\\n}\\n\\n.markdown-renderer h3 {\\n  font-size: 1.25rem;\\n}\\n\\n.markdown-renderer h4 {\\n  font-size: 1.125rem;\\n}\\n\\n.markdown-renderer h5 {\\n  font-size: 1rem;\\n}\\n\\n.markdown-renderer h6 {\\n  font-size: 0.875rem;\\n  color: #6b7280;\\n}\\n\\n/* Paragraphs */\\n.markdown-renderer p {\\n  margin-bottom: 1rem;\\n}\\n\\n/* Text formatting */\\n.markdown-renderer strong {\\n  font-weight: 600;\\n  color: #111827;\\n}\\n\\n.markdown-renderer em {\\n  font-style: italic;\\n}\\n\\n.markdown-renderer del {\\n  text-decoration: line-through;\\n  color: #6b7280;\\n}\\n\\n/* Lists */\\n.markdown-renderer ul,\\n.markdown-renderer ol {\\n  margin-bottom: 1rem;\\n  padding-left: 1.5rem;\\n}\\n\\n.markdown-renderer ul {\\n  list-style-type: disc;\\n}\\n\\n.markdown-renderer ol {\\n  list-style-type: decimal;\\n}\\n\\n.markdown-renderer li {\\n  margin-bottom: 0.25rem;\\n}\\n\\n.markdown-renderer li > ul,\\n.markdown-renderer li > ol {\\n  margin-top: 0.25rem;\\n  margin-bottom: 0.25rem;\\n}\\n\\n/* Nested lists */\\n.markdown-renderer ul ul {\\n  list-style-type: circle;\\n}\\n\\n.markdown-renderer ul ul ul {\\n  list-style-type: square;\\n}\\n\\n/* Code Blocks */\\n.code-block-wrapper {\\n  margin: 1rem 0;\\n  border-radius: 8px;\\n  background-color: #1e1e1e;\\n  overflow: hidden;\\n  border: 1px solid #374151;\\n}\\n\\n.code-block {\\n  background-color: #1e1e1e !important;\\n  color: #d1d5db !important;\\n}\\n\\n.code-block-header {\\n  display: flex;\\n  justify-content: space-between;\\n  align-items: center;\\n  padding: 0.75rem 1rem;\\n  background-color: #374151;\\n  border-bottom: 1px solid #4b5563;\\n}\\n\\n.code-language {\\n  font-size: 0.875rem;\\n  color: #d1d5db;\\n  font-weight: 500;\\n  text-transform: uppercase;\\n}\\n\\n.copy-code-button {\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  width: 32px;\\n  height: 32px;\\n  background-color: rgba(59, 130, 246, 0.1);\\n  border: 1px solid rgba(59, 130, 246, 0.3);\\n  border-radius: 6px;\\n  color: #3b82f6;\\n  cursor: pointer;\\n  transition: all 0.2s ease;\\n}\\n\\n.copy-code-button:hover {\\n  background-color: rgba(59, 130, 246, 0.2);\\n  border-color: #3b82f6;\\n  transform: scale(1.05);\\n}\\n\\n.copy-icon {\\n  width: 16px;\\n  height: 16px;\\n}\\n\\n.code-block-wrapper pre {\\n  margin: 0;\\n  padding: 1rem;\\n  overflow-x: auto;\\n  background-color: #1e1e1e;\\n  font-size: 0.875rem;\\n  line-height: 1.5;\\n}\\n\\n.code-block-wrapper code {\\n  color: #d1d5db;\\n  font-family: 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;\\n}\\n\\n/* Inline Code */\\n.inline-code {\\n  background-color: rgba(55, 65, 81, 0.1);\\n  border: 1px solid rgba(55, 65, 81, 0.2);\\n  border-radius: 4px;\\n  padding: 0.125rem 0.25rem;\\n  font-family: 'SF Mono', Consolas, 'Liberation Mono', Menlo, monospace;\\n  font-size: 0.875em;\\n  color: #dc2626;\\n}\\n\\n/* Tables */\\n.table-wrapper {\\n  overflow-x: auto;\\n  margin: 1rem 0;\\n}\\n\\n.markdown-table {\\n  width: 100%;\\n  border-collapse: collapse;\\n  border: 1px solid #e5e7eb;\\n  border-radius: 8px;\\n  overflow: hidden;\\n}\\n\\n.markdown-table th,\\n.markdown-table td {\\n  border: 1px solid #e5e7eb;\\n  padding: 0.75rem;\\n  text-align: left;\\n}\\n\\n.markdown-table th {\\n  background-color: #f9fafb;\\n  font-weight: 600;\\n  color: #111827;\\n}\\n\\n.markdown-table tr:nth-child(even) {\\n  background-color: #f9fafb;\\n}\\n\\n.markdown-table tr:hover {\\n  background-color: #f3f4f6;\\n}\\n\\n/* Blockquotes */\\n.markdown-blockquote {\\n  border-left: 4px solid #3b82f6;\\n  margin: 1rem 0;\\n  padding: 1rem 1.5rem;\\n  background-color: rgba(59, 130, 246, 0.05);\\n  border-radius: 0 8px 8px 0;\\n  font-style: italic;\\n  color: #374151;\\n}\\n\\n.markdown-blockquote p:last-child {\\n  margin-bottom: 0;\\n}\\n\\n/* Links */\\n.markdown-link {\\n  color: #2563eb;\\n  text-decoration: underline;\\n  transition: color 0.2s ease;\\n}\\n\\n.markdown-link:hover {\\n  color: #1d4ed8;\\n  text-decoration: none;\\n}\\n\\n/* Horizontal Rules */\\n.markdown-renderer hr {\\n  border: none;\\n  height: 2px;\\n  background: linear-gradient(to right, transparent, #e5e7eb, transparent);\\n  margin: 2rem 0;\\n}\\n\\n/* Math Expressions */\\n.markdown-renderer .katex {\\n  font-size: 1.1em;\\n}\\n\\n.markdown-renderer .katex-display {\\n  margin: 1rem 0;\\n  overflow-x: auto;\\n}\\n\\n/* Images */\\n.markdown-renderer img {\\n  max-width: 100%;\\n  height: auto;\\n  border-radius: 8px;\\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);\\n  margin: 1rem 0;\\n}\\n\\n/* Task Lists */\\n.markdown-renderer input[type=\\\"checkbox\\\"] {\\n  margin-right: 0.5rem;\\n  accent-color: #2563eb;\\n}\\n\\n/* Mobile Responsiveness */\\n@media (max-width: 768px) {\\n  .markdown-renderer {\\n    font-size: 0.9rem;\\n  }\\n  \\n  .markdown-renderer h1 {\\n    font-size: 1.5rem;\\n  }\\n  \\n  .markdown-renderer h2 {\\n    font-size: 1.25rem;\\n  }\\n  \\n  .markdown-renderer h3 {\\n    font-size: 1.125rem;\\n  }\\n  \\n  .code-block-header {\\n    padding: 0.5rem 0.75rem;\\n  }\\n  \\n  .code-block-wrapper pre {\\n    padding: 0.75rem;\\n    font-size: 0.8rem;\\n  }\\n  \\n  .markdown-table {\\n    font-size: 0.875rem;\\n  }\\n  \\n  .markdown-table th,\\n  .markdown-table td {\\n    padding: 0.5rem;\\n  }\\n  \\n  .markdown-blockquote {\\n    padding: 0.75rem 1rem;\\n    margin: 0.75rem 0;\\n  }\\n}\\n\\n/* Dark mode compatibility */\\n@media (prefers-color-scheme: dark) {\\n  .markdown-renderer {\\n    color: #f9fafb;\\n  }\\n  \\n  .markdown-renderer h1,\\n  .markdown-renderer h2,\\n  .markdown-renderer h3,\\n  .markdown-renderer h4,\\n  .markdown-renderer h5,\\n  .markdown-renderer h6 {\\n    color: #f9fafb;\\n  }\\n  \\n  .markdown-renderer h1 {\\n    border-bottom-color: #374151;\\n  }\\n  \\n  .markdown-renderer h2 {\\n    border-bottom-color: #374151;\\n  }\\n  \\n  .inline-code {\\n    background-color: rgba(75, 85, 99, 0.3);\\n    border-color: rgba(75, 85, 99, 0.5);\\n    color: #fbbf24;\\n  }\\n  \\n  .markdown-table {\\n    border-color: #374151;\\n  }\\n  \\n  .markdown-table th,\\n  .markdown-table td {\\n    border-color: #374151;\\n  }\\n  \\n  .markdown-table th {\\n    background-color: #1f2937;\\n    color: #f9fafb;\\n  }\\n  \\n  .markdown-table tr:nth-child(even) {\\n    background-color: #1f2937;\\n  }\\n  \\n  .markdown-table tr:hover {\\n    background-color: #374151;\\n  }\\n  \\n  .markdown-blockquote {\\n    background-color: rgba(59, 130, 246, 0.1);\\n    color: #d1d5db;\\n  }\\n}\"\n__vite__updateStyle(__vite__id, __vite__css)\nimport.meta.hot.accept()\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 9.49299999935343,
        "timings": {
          "blocked": 2.9630000004381873,
          "dns": 0.006000000000000005,
          "ssl": -1,
          "connect": 1.992,
          "send": 0.5409999999999999,
          "wait": 3.482000001223525,
          "receive": 0.508999997691717,
          "_blocked_queueing": 2.2580000004381873,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184654",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/main.tsx",
          "lineNumber": 6
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/styles/file-upload.css",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"11c8-AuwNmL+nHPI62qbGc2JngyFGXqs\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/main.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 533,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 4552,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/styles/file-upload.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/jano/DEV_WSL/LLM/src/frontend/styles/file-upload.css\"\nconst __vite__css = \"/* File Upload Component Styles */\\n.file-upload-container {\\n  margin: 1rem 0;\\n}\\n\\n.file-upload-dropzone {\\n  border: 2px dashed #e5e7eb;\\n  border-radius: 8px;\\n  padding: 2rem;\\n  text-align: center;\\n  cursor: pointer;\\n  transition: all 0.3s ease;\\n  background-color: #f9fafb;\\n}\\n\\n.file-upload-dropzone:hover {\\n  border-color: #3b82f6;\\n  background-color: #eff6ff;\\n}\\n\\n.file-upload-dropzone.drag-active {\\n  border-color: #3b82f6;\\n  background-color: #dbeafe;\\n  transform: scale(1.02);\\n}\\n\\n.dropzone-content {\\n  pointer-events: none;\\n}\\n\\n.upload-icon {\\n  width: 48px;\\n  height: 48px;\\n  margin: 0 auto 1rem;\\n  color: #9ca3af;\\n}\\n\\n.file-upload-dropzone:hover .upload-icon,\\n.file-upload-dropzone.drag-active .upload-icon {\\n  color: #3b82f6;\\n}\\n\\n.dropzone-text {\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25rem;\\n}\\n\\n.dropzone-text-primary {\\n  font-weight: 600;\\n  color: #374151;\\n  font-size: 1rem;\\n}\\n\\n.dropzone-text-secondary {\\n  font-size: 0.875rem;\\n  color: #6b7280;\\n}\\n\\n/* Uploaded Files List */\\n.uploaded-files-list {\\n  display: grid;\\n  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));\\n  gap: 1rem;\\n  margin-top: 1rem;\\n}\\n\\n.uploaded-file-item {\\n  position: relative;\\n  background: white;\\n  border: 1px solid #e5e7eb;\\n  border-radius: 8px;\\n  padding: 0.5rem;\\n  transition: all 0.2s ease;\\n}\\n\\n.uploaded-file-item:hover {\\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);\\n  transform: translateY(-2px);\\n}\\n\\n.file-preview-image {\\n  width: 100%;\\n  height: 100px;\\n  object-fit: cover;\\n  border-radius: 4px;\\n  margin-bottom: 0.5rem;\\n}\\n\\n.file-preview-pdf {\\n  width: 100%;\\n  height: 100px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  background-color: #fee2e2;\\n  border-radius: 4px;\\n  margin-bottom: 0.5rem;\\n}\\n\\n.pdf-icon {\\n  width: 40px;\\n  height: 40px;\\n  color: #dc2626;\\n}\\n\\n.file-info {\\n  padding: 0.25rem;\\n}\\n\\n.file-name {\\n  font-size: 0.75rem;\\n  font-weight: 500;\\n  color: #374151;\\n  white-space: nowrap;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  margin-bottom: 0.25rem;\\n}\\n\\n.file-size {\\n  font-size: 0.7rem;\\n  color: #6b7280;\\n}\\n\\n.file-remove-button {\\n  position: absolute;\\n  top: 0.25rem;\\n  right: 0.25rem;\\n  width: 24px;\\n  height: 24px;\\n  background-color: rgba(239, 68, 68, 0.9);\\n  border: none;\\n  border-radius: 50%;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n  cursor: pointer;\\n  opacity: 0;\\n  transition: opacity 0.2s ease;\\n}\\n\\n.uploaded-file-item:hover .file-remove-button {\\n  opacity: 1;\\n}\\n\\n.file-remove-button:hover {\\n  background-color: #dc2626;\\n  transform: scale(1.1);\\n}\\n\\n.remove-icon {\\n  width: 14px;\\n  height: 14px;\\n  color: white;\\n}\\n\\n/* File Processing Status */\\n.file-status-message {\\n  margin-top: 0.5rem;\\n  padding: 0.75rem;\\n  border-radius: 6px;\\n  font-size: 0.875rem;\\n}\\n\\n.file-status-success {\\n  background-color: #d1fae5;\\n  color: #065f46;\\n  border: 1px solid #a7f3d0;\\n}\\n\\n.file-status-warning {\\n  background-color: #fed7aa;\\n  color: #92400e;\\n  border: 1px solid #fdba74;\\n}\\n\\n.file-status-error {\\n  background-color: #fee2e2;\\n  color: #991b1b;\\n  border: 1px solid #fecaca;\\n}\\n\\n/* Mobile Responsiveness */\\n@media (max-width: 768px) {\\n  .file-upload-dropzone {\\n    padding: 1.5rem;\\n  }\\n  \\n  .uploaded-files-list {\\n    grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));\\n    gap: 0.75rem;\\n  }\\n  \\n  .file-preview-image,\\n  .file-preview-pdf {\\n    height: 80px;\\n  }\\n  \\n  .upload-icon {\\n    width: 36px;\\n    height: 36px;\\n  }\\n}\\n\\n/* Integration with Prompt Input */\\n.prompt-with-files {\\n  border: 2px solid #3b82f6;\\n  background-color: #eff6ff;\\n}\\n\\n.files-attached-indicator {\\n  display: inline-flex;\\n  align-items: center;\\n  gap: 0.25rem;\\n  padding: 0.25rem 0.75rem;\\n  background-color: #3b82f6;\\n  color: white;\\n  border-radius: 9999px;\\n  font-size: 0.75rem;\\n  font-weight: 500;\\n  margin-left: 0.5rem;\\n}\\n\\n.files-attached-indicator svg {\\n  width: 14px;\\n  height: 14px;\\n}\"\n__vite__updateStyle(__vite__id, __vite__css)\nimport.meta.hot.accept()\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 9.631999999116175,
        "timings": {
          "blocked": 3.2869999996803236,
          "dns": 0.005999999999999894,
          "ssl": -1,
          "connect": 1.657,
          "send": 0.7509999999999999,
          "wait": 3.445999998955056,
          "receive": 0.4850000004807953,
          "_blocked_queueing": 2.2879999996803235,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184658",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@vite/client",
          "lineNumber": 0
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/vite/dist/client/env.mjs",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"27a-50Oe5S7HDq59Hm15o909pGTGmf8\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@vite/client"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 577,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 4021,
            "mimeType": "text/javascript",
            "text": "const context = (() => {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  } else if (typeof self !== \"undefined\") {\n    return self;\n  } else if (typeof window !== \"undefined\") {\n    return window;\n  } else {\n    return Function(\"return this\")();\n  }\n})();\nconst defines = {};\nObject.keys(defines).forEach((key) => {\n  const segments = key.split(\".\");\n  let target = context;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (i === segments.length - 1) {\n      target[segment] = defines[key];\n    } else {\n      target = target[segment] || (target[segment] = {});\n    }\n  }\n});\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImVudi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udGV4dCA9ICgoKSA9PiB7XG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBnbG9iYWxUaGlzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbiAgfVxufSkoKTtcbmNvbnN0IGRlZmluZXMgPSB7fTtcbk9iamVjdC5rZXlzKGRlZmluZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICBjb25zdCBzZWdtZW50cyA9IGtleS5zcGxpdChcIi5cIik7XG4gIGxldCB0YXJnZXQgPSBjb250ZXh0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmIChpID09PSBzZWdtZW50cy5sZW5ndGggLSAxKSB7XG4gICAgICB0YXJnZXRbc2VnbWVudF0gPSBkZWZpbmVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldFtzZWdtZW50XSB8fCAodGFyZ2V0W3NlZ21lbnRdID0ge30pO1xuICAgIH1cbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDMUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO0FBQ3RCLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUMzQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDaEIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ1YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3JDLENBQUMsQ0FBQyxDQUFDO0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ0wsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDbkIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQ3ZCLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM3QyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNoQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN6RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQztBQUNILENBQUMsQ0FBQyxDQUFDOyJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.678Z",
        "time": 9.693999999207213,
        "timings": {
          "blocked": 3.931999998831423,
          "dns": 0.014000000000000012,
          "ssl": -1,
          "connect": 0.929,
          "send": 1.012,
          "wait": 3.262000001410721,
          "receive": 0.5449999989650678,
          "_blocked_queueing": 2.263999998831423,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed",
          "lineNumber": 2
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-RLJ2RCJQ.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "77844"
            },
            {
              "name": "Etag",
              "value": "W/\"13014-q0zmFdc0jOVtq5NCkC0u6YkKjBQ\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 77844,
            "mimeType": "text/javascript",
            "text": "import {\n  __commonJS\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/react/cjs/react.development.js\nvar require_react_development = __commonJS({\n  \"node_modules/react/cjs/react.development.js\"(exports, module) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var ReactVersion = \"18.3.1\";\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var ReactCurrentDispatcher = {\n          /**\n           * @internal\n           * @type {ReactComponent}\n           */\n          current: null\n        };\n        var ReactCurrentBatchConfig = {\n          transition: null\n        };\n        var ReactCurrentActQueue = {\n          current: null,\n          // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n          isBatchingLegacy: false,\n          didScheduleLegacyUpdate: false\n        };\n        var ReactCurrentOwner = {\n          /**\n           * @internal\n           * @type {ReactComponent}\n           */\n          current: null\n        };\n        var ReactDebugCurrentFrame = {};\n        var currentExtraStackFrame = null;\n        function setExtraStackFrame(stack) {\n          {\n            currentExtraStackFrame = stack;\n          }\n        }\n        {\n          ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {\n            {\n              currentExtraStackFrame = stack;\n            }\n          };\n          ReactDebugCurrentFrame.getCurrentStack = null;\n          ReactDebugCurrentFrame.getStackAddendum = function() {\n            var stack = \"\";\n            if (currentExtraStackFrame) {\n              stack += currentExtraStackFrame;\n            }\n            var impl = ReactDebugCurrentFrame.getCurrentStack;\n            if (impl) {\n              stack += impl() || \"\";\n            }\n            return stack;\n          };\n        }\n        var enableScopeAPI = false;\n        var enableCacheElement = false;\n        var enableTransitionTracing = false;\n        var enableLegacyHidden = false;\n        var enableDebugTracing = false;\n        var ReactSharedInternals = {\n          ReactCurrentDispatcher,\n          ReactCurrentBatchConfig,\n          ReactCurrentOwner\n        };\n        {\n          ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n          ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n        }\n        function warn(format) {\n          {\n            {\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n              printWarning(\"warn\", format, args);\n            }\n          }\n        }\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var didWarnStateUpdateForUnmountedComponent = {};\n        function warnNoop(publicInstance, callerName) {\n          {\n            var _constructor = publicInstance.constructor;\n            var componentName = _constructor && (_constructor.displayName || _constructor.name) || \"ReactClass\";\n            var warningKey = componentName + \".\" + callerName;\n            if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n              return;\n            }\n            error(\"Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.\", callerName, componentName);\n            didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n          }\n        }\n        var ReactNoopUpdateQueue = {\n          /**\n           * Checks whether or not this composite component is mounted.\n           * @param {ReactClass} publicInstance The instance we want to test.\n           * @return {boolean} True if mounted, false otherwise.\n           * @protected\n           * @final\n           */\n          isMounted: function(publicInstance) {\n            return false;\n          },\n          /**\n           * Forces an update. This should only be invoked when it is known with\n           * certainty that we are **not** in a DOM transaction.\n           *\n           * You may want to call this when you know that some deeper aspect of the\n           * component's state has changed but `setState` was not called.\n           *\n           * This will not invoke `shouldComponentUpdate`, but it will invoke\n           * `componentWillUpdate` and `componentDidUpdate`.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {?function} callback Called after component is updated.\n           * @param {?string} callerName name of the calling function in the public API.\n           * @internal\n           */\n          enqueueForceUpdate: function(publicInstance, callback, callerName) {\n            warnNoop(publicInstance, \"forceUpdate\");\n          },\n          /**\n           * Replaces all of the state. Always use this or `setState` to mutate state.\n           * You should treat `this.state` as immutable.\n           *\n           * There is no guarantee that `this.state` will be immediately updated, so\n           * accessing `this.state` after calling this method may return the old value.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {object} completeState Next state.\n           * @param {?function} callback Called after component is updated.\n           * @param {?string} callerName name of the calling function in the public API.\n           * @internal\n           */\n          enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {\n            warnNoop(publicInstance, \"replaceState\");\n          },\n          /**\n           * Sets a subset of the state. This only exists because _pendingState is\n           * internal. This provides a merging strategy that is not available to deep\n           * properties which is confusing. TODO: Expose pendingState or don't use it\n           * during the merge.\n           *\n           * @param {ReactClass} publicInstance The instance that should rerender.\n           * @param {object} partialState Next partial state to be merged with state.\n           * @param {?function} callback Called after component is updated.\n           * @param {?string} Name of the calling function in the public API.\n           * @internal\n           */\n          enqueueSetState: function(publicInstance, partialState, callback, callerName) {\n            warnNoop(publicInstance, \"setState\");\n          }\n        };\n        var assign = Object.assign;\n        var emptyObject = {};\n        {\n          Object.freeze(emptyObject);\n        }\n        function Component(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject;\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n        Component.prototype.isReactComponent = {};\n        Component.prototype.setState = function(partialState, callback) {\n          if (typeof partialState !== \"object\" && typeof partialState !== \"function\" && partialState != null) {\n            throw new Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");\n          }\n          this.updater.enqueueSetState(this, partialState, callback, \"setState\");\n        };\n        Component.prototype.forceUpdate = function(callback) {\n          this.updater.enqueueForceUpdate(this, callback, \"forceUpdate\");\n        };\n        {\n          var deprecatedAPIs = {\n            isMounted: [\"isMounted\", \"Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks.\"],\n            replaceState: [\"replaceState\", \"Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236).\"]\n          };\n          var defineDeprecationWarning = function(methodName, info) {\n            Object.defineProperty(Component.prototype, methodName, {\n              get: function() {\n                warn(\"%s(...) is deprecated in plain JavaScript React classes. %s\", info[0], info[1]);\n                return void 0;\n              }\n            });\n          };\n          for (var fnName in deprecatedAPIs) {\n            if (deprecatedAPIs.hasOwnProperty(fnName)) {\n              defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n            }\n          }\n        }\n        function ComponentDummy() {\n        }\n        ComponentDummy.prototype = Component.prototype;\n        function PureComponent(props, context, updater) {\n          this.props = props;\n          this.context = context;\n          this.refs = emptyObject;\n          this.updater = updater || ReactNoopUpdateQueue;\n        }\n        var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n        pureComponentPrototype.constructor = PureComponent;\n        assign(pureComponentPrototype, Component.prototype);\n        pureComponentPrototype.isPureReactComponent = true;\n        function createRef() {\n          var refObject = {\n            current: null\n          };\n          {\n            Object.seal(refObject);\n          }\n          return refObject;\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n        {\n          didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n          {\n            if (hasOwnProperty.call(config, \"ref\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.ref !== void 0;\n        }\n        function hasValidKey(config) {\n          {\n            if (hasOwnProperty.call(config, \"key\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.key !== void 0;\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n          var warnAboutAccessingKey = function() {\n            {\n              if (!specialPropKeyWarningShown) {\n                specialPropKeyWarningShown = true;\n                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            }\n          };\n          warnAboutAccessingKey.isReactWarning = true;\n          Object.defineProperty(props, \"key\", {\n            get: warnAboutAccessingKey,\n            configurable: true\n          });\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n          var warnAboutAccessingRef = function() {\n            {\n              if (!specialPropRefWarningShown) {\n                specialPropRefWarningShown = true;\n                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            }\n          };\n          warnAboutAccessingRef.isReactWarning = true;\n          Object.defineProperty(props, \"ref\", {\n            get: warnAboutAccessingRef,\n            configurable: true\n          });\n        }\n        function warnIfStringRefCannotBeAutoConverted(config) {\n          {\n            if (typeof config.ref === \"string\" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n              if (!didWarnAboutStringRefs[componentName]) {\n                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n        }\n        var ReactElement = function(type, key, ref, self, source, owner, props) {\n          var element = {\n            // This tag allows us to uniquely identify this as a React Element\n            $$typeof: REACT_ELEMENT_TYPE,\n            // Built-in properties that belong on the element\n            type,\n            key,\n            ref,\n            props,\n            // Record the component responsible for creating this element.\n            _owner: owner\n          };\n          {\n            element._store = {};\n            Object.defineProperty(element._store, \"validated\", {\n              configurable: false,\n              enumerable: false,\n              writable: true,\n              value: false\n            });\n            Object.defineProperty(element, \"_self\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: self\n            });\n            Object.defineProperty(element, \"_source\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: source\n            });\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n          return element;\n        };\n        function createElement(type, config, children) {\n          var propName;\n          var props = {};\n          var key = null;\n          var ref = null;\n          var self = null;\n          var source = null;\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              {\n                warnIfStringRefCannotBeAutoConverted(config);\n              }\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            self = config.__self === void 0 ? null : config.__self;\n            source = config.__source === void 0 ? null : config.__source;\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n          }\n          var childrenLength = arguments.length - 2;\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n            {\n              if (Object.freeze) {\n                Object.freeze(childArray);\n              }\n            }\n            props.children = childArray;\n          }\n          if (type && type.defaultProps) {\n            var defaultProps = type.defaultProps;\n            for (propName in defaultProps) {\n              if (props[propName] === void 0) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n          }\n          {\n            if (key || ref) {\n              var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n              if (key) {\n                defineKeyPropWarningGetter(props, displayName);\n              }\n              if (ref) {\n                defineRefPropWarningGetter(props, displayName);\n              }\n            }\n          }\n          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n        function cloneAndReplaceKey(oldElement, newKey) {\n          var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n          return newElement;\n        }\n        function cloneElement(element, config, children) {\n          if (element === null || element === void 0) {\n            throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n          }\n          var propName;\n          var props = assign({}, element.props);\n          var key = element.key;\n          var ref = element.ref;\n          var self = element._self;\n          var source = element._source;\n          var owner = element._owner;\n          if (config != null) {\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              owner = ReactCurrentOwner.current;\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            var defaultProps;\n            if (element.type && element.type.defaultProps) {\n              defaultProps = element.type.defaultProps;\n            }\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                if (config[propName] === void 0 && defaultProps !== void 0) {\n                  props[propName] = defaultProps[propName];\n                } else {\n                  props[propName] = config[propName];\n                }\n              }\n            }\n          }\n          var childrenLength = arguments.length - 2;\n          if (childrenLength === 1) {\n            props.children = children;\n          } else if (childrenLength > 1) {\n            var childArray = Array(childrenLength);\n            for (var i = 0; i < childrenLength; i++) {\n              childArray[i] = arguments[i + 2];\n            }\n            props.children = childArray;\n          }\n          return ReactElement(element.type, key, ref, self, source, owner, props);\n        }\n        function isValidElement(object) {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n        var SEPARATOR = \".\";\n        var SUBSEPARATOR = \":\";\n        function escape(key) {\n          var escapeRegex = /[=:]/g;\n          var escaperLookup = {\n            \"=\": \"=0\",\n            \":\": \"=2\"\n          };\n          var escapedString = key.replace(escapeRegex, function(match) {\n            return escaperLookup[match];\n          });\n          return \"$\" + escapedString;\n        }\n        var didWarnAboutMaps = false;\n        var userProvidedKeyEscapeRegex = /\\/+/g;\n        function escapeUserProvidedKey(text) {\n          return text.replace(userProvidedKeyEscapeRegex, \"$&/\");\n        }\n        function getElementKey(element, index) {\n          if (typeof element === \"object\" && element !== null && element.key != null) {\n            {\n              checkKeyStringCoercion(element.key);\n            }\n            return escape(\"\" + element.key);\n          }\n          return index.toString(36);\n        }\n        function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n          var type = typeof children;\n          if (type === \"undefined\" || type === \"boolean\") {\n            children = null;\n          }\n          var invokeCallback = false;\n          if (children === null) {\n            invokeCallback = true;\n          } else {\n            switch (type) {\n              case \"string\":\n              case \"number\":\n                invokeCallback = true;\n                break;\n              case \"object\":\n                switch (children.$$typeof) {\n                  case REACT_ELEMENT_TYPE:\n                  case REACT_PORTAL_TYPE:\n                    invokeCallback = true;\n                }\n            }\n          }\n          if (invokeCallback) {\n            var _child = children;\n            var mappedChild = callback(_child);\n            var childKey = nameSoFar === \"\" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n            if (isArray(mappedChild)) {\n              var escapedChildKey = \"\";\n              if (childKey != null) {\n                escapedChildKey = escapeUserProvidedKey(childKey) + \"/\";\n              }\n              mapIntoArray(mappedChild, array, escapedChildKey, \"\", function(c) {\n                return c;\n              });\n            } else if (mappedChild != null) {\n              if (isValidElement(mappedChild)) {\n                {\n                  if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n                    checkKeyStringCoercion(mappedChild.key);\n                  }\n                }\n                mappedChild = cloneAndReplaceKey(\n                  mappedChild,\n                  // Keep both the (mapped) and old keys if they differ, just as\n                  // traverseAllChildren used to do for objects as children\n                  escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n                  (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (\n                    // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    escapeUserProvidedKey(\"\" + mappedChild.key) + \"/\"\n                  ) : \"\") + childKey\n                );\n              }\n              array.push(mappedChild);\n            }\n            return 1;\n          }\n          var child;\n          var nextName;\n          var subtreeCount = 0;\n          var nextNamePrefix = nameSoFar === \"\" ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              child = children[i];\n              nextName = nextNamePrefix + getElementKey(child, i);\n              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n            }\n          } else {\n            var iteratorFn = getIteratorFn(children);\n            if (typeof iteratorFn === \"function\") {\n              var iterableChildren = children;\n              {\n                if (iteratorFn === iterableChildren.entries) {\n                  if (!didWarnAboutMaps) {\n                    warn(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\");\n                  }\n                  didWarnAboutMaps = true;\n                }\n              }\n              var iterator = iteratorFn.call(iterableChildren);\n              var step;\n              var ii = 0;\n              while (!(step = iterator.next()).done) {\n                child = step.value;\n                nextName = nextNamePrefix + getElementKey(child, ii++);\n                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n              }\n            } else if (type === \"object\") {\n              var childrenString = String(children);\n              throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === \"[object Object]\" ? \"object with keys {\" + Object.keys(children).join(\", \") + \"}\" : childrenString) + \"). If you meant to render a collection of children, use an array instead.\");\n            }\n          }\n          return subtreeCount;\n        }\n        function mapChildren(children, func, context) {\n          if (children == null) {\n            return children;\n          }\n          var result = [];\n          var count = 0;\n          mapIntoArray(children, result, \"\", \"\", function(child) {\n            return func.call(context, child, count++);\n          });\n          return result;\n        }\n        function countChildren(children) {\n          var n = 0;\n          mapChildren(children, function() {\n            n++;\n          });\n          return n;\n        }\n        function forEachChildren(children, forEachFunc, forEachContext) {\n          mapChildren(children, function() {\n            forEachFunc.apply(this, arguments);\n          }, forEachContext);\n        }\n        function toArray(children) {\n          return mapChildren(children, function(child) {\n            return child;\n          }) || [];\n        }\n        function onlyChild(children) {\n          if (!isValidElement(children)) {\n            throw new Error(\"React.Children.only expected to receive a single React element child.\");\n          }\n          return children;\n        }\n        function createContext(defaultValue) {\n          var context = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            // As a workaround to support multiple concurrent renderers, we categorize\n            // some renderers as primary and others as secondary. We only expect\n            // there to be two concurrent renderers at most: React Native (primary) and\n            // Fabric (secondary); React DOM (primary) and React ART (secondary).\n            // Secondary renderers store their context values on separate fields.\n            _currentValue: defaultValue,\n            _currentValue2: defaultValue,\n            // Used to track how many concurrent renderers this context currently\n            // supports within in a single renderer. Such as parallel server rendering.\n            _threadCount: 0,\n            // These are circular\n            Provider: null,\n            Consumer: null,\n            // Add these to use same hidden class in VM as ServerContext\n            _defaultValue: null,\n            _globalName: null\n          };\n          context.Provider = {\n            $$typeof: REACT_PROVIDER_TYPE,\n            _context: context\n          };\n          var hasWarnedAboutUsingNestedContextConsumers = false;\n          var hasWarnedAboutUsingConsumerProvider = false;\n          var hasWarnedAboutDisplayNameOnConsumer = false;\n          {\n            var Consumer = {\n              $$typeof: REACT_CONTEXT_TYPE,\n              _context: context\n            };\n            Object.defineProperties(Consumer, {\n              Provider: {\n                get: function() {\n                  if (!hasWarnedAboutUsingConsumerProvider) {\n                    hasWarnedAboutUsingConsumerProvider = true;\n                    error(\"Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?\");\n                  }\n                  return context.Provider;\n                },\n                set: function(_Provider) {\n                  context.Provider = _Provider;\n                }\n              },\n              _currentValue: {\n                get: function() {\n                  return context._currentValue;\n                },\n                set: function(_currentValue) {\n                  context._currentValue = _currentValue;\n                }\n              },\n              _currentValue2: {\n                get: function() {\n                  return context._currentValue2;\n                },\n                set: function(_currentValue2) {\n                  context._currentValue2 = _currentValue2;\n                }\n              },\n              _threadCount: {\n                get: function() {\n                  return context._threadCount;\n                },\n                set: function(_threadCount) {\n                  context._threadCount = _threadCount;\n                }\n              },\n              Consumer: {\n                get: function() {\n                  if (!hasWarnedAboutUsingNestedContextConsumers) {\n                    hasWarnedAboutUsingNestedContextConsumers = true;\n                    error(\"Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\");\n                  }\n                  return context.Consumer;\n                }\n              },\n              displayName: {\n                get: function() {\n                  return context.displayName;\n                },\n                set: function(displayName) {\n                  if (!hasWarnedAboutDisplayNameOnConsumer) {\n                    warn(\"Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n                    hasWarnedAboutDisplayNameOnConsumer = true;\n                  }\n                }\n              }\n            });\n            context.Consumer = Consumer;\n          }\n          {\n            context._currentRenderer = null;\n            context._currentRenderer2 = null;\n          }\n          return context;\n        }\n        var Uninitialized = -1;\n        var Pending = 0;\n        var Resolved = 1;\n        var Rejected = 2;\n        function lazyInitializer(payload) {\n          if (payload._status === Uninitialized) {\n            var ctor = payload._result;\n            var thenable = ctor();\n            thenable.then(function(moduleObject2) {\n              if (payload._status === Pending || payload._status === Uninitialized) {\n                var resolved = payload;\n                resolved._status = Resolved;\n                resolved._result = moduleObject2;\n              }\n            }, function(error2) {\n              if (payload._status === Pending || payload._status === Uninitialized) {\n                var rejected = payload;\n                rejected._status = Rejected;\n                rejected._result = error2;\n              }\n            });\n            if (payload._status === Uninitialized) {\n              var pending = payload;\n              pending._status = Pending;\n              pending._result = thenable;\n            }\n          }\n          if (payload._status === Resolved) {\n            var moduleObject = payload._result;\n            {\n              if (moduleObject === void 0) {\n                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\\n\\nDid you accidentally put curly braces around the import?\", moduleObject);\n              }\n            }\n            {\n              if (!(\"default\" in moduleObject)) {\n                error(\"lazy: Expected the result of a dynamic import() call. Instead received: %s\\n\\nYour code should look like: \\n  const MyComponent = lazy(() => import('./MyComponent'))\", moduleObject);\n              }\n            }\n            return moduleObject.default;\n          } else {\n            throw payload._result;\n          }\n        }\n        function lazy(ctor) {\n          var payload = {\n            // We use these fields to store the result.\n            _status: Uninitialized,\n            _result: ctor\n          };\n          var lazyType = {\n            $$typeof: REACT_LAZY_TYPE,\n            _payload: payload,\n            _init: lazyInitializer\n          };\n          {\n            var defaultProps;\n            var propTypes;\n            Object.defineProperties(lazyType, {\n              defaultProps: {\n                configurable: true,\n                get: function() {\n                  return defaultProps;\n                },\n                set: function(newDefaultProps) {\n                  error(\"React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\n                  defaultProps = newDefaultProps;\n                  Object.defineProperty(lazyType, \"defaultProps\", {\n                    enumerable: true\n                  });\n                }\n              },\n              propTypes: {\n                configurable: true,\n                get: function() {\n                  return propTypes;\n                },\n                set: function(newPropTypes) {\n                  error(\"React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.\");\n                  propTypes = newPropTypes;\n                  Object.defineProperty(lazyType, \"propTypes\", {\n                    enumerable: true\n                  });\n                }\n              }\n            });\n          }\n          return lazyType;\n        }\n        function forwardRef(render) {\n          {\n            if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n              error(\"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).\");\n            } else if (typeof render !== \"function\") {\n              error(\"forwardRef requires a render function but was given %s.\", render === null ? \"null\" : typeof render);\n            } else {\n              if (render.length !== 0 && render.length !== 2) {\n                error(\"forwardRef render functions accept exactly two parameters: props and ref. %s\", render.length === 1 ? \"Did you forget to use the ref parameter?\" : \"Any additional parameter will be undefined.\");\n              }\n            }\n            if (render != null) {\n              if (render.defaultProps != null || render.propTypes != null) {\n                error(\"forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?\");\n              }\n            }\n          }\n          var elementType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render\n          };\n          {\n            var ownName;\n            Object.defineProperty(elementType, \"displayName\", {\n              enumerable: false,\n              configurable: true,\n              get: function() {\n                return ownName;\n              },\n              set: function(name) {\n                ownName = name;\n                if (!render.name && !render.displayName) {\n                  render.displayName = name;\n                }\n              }\n            });\n          }\n          return elementType;\n        }\n        var REACT_MODULE_REFERENCE;\n        {\n          REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n            // types supported by any Flight configuration anywhere since\n            // we don't know which Flight build this will end up being used\n            // with.\n            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function memo(type, compare) {\n          {\n            if (!isValidElementType(type)) {\n              error(\"memo: The first argument must be a component. Instead received: %s\", type === null ? \"null\" : typeof type);\n            }\n          }\n          var elementType = {\n            $$typeof: REACT_MEMO_TYPE,\n            type,\n            compare: compare === void 0 ? null : compare\n          };\n          {\n            var ownName;\n            Object.defineProperty(elementType, \"displayName\", {\n              enumerable: false,\n              configurable: true,\n              get: function() {\n                return ownName;\n              },\n              set: function(name) {\n                ownName = name;\n                if (!type.name && !type.displayName) {\n                  type.displayName = name;\n                }\n              }\n            });\n          }\n          return elementType;\n        }\n        function resolveDispatcher() {\n          var dispatcher = ReactCurrentDispatcher.current;\n          {\n            if (dispatcher === null) {\n              error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n            }\n          }\n          return dispatcher;\n        }\n        function useContext(Context) {\n          var dispatcher = resolveDispatcher();\n          {\n            if (Context._context !== void 0) {\n              var realContext = Context._context;\n              if (realContext.Consumer === Context) {\n                error(\"Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?\");\n              } else if (realContext.Provider === Context) {\n                error(\"Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?\");\n              }\n            }\n          }\n          return dispatcher.useContext(Context);\n        }\n        function useState(initialState) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useState(initialState);\n        }\n        function useReducer(reducer, initialArg, init) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useReducer(reducer, initialArg, init);\n        }\n        function useRef(initialValue) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useRef(initialValue);\n        }\n        function useEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useEffect(create, deps);\n        }\n        function useInsertionEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useInsertionEffect(create, deps);\n        }\n        function useLayoutEffect(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useLayoutEffect(create, deps);\n        }\n        function useCallback(callback, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useCallback(callback, deps);\n        }\n        function useMemo(create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useMemo(create, deps);\n        }\n        function useImperativeHandle(ref, create, deps) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useImperativeHandle(ref, create, deps);\n        }\n        function useDebugValue(value, formatterFn) {\n          {\n            var dispatcher = resolveDispatcher();\n            return dispatcher.useDebugValue(value, formatterFn);\n          }\n        }\n        function useTransition() {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useTransition();\n        }\n        function useDeferredValue(value) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useDeferredValue(value);\n        }\n        function useId() {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useId();\n        }\n        function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var dispatcher = resolveDispatcher();\n          return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n        }\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher$1.current;\n            ReactCurrentDispatcher$1.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher$1.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component2) {\n          var prototype = Component2.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        function setCurrentlyValidatingElement$1(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              setExtraStackFrame(stack);\n            } else {\n              setExtraStackFrame(null);\n            }\n          }\n        }\n        var propTypesMisspellWarningShown;\n        {\n          propTypesMisspellWarningShown = false;\n        }\n        function getDeclarationErrorAddendum() {\n          if (ReactCurrentOwner.current) {\n            var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n            if (name) {\n              return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n            }\n          }\n          return \"\";\n        }\n        function getSourceInfoErrorAddendum(source) {\n          if (source !== void 0) {\n            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n            var lineNumber = source.lineNumber;\n            return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n          }\n          return \"\";\n        }\n        function getSourceInfoErrorAddendumForProps(elementProps) {\n          if (elementProps !== null && elementProps !== void 0) {\n            return getSourceInfoErrorAddendum(elementProps.__source);\n          }\n          return \"\";\n        }\n        var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n          var info = getDeclarationErrorAddendum();\n          if (!info) {\n            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n            if (parentName) {\n              info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n            }\n          }\n          return info;\n        }\n        function validateExplicitKey(element, parentType) {\n          if (!element._store || element._store.validated || element.key != null) {\n            return;\n          }\n          element._store.validated = true;\n          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n            return;\n          }\n          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n          var childOwner = \"\";\n          if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n            childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n          }\n          {\n            setCurrentlyValidatingElement$1(element);\n            error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n        function validateChildKeys(node, parentType) {\n          if (typeof node !== \"object\") {\n            return;\n          }\n          if (isArray(node)) {\n            for (var i = 0; i < node.length; i++) {\n              var child = node[i];\n              if (isValidElement(child)) {\n                validateExplicitKey(child, parentType);\n              }\n            }\n          } else if (isValidElement(node)) {\n            if (node._store) {\n              node._store.validated = true;\n            }\n          } else if (node) {\n            var iteratorFn = getIteratorFn(node);\n            if (typeof iteratorFn === \"function\") {\n              if (iteratorFn !== node.entries) {\n                var iterator = iteratorFn.call(node);\n                var step;\n                while (!(step = iterator.next()).done) {\n                  if (isValidElement(step.value)) {\n                    validateExplicitKey(step.value, parentType);\n                  }\n                }\n              }\n            }\n          }\n        }\n        function validatePropTypes(element) {\n          {\n            var type = element.type;\n            if (type === null || type === void 0 || typeof type === \"string\") {\n              return;\n            }\n            var propTypes;\n            if (typeof type === \"function\") {\n              propTypes = type.propTypes;\n            } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n            // Inner props are checked in the reconciler.\n            type.$$typeof === REACT_MEMO_TYPE)) {\n              propTypes = type.propTypes;\n            } else {\n              return;\n            }\n            if (propTypes) {\n              var name = getComponentNameFromType(type);\n              checkPropTypes(propTypes, element.props, \"prop\", name, element);\n            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n              propTypesMisspellWarningShown = true;\n              var _name = getComponentNameFromType(type);\n              error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n            }\n            if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n            }\n          }\n        }\n        function validateFragmentProps(fragment) {\n          {\n            var keys = Object.keys(fragment.props);\n            for (var i = 0; i < keys.length; i++) {\n              var key = keys[i];\n              if (key !== \"children\" && key !== \"key\") {\n                setCurrentlyValidatingElement$1(fragment);\n                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n                setCurrentlyValidatingElement$1(null);\n                break;\n              }\n            }\n            if (fragment.ref !== null) {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n              setCurrentlyValidatingElement$1(null);\n            }\n          }\n        }\n        function createElementWithValidation(type, props, children) {\n          var validType = isValidElementType(type);\n          if (!validType) {\n            var info = \"\";\n            if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n              info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n            }\n            var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n            if (sourceInfo) {\n              info += sourceInfo;\n            } else {\n              info += getDeclarationErrorAddendum();\n            }\n            var typeString;\n            if (type === null) {\n              typeString = \"null\";\n            } else if (isArray(type)) {\n              typeString = \"array\";\n            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n              typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n              info = \" Did you accidentally export a JSX literal instead of a component?\";\n            } else {\n              typeString = typeof type;\n            }\n            {\n              error(\"React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n            }\n          }\n          var element = createElement.apply(this, arguments);\n          if (element == null) {\n            return element;\n          }\n          if (validType) {\n            for (var i = 2; i < arguments.length; i++) {\n              validateChildKeys(arguments[i], type);\n            }\n          }\n          if (type === REACT_FRAGMENT_TYPE) {\n            validateFragmentProps(element);\n          } else {\n            validatePropTypes(element);\n          }\n          return element;\n        }\n        var didWarnAboutDeprecatedCreateFactory = false;\n        function createFactoryWithValidation(type) {\n          var validatedFactory = createElementWithValidation.bind(null, type);\n          validatedFactory.type = type;\n          {\n            if (!didWarnAboutDeprecatedCreateFactory) {\n              didWarnAboutDeprecatedCreateFactory = true;\n              warn(\"React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.\");\n            }\n            Object.defineProperty(validatedFactory, \"type\", {\n              enumerable: false,\n              get: function() {\n                warn(\"Factory.type is deprecated. Access the class directly before passing it to createFactory.\");\n                Object.defineProperty(this, \"type\", {\n                  value: type\n                });\n                return type;\n              }\n            });\n          }\n          return validatedFactory;\n        }\n        function cloneElementWithValidation(element, props, children) {\n          var newElement = cloneElement.apply(this, arguments);\n          for (var i = 2; i < arguments.length; i++) {\n            validateChildKeys(arguments[i], newElement.type);\n          }\n          validatePropTypes(newElement);\n          return newElement;\n        }\n        function startTransition(scope, options) {\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = {};\n          var currentTransition = ReactCurrentBatchConfig.transition;\n          {\n            ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();\n          }\n          try {\n            scope();\n          } finally {\n            ReactCurrentBatchConfig.transition = prevTransition;\n            {\n              if (prevTransition === null && currentTransition._updatedFibers) {\n                var updatedFibersCount = currentTransition._updatedFibers.size;\n                if (updatedFibersCount > 10) {\n                  warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\");\n                }\n                currentTransition._updatedFibers.clear();\n              }\n            }\n          }\n        }\n        var didWarnAboutMessageChannel = false;\n        var enqueueTaskImpl = null;\n        function enqueueTask(task) {\n          if (enqueueTaskImpl === null) {\n            try {\n              var requireString = (\"require\" + Math.random()).slice(0, 7);\n              var nodeRequire = module && module[requireString];\n              enqueueTaskImpl = nodeRequire.call(module, \"timers\").setImmediate;\n            } catch (_err) {\n              enqueueTaskImpl = function(callback) {\n                {\n                  if (didWarnAboutMessageChannel === false) {\n                    didWarnAboutMessageChannel = true;\n                    if (typeof MessageChannel === \"undefined\") {\n                      error(\"This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.\");\n                    }\n                  }\n                }\n                var channel = new MessageChannel();\n                channel.port1.onmessage = callback;\n                channel.port2.postMessage(void 0);\n              };\n            }\n          }\n          return enqueueTaskImpl(task);\n        }\n        var actScopeDepth = 0;\n        var didWarnNoAwaitAct = false;\n        function act(callback) {\n          {\n            var prevActScopeDepth = actScopeDepth;\n            actScopeDepth++;\n            if (ReactCurrentActQueue.current === null) {\n              ReactCurrentActQueue.current = [];\n            }\n            var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n            var result;\n            try {\n              ReactCurrentActQueue.isBatchingLegacy = true;\n              result = callback();\n              if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n                var queue = ReactCurrentActQueue.current;\n                if (queue !== null) {\n                  ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n                  flushActQueue(queue);\n                }\n              }\n            } catch (error2) {\n              popActScope(prevActScopeDepth);\n              throw error2;\n            } finally {\n              ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n            }\n            if (result !== null && typeof result === \"object\" && typeof result.then === \"function\") {\n              var thenableResult = result;\n              var wasAwaited = false;\n              var thenable = {\n                then: function(resolve, reject) {\n                  wasAwaited = true;\n                  thenableResult.then(function(returnValue2) {\n                    popActScope(prevActScopeDepth);\n                    if (actScopeDepth === 0) {\n                      recursivelyFlushAsyncActWork(returnValue2, resolve, reject);\n                    } else {\n                      resolve(returnValue2);\n                    }\n                  }, function(error2) {\n                    popActScope(prevActScopeDepth);\n                    reject(error2);\n                  });\n                }\n              };\n              {\n                if (!didWarnNoAwaitAct && typeof Promise !== \"undefined\") {\n                  Promise.resolve().then(function() {\n                  }).then(function() {\n                    if (!wasAwaited) {\n                      didWarnNoAwaitAct = true;\n                      error(\"You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);\");\n                    }\n                  });\n                }\n              }\n              return thenable;\n            } else {\n              var returnValue = result;\n              popActScope(prevActScopeDepth);\n              if (actScopeDepth === 0) {\n                var _queue = ReactCurrentActQueue.current;\n                if (_queue !== null) {\n                  flushActQueue(_queue);\n                  ReactCurrentActQueue.current = null;\n                }\n                var _thenable = {\n                  then: function(resolve, reject) {\n                    if (ReactCurrentActQueue.current === null) {\n                      ReactCurrentActQueue.current = [];\n                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                    } else {\n                      resolve(returnValue);\n                    }\n                  }\n                };\n                return _thenable;\n              } else {\n                var _thenable2 = {\n                  then: function(resolve, reject) {\n                    resolve(returnValue);\n                  }\n                };\n                return _thenable2;\n              }\n            }\n          }\n        }\n        function popActScope(prevActScopeDepth) {\n          {\n            if (prevActScopeDepth !== actScopeDepth - 1) {\n              error(\"You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. \");\n            }\n            actScopeDepth = prevActScopeDepth;\n          }\n        }\n        function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n          {\n            var queue = ReactCurrentActQueue.current;\n            if (queue !== null) {\n              try {\n                flushActQueue(queue);\n                enqueueTask(function() {\n                  if (queue.length === 0) {\n                    ReactCurrentActQueue.current = null;\n                    resolve(returnValue);\n                  } else {\n                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n                  }\n                });\n              } catch (error2) {\n                reject(error2);\n              }\n            } else {\n              resolve(returnValue);\n            }\n          }\n        }\n        var isFlushing = false;\n        function flushActQueue(queue) {\n          {\n            if (!isFlushing) {\n              isFlushing = true;\n              var i = 0;\n              try {\n                for (; i < queue.length; i++) {\n                  var callback = queue[i];\n                  do {\n                    callback = callback(true);\n                  } while (callback !== null);\n                }\n                queue.length = 0;\n              } catch (error2) {\n                queue = queue.slice(i + 1);\n                throw error2;\n              } finally {\n                isFlushing = false;\n              }\n            }\n          }\n        }\n        var createElement$1 = createElementWithValidation;\n        var cloneElement$1 = cloneElementWithValidation;\n        var createFactory = createFactoryWithValidation;\n        var Children = {\n          map: mapChildren,\n          forEach: forEachChildren,\n          count: countChildren,\n          toArray,\n          only: onlyChild\n        };\n        exports.Children = Children;\n        exports.Component = Component;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.Profiler = REACT_PROFILER_TYPE;\n        exports.PureComponent = PureComponent;\n        exports.StrictMode = REACT_STRICT_MODE_TYPE;\n        exports.Suspense = REACT_SUSPENSE_TYPE;\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n        exports.act = act;\n        exports.cloneElement = cloneElement$1;\n        exports.createContext = createContext;\n        exports.createElement = createElement$1;\n        exports.createFactory = createFactory;\n        exports.createRef = createRef;\n        exports.forwardRef = forwardRef;\n        exports.isValidElement = isValidElement;\n        exports.lazy = lazy;\n        exports.memo = memo;\n        exports.startTransition = startTransition;\n        exports.unstable_act = act;\n        exports.useCallback = useCallback;\n        exports.useContext = useContext;\n        exports.useDebugValue = useDebugValue;\n        exports.useDeferredValue = useDeferredValue;\n        exports.useEffect = useEffect;\n        exports.useId = useId;\n        exports.useImperativeHandle = useImperativeHandle;\n        exports.useInsertionEffect = useInsertionEffect;\n        exports.useLayoutEffect = useLayoutEffect;\n        exports.useMemo = useMemo;\n        exports.useReducer = useReducer;\n        exports.useRef = useRef;\n        exports.useState = useState;\n        exports.useSyncExternalStore = useSyncExternalStore;\n        exports.useTransition = useTransition;\n        exports.version = ReactVersion;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/react/index.js\nvar require_react = __commonJS({\n  \"node_modules/react/index.js\"(exports, module) {\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_react_development();\n    }\n  }\n});\n\nexport {\n  require_react\n};\n/*! Bundled license information:\n\nreact/cjs/react.development.js:\n  (**\n   * @license React\n   * react.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n//# sourceMappingURL=chunk-RLJ2RCJQ.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.684Z",
        "time": 5.380000002332963,
        "timings": {
          "blocked": 4.3640000010174695,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.2840000008898787,
          "receive": 0.7320000004256144,
          "_blocked_queueing": 4.28000000101747,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed",
          "lineNumber": 5
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "1830"
            },
            {
              "name": "Etag",
              "value": "W/\"726-MpnTNQme1mPJU5N20sIRb5PRDAQ\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 1830,
            "mimeType": "text/javascript",
            "text": "var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\nexport {\n  __commonJS,\n  __export,\n  __toESM,\n  __publicField\n};\n//# sourceMappingURL=chunk-DC5AMYBS.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.684Z",
        "time": 6.864999999379506,
        "timings": {
          "blocked": 6.529999998908956,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.15200000036414713,
          "receive": 0.1830000001064036,
          "_blocked_queueing": 6.465999998908956,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-dom_client.js?v=2a7591ed",
          "lineNumber": 2
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-dom_client.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "928147"
            },
            {
              "name": "Etag",
              "value": "W/\"e2993-udGBaA5NaSpf2wNl6m19lu4G2Vg\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 928147,
            "mimeType": "text/javascript",
            "text": "import {\n  require_react\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-RLJ2RCJQ.js?v=2a7591ed\";\nimport {\n  __commonJS\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/scheduler/cjs/scheduler.development.js\nvar require_scheduler_development = __commonJS({\n  \"node_modules/scheduler/cjs/scheduler.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n          var index = heap.length;\n          heap.push(node);\n          siftUp(heap, node, index);\n        }\n        function peek(heap) {\n          return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n          if (heap.length === 0) {\n            return null;\n          }\n          var first = heap[0];\n          var last = heap.pop();\n          if (last !== first) {\n            heap[0] = last;\n            siftDown(heap, last, 0);\n          }\n          return first;\n        }\n        function siftUp(heap, node, i) {\n          var index = i;\n          while (index > 0) {\n            var parentIndex = index - 1 >>> 1;\n            var parent = heap[parentIndex];\n            if (compare(parent, node) > 0) {\n              heap[parentIndex] = node;\n              heap[index] = parent;\n              index = parentIndex;\n            } else {\n              return;\n            }\n          }\n        }\n        function siftDown(heap, node, i) {\n          var index = i;\n          var length = heap.length;\n          var halfLength = length >>> 1;\n          while (index < halfLength) {\n            var leftIndex = (index + 1) * 2 - 1;\n            var left = heap[leftIndex];\n            var rightIndex = leftIndex + 1;\n            var right = heap[rightIndex];\n            if (compare(left, node) < 0) {\n              if (rightIndex < length && compare(right, left) < 0) {\n                heap[index] = right;\n                heap[rightIndex] = node;\n                index = rightIndex;\n              } else {\n                heap[index] = left;\n                heap[leftIndex] = node;\n                index = leftIndex;\n              }\n            } else if (rightIndex < length && compare(right, node) < 0) {\n              heap[index] = right;\n              heap[rightIndex] = node;\n              index = rightIndex;\n            } else {\n              return;\n            }\n          }\n        }\n        function compare(a, b) {\n          var diff = a.sortIndex - b.sortIndex;\n          return diff !== 0 ? diff : a.id - b.id;\n        }\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {\n        }\n        var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n          var localPerformance = performance;\n          exports.unstable_now = function() {\n            return localPerformance.now();\n          };\n        } else {\n          var localDate = Date;\n          var initialTime = localDate.now();\n          exports.unstable_now = function() {\n            return localDate.now() - initialTime;\n          };\n        }\n        var maxSigned31BitInt = 1073741823;\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1;\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5e3;\n        var LOW_PRIORITY_TIMEOUT = 1e4;\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;\n        var taskQueue = [];\n        var timerQueue = [];\n        var taskIdCounter = 1;\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority;\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false;\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null;\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n          var timer = peek(timerQueue);\n          while (timer !== null) {\n            if (timer.callback === null) {\n              pop(timerQueue);\n            } else if (timer.startTime <= currentTime) {\n              pop(timerQueue);\n              timer.sortIndex = timer.expirationTime;\n              push(taskQueue, timer);\n            } else {\n              return;\n            }\n            timer = peek(timerQueue);\n          }\n        }\n        function handleTimeout(currentTime) {\n          isHostTimeoutScheduled = false;\n          advanceTimers(currentTime);\n          if (!isHostCallbackScheduled) {\n            if (peek(taskQueue) !== null) {\n              isHostCallbackScheduled = true;\n              requestHostCallback(flushWork);\n            } else {\n              var firstTimer = peek(timerQueue);\n              if (firstTimer !== null) {\n                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n              }\n            }\n          }\n        }\n        function flushWork(hasTimeRemaining, initialTime2) {\n          isHostCallbackScheduled = false;\n          if (isHostTimeoutScheduled) {\n            isHostTimeoutScheduled = false;\n            cancelHostTimeout();\n          }\n          isPerformingWork = true;\n          var previousPriorityLevel = currentPriorityLevel;\n          try {\n            if (enableProfiling) {\n              try {\n                return workLoop(hasTimeRemaining, initialTime2);\n              } catch (error) {\n                if (currentTask !== null) {\n                  var currentTime = exports.unstable_now();\n                  markTaskErrored(currentTask, currentTime);\n                  currentTask.isQueued = false;\n                }\n                throw error;\n              }\n            } else {\n              return workLoop(hasTimeRemaining, initialTime2);\n            }\n          } finally {\n            currentTask = null;\n            currentPriorityLevel = previousPriorityLevel;\n            isPerformingWork = false;\n          }\n        }\n        function workLoop(hasTimeRemaining, initialTime2) {\n          var currentTime = initialTime2;\n          advanceTimers(currentTime);\n          currentTask = peek(taskQueue);\n          while (currentTask !== null && !enableSchedulerDebugging) {\n            if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n              break;\n            }\n            var callback = currentTask.callback;\n            if (typeof callback === \"function\") {\n              currentTask.callback = null;\n              currentPriorityLevel = currentTask.priorityLevel;\n              var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n              var continuationCallback = callback(didUserCallbackTimeout);\n              currentTime = exports.unstable_now();\n              if (typeof continuationCallback === \"function\") {\n                currentTask.callback = continuationCallback;\n              } else {\n                if (currentTask === peek(taskQueue)) {\n                  pop(taskQueue);\n                }\n              }\n              advanceTimers(currentTime);\n            } else {\n              pop(taskQueue);\n            }\n            currentTask = peek(taskQueue);\n          }\n          if (currentTask !== null) {\n            return true;\n          } else {\n            var firstTimer = peek(timerQueue);\n            if (firstTimer !== null) {\n              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n            }\n            return false;\n          }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n          switch (priorityLevel) {\n            case ImmediatePriority:\n            case UserBlockingPriority:\n            case NormalPriority:\n            case LowPriority:\n            case IdlePriority:\n              break;\n            default:\n              priorityLevel = NormalPriority;\n          }\n          var previousPriorityLevel = currentPriorityLevel;\n          currentPriorityLevel = priorityLevel;\n          try {\n            return eventHandler();\n          } finally {\n            currentPriorityLevel = previousPriorityLevel;\n          }\n        }\n        function unstable_next(eventHandler) {\n          var priorityLevel;\n          switch (currentPriorityLevel) {\n            case ImmediatePriority:\n            case UserBlockingPriority:\n            case NormalPriority:\n              priorityLevel = NormalPriority;\n              break;\n            default:\n              priorityLevel = currentPriorityLevel;\n              break;\n          }\n          var previousPriorityLevel = currentPriorityLevel;\n          currentPriorityLevel = priorityLevel;\n          try {\n            return eventHandler();\n          } finally {\n            currentPriorityLevel = previousPriorityLevel;\n          }\n        }\n        function unstable_wrapCallback(callback) {\n          var parentPriorityLevel = currentPriorityLevel;\n          return function() {\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = parentPriorityLevel;\n            try {\n              return callback.apply(this, arguments);\n            } finally {\n              currentPriorityLevel = previousPriorityLevel;\n            }\n          };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n          var currentTime = exports.unstable_now();\n          var startTime2;\n          if (typeof options === \"object\" && options !== null) {\n            var delay = options.delay;\n            if (typeof delay === \"number\" && delay > 0) {\n              startTime2 = currentTime + delay;\n            } else {\n              startTime2 = currentTime;\n            }\n          } else {\n            startTime2 = currentTime;\n          }\n          var timeout;\n          switch (priorityLevel) {\n            case ImmediatePriority:\n              timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n              break;\n            case UserBlockingPriority:\n              timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n              break;\n            case IdlePriority:\n              timeout = IDLE_PRIORITY_TIMEOUT;\n              break;\n            case LowPriority:\n              timeout = LOW_PRIORITY_TIMEOUT;\n              break;\n            case NormalPriority:\n            default:\n              timeout = NORMAL_PRIORITY_TIMEOUT;\n              break;\n          }\n          var expirationTime = startTime2 + timeout;\n          var newTask = {\n            id: taskIdCounter++,\n            callback,\n            priorityLevel,\n            startTime: startTime2,\n            expirationTime,\n            sortIndex: -1\n          };\n          if (startTime2 > currentTime) {\n            newTask.sortIndex = startTime2;\n            push(timerQueue, newTask);\n            if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n              if (isHostTimeoutScheduled) {\n                cancelHostTimeout();\n              } else {\n                isHostTimeoutScheduled = true;\n              }\n              requestHostTimeout(handleTimeout, startTime2 - currentTime);\n            }\n          } else {\n            newTask.sortIndex = expirationTime;\n            push(taskQueue, newTask);\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n              isHostCallbackScheduled = true;\n              requestHostCallback(flushWork);\n            }\n          }\n          return newTask;\n        }\n        function unstable_pauseExecution() {\n        }\n        function unstable_continueExecution() {\n          if (!isHostCallbackScheduled && !isPerformingWork) {\n            isHostCallbackScheduled = true;\n            requestHostCallback(flushWork);\n          }\n        }\n        function unstable_getFirstCallbackNode() {\n          return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n          task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n          return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1;\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n          var timeElapsed = exports.unstable_now() - startTime;\n          if (timeElapsed < frameInterval) {\n            return false;\n          }\n          return true;\n        }\n        function requestPaint() {\n        }\n        function forceFrameRate(fps) {\n          if (fps < 0 || fps > 125) {\n            console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\");\n            return;\n          }\n          if (fps > 0) {\n            frameInterval = Math.floor(1e3 / fps);\n          } else {\n            frameInterval = frameYieldMs;\n          }\n        }\n        var performWorkUntilDeadline = function() {\n          if (scheduledHostCallback !== null) {\n            var currentTime = exports.unstable_now();\n            startTime = currentTime;\n            var hasTimeRemaining = true;\n            var hasMoreWork = true;\n            try {\n              hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n            } finally {\n              if (hasMoreWork) {\n                schedulePerformWorkUntilDeadline();\n              } else {\n                isMessageLoopRunning = false;\n                scheduledHostCallback = null;\n              }\n            }\n          } else {\n            isMessageLoopRunning = false;\n          }\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n          schedulePerformWorkUntilDeadline = function() {\n            localSetImmediate(performWorkUntilDeadline);\n          };\n        } else if (typeof MessageChannel !== \"undefined\") {\n          var channel = new MessageChannel();\n          var port = channel.port2;\n          channel.port1.onmessage = performWorkUntilDeadline;\n          schedulePerformWorkUntilDeadline = function() {\n            port.postMessage(null);\n          };\n        } else {\n          schedulePerformWorkUntilDeadline = function() {\n            localSetTimeout(performWorkUntilDeadline, 0);\n          };\n        }\n        function requestHostCallback(callback) {\n          scheduledHostCallback = callback;\n          if (!isMessageLoopRunning) {\n            isMessageLoopRunning = true;\n            schedulePerformWorkUntilDeadline();\n          }\n        }\n        function requestHostTimeout(callback, ms) {\n          taskTimeoutID = localSetTimeout(function() {\n            callback(exports.unstable_now());\n          }, ms);\n        }\n        function cancelHostTimeout() {\n          localClearTimeout(taskTimeoutID);\n          taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/scheduler/index.js\nvar require_scheduler = __commonJS({\n  \"node_modules/scheduler/index.js\"(exports, module) {\n    \"use strict\";\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_scheduler_development();\n    }\n  }\n});\n\n// node_modules/react-dom/cjs/react-dom.development.js\nvar require_react_dom_development = __commonJS({\n  \"node_modules/react-dom/cjs/react-dom.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var React = require_react();\n        var Scheduler = require_scheduler();\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n          {\n            suppressWarning = newSuppressWarning;\n          }\n        }\n        function warn(format) {\n          {\n            if (!suppressWarning) {\n              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n              }\n              printWarning(\"warn\", format, args);\n            }\n          }\n        }\n        function error(format) {\n          {\n            if (!suppressWarning) {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var IndeterminateComponent = 2;\n        var HostRoot = 3;\n        var HostPortal = 4;\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        var enableClientRenderFallbackOnTextMismatch = true;\n        var enableNewReconciler = false;\n        var enableLazyContextPropagation = false;\n        var enableLegacyHidden = false;\n        var enableSuspenseAvoidThisFallback = false;\n        var disableCommentsAsDOMContainers = true;\n        var enableCustomElementPropertySupport = false;\n        var warnAboutStringRefs = true;\n        var enableSchedulingProfiler = true;\n        var enableProfilerTimer = true;\n        var enableProfilerCommitHooks = true;\n        var allNativeEvents = /* @__PURE__ */ new Set();\n        var registrationNameDependencies = {};\n        var possibleRegistrationNames = {};\n        function registerTwoPhaseEvent(registrationName, dependencies) {\n          registerDirectEvent(registrationName, dependencies);\n          registerDirectEvent(registrationName + \"Capture\", dependencies);\n        }\n        function registerDirectEvent(registrationName, dependencies) {\n          {\n            if (registrationNameDependencies[registrationName]) {\n              error(\"EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.\", registrationName);\n            }\n          }\n          registrationNameDependencies[registrationName] = dependencies;\n          {\n            var lowerCasedName = registrationName.toLowerCase();\n            possibleRegistrationNames[lowerCasedName] = registrationName;\n            if (registrationName === \"onDoubleClick\") {\n              possibleRegistrationNames.ondblclick = registrationName;\n            }\n          }\n          for (var i = 0; i < dependencies.length; i++) {\n            allNativeEvents.add(dependencies[i]);\n          }\n        }\n        var canUseDOM = !!(typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\");\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkAttributeStringCoercion(value, attributeName) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.\", attributeName, typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkPropStringCoercion(value, propName) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.\", propName, typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkCSSPropertyStringCoercion(value, propName) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.\", propName, typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkHtmlStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        function checkFormFieldValueStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        var RESERVED = 0;\n        var STRING = 1;\n        var BOOLEANISH_STRING = 2;\n        var BOOLEAN = 3;\n        var OVERLOADED_BOOLEAN = 4;\n        var NUMERIC = 5;\n        var POSITIVE_NUMERIC = 6;\n        var ATTRIBUTE_NAME_START_CHAR = \":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";\n        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + \"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";\n        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp(\"^[\" + ATTRIBUTE_NAME_START_CHAR + \"][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var illegalAttributeNameCache = {};\n        var validatedAttributeNameCache = {};\n        function isAttributeNameSafe(attributeName) {\n          if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {\n            return true;\n          }\n          if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {\n            return false;\n          }\n          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {\n            validatedAttributeNameCache[attributeName] = true;\n            return true;\n          }\n          illegalAttributeNameCache[attributeName] = true;\n          {\n            error(\"Invalid attribute name: `%s`\", attributeName);\n          }\n          return false;\n        }\n        function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {\n          if (propertyInfo !== null) {\n            return propertyInfo.type === RESERVED;\n          }\n          if (isCustomComponentTag) {\n            return false;\n          }\n          if (name.length > 2 && (name[0] === \"o\" || name[0] === \"O\") && (name[1] === \"n\" || name[1] === \"N\")) {\n            return true;\n          }\n          return false;\n        }\n        function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {\n          if (propertyInfo !== null && propertyInfo.type === RESERVED) {\n            return false;\n          }\n          switch (typeof value) {\n            case \"function\":\n            case \"symbol\":\n              return true;\n            case \"boolean\": {\n              if (isCustomComponentTag) {\n                return false;\n              }\n              if (propertyInfo !== null) {\n                return !propertyInfo.acceptsBooleans;\n              } else {\n                var prefix2 = name.toLowerCase().slice(0, 5);\n                return prefix2 !== \"data-\" && prefix2 !== \"aria-\";\n              }\n            }\n            default:\n              return false;\n          }\n        }\n        function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {\n          if (value === null || typeof value === \"undefined\") {\n            return true;\n          }\n          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {\n            return true;\n          }\n          if (isCustomComponentTag) {\n            return false;\n          }\n          if (propertyInfo !== null) {\n            switch (propertyInfo.type) {\n              case BOOLEAN:\n                return !value;\n              case OVERLOADED_BOOLEAN:\n                return value === false;\n              case NUMERIC:\n                return isNaN(value);\n              case POSITIVE_NUMERIC:\n                return isNaN(value) || value < 1;\n            }\n          }\n          return false;\n        }\n        function getPropertyInfo(name) {\n          return properties.hasOwnProperty(name) ? properties[name] : null;\n        }\n        function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {\n          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;\n          this.attributeName = attributeName;\n          this.attributeNamespace = attributeNamespace;\n          this.mustUseProperty = mustUseProperty;\n          this.propertyName = name;\n          this.type = type;\n          this.sanitizeURL = sanitizeURL2;\n          this.removeEmptyString = removeEmptyString;\n        }\n        var properties = {};\n        var reservedProps = [\n          \"children\",\n          \"dangerouslySetInnerHTML\",\n          // TODO: This prevents the assignment of defaultValue to regular\n          // elements (not just inputs). Now that ReactDOMInput assigns to the\n          // defaultValue property -- do we need this?\n          \"defaultValue\",\n          \"defaultChecked\",\n          \"innerHTML\",\n          \"suppressContentEditableWarning\",\n          \"suppressHydrationWarning\",\n          \"style\"\n        ];\n        reservedProps.forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            RESERVED,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [[\"acceptCharset\", \"accept-charset\"], [\"className\", \"class\"], [\"htmlFor\", \"for\"], [\"httpEquiv\", \"http-equiv\"]].forEach(function(_ref) {\n          var name = _ref[0], attributeName = _ref[1];\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"contentEditable\", \"draggable\", \"spellCheck\", \"value\"].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEANISH_STRING,\n            false,\n            // mustUseProperty\n            name.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"autoReverse\", \"externalResourcesRequired\", \"focusable\", \"preserveAlpha\"].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEANISH_STRING,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"allowFullScreen\",\n          \"async\",\n          // Note: there is a special case that prevents it from being written to the DOM\n          // on the client side because the browsers are inconsistent. Instead we call focus().\n          \"autoFocus\",\n          \"autoPlay\",\n          \"controls\",\n          \"default\",\n          \"defer\",\n          \"disabled\",\n          \"disablePictureInPicture\",\n          \"disableRemotePlayback\",\n          \"formNoValidate\",\n          \"hidden\",\n          \"loop\",\n          \"noModule\",\n          \"noValidate\",\n          \"open\",\n          \"playsInline\",\n          \"readOnly\",\n          \"required\",\n          \"reversed\",\n          \"scoped\",\n          \"seamless\",\n          // Microdata\n          \"itemScope\"\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEAN,\n            false,\n            // mustUseProperty\n            name.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"checked\",\n          // Note: `option.selected` is not updated if `select.multiple` is\n          // disabled with `removeAttribute`. We have special logic for handling this.\n          \"multiple\",\n          \"muted\",\n          \"selected\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            BOOLEAN,\n            true,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"capture\",\n          \"download\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            OVERLOADED_BOOLEAN,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"cols\",\n          \"rows\",\n          \"size\",\n          \"span\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            POSITIVE_NUMERIC,\n            false,\n            // mustUseProperty\n            name,\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"rowSpan\", \"start\"].forEach(function(name) {\n          properties[name] = new PropertyInfoRecord(\n            name,\n            NUMERIC,\n            false,\n            // mustUseProperty\n            name.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        var CAMELIZE = /[\\-\\:]([a-z])/g;\n        var capitalize = function(token) {\n          return token[1].toUpperCase();\n        };\n        [\n          \"accent-height\",\n          \"alignment-baseline\",\n          \"arabic-form\",\n          \"baseline-shift\",\n          \"cap-height\",\n          \"clip-path\",\n          \"clip-rule\",\n          \"color-interpolation\",\n          \"color-interpolation-filters\",\n          \"color-profile\",\n          \"color-rendering\",\n          \"dominant-baseline\",\n          \"enable-background\",\n          \"fill-opacity\",\n          \"fill-rule\",\n          \"flood-color\",\n          \"flood-opacity\",\n          \"font-family\",\n          \"font-size\",\n          \"font-size-adjust\",\n          \"font-stretch\",\n          \"font-style\",\n          \"font-variant\",\n          \"font-weight\",\n          \"glyph-name\",\n          \"glyph-orientation-horizontal\",\n          \"glyph-orientation-vertical\",\n          \"horiz-adv-x\",\n          \"horiz-origin-x\",\n          \"image-rendering\",\n          \"letter-spacing\",\n          \"lighting-color\",\n          \"marker-end\",\n          \"marker-mid\",\n          \"marker-start\",\n          \"overline-position\",\n          \"overline-thickness\",\n          \"paint-order\",\n          \"panose-1\",\n          \"pointer-events\",\n          \"rendering-intent\",\n          \"shape-rendering\",\n          \"stop-color\",\n          \"stop-opacity\",\n          \"strikethrough-position\",\n          \"strikethrough-thickness\",\n          \"stroke-dasharray\",\n          \"stroke-dashoffset\",\n          \"stroke-linecap\",\n          \"stroke-linejoin\",\n          \"stroke-miterlimit\",\n          \"stroke-opacity\",\n          \"stroke-width\",\n          \"text-anchor\",\n          \"text-decoration\",\n          \"text-rendering\",\n          \"underline-position\",\n          \"underline-thickness\",\n          \"unicode-bidi\",\n          \"unicode-range\",\n          \"units-per-em\",\n          \"v-alphabetic\",\n          \"v-hanging\",\n          \"v-ideographic\",\n          \"v-mathematical\",\n          \"vector-effect\",\n          \"vert-adv-y\",\n          \"vert-origin-x\",\n          \"vert-origin-y\",\n          \"word-spacing\",\n          \"writing-mode\",\n          \"xmlns:xlink\",\n          \"x-height\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(attributeName) {\n          var name = attributeName.replace(CAMELIZE, capitalize);\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"xlink:actuate\",\n          \"xlink:arcrole\",\n          \"xlink:role\",\n          \"xlink:show\",\n          \"xlink:title\",\n          \"xlink:type\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(attributeName) {\n          var name = attributeName.replace(CAMELIZE, capitalize);\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            \"http://www.w3.org/1999/xlink\",\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\n          \"xml:base\",\n          \"xml:lang\",\n          \"xml:space\"\n          // NOTE: if you add a camelCased prop to this list,\n          // you'll need to set attributeName to name.toLowerCase()\n          // instead in the assignment below.\n        ].forEach(function(attributeName) {\n          var name = attributeName.replace(CAMELIZE, capitalize);\n          properties[name] = new PropertyInfoRecord(\n            name,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName,\n            \"http://www.w3.org/XML/1998/namespace\",\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        [\"tabIndex\", \"crossOrigin\"].forEach(function(attributeName) {\n          properties[attributeName] = new PropertyInfoRecord(\n            attributeName,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            false,\n            // sanitizeURL\n            false\n          );\n        });\n        var xlinkHref = \"xlinkHref\";\n        properties[xlinkHref] = new PropertyInfoRecord(\n          \"xlinkHref\",\n          STRING,\n          false,\n          // mustUseProperty\n          \"xlink:href\",\n          \"http://www.w3.org/1999/xlink\",\n          true,\n          // sanitizeURL\n          false\n        );\n        [\"src\", \"href\", \"action\", \"formAction\"].forEach(function(attributeName) {\n          properties[attributeName] = new PropertyInfoRecord(\n            attributeName,\n            STRING,\n            false,\n            // mustUseProperty\n            attributeName.toLowerCase(),\n            // attributeName\n            null,\n            // attributeNamespace\n            true,\n            // sanitizeURL\n            true\n          );\n        });\n        var isJavaScriptProtocol = /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n        var didWarn = false;\n        function sanitizeURL(url) {\n          {\n            if (!didWarn && isJavaScriptProtocol.test(url)) {\n              didWarn = true;\n              error(\"A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.\", JSON.stringify(url));\n            }\n          }\n        }\n        function getValueForProperty(node, name, expected, propertyInfo) {\n          {\n            if (propertyInfo.mustUseProperty) {\n              var propertyName = propertyInfo.propertyName;\n              return node[propertyName];\n            } else {\n              {\n                checkAttributeStringCoercion(expected, name);\n              }\n              if (propertyInfo.sanitizeURL) {\n                sanitizeURL(\"\" + expected);\n              }\n              var attributeName = propertyInfo.attributeName;\n              var stringValue = null;\n              if (propertyInfo.type === OVERLOADED_BOOLEAN) {\n                if (node.hasAttribute(attributeName)) {\n                  var value = node.getAttribute(attributeName);\n                  if (value === \"\") {\n                    return true;\n                  }\n                  if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                    return value;\n                  }\n                  if (value === \"\" + expected) {\n                    return expected;\n                  }\n                  return value;\n                }\n              } else if (node.hasAttribute(attributeName)) {\n                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                  return node.getAttribute(attributeName);\n                }\n                if (propertyInfo.type === BOOLEAN) {\n                  return expected;\n                }\n                stringValue = node.getAttribute(attributeName);\n              }\n              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {\n                return stringValue === null ? expected : stringValue;\n              } else if (stringValue === \"\" + expected) {\n                return expected;\n              } else {\n                return stringValue;\n              }\n            }\n          }\n        }\n        function getValueForAttribute(node, name, expected, isCustomComponentTag) {\n          {\n            if (!isAttributeNameSafe(name)) {\n              return;\n            }\n            if (!node.hasAttribute(name)) {\n              return expected === void 0 ? void 0 : null;\n            }\n            var value = node.getAttribute(name);\n            {\n              checkAttributeStringCoercion(expected, name);\n            }\n            if (value === \"\" + expected) {\n              return expected;\n            }\n            return value;\n          }\n        }\n        function setValueForProperty(node, name, value, isCustomComponentTag) {\n          var propertyInfo = getPropertyInfo(name);\n          if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {\n            return;\n          }\n          if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {\n            value = null;\n          }\n          if (isCustomComponentTag || propertyInfo === null) {\n            if (isAttributeNameSafe(name)) {\n              var _attributeName = name;\n              if (value === null) {\n                node.removeAttribute(_attributeName);\n              } else {\n                {\n                  checkAttributeStringCoercion(value, name);\n                }\n                node.setAttribute(_attributeName, \"\" + value);\n              }\n            }\n            return;\n          }\n          var mustUseProperty = propertyInfo.mustUseProperty;\n          if (mustUseProperty) {\n            var propertyName = propertyInfo.propertyName;\n            if (value === null) {\n              var type = propertyInfo.type;\n              node[propertyName] = type === BOOLEAN ? false : \"\";\n            } else {\n              node[propertyName] = value;\n            }\n            return;\n          }\n          var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;\n          if (value === null) {\n            node.removeAttribute(attributeName);\n          } else {\n            var _type = propertyInfo.type;\n            var attributeValue;\n            if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {\n              attributeValue = \"\";\n            } else {\n              {\n                {\n                  checkAttributeStringCoercion(value, attributeName);\n                }\n                attributeValue = \"\" + value;\n              }\n              if (propertyInfo.sanitizeURL) {\n                sanitizeURL(attributeValue.toString());\n              }\n            }\n            if (attributeNamespace) {\n              node.setAttributeNS(attributeNamespace, attributeName, attributeValue);\n            } else {\n              node.setAttribute(attributeName, attributeValue);\n            }\n          }\n        }\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_SCOPE_TYPE = Symbol.for(\"react.scope\");\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for(\"react.debug_trace_mode\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for(\"react.legacy_hidden\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var REACT_TRACING_MARKER_TYPE = Symbol.for(\"react.tracing_marker\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var assign = Object.assign;\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(ctor, true);\n          }\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        function describeFiber(fiber) {\n          var owner = fiber._debugOwner ? fiber._debugOwner.type : null;\n          var source = fiber._debugSource;\n          switch (fiber.tag) {\n            case HostComponent:\n              return describeBuiltInComponentFrame(fiber.type);\n            case LazyComponent:\n              return describeBuiltInComponentFrame(\"Lazy\");\n            case SuspenseComponent:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case SuspenseListComponent:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n            case FunctionComponent:\n            case IndeterminateComponent:\n            case SimpleMemoComponent:\n              return describeFunctionComponentFrame(fiber.type);\n            case ForwardRef:\n              return describeFunctionComponentFrame(fiber.type.render);\n            case ClassComponent:\n              return describeClassComponentFrame(fiber.type);\n            default:\n              return \"\";\n          }\n        }\n        function getStackByFiberInDevAndProd(workInProgress2) {\n          try {\n            var info = \"\";\n            var node = workInProgress2;\n            do {\n              info += describeFiber(node);\n              node = node.return;\n            } while (node);\n            return info;\n          } catch (x) {\n            return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n          }\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return outerType.displayName || (functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        }\n        function getContextName$1(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromFiber(fiber) {\n          var tag = fiber.tag, type = fiber.type;\n          switch (tag) {\n            case CacheComponent:\n              return \"Cache\";\n            case ContextConsumer:\n              var context = type;\n              return getContextName$1(context) + \".Consumer\";\n            case ContextProvider:\n              var provider = type;\n              return getContextName$1(provider._context) + \".Provider\";\n            case DehydratedFragment:\n              return \"DehydratedFragment\";\n            case ForwardRef:\n              return getWrappedName$1(type, type.render, \"ForwardRef\");\n            case Fragment:\n              return \"Fragment\";\n            case HostComponent:\n              return type;\n            case HostPortal:\n              return \"Portal\";\n            case HostRoot:\n              return \"Root\";\n            case HostText:\n              return \"Text\";\n            case LazyComponent:\n              return getComponentNameFromType(type);\n            case Mode:\n              if (type === REACT_STRICT_MODE_TYPE) {\n                return \"StrictMode\";\n              }\n              return \"Mode\";\n            case OffscreenComponent:\n              return \"Offscreen\";\n            case Profiler:\n              return \"Profiler\";\n            case ScopeComponent:\n              return \"Scope\";\n            case SuspenseComponent:\n              return \"Suspense\";\n            case SuspenseListComponent:\n              return \"SuspenseList\";\n            case TracingMarkerComponent:\n              return \"TracingMarker\";\n            case ClassComponent:\n            case FunctionComponent:\n            case IncompleteClassComponent:\n            case IndeterminateComponent:\n            case MemoComponent:\n            case SimpleMemoComponent:\n              if (typeof type === \"function\") {\n                return type.displayName || type.name || null;\n              }\n              if (typeof type === \"string\") {\n                return type;\n              }\n              break;\n          }\n          return null;\n        }\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberOwnerNameInDevOrNull() {\n          {\n            if (current === null) {\n              return null;\n            }\n            var owner = current._debugOwner;\n            if (owner !== null && typeof owner !== \"undefined\") {\n              return getComponentNameFromFiber(owner);\n            }\n          }\n          return null;\n        }\n        function getCurrentFiberStackInDev() {\n          {\n            if (current === null) {\n              return \"\";\n            }\n            return getStackByFiberInDevAndProd(current);\n          }\n        }\n        function resetCurrentFiber() {\n          {\n            ReactDebugCurrentFrame.getCurrentStack = null;\n            current = null;\n            isRendering = false;\n          }\n        }\n        function setCurrentFiber(fiber) {\n          {\n            ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n            current = fiber;\n            isRendering = false;\n          }\n        }\n        function getCurrentFiber() {\n          {\n            return current;\n          }\n        }\n        function setIsRendering(rendering) {\n          {\n            isRendering = rendering;\n          }\n        }\n        function toString(value) {\n          return \"\" + value;\n        }\n        function getToStringValue(value) {\n          switch (typeof value) {\n            case \"boolean\":\n            case \"number\":\n            case \"string\":\n            case \"undefined\":\n              return value;\n            case \"object\":\n              {\n                checkFormFieldValueStringCoercion(value);\n              }\n              return value;\n            default:\n              return \"\";\n          }\n        }\n        var hasReadOnlyValue = {\n          button: true,\n          checkbox: true,\n          image: true,\n          hidden: true,\n          radio: true,\n          reset: true,\n          submit: true\n        };\n        function checkControlledValueProps(tagName, props) {\n          {\n            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {\n              error(\"You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.\");\n            }\n            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {\n              error(\"You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.\");\n            }\n          }\n        }\n        function isCheckable(elem) {\n          var type = elem.type;\n          var nodeName = elem.nodeName;\n          return nodeName && nodeName.toLowerCase() === \"input\" && (type === \"checkbox\" || type === \"radio\");\n        }\n        function getTracker(node) {\n          return node._valueTracker;\n        }\n        function detachTracker(node) {\n          node._valueTracker = null;\n        }\n        function getValueFromNode(node) {\n          var value = \"\";\n          if (!node) {\n            return value;\n          }\n          if (isCheckable(node)) {\n            value = node.checked ? \"true\" : \"false\";\n          } else {\n            value = node.value;\n          }\n          return value;\n        }\n        function trackValueOnNode(node) {\n          var valueField = isCheckable(node) ? \"checked\" : \"value\";\n          var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);\n          {\n            checkFormFieldValueStringCoercion(node[valueField]);\n          }\n          var currentValue = \"\" + node[valueField];\n          if (node.hasOwnProperty(valueField) || typeof descriptor === \"undefined\" || typeof descriptor.get !== \"function\" || typeof descriptor.set !== \"function\") {\n            return;\n          }\n          var get2 = descriptor.get, set2 = descriptor.set;\n          Object.defineProperty(node, valueField, {\n            configurable: true,\n            get: function() {\n              return get2.call(this);\n            },\n            set: function(value) {\n              {\n                checkFormFieldValueStringCoercion(value);\n              }\n              currentValue = \"\" + value;\n              set2.call(this, value);\n            }\n          });\n          Object.defineProperty(node, valueField, {\n            enumerable: descriptor.enumerable\n          });\n          var tracker = {\n            getValue: function() {\n              return currentValue;\n            },\n            setValue: function(value) {\n              {\n                checkFormFieldValueStringCoercion(value);\n              }\n              currentValue = \"\" + value;\n            },\n            stopTracking: function() {\n              detachTracker(node);\n              delete node[valueField];\n            }\n          };\n          return tracker;\n        }\n        function track(node) {\n          if (getTracker(node)) {\n            return;\n          }\n          node._valueTracker = trackValueOnNode(node);\n        }\n        function updateValueIfChanged(node) {\n          if (!node) {\n            return false;\n          }\n          var tracker = getTracker(node);\n          if (!tracker) {\n            return true;\n          }\n          var lastValue = tracker.getValue();\n          var nextValue = getValueFromNode(node);\n          if (nextValue !== lastValue) {\n            tracker.setValue(nextValue);\n            return true;\n          }\n          return false;\n        }\n        function getActiveElement(doc) {\n          doc = doc || (typeof document !== \"undefined\" ? document : void 0);\n          if (typeof doc === \"undefined\") {\n            return null;\n          }\n          try {\n            return doc.activeElement || doc.body;\n          } catch (e) {\n            return doc.body;\n          }\n        }\n        var didWarnValueDefaultValue = false;\n        var didWarnCheckedDefaultChecked = false;\n        var didWarnControlledToUncontrolled = false;\n        var didWarnUncontrolledToControlled = false;\n        function isControlled(props) {\n          var usesChecked = props.type === \"checkbox\" || props.type === \"radio\";\n          return usesChecked ? props.checked != null : props.value != null;\n        }\n        function getHostProps(element, props) {\n          var node = element;\n          var checked = props.checked;\n          var hostProps = assign({}, props, {\n            defaultChecked: void 0,\n            defaultValue: void 0,\n            value: void 0,\n            checked: checked != null ? checked : node._wrapperState.initialChecked\n          });\n          return hostProps;\n        }\n        function initWrapperState(element, props) {\n          {\n            checkControlledValueProps(\"input\", props);\n            if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {\n              error(\"%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\n              didWarnCheckedDefaultChecked = true;\n            }\n            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {\n              error(\"%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\", props.type);\n              didWarnValueDefaultValue = true;\n            }\n          }\n          var node = element;\n          var defaultValue = props.defaultValue == null ? \"\" : props.defaultValue;\n          node._wrapperState = {\n            initialChecked: props.checked != null ? props.checked : props.defaultChecked,\n            initialValue: getToStringValue(props.value != null ? props.value : defaultValue),\n            controlled: isControlled(props)\n          };\n        }\n        function updateChecked(element, props) {\n          var node = element;\n          var checked = props.checked;\n          if (checked != null) {\n            setValueForProperty(node, \"checked\", checked, false);\n          }\n        }\n        function updateWrapper(element, props) {\n          var node = element;\n          {\n            var controlled = isControlled(props);\n            if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {\n              error(\"A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\n              didWarnUncontrolledToControlled = true;\n            }\n            if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {\n              error(\"A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components\");\n              didWarnControlledToUncontrolled = true;\n            }\n          }\n          updateChecked(element, props);\n          var value = getToStringValue(props.value);\n          var type = props.type;\n          if (value != null) {\n            if (type === \"number\") {\n              if (value === 0 && node.value === \"\" || // We explicitly want to coerce to number here if possible.\n              // eslint-disable-next-line\n              node.value != value) {\n                node.value = toString(value);\n              }\n            } else if (node.value !== toString(value)) {\n              node.value = toString(value);\n            }\n          } else if (type === \"submit\" || type === \"reset\") {\n            node.removeAttribute(\"value\");\n            return;\n          }\n          {\n            if (props.hasOwnProperty(\"value\")) {\n              setDefaultValue(node, props.type, value);\n            } else if (props.hasOwnProperty(\"defaultValue\")) {\n              setDefaultValue(node, props.type, getToStringValue(props.defaultValue));\n            }\n          }\n          {\n            if (props.checked == null && props.defaultChecked != null) {\n              node.defaultChecked = !!props.defaultChecked;\n            }\n          }\n        }\n        function postMountWrapper(element, props, isHydrating2) {\n          var node = element;\n          if (props.hasOwnProperty(\"value\") || props.hasOwnProperty(\"defaultValue\")) {\n            var type = props.type;\n            var isButton = type === \"submit\" || type === \"reset\";\n            if (isButton && (props.value === void 0 || props.value === null)) {\n              return;\n            }\n            var initialValue = toString(node._wrapperState.initialValue);\n            if (!isHydrating2) {\n              {\n                if (initialValue !== node.value) {\n                  node.value = initialValue;\n                }\n              }\n            }\n            {\n              node.defaultValue = initialValue;\n            }\n          }\n          var name = node.name;\n          if (name !== \"\") {\n            node.name = \"\";\n          }\n          {\n            node.defaultChecked = !node.defaultChecked;\n            node.defaultChecked = !!node._wrapperState.initialChecked;\n          }\n          if (name !== \"\") {\n            node.name = name;\n          }\n        }\n        function restoreControlledState(element, props) {\n          var node = element;\n          updateWrapper(node, props);\n          updateNamedCousins(node, props);\n        }\n        function updateNamedCousins(rootNode, props) {\n          var name = props.name;\n          if (props.type === \"radio\" && name != null) {\n            var queryRoot = rootNode;\n            while (queryRoot.parentNode) {\n              queryRoot = queryRoot.parentNode;\n            }\n            {\n              checkAttributeStringCoercion(name, \"name\");\n            }\n            var group = queryRoot.querySelectorAll(\"input[name=\" + JSON.stringify(\"\" + name) + '][type=\"radio\"]');\n            for (var i = 0; i < group.length; i++) {\n              var otherNode = group[i];\n              if (otherNode === rootNode || otherNode.form !== rootNode.form) {\n                continue;\n              }\n              var otherProps = getFiberCurrentPropsFromNode(otherNode);\n              if (!otherProps) {\n                throw new Error(\"ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.\");\n              }\n              updateValueIfChanged(otherNode);\n              updateWrapper(otherNode, otherProps);\n            }\n          }\n        }\n        function setDefaultValue(node, type, value) {\n          if (\n            // Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n            type !== \"number\" || getActiveElement(node.ownerDocument) !== node\n          ) {\n            if (value == null) {\n              node.defaultValue = toString(node._wrapperState.initialValue);\n            } else if (node.defaultValue !== toString(value)) {\n              node.defaultValue = toString(value);\n            }\n          }\n        }\n        var didWarnSelectedSetOnOption = false;\n        var didWarnInvalidChild = false;\n        var didWarnInvalidInnerHTML = false;\n        function validateProps(element, props) {\n          {\n            if (props.value == null) {\n              if (typeof props.children === \"object\" && props.children !== null) {\n                React.Children.forEach(props.children, function(child) {\n                  if (child == null) {\n                    return;\n                  }\n                  if (typeof child === \"string\" || typeof child === \"number\") {\n                    return;\n                  }\n                  if (!didWarnInvalidChild) {\n                    didWarnInvalidChild = true;\n                    error(\"Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.\");\n                  }\n                });\n              } else if (props.dangerouslySetInnerHTML != null) {\n                if (!didWarnInvalidInnerHTML) {\n                  didWarnInvalidInnerHTML = true;\n                  error(\"Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.\");\n                }\n              }\n            }\n            if (props.selected != null && !didWarnSelectedSetOnOption) {\n              error(\"Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.\");\n              didWarnSelectedSetOnOption = true;\n            }\n          }\n        }\n        function postMountWrapper$1(element, props) {\n          if (props.value != null) {\n            element.setAttribute(\"value\", toString(getToStringValue(props.value)));\n          }\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        var didWarnValueDefaultValue$1;\n        {\n          didWarnValueDefaultValue$1 = false;\n        }\n        function getDeclarationErrorAddendum() {\n          var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n          if (ownerName) {\n            return \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n          }\n          return \"\";\n        }\n        var valuePropNames = [\"value\", \"defaultValue\"];\n        function checkSelectPropTypes(props) {\n          {\n            checkControlledValueProps(\"select\", props);\n            for (var i = 0; i < valuePropNames.length; i++) {\n              var propName = valuePropNames[i];\n              if (props[propName] == null) {\n                continue;\n              }\n              var propNameIsArray = isArray(props[propName]);\n              if (props.multiple && !propNameIsArray) {\n                error(\"The `%s` prop supplied to <select> must be an array if `multiple` is true.%s\", propName, getDeclarationErrorAddendum());\n              } else if (!props.multiple && propNameIsArray) {\n                error(\"The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s\", propName, getDeclarationErrorAddendum());\n              }\n            }\n          }\n        }\n        function updateOptions(node, multiple, propValue, setDefaultSelected) {\n          var options2 = node.options;\n          if (multiple) {\n            var selectedValues = propValue;\n            var selectedValue = {};\n            for (var i = 0; i < selectedValues.length; i++) {\n              selectedValue[\"$\" + selectedValues[i]] = true;\n            }\n            for (var _i = 0; _i < options2.length; _i++) {\n              var selected = selectedValue.hasOwnProperty(\"$\" + options2[_i].value);\n              if (options2[_i].selected !== selected) {\n                options2[_i].selected = selected;\n              }\n              if (selected && setDefaultSelected) {\n                options2[_i].defaultSelected = true;\n              }\n            }\n          } else {\n            var _selectedValue = toString(getToStringValue(propValue));\n            var defaultSelected = null;\n            for (var _i2 = 0; _i2 < options2.length; _i2++) {\n              if (options2[_i2].value === _selectedValue) {\n                options2[_i2].selected = true;\n                if (setDefaultSelected) {\n                  options2[_i2].defaultSelected = true;\n                }\n                return;\n              }\n              if (defaultSelected === null && !options2[_i2].disabled) {\n                defaultSelected = options2[_i2];\n              }\n            }\n            if (defaultSelected !== null) {\n              defaultSelected.selected = true;\n            }\n          }\n        }\n        function getHostProps$1(element, props) {\n          return assign({}, props, {\n            value: void 0\n          });\n        }\n        function initWrapperState$1(element, props) {\n          var node = element;\n          {\n            checkSelectPropTypes(props);\n          }\n          node._wrapperState = {\n            wasMultiple: !!props.multiple\n          };\n          {\n            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {\n              error(\"Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components\");\n              didWarnValueDefaultValue$1 = true;\n            }\n          }\n        }\n        function postMountWrapper$2(element, props) {\n          var node = element;\n          node.multiple = !!props.multiple;\n          var value = props.value;\n          if (value != null) {\n            updateOptions(node, !!props.multiple, value, false);\n          } else if (props.defaultValue != null) {\n            updateOptions(node, !!props.multiple, props.defaultValue, true);\n          }\n        }\n        function postUpdateWrapper(element, props) {\n          var node = element;\n          var wasMultiple = node._wrapperState.wasMultiple;\n          node._wrapperState.wasMultiple = !!props.multiple;\n          var value = props.value;\n          if (value != null) {\n            updateOptions(node, !!props.multiple, value, false);\n          } else if (wasMultiple !== !!props.multiple) {\n            if (props.defaultValue != null) {\n              updateOptions(node, !!props.multiple, props.defaultValue, true);\n            } else {\n              updateOptions(node, !!props.multiple, props.multiple ? [] : \"\", false);\n            }\n          }\n        }\n        function restoreControlledState$1(element, props) {\n          var node = element;\n          var value = props.value;\n          if (value != null) {\n            updateOptions(node, !!props.multiple, value, false);\n          }\n        }\n        var didWarnValDefaultVal = false;\n        function getHostProps$2(element, props) {\n          var node = element;\n          if (props.dangerouslySetInnerHTML != null) {\n            throw new Error(\"`dangerouslySetInnerHTML` does not make sense on <textarea>.\");\n          }\n          var hostProps = assign({}, props, {\n            value: void 0,\n            defaultValue: void 0,\n            children: toString(node._wrapperState.initialValue)\n          });\n          return hostProps;\n        }\n        function initWrapperState$2(element, props) {\n          var node = element;\n          {\n            checkControlledValueProps(\"textarea\", props);\n            if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {\n              error(\"%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components\", getCurrentFiberOwnerNameInDevOrNull() || \"A component\");\n              didWarnValDefaultVal = true;\n            }\n          }\n          var initialValue = props.value;\n          if (initialValue == null) {\n            var children = props.children, defaultValue = props.defaultValue;\n            if (children != null) {\n              {\n                error(\"Use the `defaultValue` or `value` props instead of setting children on <textarea>.\");\n              }\n              {\n                if (defaultValue != null) {\n                  throw new Error(\"If you supply `defaultValue` on a <textarea>, do not pass children.\");\n                }\n                if (isArray(children)) {\n                  if (children.length > 1) {\n                    throw new Error(\"<textarea> can only have at most one child.\");\n                  }\n                  children = children[0];\n                }\n                defaultValue = children;\n              }\n            }\n            if (defaultValue == null) {\n              defaultValue = \"\";\n            }\n            initialValue = defaultValue;\n          }\n          node._wrapperState = {\n            initialValue: getToStringValue(initialValue)\n          };\n        }\n        function updateWrapper$1(element, props) {\n          var node = element;\n          var value = getToStringValue(props.value);\n          var defaultValue = getToStringValue(props.defaultValue);\n          if (value != null) {\n            var newValue = toString(value);\n            if (newValue !== node.value) {\n              node.value = newValue;\n            }\n            if (props.defaultValue == null && node.defaultValue !== newValue) {\n              node.defaultValue = newValue;\n            }\n          }\n          if (defaultValue != null) {\n            node.defaultValue = toString(defaultValue);\n          }\n        }\n        function postMountWrapper$3(element, props) {\n          var node = element;\n          var textContent = node.textContent;\n          if (textContent === node._wrapperState.initialValue) {\n            if (textContent !== \"\" && textContent !== null) {\n              node.value = textContent;\n            }\n          }\n        }\n        function restoreControlledState$2(element, props) {\n          updateWrapper$1(element, props);\n        }\n        var HTML_NAMESPACE = \"http://www.w3.org/1999/xhtml\";\n        var MATH_NAMESPACE = \"http://www.w3.org/1998/Math/MathML\";\n        var SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\n        function getIntrinsicNamespace(type) {\n          switch (type) {\n            case \"svg\":\n              return SVG_NAMESPACE;\n            case \"math\":\n              return MATH_NAMESPACE;\n            default:\n              return HTML_NAMESPACE;\n          }\n        }\n        function getChildNamespace(parentNamespace, type) {\n          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {\n            return getIntrinsicNamespace(type);\n          }\n          if (parentNamespace === SVG_NAMESPACE && type === \"foreignObject\") {\n            return HTML_NAMESPACE;\n          }\n          return parentNamespace;\n        }\n        var createMicrosoftUnsafeLocalFunction = function(func) {\n          if (typeof MSApp !== \"undefined\" && MSApp.execUnsafeLocalFunction) {\n            return function(arg0, arg1, arg2, arg3) {\n              MSApp.execUnsafeLocalFunction(function() {\n                return func(arg0, arg1, arg2, arg3);\n              });\n            };\n          } else {\n            return func;\n          }\n        };\n        var reusableSVGContainer;\n        var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {\n          if (node.namespaceURI === SVG_NAMESPACE) {\n            if (!(\"innerHTML\" in node)) {\n              reusableSVGContainer = reusableSVGContainer || document.createElement(\"div\");\n              reusableSVGContainer.innerHTML = \"<svg>\" + html.valueOf().toString() + \"</svg>\";\n              var svgNode = reusableSVGContainer.firstChild;\n              while (node.firstChild) {\n                node.removeChild(node.firstChild);\n              }\n              while (svgNode.firstChild) {\n                node.appendChild(svgNode.firstChild);\n              }\n              return;\n            }\n          }\n          node.innerHTML = html;\n        });\n        var ELEMENT_NODE = 1;\n        var TEXT_NODE = 3;\n        var COMMENT_NODE = 8;\n        var DOCUMENT_NODE = 9;\n        var DOCUMENT_FRAGMENT_NODE = 11;\n        var setTextContent = function(node, text) {\n          if (text) {\n            var firstChild = node.firstChild;\n            if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {\n              firstChild.nodeValue = text;\n              return;\n            }\n          }\n          node.textContent = text;\n        };\n        var shorthandToLonghand = {\n          animation: [\"animationDelay\", \"animationDirection\", \"animationDuration\", \"animationFillMode\", \"animationIterationCount\", \"animationName\", \"animationPlayState\", \"animationTimingFunction\"],\n          background: [\"backgroundAttachment\", \"backgroundClip\", \"backgroundColor\", \"backgroundImage\", \"backgroundOrigin\", \"backgroundPositionX\", \"backgroundPositionY\", \"backgroundRepeat\", \"backgroundSize\"],\n          backgroundPosition: [\"backgroundPositionX\", \"backgroundPositionY\"],\n          border: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\", \"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\", \"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\", \"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\", \"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\n          borderBlockEnd: [\"borderBlockEndColor\", \"borderBlockEndStyle\", \"borderBlockEndWidth\"],\n          borderBlockStart: [\"borderBlockStartColor\", \"borderBlockStartStyle\", \"borderBlockStartWidth\"],\n          borderBottom: [\"borderBottomColor\", \"borderBottomStyle\", \"borderBottomWidth\"],\n          borderColor: [\"borderBottomColor\", \"borderLeftColor\", \"borderRightColor\", \"borderTopColor\"],\n          borderImage: [\"borderImageOutset\", \"borderImageRepeat\", \"borderImageSlice\", \"borderImageSource\", \"borderImageWidth\"],\n          borderInlineEnd: [\"borderInlineEndColor\", \"borderInlineEndStyle\", \"borderInlineEndWidth\"],\n          borderInlineStart: [\"borderInlineStartColor\", \"borderInlineStartStyle\", \"borderInlineStartWidth\"],\n          borderLeft: [\"borderLeftColor\", \"borderLeftStyle\", \"borderLeftWidth\"],\n          borderRadius: [\"borderBottomLeftRadius\", \"borderBottomRightRadius\", \"borderTopLeftRadius\", \"borderTopRightRadius\"],\n          borderRight: [\"borderRightColor\", \"borderRightStyle\", \"borderRightWidth\"],\n          borderStyle: [\"borderBottomStyle\", \"borderLeftStyle\", \"borderRightStyle\", \"borderTopStyle\"],\n          borderTop: [\"borderTopColor\", \"borderTopStyle\", \"borderTopWidth\"],\n          borderWidth: [\"borderBottomWidth\", \"borderLeftWidth\", \"borderRightWidth\", \"borderTopWidth\"],\n          columnRule: [\"columnRuleColor\", \"columnRuleStyle\", \"columnRuleWidth\"],\n          columns: [\"columnCount\", \"columnWidth\"],\n          flex: [\"flexBasis\", \"flexGrow\", \"flexShrink\"],\n          flexFlow: [\"flexDirection\", \"flexWrap\"],\n          font: [\"fontFamily\", \"fontFeatureSettings\", \"fontKerning\", \"fontLanguageOverride\", \"fontSize\", \"fontSizeAdjust\", \"fontStretch\", \"fontStyle\", \"fontVariant\", \"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\", \"fontWeight\", \"lineHeight\"],\n          fontVariant: [\"fontVariantAlternates\", \"fontVariantCaps\", \"fontVariantEastAsian\", \"fontVariantLigatures\", \"fontVariantNumeric\", \"fontVariantPosition\"],\n          gap: [\"columnGap\", \"rowGap\"],\n          grid: [\"gridAutoColumns\", \"gridAutoFlow\", \"gridAutoRows\", \"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\n          gridArea: [\"gridColumnEnd\", \"gridColumnStart\", \"gridRowEnd\", \"gridRowStart\"],\n          gridColumn: [\"gridColumnEnd\", \"gridColumnStart\"],\n          gridColumnGap: [\"columnGap\"],\n          gridGap: [\"columnGap\", \"rowGap\"],\n          gridRow: [\"gridRowEnd\", \"gridRowStart\"],\n          gridRowGap: [\"rowGap\"],\n          gridTemplate: [\"gridTemplateAreas\", \"gridTemplateColumns\", \"gridTemplateRows\"],\n          listStyle: [\"listStyleImage\", \"listStylePosition\", \"listStyleType\"],\n          margin: [\"marginBottom\", \"marginLeft\", \"marginRight\", \"marginTop\"],\n          marker: [\"markerEnd\", \"markerMid\", \"markerStart\"],\n          mask: [\"maskClip\", \"maskComposite\", \"maskImage\", \"maskMode\", \"maskOrigin\", \"maskPositionX\", \"maskPositionY\", \"maskRepeat\", \"maskSize\"],\n          maskPosition: [\"maskPositionX\", \"maskPositionY\"],\n          outline: [\"outlineColor\", \"outlineStyle\", \"outlineWidth\"],\n          overflow: [\"overflowX\", \"overflowY\"],\n          padding: [\"paddingBottom\", \"paddingLeft\", \"paddingRight\", \"paddingTop\"],\n          placeContent: [\"alignContent\", \"justifyContent\"],\n          placeItems: [\"alignItems\", \"justifyItems\"],\n          placeSelf: [\"alignSelf\", \"justifySelf\"],\n          textDecoration: [\"textDecorationColor\", \"textDecorationLine\", \"textDecorationStyle\"],\n          textEmphasis: [\"textEmphasisColor\", \"textEmphasisStyle\"],\n          transition: [\"transitionDelay\", \"transitionDuration\", \"transitionProperty\", \"transitionTimingFunction\"],\n          wordWrap: [\"overflowWrap\"]\n        };\n        var isUnitlessNumber = {\n          animationIterationCount: true,\n          aspectRatio: true,\n          borderImageOutset: true,\n          borderImageSlice: true,\n          borderImageWidth: true,\n          boxFlex: true,\n          boxFlexGroup: true,\n          boxOrdinalGroup: true,\n          columnCount: true,\n          columns: true,\n          flex: true,\n          flexGrow: true,\n          flexPositive: true,\n          flexShrink: true,\n          flexNegative: true,\n          flexOrder: true,\n          gridArea: true,\n          gridRow: true,\n          gridRowEnd: true,\n          gridRowSpan: true,\n          gridRowStart: true,\n          gridColumn: true,\n          gridColumnEnd: true,\n          gridColumnSpan: true,\n          gridColumnStart: true,\n          fontWeight: true,\n          lineClamp: true,\n          lineHeight: true,\n          opacity: true,\n          order: true,\n          orphans: true,\n          tabSize: true,\n          widows: true,\n          zIndex: true,\n          zoom: true,\n          // SVG-related properties\n          fillOpacity: true,\n          floodOpacity: true,\n          stopOpacity: true,\n          strokeDasharray: true,\n          strokeDashoffset: true,\n          strokeMiterlimit: true,\n          strokeOpacity: true,\n          strokeWidth: true\n        };\n        function prefixKey(prefix2, key) {\n          return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);\n        }\n        var prefixes = [\"Webkit\", \"ms\", \"Moz\", \"O\"];\n        Object.keys(isUnitlessNumber).forEach(function(prop) {\n          prefixes.forEach(function(prefix2) {\n            isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];\n          });\n        });\n        function dangerousStyleValue(name, value, isCustomProperty) {\n          var isEmpty = value == null || typeof value === \"boolean\" || value === \"\";\n          if (isEmpty) {\n            return \"\";\n          }\n          if (!isCustomProperty && typeof value === \"number\" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {\n            return value + \"px\";\n          }\n          {\n            checkCSSPropertyStringCoercion(value, name);\n          }\n          return (\"\" + value).trim();\n        }\n        var uppercasePattern = /([A-Z])/g;\n        var msPattern = /^ms-/;\n        function hyphenateStyleName(name) {\n          return name.replace(uppercasePattern, \"-$1\").toLowerCase().replace(msPattern, \"-ms-\");\n        }\n        var warnValidStyle = function() {\n        };\n        {\n          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;\n          var msPattern$1 = /^-ms-/;\n          var hyphenPattern = /-(.)/g;\n          var badStyleValueWithSemicolonPattern = /;\\s*$/;\n          var warnedStyleNames = {};\n          var warnedStyleValues = {};\n          var warnedForNaNValue = false;\n          var warnedForInfinityValue = false;\n          var camelize = function(string) {\n            return string.replace(hyphenPattern, function(_, character) {\n              return character.toUpperCase();\n            });\n          };\n          var warnHyphenatedStyleName = function(name) {\n            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n              return;\n            }\n            warnedStyleNames[name] = true;\n            error(\n              \"Unsupported style property %s. Did you mean %s?\",\n              name,\n              // As Andi Smith suggests\n              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n              // is converted to lowercase `ms`.\n              camelize(name.replace(msPattern$1, \"ms-\"))\n            );\n          };\n          var warnBadVendoredStyleName = function(name) {\n            if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {\n              return;\n            }\n            warnedStyleNames[name] = true;\n            error(\"Unsupported vendor-prefixed style property %s. Did you mean %s?\", name, name.charAt(0).toUpperCase() + name.slice(1));\n          };\n          var warnStyleValueWithSemicolon = function(name, value) {\n            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {\n              return;\n            }\n            warnedStyleValues[value] = true;\n            error(`Style property values shouldn't contain a semicolon. Try \"%s: %s\" instead.`, name, value.replace(badStyleValueWithSemicolonPattern, \"\"));\n          };\n          var warnStyleValueIsNaN = function(name, value) {\n            if (warnedForNaNValue) {\n              return;\n            }\n            warnedForNaNValue = true;\n            error(\"`NaN` is an invalid value for the `%s` css style property.\", name);\n          };\n          var warnStyleValueIsInfinity = function(name, value) {\n            if (warnedForInfinityValue) {\n              return;\n            }\n            warnedForInfinityValue = true;\n            error(\"`Infinity` is an invalid value for the `%s` css style property.\", name);\n          };\n          warnValidStyle = function(name, value) {\n            if (name.indexOf(\"-\") > -1) {\n              warnHyphenatedStyleName(name);\n            } else if (badVendoredStyleNamePattern.test(name)) {\n              warnBadVendoredStyleName(name);\n            } else if (badStyleValueWithSemicolonPattern.test(value)) {\n              warnStyleValueWithSemicolon(name, value);\n            }\n            if (typeof value === \"number\") {\n              if (isNaN(value)) {\n                warnStyleValueIsNaN(name, value);\n              } else if (!isFinite(value)) {\n                warnStyleValueIsInfinity(name, value);\n              }\n            }\n          };\n        }\n        var warnValidStyle$1 = warnValidStyle;\n        function createDangerousStringForStyles(styles) {\n          {\n            var serialized = \"\";\n            var delimiter = \"\";\n            for (var styleName in styles) {\n              if (!styles.hasOwnProperty(styleName)) {\n                continue;\n              }\n              var styleValue = styles[styleName];\n              if (styleValue != null) {\n                var isCustomProperty = styleName.indexOf(\"--\") === 0;\n                serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + \":\";\n                serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);\n                delimiter = \";\";\n              }\n            }\n            return serialized || null;\n          }\n        }\n        function setValueForStyles(node, styles) {\n          var style2 = node.style;\n          for (var styleName in styles) {\n            if (!styles.hasOwnProperty(styleName)) {\n              continue;\n            }\n            var isCustomProperty = styleName.indexOf(\"--\") === 0;\n            {\n              if (!isCustomProperty) {\n                warnValidStyle$1(styleName, styles[styleName]);\n              }\n            }\n            var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);\n            if (styleName === \"float\") {\n              styleName = \"cssFloat\";\n            }\n            if (isCustomProperty) {\n              style2.setProperty(styleName, styleValue);\n            } else {\n              style2[styleName] = styleValue;\n            }\n          }\n        }\n        function isValueEmpty(value) {\n          return value == null || typeof value === \"boolean\" || value === \"\";\n        }\n        function expandShorthandMap(styles) {\n          var expanded = {};\n          for (var key in styles) {\n            var longhands = shorthandToLonghand[key] || [key];\n            for (var i = 0; i < longhands.length; i++) {\n              expanded[longhands[i]] = key;\n            }\n          }\n          return expanded;\n        }\n        function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {\n          {\n            if (!nextStyles) {\n              return;\n            }\n            var expandedUpdates = expandShorthandMap(styleUpdates);\n            var expandedStyles = expandShorthandMap(nextStyles);\n            var warnedAbout = {};\n            for (var key in expandedUpdates) {\n              var originalKey = expandedUpdates[key];\n              var correctOriginalKey = expandedStyles[key];\n              if (correctOriginalKey && originalKey !== correctOriginalKey) {\n                var warningKey = originalKey + \",\" + correctOriginalKey;\n                if (warnedAbout[warningKey]) {\n                  continue;\n                }\n                warnedAbout[warningKey] = true;\n                error(\"%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.\", isValueEmpty(styleUpdates[originalKey]) ? \"Removing\" : \"Updating\", originalKey, correctOriginalKey);\n              }\n            }\n          }\n        }\n        var omittedCloseTags = {\n          area: true,\n          base: true,\n          br: true,\n          col: true,\n          embed: true,\n          hr: true,\n          img: true,\n          input: true,\n          keygen: true,\n          link: true,\n          meta: true,\n          param: true,\n          source: true,\n          track: true,\n          wbr: true\n          // NOTE: menuitem's close tag should be omitted, but that causes problems.\n        };\n        var voidElementTags = assign({\n          menuitem: true\n        }, omittedCloseTags);\n        var HTML = \"__html\";\n        function assertValidProps(tag, props) {\n          if (!props) {\n            return;\n          }\n          if (voidElementTags[tag]) {\n            if (props.children != null || props.dangerouslySetInnerHTML != null) {\n              throw new Error(tag + \" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.\");\n            }\n          }\n          if (props.dangerouslySetInnerHTML != null) {\n            if (props.children != null) {\n              throw new Error(\"Can only set one of `children` or `props.dangerouslySetInnerHTML`.\");\n            }\n            if (typeof props.dangerouslySetInnerHTML !== \"object\" || !(HTML in props.dangerouslySetInnerHTML)) {\n              throw new Error(\"`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.\");\n            }\n          }\n          {\n            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {\n              error(\"A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.\");\n            }\n          }\n          if (props.style != null && typeof props.style !== \"object\") {\n            throw new Error(\"The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.\");\n          }\n        }\n        function isCustomComponent(tagName, props) {\n          if (tagName.indexOf(\"-\") === -1) {\n            return typeof props.is === \"string\";\n          }\n          switch (tagName) {\n            case \"annotation-xml\":\n            case \"color-profile\":\n            case \"font-face\":\n            case \"font-face-src\":\n            case \"font-face-uri\":\n            case \"font-face-format\":\n            case \"font-face-name\":\n            case \"missing-glyph\":\n              return false;\n            default:\n              return true;\n          }\n        }\n        var possibleStandardNames = {\n          // HTML\n          accept: \"accept\",\n          acceptcharset: \"acceptCharset\",\n          \"accept-charset\": \"acceptCharset\",\n          accesskey: \"accessKey\",\n          action: \"action\",\n          allowfullscreen: \"allowFullScreen\",\n          alt: \"alt\",\n          as: \"as\",\n          async: \"async\",\n          autocapitalize: \"autoCapitalize\",\n          autocomplete: \"autoComplete\",\n          autocorrect: \"autoCorrect\",\n          autofocus: \"autoFocus\",\n          autoplay: \"autoPlay\",\n          autosave: \"autoSave\",\n          capture: \"capture\",\n          cellpadding: \"cellPadding\",\n          cellspacing: \"cellSpacing\",\n          challenge: \"challenge\",\n          charset: \"charSet\",\n          checked: \"checked\",\n          children: \"children\",\n          cite: \"cite\",\n          class: \"className\",\n          classid: \"classID\",\n          classname: \"className\",\n          cols: \"cols\",\n          colspan: \"colSpan\",\n          content: \"content\",\n          contenteditable: \"contentEditable\",\n          contextmenu: \"contextMenu\",\n          controls: \"controls\",\n          controlslist: \"controlsList\",\n          coords: \"coords\",\n          crossorigin: \"crossOrigin\",\n          dangerouslysetinnerhtml: \"dangerouslySetInnerHTML\",\n          data: \"data\",\n          datetime: \"dateTime\",\n          default: \"default\",\n          defaultchecked: \"defaultChecked\",\n          defaultvalue: \"defaultValue\",\n          defer: \"defer\",\n          dir: \"dir\",\n          disabled: \"disabled\",\n          disablepictureinpicture: \"disablePictureInPicture\",\n          disableremoteplayback: \"disableRemotePlayback\",\n          download: \"download\",\n          draggable: \"draggable\",\n          enctype: \"encType\",\n          enterkeyhint: \"enterKeyHint\",\n          for: \"htmlFor\",\n          form: \"form\",\n          formmethod: \"formMethod\",\n          formaction: \"formAction\",\n          formenctype: \"formEncType\",\n          formnovalidate: \"formNoValidate\",\n          formtarget: \"formTarget\",\n          frameborder: \"frameBorder\",\n          headers: \"headers\",\n          height: \"height\",\n          hidden: \"hidden\",\n          high: \"high\",\n          href: \"href\",\n          hreflang: \"hrefLang\",\n          htmlfor: \"htmlFor\",\n          httpequiv: \"httpEquiv\",\n          \"http-equiv\": \"httpEquiv\",\n          icon: \"icon\",\n          id: \"id\",\n          imagesizes: \"imageSizes\",\n          imagesrcset: \"imageSrcSet\",\n          innerhtml: \"innerHTML\",\n          inputmode: \"inputMode\",\n          integrity: \"integrity\",\n          is: \"is\",\n          itemid: \"itemID\",\n          itemprop: \"itemProp\",\n          itemref: \"itemRef\",\n          itemscope: \"itemScope\",\n          itemtype: \"itemType\",\n          keyparams: \"keyParams\",\n          keytype: \"keyType\",\n          kind: \"kind\",\n          label: \"label\",\n          lang: \"lang\",\n          list: \"list\",\n          loop: \"loop\",\n          low: \"low\",\n          manifest: \"manifest\",\n          marginwidth: \"marginWidth\",\n          marginheight: \"marginHeight\",\n          max: \"max\",\n          maxlength: \"maxLength\",\n          media: \"media\",\n          mediagroup: \"mediaGroup\",\n          method: \"method\",\n          min: \"min\",\n          minlength: \"minLength\",\n          multiple: \"multiple\",\n          muted: \"muted\",\n          name: \"name\",\n          nomodule: \"noModule\",\n          nonce: \"nonce\",\n          novalidate: \"noValidate\",\n          open: \"open\",\n          optimum: \"optimum\",\n          pattern: \"pattern\",\n          placeholder: \"placeholder\",\n          playsinline: \"playsInline\",\n          poster: \"poster\",\n          preload: \"preload\",\n          profile: \"profile\",\n          radiogroup: \"radioGroup\",\n          readonly: \"readOnly\",\n          referrerpolicy: \"referrerPolicy\",\n          rel: \"rel\",\n          required: \"required\",\n          reversed: \"reversed\",\n          role: \"role\",\n          rows: \"rows\",\n          rowspan: \"rowSpan\",\n          sandbox: \"sandbox\",\n          scope: \"scope\",\n          scoped: \"scoped\",\n          scrolling: \"scrolling\",\n          seamless: \"seamless\",\n          selected: \"selected\",\n          shape: \"shape\",\n          size: \"size\",\n          sizes: \"sizes\",\n          span: \"span\",\n          spellcheck: \"spellCheck\",\n          src: \"src\",\n          srcdoc: \"srcDoc\",\n          srclang: \"srcLang\",\n          srcset: \"srcSet\",\n          start: \"start\",\n          step: \"step\",\n          style: \"style\",\n          summary: \"summary\",\n          tabindex: \"tabIndex\",\n          target: \"target\",\n          title: \"title\",\n          type: \"type\",\n          usemap: \"useMap\",\n          value: \"value\",\n          width: \"width\",\n          wmode: \"wmode\",\n          wrap: \"wrap\",\n          // SVG\n          about: \"about\",\n          accentheight: \"accentHeight\",\n          \"accent-height\": \"accentHeight\",\n          accumulate: \"accumulate\",\n          additive: \"additive\",\n          alignmentbaseline: \"alignmentBaseline\",\n          \"alignment-baseline\": \"alignmentBaseline\",\n          allowreorder: \"allowReorder\",\n          alphabetic: \"alphabetic\",\n          amplitude: \"amplitude\",\n          arabicform: \"arabicForm\",\n          \"arabic-form\": \"arabicForm\",\n          ascent: \"ascent\",\n          attributename: \"attributeName\",\n          attributetype: \"attributeType\",\n          autoreverse: \"autoReverse\",\n          azimuth: \"azimuth\",\n          basefrequency: \"baseFrequency\",\n          baselineshift: \"baselineShift\",\n          \"baseline-shift\": \"baselineShift\",\n          baseprofile: \"baseProfile\",\n          bbox: \"bbox\",\n          begin: \"begin\",\n          bias: \"bias\",\n          by: \"by\",\n          calcmode: \"calcMode\",\n          capheight: \"capHeight\",\n          \"cap-height\": \"capHeight\",\n          clip: \"clip\",\n          clippath: \"clipPath\",\n          \"clip-path\": \"clipPath\",\n          clippathunits: \"clipPathUnits\",\n          cliprule: \"clipRule\",\n          \"clip-rule\": \"clipRule\",\n          color: \"color\",\n          colorinterpolation: \"colorInterpolation\",\n          \"color-interpolation\": \"colorInterpolation\",\n          colorinterpolationfilters: \"colorInterpolationFilters\",\n          \"color-interpolation-filters\": \"colorInterpolationFilters\",\n          colorprofile: \"colorProfile\",\n          \"color-profile\": \"colorProfile\",\n          colorrendering: \"colorRendering\",\n          \"color-rendering\": \"colorRendering\",\n          contentscripttype: \"contentScriptType\",\n          contentstyletype: \"contentStyleType\",\n          cursor: \"cursor\",\n          cx: \"cx\",\n          cy: \"cy\",\n          d: \"d\",\n          datatype: \"datatype\",\n          decelerate: \"decelerate\",\n          descent: \"descent\",\n          diffuseconstant: \"diffuseConstant\",\n          direction: \"direction\",\n          display: \"display\",\n          divisor: \"divisor\",\n          dominantbaseline: \"dominantBaseline\",\n          \"dominant-baseline\": \"dominantBaseline\",\n          dur: \"dur\",\n          dx: \"dx\",\n          dy: \"dy\",\n          edgemode: \"edgeMode\",\n          elevation: \"elevation\",\n          enablebackground: \"enableBackground\",\n          \"enable-background\": \"enableBackground\",\n          end: \"end\",\n          exponent: \"exponent\",\n          externalresourcesrequired: \"externalResourcesRequired\",\n          fill: \"fill\",\n          fillopacity: \"fillOpacity\",\n          \"fill-opacity\": \"fillOpacity\",\n          fillrule: \"fillRule\",\n          \"fill-rule\": \"fillRule\",\n          filter: \"filter\",\n          filterres: \"filterRes\",\n          filterunits: \"filterUnits\",\n          floodopacity: \"floodOpacity\",\n          \"flood-opacity\": \"floodOpacity\",\n          floodcolor: \"floodColor\",\n          \"flood-color\": \"floodColor\",\n          focusable: \"focusable\",\n          fontfamily: \"fontFamily\",\n          \"font-family\": \"fontFamily\",\n          fontsize: \"fontSize\",\n          \"font-size\": \"fontSize\",\n          fontsizeadjust: \"fontSizeAdjust\",\n          \"font-size-adjust\": \"fontSizeAdjust\",\n          fontstretch: \"fontStretch\",\n          \"font-stretch\": \"fontStretch\",\n          fontstyle: \"fontStyle\",\n          \"font-style\": \"fontStyle\",\n          fontvariant: \"fontVariant\",\n          \"font-variant\": \"fontVariant\",\n          fontweight: \"fontWeight\",\n          \"font-weight\": \"fontWeight\",\n          format: \"format\",\n          from: \"from\",\n          fx: \"fx\",\n          fy: \"fy\",\n          g1: \"g1\",\n          g2: \"g2\",\n          glyphname: \"glyphName\",\n          \"glyph-name\": \"glyphName\",\n          glyphorientationhorizontal: \"glyphOrientationHorizontal\",\n          \"glyph-orientation-horizontal\": \"glyphOrientationHorizontal\",\n          glyphorientationvertical: \"glyphOrientationVertical\",\n          \"glyph-orientation-vertical\": \"glyphOrientationVertical\",\n          glyphref: \"glyphRef\",\n          gradienttransform: \"gradientTransform\",\n          gradientunits: \"gradientUnits\",\n          hanging: \"hanging\",\n          horizadvx: \"horizAdvX\",\n          \"horiz-adv-x\": \"horizAdvX\",\n          horizoriginx: \"horizOriginX\",\n          \"horiz-origin-x\": \"horizOriginX\",\n          ideographic: \"ideographic\",\n          imagerendering: \"imageRendering\",\n          \"image-rendering\": \"imageRendering\",\n          in2: \"in2\",\n          in: \"in\",\n          inlist: \"inlist\",\n          intercept: \"intercept\",\n          k1: \"k1\",\n          k2: \"k2\",\n          k3: \"k3\",\n          k4: \"k4\",\n          k: \"k\",\n          kernelmatrix: \"kernelMatrix\",\n          kernelunitlength: \"kernelUnitLength\",\n          kerning: \"kerning\",\n          keypoints: \"keyPoints\",\n          keysplines: \"keySplines\",\n          keytimes: \"keyTimes\",\n          lengthadjust: \"lengthAdjust\",\n          letterspacing: \"letterSpacing\",\n          \"letter-spacing\": \"letterSpacing\",\n          lightingcolor: \"lightingColor\",\n          \"lighting-color\": \"lightingColor\",\n          limitingconeangle: \"limitingConeAngle\",\n          local: \"local\",\n          markerend: \"markerEnd\",\n          \"marker-end\": \"markerEnd\",\n          markerheight: \"markerHeight\",\n          markermid: \"markerMid\",\n          \"marker-mid\": \"markerMid\",\n          markerstart: \"markerStart\",\n          \"marker-start\": \"markerStart\",\n          markerunits: \"markerUnits\",\n          markerwidth: \"markerWidth\",\n          mask: \"mask\",\n          maskcontentunits: \"maskContentUnits\",\n          maskunits: \"maskUnits\",\n          mathematical: \"mathematical\",\n          mode: \"mode\",\n          numoctaves: \"numOctaves\",\n          offset: \"offset\",\n          opacity: \"opacity\",\n          operator: \"operator\",\n          order: \"order\",\n          orient: \"orient\",\n          orientation: \"orientation\",\n          origin: \"origin\",\n          overflow: \"overflow\",\n          overlineposition: \"overlinePosition\",\n          \"overline-position\": \"overlinePosition\",\n          overlinethickness: \"overlineThickness\",\n          \"overline-thickness\": \"overlineThickness\",\n          paintorder: \"paintOrder\",\n          \"paint-order\": \"paintOrder\",\n          panose1: \"panose1\",\n          \"panose-1\": \"panose1\",\n          pathlength: \"pathLength\",\n          patterncontentunits: \"patternContentUnits\",\n          patterntransform: \"patternTransform\",\n          patternunits: \"patternUnits\",\n          pointerevents: \"pointerEvents\",\n          \"pointer-events\": \"pointerEvents\",\n          points: \"points\",\n          pointsatx: \"pointsAtX\",\n          pointsaty: \"pointsAtY\",\n          pointsatz: \"pointsAtZ\",\n          prefix: \"prefix\",\n          preservealpha: \"preserveAlpha\",\n          preserveaspectratio: \"preserveAspectRatio\",\n          primitiveunits: \"primitiveUnits\",\n          property: \"property\",\n          r: \"r\",\n          radius: \"radius\",\n          refx: \"refX\",\n          refy: \"refY\",\n          renderingintent: \"renderingIntent\",\n          \"rendering-intent\": \"renderingIntent\",\n          repeatcount: \"repeatCount\",\n          repeatdur: \"repeatDur\",\n          requiredextensions: \"requiredExtensions\",\n          requiredfeatures: \"requiredFeatures\",\n          resource: \"resource\",\n          restart: \"restart\",\n          result: \"result\",\n          results: \"results\",\n          rotate: \"rotate\",\n          rx: \"rx\",\n          ry: \"ry\",\n          scale: \"scale\",\n          security: \"security\",\n          seed: \"seed\",\n          shaperendering: \"shapeRendering\",\n          \"shape-rendering\": \"shapeRendering\",\n          slope: \"slope\",\n          spacing: \"spacing\",\n          specularconstant: \"specularConstant\",\n          specularexponent: \"specularExponent\",\n          speed: \"speed\",\n          spreadmethod: \"spreadMethod\",\n          startoffset: \"startOffset\",\n          stddeviation: \"stdDeviation\",\n          stemh: \"stemh\",\n          stemv: \"stemv\",\n          stitchtiles: \"stitchTiles\",\n          stopcolor: \"stopColor\",\n          \"stop-color\": \"stopColor\",\n          stopopacity: \"stopOpacity\",\n          \"stop-opacity\": \"stopOpacity\",\n          strikethroughposition: \"strikethroughPosition\",\n          \"strikethrough-position\": \"strikethroughPosition\",\n          strikethroughthickness: \"strikethroughThickness\",\n          \"strikethrough-thickness\": \"strikethroughThickness\",\n          string: \"string\",\n          stroke: \"stroke\",\n          strokedasharray: \"strokeDasharray\",\n          \"stroke-dasharray\": \"strokeDasharray\",\n          strokedashoffset: \"strokeDashoffset\",\n          \"stroke-dashoffset\": \"strokeDashoffset\",\n          strokelinecap: \"strokeLinecap\",\n          \"stroke-linecap\": \"strokeLinecap\",\n          strokelinejoin: \"strokeLinejoin\",\n          \"stroke-linejoin\": \"strokeLinejoin\",\n          strokemiterlimit: \"strokeMiterlimit\",\n          \"stroke-miterlimit\": \"strokeMiterlimit\",\n          strokewidth: \"strokeWidth\",\n          \"stroke-width\": \"strokeWidth\",\n          strokeopacity: \"strokeOpacity\",\n          \"stroke-opacity\": \"strokeOpacity\",\n          suppresscontenteditablewarning: \"suppressContentEditableWarning\",\n          suppresshydrationwarning: \"suppressHydrationWarning\",\n          surfacescale: \"surfaceScale\",\n          systemlanguage: \"systemLanguage\",\n          tablevalues: \"tableValues\",\n          targetx: \"targetX\",\n          targety: \"targetY\",\n          textanchor: \"textAnchor\",\n          \"text-anchor\": \"textAnchor\",\n          textdecoration: \"textDecoration\",\n          \"text-decoration\": \"textDecoration\",\n          textlength: \"textLength\",\n          textrendering: \"textRendering\",\n          \"text-rendering\": \"textRendering\",\n          to: \"to\",\n          transform: \"transform\",\n          typeof: \"typeof\",\n          u1: \"u1\",\n          u2: \"u2\",\n          underlineposition: \"underlinePosition\",\n          \"underline-position\": \"underlinePosition\",\n          underlinethickness: \"underlineThickness\",\n          \"underline-thickness\": \"underlineThickness\",\n          unicode: \"unicode\",\n          unicodebidi: \"unicodeBidi\",\n          \"unicode-bidi\": \"unicodeBidi\",\n          unicoderange: \"unicodeRange\",\n          \"unicode-range\": \"unicodeRange\",\n          unitsperem: \"unitsPerEm\",\n          \"units-per-em\": \"unitsPerEm\",\n          unselectable: \"unselectable\",\n          valphabetic: \"vAlphabetic\",\n          \"v-alphabetic\": \"vAlphabetic\",\n          values: \"values\",\n          vectoreffect: \"vectorEffect\",\n          \"vector-effect\": \"vectorEffect\",\n          version: \"version\",\n          vertadvy: \"vertAdvY\",\n          \"vert-adv-y\": \"vertAdvY\",\n          vertoriginx: \"vertOriginX\",\n          \"vert-origin-x\": \"vertOriginX\",\n          vertoriginy: \"vertOriginY\",\n          \"vert-origin-y\": \"vertOriginY\",\n          vhanging: \"vHanging\",\n          \"v-hanging\": \"vHanging\",\n          videographic: \"vIdeographic\",\n          \"v-ideographic\": \"vIdeographic\",\n          viewbox: \"viewBox\",\n          viewtarget: \"viewTarget\",\n          visibility: \"visibility\",\n          vmathematical: \"vMathematical\",\n          \"v-mathematical\": \"vMathematical\",\n          vocab: \"vocab\",\n          widths: \"widths\",\n          wordspacing: \"wordSpacing\",\n          \"word-spacing\": \"wordSpacing\",\n          writingmode: \"writingMode\",\n          \"writing-mode\": \"writingMode\",\n          x1: \"x1\",\n          x2: \"x2\",\n          x: \"x\",\n          xchannelselector: \"xChannelSelector\",\n          xheight: \"xHeight\",\n          \"x-height\": \"xHeight\",\n          xlinkactuate: \"xlinkActuate\",\n          \"xlink:actuate\": \"xlinkActuate\",\n          xlinkarcrole: \"xlinkArcrole\",\n          \"xlink:arcrole\": \"xlinkArcrole\",\n          xlinkhref: \"xlinkHref\",\n          \"xlink:href\": \"xlinkHref\",\n          xlinkrole: \"xlinkRole\",\n          \"xlink:role\": \"xlinkRole\",\n          xlinkshow: \"xlinkShow\",\n          \"xlink:show\": \"xlinkShow\",\n          xlinktitle: \"xlinkTitle\",\n          \"xlink:title\": \"xlinkTitle\",\n          xlinktype: \"xlinkType\",\n          \"xlink:type\": \"xlinkType\",\n          xmlbase: \"xmlBase\",\n          \"xml:base\": \"xmlBase\",\n          xmllang: \"xmlLang\",\n          \"xml:lang\": \"xmlLang\",\n          xmlns: \"xmlns\",\n          \"xml:space\": \"xmlSpace\",\n          xmlnsxlink: \"xmlnsXlink\",\n          \"xmlns:xlink\": \"xmlnsXlink\",\n          xmlspace: \"xmlSpace\",\n          y1: \"y1\",\n          y2: \"y2\",\n          y: \"y\",\n          ychannelselector: \"yChannelSelector\",\n          z: \"z\",\n          zoomandpan: \"zoomAndPan\"\n        };\n        var ariaProperties = {\n          \"aria-current\": 0,\n          // state\n          \"aria-description\": 0,\n          \"aria-details\": 0,\n          \"aria-disabled\": 0,\n          // state\n          \"aria-hidden\": 0,\n          // state\n          \"aria-invalid\": 0,\n          // state\n          \"aria-keyshortcuts\": 0,\n          \"aria-label\": 0,\n          \"aria-roledescription\": 0,\n          // Widget Attributes\n          \"aria-autocomplete\": 0,\n          \"aria-checked\": 0,\n          \"aria-expanded\": 0,\n          \"aria-haspopup\": 0,\n          \"aria-level\": 0,\n          \"aria-modal\": 0,\n          \"aria-multiline\": 0,\n          \"aria-multiselectable\": 0,\n          \"aria-orientation\": 0,\n          \"aria-placeholder\": 0,\n          \"aria-pressed\": 0,\n          \"aria-readonly\": 0,\n          \"aria-required\": 0,\n          \"aria-selected\": 0,\n          \"aria-sort\": 0,\n          \"aria-valuemax\": 0,\n          \"aria-valuemin\": 0,\n          \"aria-valuenow\": 0,\n          \"aria-valuetext\": 0,\n          // Live Region Attributes\n          \"aria-atomic\": 0,\n          \"aria-busy\": 0,\n          \"aria-live\": 0,\n          \"aria-relevant\": 0,\n          // Drag-and-Drop Attributes\n          \"aria-dropeffect\": 0,\n          \"aria-grabbed\": 0,\n          // Relationship Attributes\n          \"aria-activedescendant\": 0,\n          \"aria-colcount\": 0,\n          \"aria-colindex\": 0,\n          \"aria-colspan\": 0,\n          \"aria-controls\": 0,\n          \"aria-describedby\": 0,\n          \"aria-errormessage\": 0,\n          \"aria-flowto\": 0,\n          \"aria-labelledby\": 0,\n          \"aria-owns\": 0,\n          \"aria-posinset\": 0,\n          \"aria-rowcount\": 0,\n          \"aria-rowindex\": 0,\n          \"aria-rowspan\": 0,\n          \"aria-setsize\": 0\n        };\n        var warnedProperties = {};\n        var rARIA = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        var rARIACamel = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n        function validateProperty(tagName, name) {\n          {\n            if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {\n              return true;\n            }\n            if (rARIACamel.test(name)) {\n              var ariaName = \"aria-\" + name.slice(4).toLowerCase();\n              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;\n              if (correctName == null) {\n                error(\"Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.\", name);\n                warnedProperties[name] = true;\n                return true;\n              }\n              if (name !== correctName) {\n                error(\"Invalid ARIA attribute `%s`. Did you mean `%s`?\", name, correctName);\n                warnedProperties[name] = true;\n                return true;\n              }\n            }\n            if (rARIA.test(name)) {\n              var lowerCasedName = name.toLowerCase();\n              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;\n              if (standardName == null) {\n                warnedProperties[name] = true;\n                return false;\n              }\n              if (name !== standardName) {\n                error(\"Unknown ARIA attribute `%s`. Did you mean `%s`?\", name, standardName);\n                warnedProperties[name] = true;\n                return true;\n              }\n            }\n          }\n          return true;\n        }\n        function warnInvalidARIAProps(type, props) {\n          {\n            var invalidProps = [];\n            for (var key in props) {\n              var isValid = validateProperty(type, key);\n              if (!isValid) {\n                invalidProps.push(key);\n              }\n            }\n            var unknownPropString = invalidProps.map(function(prop) {\n              return \"`\" + prop + \"`\";\n            }).join(\", \");\n            if (invalidProps.length === 1) {\n              error(\"Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n            } else if (invalidProps.length > 1) {\n              error(\"Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props\", unknownPropString, type);\n            }\n          }\n        }\n        function validateProperties(type, props) {\n          if (isCustomComponent(type, props)) {\n            return;\n          }\n          warnInvalidARIAProps(type, props);\n        }\n        var didWarnValueNull = false;\n        function validateProperties$1(type, props) {\n          {\n            if (type !== \"input\" && type !== \"textarea\" && type !== \"select\") {\n              return;\n            }\n            if (props != null && props.value === null && !didWarnValueNull) {\n              didWarnValueNull = true;\n              if (type === \"select\" && props.multiple) {\n                error(\"`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.\", type);\n              } else {\n                error(\"`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.\", type);\n              }\n            }\n          }\n        }\n        var validateProperty$1 = function() {\n        };\n        {\n          var warnedProperties$1 = {};\n          var EVENT_NAME_REGEX = /^on./;\n          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;\n          var rARIA$1 = new RegExp(\"^(aria)-[\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n          var rARIACamel$1 = new RegExp(\"^(aria)[A-Z][\" + ATTRIBUTE_NAME_CHAR + \"]*$\");\n          validateProperty$1 = function(tagName, name, value, eventRegistry) {\n            if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {\n              return true;\n            }\n            var lowerCasedName = name.toLowerCase();\n            if (lowerCasedName === \"onfocusin\" || lowerCasedName === \"onfocusout\") {\n              error(\"React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.\");\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (eventRegistry != null) {\n              var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;\n              if (registrationNameDependencies2.hasOwnProperty(name)) {\n                return true;\n              }\n              var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;\n              if (registrationName != null) {\n                error(\"Invalid event handler property `%s`. Did you mean `%s`?\", name, registrationName);\n                warnedProperties$1[name] = true;\n                return true;\n              }\n              if (EVENT_NAME_REGEX.test(name)) {\n                error(\"Unknown event handler property `%s`. It will be ignored.\", name);\n                warnedProperties$1[name] = true;\n                return true;\n              }\n            } else if (EVENT_NAME_REGEX.test(name)) {\n              if (INVALID_EVENT_NAME_REGEX.test(name)) {\n                error(\"Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.\", name);\n              }\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (rARIA$1.test(name) || rARIACamel$1.test(name)) {\n              return true;\n            }\n            if (lowerCasedName === \"innerhtml\") {\n              error(\"Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.\");\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (lowerCasedName === \"aria\") {\n              error(\"The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.\");\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (lowerCasedName === \"is\" && value !== null && value !== void 0 && typeof value !== \"string\") {\n              error(\"Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.\", typeof value);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (typeof value === \"number\" && isNaN(value)) {\n              error(\"Received NaN for the `%s` attribute. If this is expected, cast the value to a string.\", name);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            var propertyInfo = getPropertyInfo(name);\n            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;\n            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n              var standardName = possibleStandardNames[lowerCasedName];\n              if (standardName !== name) {\n                error(\"Invalid DOM property `%s`. Did you mean `%s`?\", name, standardName);\n                warnedProperties$1[name] = true;\n                return true;\n              }\n            } else if (!isReserved && name !== lowerCasedName) {\n              error(\"React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.\", name, lowerCasedName);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (typeof value === \"boolean\" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n              if (value) {\n                error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.', value, name, name, value, name);\n              } else {\n                error('Received `%s` for a non-boolean attribute `%s`.\\n\\nIf you want to write it to the DOM, pass a string instead: %s=\"%s\" or %s={value.toString()}.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name, name, value, name, name, name);\n              }\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            if (isReserved) {\n              return true;\n            }\n            if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {\n              warnedProperties$1[name] = true;\n              return false;\n            }\n            if ((value === \"false\" || value === \"true\") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {\n              error(\"Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?\", value, name, value === \"false\" ? \"The browser will interpret it as a truthy value.\" : 'Although this works, it will not work as expected if you pass the string \"false\".', name, value);\n              warnedProperties$1[name] = true;\n              return true;\n            }\n            return true;\n          };\n        }\n        var warnUnknownProperties = function(type, props, eventRegistry) {\n          {\n            var unknownProps = [];\n            for (var key in props) {\n              var isValid = validateProperty$1(type, key, props[key], eventRegistry);\n              if (!isValid) {\n                unknownProps.push(key);\n              }\n            }\n            var unknownPropString = unknownProps.map(function(prop) {\n              return \"`\" + prop + \"`\";\n            }).join(\", \");\n            if (unknownProps.length === 1) {\n              error(\"Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n            } else if (unknownProps.length > 1) {\n              error(\"Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior \", unknownPropString, type);\n            }\n          }\n        };\n        function validateProperties$2(type, props, eventRegistry) {\n          if (isCustomComponent(type, props)) {\n            return;\n          }\n          warnUnknownProperties(type, props, eventRegistry);\n        }\n        var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;\n        var IS_NON_DELEGATED = 1 << 1;\n        var IS_CAPTURE_PHASE = 1 << 2;\n        var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;\n        var currentReplayingEvent = null;\n        function setReplayingEvent(event) {\n          {\n            if (currentReplayingEvent !== null) {\n              error(\"Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          currentReplayingEvent = event;\n        }\n        function resetReplayingEvent() {\n          {\n            if (currentReplayingEvent === null) {\n              error(\"Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          currentReplayingEvent = null;\n        }\n        function isReplayingEvent(event) {\n          return event === currentReplayingEvent;\n        }\n        function getEventTarget(nativeEvent) {\n          var target = nativeEvent.target || nativeEvent.srcElement || window;\n          if (target.correspondingUseElement) {\n            target = target.correspondingUseElement;\n          }\n          return target.nodeType === TEXT_NODE ? target.parentNode : target;\n        }\n        var restoreImpl = null;\n        var restoreTarget = null;\n        var restoreQueue = null;\n        function restoreStateOfTarget(target) {\n          var internalInstance = getInstanceFromNode(target);\n          if (!internalInstance) {\n            return;\n          }\n          if (typeof restoreImpl !== \"function\") {\n            throw new Error(\"setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          var stateNode = internalInstance.stateNode;\n          if (stateNode) {\n            var _props = getFiberCurrentPropsFromNode(stateNode);\n            restoreImpl(internalInstance.stateNode, internalInstance.type, _props);\n          }\n        }\n        function setRestoreImplementation(impl) {\n          restoreImpl = impl;\n        }\n        function enqueueStateRestore(target) {\n          if (restoreTarget) {\n            if (restoreQueue) {\n              restoreQueue.push(target);\n            } else {\n              restoreQueue = [target];\n            }\n          } else {\n            restoreTarget = target;\n          }\n        }\n        function needsStateRestore() {\n          return restoreTarget !== null || restoreQueue !== null;\n        }\n        function restoreStateIfNeeded() {\n          if (!restoreTarget) {\n            return;\n          }\n          var target = restoreTarget;\n          var queuedTargets = restoreQueue;\n          restoreTarget = null;\n          restoreQueue = null;\n          restoreStateOfTarget(target);\n          if (queuedTargets) {\n            for (var i = 0; i < queuedTargets.length; i++) {\n              restoreStateOfTarget(queuedTargets[i]);\n            }\n          }\n        }\n        var batchedUpdatesImpl = function(fn, bookkeeping) {\n          return fn(bookkeeping);\n        };\n        var flushSyncImpl = function() {\n        };\n        var isInsideEventHandler = false;\n        function finishEventHandler() {\n          var controlledComponentsHavePendingUpdates = needsStateRestore();\n          if (controlledComponentsHavePendingUpdates) {\n            flushSyncImpl();\n            restoreStateIfNeeded();\n          }\n        }\n        function batchedUpdates(fn, a, b) {\n          if (isInsideEventHandler) {\n            return fn(a, b);\n          }\n          isInsideEventHandler = true;\n          try {\n            return batchedUpdatesImpl(fn, a, b);\n          } finally {\n            isInsideEventHandler = false;\n            finishEventHandler();\n          }\n        }\n        function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {\n          batchedUpdatesImpl = _batchedUpdatesImpl;\n          flushSyncImpl = _flushSyncImpl;\n        }\n        function isInteractive(tag) {\n          return tag === \"button\" || tag === \"input\" || tag === \"select\" || tag === \"textarea\";\n        }\n        function shouldPreventMouseEvent(name, type, props) {\n          switch (name) {\n            case \"onClick\":\n            case \"onClickCapture\":\n            case \"onDoubleClick\":\n            case \"onDoubleClickCapture\":\n            case \"onMouseDown\":\n            case \"onMouseDownCapture\":\n            case \"onMouseMove\":\n            case \"onMouseMoveCapture\":\n            case \"onMouseUp\":\n            case \"onMouseUpCapture\":\n            case \"onMouseEnter\":\n              return !!(props.disabled && isInteractive(type));\n            default:\n              return false;\n          }\n        }\n        function getListener(inst, registrationName) {\n          var stateNode = inst.stateNode;\n          if (stateNode === null) {\n            return null;\n          }\n          var props = getFiberCurrentPropsFromNode(stateNode);\n          if (props === null) {\n            return null;\n          }\n          var listener = props[registrationName];\n          if (shouldPreventMouseEvent(registrationName, inst.type, props)) {\n            return null;\n          }\n          if (listener && typeof listener !== \"function\") {\n            throw new Error(\"Expected `\" + registrationName + \"` listener to be a function, instead got a value of `\" + typeof listener + \"` type.\");\n          }\n          return listener;\n        }\n        var passiveBrowserEventsSupported = false;\n        if (canUseDOM) {\n          try {\n            var options = {};\n            Object.defineProperty(options, \"passive\", {\n              get: function() {\n                passiveBrowserEventsSupported = true;\n              }\n            });\n            window.addEventListener(\"test\", options, options);\n            window.removeEventListener(\"test\", options, options);\n          } catch (e) {\n            passiveBrowserEventsSupported = false;\n          }\n        }\n        function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n          var funcArgs = Array.prototype.slice.call(arguments, 3);\n          try {\n            func.apply(context, funcArgs);\n          } catch (error2) {\n            this.onError(error2);\n          }\n        }\n        var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n        {\n          if (typeof window !== \"undefined\" && typeof window.dispatchEvent === \"function\" && typeof document !== \"undefined\" && typeof document.createEvent === \"function\") {\n            var fakeNode = document.createElement(\"react\");\n            invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n              if (typeof document === \"undefined\" || document === null) {\n                throw new Error(\"The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.\");\n              }\n              var evt = document.createEvent(\"Event\");\n              var didCall = false;\n              var didError = true;\n              var windowEvent = window.event;\n              var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, \"event\");\n              function restoreAfterDispatch() {\n                fakeNode.removeEventListener(evtType, callCallback2, false);\n                if (typeof window.event !== \"undefined\" && window.hasOwnProperty(\"event\")) {\n                  window.event = windowEvent;\n                }\n              }\n              var funcArgs = Array.prototype.slice.call(arguments, 3);\n              function callCallback2() {\n                didCall = true;\n                restoreAfterDispatch();\n                func.apply(context, funcArgs);\n                didError = false;\n              }\n              var error2;\n              var didSetError = false;\n              var isCrossOriginError = false;\n              function handleWindowError(event) {\n                error2 = event.error;\n                didSetError = true;\n                if (error2 === null && event.colno === 0 && event.lineno === 0) {\n                  isCrossOriginError = true;\n                }\n                if (event.defaultPrevented) {\n                  if (error2 != null && typeof error2 === \"object\") {\n                    try {\n                      error2._suppressLogging = true;\n                    } catch (inner) {\n                    }\n                  }\n                }\n              }\n              var evtType = \"react-\" + (name ? name : \"invokeguardedcallback\");\n              window.addEventListener(\"error\", handleWindowError);\n              fakeNode.addEventListener(evtType, callCallback2, false);\n              evt.initEvent(evtType, false, false);\n              fakeNode.dispatchEvent(evt);\n              if (windowEventDescriptor) {\n                Object.defineProperty(window, \"event\", windowEventDescriptor);\n              }\n              if (didCall && didError) {\n                if (!didSetError) {\n                  error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \"Pause on exceptions\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);\n                } else if (isCrossOriginError) {\n                  error2 = new Error(\"A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.\");\n                }\n                this.onError(error2);\n              }\n              window.removeEventListener(\"error\", handleWindowError);\n              if (!didCall) {\n                restoreAfterDispatch();\n                return invokeGuardedCallbackProd.apply(this, arguments);\n              }\n            };\n          }\n        }\n        var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n        var hasError = false;\n        var caughtError = null;\n        var hasRethrowError = false;\n        var rethrowError = null;\n        var reporter = {\n          onError: function(error2) {\n            hasError = true;\n            caughtError = error2;\n          }\n        };\n        function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n          hasError = false;\n          caughtError = null;\n          invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n        }\n        function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {\n          invokeGuardedCallback.apply(this, arguments);\n          if (hasError) {\n            var error2 = clearCaughtError();\n            if (!hasRethrowError) {\n              hasRethrowError = true;\n              rethrowError = error2;\n            }\n          }\n        }\n        function rethrowCaughtError() {\n          if (hasRethrowError) {\n            var error2 = rethrowError;\n            hasRethrowError = false;\n            rethrowError = null;\n            throw error2;\n          }\n        }\n        function hasCaughtError() {\n          return hasError;\n        }\n        function clearCaughtError() {\n          if (hasError) {\n            var error2 = caughtError;\n            hasError = false;\n            caughtError = null;\n            return error2;\n          } else {\n            throw new Error(\"clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        function get(key) {\n          return key._reactInternals;\n        }\n        function has(key) {\n          return key._reactInternals !== void 0;\n        }\n        function set(key, value) {\n          key._reactInternals = value;\n        }\n        var NoFlags = (\n          /*                      */\n          0\n        );\n        var PerformedWork = (\n          /*                */\n          1\n        );\n        var Placement = (\n          /*                    */\n          2\n        );\n        var Update = (\n          /*                       */\n          4\n        );\n        var ChildDeletion = (\n          /*                */\n          16\n        );\n        var ContentReset = (\n          /*                 */\n          32\n        );\n        var Callback = (\n          /*                     */\n          64\n        );\n        var DidCapture = (\n          /*                   */\n          128\n        );\n        var ForceClientRender = (\n          /*            */\n          256\n        );\n        var Ref = (\n          /*                          */\n          512\n        );\n        var Snapshot = (\n          /*                     */\n          1024\n        );\n        var Passive = (\n          /*                      */\n          2048\n        );\n        var Hydrating = (\n          /*                    */\n          4096\n        );\n        var Visibility = (\n          /*                   */\n          8192\n        );\n        var StoreConsistency = (\n          /*             */\n          16384\n        );\n        var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;\n        var HostEffectMask = (\n          /*               */\n          32767\n        );\n        var Incomplete = (\n          /*                   */\n          32768\n        );\n        var ShouldCapture = (\n          /*                */\n          65536\n        );\n        var ForceUpdateForLegacySuspense = (\n          /* */\n          131072\n        );\n        var Forked = (\n          /*                       */\n          1048576\n        );\n        var RefStatic = (\n          /*                    */\n          2097152\n        );\n        var LayoutStatic = (\n          /*                 */\n          4194304\n        );\n        var PassiveStatic = (\n          /*                */\n          8388608\n        );\n        var MountLayoutDev = (\n          /*               */\n          16777216\n        );\n        var MountPassiveDev = (\n          /*              */\n          33554432\n        );\n        var BeforeMutationMask = (\n          // TODO: Remove Update flag from before mutation phase by re-landing Visibility\n          // flag logic (see #20043)\n          Update | Snapshot | 0\n        );\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\n        var LayoutMask = Update | Callback | Ref | Visibility;\n        var PassiveMask = Passive | ChildDeletion;\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        function getNearestMountedFiber(fiber) {\n          var node = fiber;\n          var nearestMounted = fiber;\n          if (!fiber.alternate) {\n            var nextNode = node;\n            do {\n              node = nextNode;\n              if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n                nearestMounted = node.return;\n              }\n              nextNode = node.return;\n            } while (nextNode);\n          } else {\n            while (node.return) {\n              node = node.return;\n            }\n          }\n          if (node.tag === HostRoot) {\n            return nearestMounted;\n          }\n          return null;\n        }\n        function getSuspenseInstanceFromFiber(fiber) {\n          if (fiber.tag === SuspenseComponent) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState === null) {\n              var current2 = fiber.alternate;\n              if (current2 !== null) {\n                suspenseState = current2.memoizedState;\n              }\n            }\n            if (suspenseState !== null) {\n              return suspenseState.dehydrated;\n            }\n          }\n          return null;\n        }\n        function getContainerFromFiber(fiber) {\n          return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;\n        }\n        function isFiberMounted(fiber) {\n          return getNearestMountedFiber(fiber) === fiber;\n        }\n        function isMounted(component) {\n          {\n            var owner = ReactCurrentOwner.current;\n            if (owner !== null && owner.tag === ClassComponent) {\n              var ownerFiber = owner;\n              var instance = ownerFiber.stateNode;\n              if (!instance._warnedAboutRefsInRender) {\n                error(\"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromFiber(ownerFiber) || \"A component\");\n              }\n              instance._warnedAboutRefsInRender = true;\n            }\n          }\n          var fiber = get(component);\n          if (!fiber) {\n            return false;\n          }\n          return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n          if (getNearestMountedFiber(fiber) !== fiber) {\n            throw new Error(\"Unable to find node on an unmounted component.\");\n          }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n          var alternate = fiber.alternate;\n          if (!alternate) {\n            var nearestMounted = getNearestMountedFiber(fiber);\n            if (nearestMounted === null) {\n              throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (nearestMounted !== fiber) {\n              return null;\n            }\n            return fiber;\n          }\n          var a = fiber;\n          var b = alternate;\n          while (true) {\n            var parentA = a.return;\n            if (parentA === null) {\n              break;\n            }\n            var parentB = parentA.alternate;\n            if (parentB === null) {\n              var nextParent = parentA.return;\n              if (nextParent !== null) {\n                a = b = nextParent;\n                continue;\n              }\n              break;\n            }\n            if (parentA.child === parentB.child) {\n              var child = parentA.child;\n              while (child) {\n                if (child === a) {\n                  assertIsMounted(parentA);\n                  return fiber;\n                }\n                if (child === b) {\n                  assertIsMounted(parentA);\n                  return alternate;\n                }\n                child = child.sibling;\n              }\n              throw new Error(\"Unable to find node on an unmounted component.\");\n            }\n            if (a.return !== b.return) {\n              a = parentA;\n              b = parentB;\n            } else {\n              var didFindChild = false;\n              var _child = parentA.child;\n              while (_child) {\n                if (_child === a) {\n                  didFindChild = true;\n                  a = parentA;\n                  b = parentB;\n                  break;\n                }\n                if (_child === b) {\n                  didFindChild = true;\n                  b = parentA;\n                  a = parentB;\n                  break;\n                }\n                _child = _child.sibling;\n              }\n              if (!didFindChild) {\n                _child = parentB.child;\n                while (_child) {\n                  if (_child === a) {\n                    didFindChild = true;\n                    a = parentB;\n                    b = parentA;\n                    break;\n                  }\n                  if (_child === b) {\n                    didFindChild = true;\n                    b = parentB;\n                    a = parentA;\n                    break;\n                  }\n                  _child = _child.sibling;\n                }\n                if (!didFindChild) {\n                  throw new Error(\"Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.\");\n                }\n              }\n            }\n            if (a.alternate !== b) {\n              throw new Error(\"Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          if (a.tag !== HostRoot) {\n            throw new Error(\"Unable to find node on an unmounted component.\");\n          }\n          if (a.stateNode.current === a) {\n            return fiber;\n          }\n          return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n          var currentParent = findCurrentFiberUsingSlowPath(parent);\n          return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            return node;\n          }\n          var child = node.child;\n          while (child !== null) {\n            var match = findCurrentHostFiberImpl(child);\n            if (match !== null) {\n              return match;\n            }\n            child = child.sibling;\n          }\n          return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n          var currentParent = findCurrentFiberUsingSlowPath(parent);\n          return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n          if (node.tag === HostComponent || node.tag === HostText) {\n            return node;\n          }\n          var child = node.child;\n          while (child !== null) {\n            if (child.tag !== HostPortal) {\n              var match = findCurrentHostFiberWithNoPortalsImpl(child);\n              if (match !== null) {\n                return match;\n              }\n            }\n            child = child.sibling;\n          }\n          return null;\n        }\n        var scheduleCallback = Scheduler.unstable_scheduleCallback;\n        var cancelCallback = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now = Scheduler.unstable_now;\n        var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority = Scheduler.unstable_NormalPriority;\n        var LowPriority = Scheduler.unstable_LowPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority;\n        var unstable_yieldValue = Scheduler.unstable_yieldValue;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\";\n        function injectInternals(internals) {\n          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\") {\n            return false;\n          }\n          var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n          if (hook.isDisabled) {\n            return true;\n          }\n          if (!hook.supportsFiber) {\n            {\n              error(\"The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools\");\n            }\n            return true;\n          }\n          try {\n            if (enableSchedulingProfiler) {\n              internals = assign({}, internals, {\n                getLaneLabelMap,\n                injectProfilingHooks\n              });\n            }\n            rendererID = hook.inject(internals);\n            injectedHook = hook;\n          } catch (err) {\n            {\n              error(\"React instrumentation encountered an error: %s.\", err);\n            }\n          }\n          if (hook.checkDCE) {\n            return true;\n          } else {\n            return false;\n          }\n        }\n        function onScheduleRoot(root2, children) {\n          {\n            if (injectedHook && typeof injectedHook.onScheduleFiberRoot === \"function\") {\n              try {\n                injectedHook.onScheduleFiberRoot(rendererID, root2, children);\n              } catch (err) {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function onCommitRoot(root2, eventPriority) {\n          if (injectedHook && typeof injectedHook.onCommitFiberRoot === \"function\") {\n            try {\n              var didError = (root2.current.flags & DidCapture) === DidCapture;\n              if (enableProfilerTimer) {\n                var schedulerPriority;\n                switch (eventPriority) {\n                  case DiscreteEventPriority:\n                    schedulerPriority = ImmediatePriority;\n                    break;\n                  case ContinuousEventPriority:\n                    schedulerPriority = UserBlockingPriority;\n                    break;\n                  case DefaultEventPriority:\n                    schedulerPriority = NormalPriority;\n                    break;\n                  case IdleEventPriority:\n                    schedulerPriority = IdlePriority;\n                    break;\n                  default:\n                    schedulerPriority = NormalPriority;\n                    break;\n                }\n                injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);\n              } else {\n                injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);\n              }\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function onPostCommitRoot(root2) {\n          if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === \"function\") {\n            try {\n              injectedHook.onPostCommitFiberRoot(rendererID, root2);\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function onCommitUnmount(fiber) {\n          if (injectedHook && typeof injectedHook.onCommitFiberUnmount === \"function\") {\n            try {\n              injectedHook.onCommitFiberUnmount(rendererID, fiber);\n            } catch (err) {\n              {\n                if (!hasLoggedError) {\n                  hasLoggedError = true;\n                  error(\"React instrumentation encountered an error: %s\", err);\n                }\n              }\n            }\n          }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n          {\n            if (typeof unstable_yieldValue === \"function\") {\n              unstable_setDisableYieldValue(newIsStrictMode);\n              setSuppressWarning(newIsStrictMode);\n            }\n            if (injectedHook && typeof injectedHook.setStrictMode === \"function\") {\n              try {\n                injectedHook.setStrictMode(rendererID, newIsStrictMode);\n              } catch (err) {\n                {\n                  if (!hasLoggedError) {\n                    hasLoggedError = true;\n                    error(\"React instrumentation encountered an error: %s\", err);\n                  }\n                }\n              }\n            }\n          }\n        }\n        function injectProfilingHooks(profilingHooks) {\n          injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n          {\n            var map = /* @__PURE__ */ new Map();\n            var lane = 1;\n            for (var index2 = 0; index2 < TotalLanes; index2++) {\n              var label = getLabelForLane(lane);\n              map.set(lane, label);\n              lane *= 2;\n            }\n            return map;\n          }\n        }\n        function markCommitStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === \"function\") {\n              injectedProfilingHooks.markCommitStarted(lanes);\n            }\n          }\n        }\n        function markCommitStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === \"function\") {\n              injectedProfilingHooks.markCommitStopped();\n            }\n          }\n        }\n        function markComponentRenderStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === \"function\") {\n              injectedProfilingHooks.markComponentRenderStarted(fiber);\n            }\n          }\n        }\n        function markComponentRenderStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === \"function\") {\n              injectedProfilingHooks.markComponentRenderStopped();\n            }\n          }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n            }\n          }\n        }\n        function markComponentPassiveEffectMountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n            }\n          }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n            }\n          }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === \"function\") {\n              injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n            }\n          }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n            }\n          }\n        }\n        function markComponentLayoutEffectMountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n            }\n          }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n            }\n          }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === \"function\") {\n              injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === \"function\") {\n              injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n            }\n          }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === \"function\") {\n              injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n            }\n          }\n        }\n        function markLayoutEffectsStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === \"function\") {\n              injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n            }\n          }\n        }\n        function markLayoutEffectsStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === \"function\") {\n              injectedProfilingHooks.markLayoutEffectsStopped();\n            }\n          }\n        }\n        function markPassiveEffectsStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === \"function\") {\n              injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n            }\n          }\n        }\n        function markPassiveEffectsStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === \"function\") {\n              injectedProfilingHooks.markPassiveEffectsStopped();\n            }\n          }\n        }\n        function markRenderStarted(lanes) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === \"function\") {\n              injectedProfilingHooks.markRenderStarted(lanes);\n            }\n          }\n        }\n        function markRenderYielded() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === \"function\") {\n              injectedProfilingHooks.markRenderYielded();\n            }\n          }\n        }\n        function markRenderStopped() {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === \"function\") {\n              injectedProfilingHooks.markRenderStopped();\n            }\n          }\n        }\n        function markRenderScheduled(lane) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === \"function\") {\n              injectedProfilingHooks.markRenderScheduled(lane);\n            }\n          }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === \"function\") {\n              injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n            }\n          }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n          {\n            if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === \"function\") {\n              injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n            }\n          }\n        }\n        var NoMode = (\n          /*                         */\n          0\n        );\n        var ConcurrentMode = (\n          /*                 */\n          1\n        );\n        var ProfileMode = (\n          /*                    */\n          2\n        );\n        var StrictLegacyMode = (\n          /*               */\n          8\n        );\n        var StrictEffectsMode = (\n          /*              */\n          16\n        );\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;\n        var log = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n          var asUint = x >>> 0;\n          if (asUint === 0) {\n            return 32;\n          }\n          return 31 - (log(asUint) / LN2 | 0) | 0;\n        }\n        var TotalLanes = 31;\n        var NoLanes = (\n          /*                        */\n          0\n        );\n        var NoLane = (\n          /*                          */\n          0\n        );\n        var SyncLane = (\n          /*                        */\n          1\n        );\n        var InputContinuousHydrationLane = (\n          /*    */\n          2\n        );\n        var InputContinuousLane = (\n          /*             */\n          4\n        );\n        var DefaultHydrationLane = (\n          /*            */\n          8\n        );\n        var DefaultLane = (\n          /*                     */\n          16\n        );\n        var TransitionHydrationLane = (\n          /*                */\n          32\n        );\n        var TransitionLanes = (\n          /*                       */\n          4194240\n        );\n        var TransitionLane1 = (\n          /*                        */\n          64\n        );\n        var TransitionLane2 = (\n          /*                        */\n          128\n        );\n        var TransitionLane3 = (\n          /*                        */\n          256\n        );\n        var TransitionLane4 = (\n          /*                        */\n          512\n        );\n        var TransitionLane5 = (\n          /*                        */\n          1024\n        );\n        var TransitionLane6 = (\n          /*                        */\n          2048\n        );\n        var TransitionLane7 = (\n          /*                        */\n          4096\n        );\n        var TransitionLane8 = (\n          /*                        */\n          8192\n        );\n        var TransitionLane9 = (\n          /*                        */\n          16384\n        );\n        var TransitionLane10 = (\n          /*                       */\n          32768\n        );\n        var TransitionLane11 = (\n          /*                       */\n          65536\n        );\n        var TransitionLane12 = (\n          /*                       */\n          131072\n        );\n        var TransitionLane13 = (\n          /*                       */\n          262144\n        );\n        var TransitionLane14 = (\n          /*                       */\n          524288\n        );\n        var TransitionLane15 = (\n          /*                       */\n          1048576\n        );\n        var TransitionLane16 = (\n          /*                       */\n          2097152\n        );\n        var RetryLanes = (\n          /*                            */\n          130023424\n        );\n        var RetryLane1 = (\n          /*                             */\n          4194304\n        );\n        var RetryLane2 = (\n          /*                             */\n          8388608\n        );\n        var RetryLane3 = (\n          /*                             */\n          16777216\n        );\n        var RetryLane4 = (\n          /*                             */\n          33554432\n        );\n        var RetryLane5 = (\n          /*                             */\n          67108864\n        );\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = (\n          /*          */\n          134217728\n        );\n        var NonIdleLanes = (\n          /*                          */\n          268435455\n        );\n        var IdleHydrationLane = (\n          /*               */\n          268435456\n        );\n        var IdleLane = (\n          /*                        */\n          536870912\n        );\n        var OffscreenLane = (\n          /*                   */\n          1073741824\n        );\n        function getLabelForLane(lane) {\n          {\n            if (lane & SyncLane) {\n              return \"Sync\";\n            }\n            if (lane & InputContinuousHydrationLane) {\n              return \"InputContinuousHydration\";\n            }\n            if (lane & InputContinuousLane) {\n              return \"InputContinuous\";\n            }\n            if (lane & DefaultHydrationLane) {\n              return \"DefaultHydration\";\n            }\n            if (lane & DefaultLane) {\n              return \"Default\";\n            }\n            if (lane & TransitionHydrationLane) {\n              return \"TransitionHydration\";\n            }\n            if (lane & TransitionLanes) {\n              return \"Transition\";\n            }\n            if (lane & RetryLanes) {\n              return \"Retry\";\n            }\n            if (lane & SelectiveHydrationLane) {\n              return \"SelectiveHydration\";\n            }\n            if (lane & IdleHydrationLane) {\n              return \"IdleHydration\";\n            }\n            if (lane & IdleLane) {\n              return \"Idle\";\n            }\n            if (lane & OffscreenLane) {\n              return \"Offscreen\";\n            }\n          }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n          switch (getHighestPriorityLane(lanes)) {\n            case SyncLane:\n              return SyncLane;\n            case InputContinuousHydrationLane:\n              return InputContinuousHydrationLane;\n            case InputContinuousLane:\n              return InputContinuousLane;\n            case DefaultHydrationLane:\n              return DefaultHydrationLane;\n            case DefaultLane:\n              return DefaultLane;\n            case TransitionHydrationLane:\n              return TransitionHydrationLane;\n            case TransitionLane1:\n            case TransitionLane2:\n            case TransitionLane3:\n            case TransitionLane4:\n            case TransitionLane5:\n            case TransitionLane6:\n            case TransitionLane7:\n            case TransitionLane8:\n            case TransitionLane9:\n            case TransitionLane10:\n            case TransitionLane11:\n            case TransitionLane12:\n            case TransitionLane13:\n            case TransitionLane14:\n            case TransitionLane15:\n            case TransitionLane16:\n              return lanes & TransitionLanes;\n            case RetryLane1:\n            case RetryLane2:\n            case RetryLane3:\n            case RetryLane4:\n            case RetryLane5:\n              return lanes & RetryLanes;\n            case SelectiveHydrationLane:\n              return SelectiveHydrationLane;\n            case IdleHydrationLane:\n              return IdleHydrationLane;\n            case IdleLane:\n              return IdleLane;\n            case OffscreenLane:\n              return OffscreenLane;\n            default:\n              {\n                error(\"Should have found matching lanes. This is a bug in React.\");\n              }\n              return lanes;\n          }\n        }\n        function getNextLanes(root2, wipLanes) {\n          var pendingLanes = root2.pendingLanes;\n          if (pendingLanes === NoLanes) {\n            return NoLanes;\n          }\n          var nextLanes = NoLanes;\n          var suspendedLanes = root2.suspendedLanes;\n          var pingedLanes = root2.pingedLanes;\n          var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n          if (nonIdlePendingLanes !== NoLanes) {\n            var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n            if (nonIdleUnblockedLanes !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n            } else {\n              var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n              if (nonIdlePingedLanes !== NoLanes) {\n                nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n              }\n            }\n          } else {\n            var unblockedLanes = pendingLanes & ~suspendedLanes;\n            if (unblockedLanes !== NoLanes) {\n              nextLanes = getHighestPriorityLanes(unblockedLanes);\n            } else {\n              if (pingedLanes !== NoLanes) {\n                nextLanes = getHighestPriorityLanes(pingedLanes);\n              }\n            }\n          }\n          if (nextLanes === NoLanes) {\n            return NoLanes;\n          }\n          if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n          // bother waiting until the root is complete.\n          (wipLanes & suspendedLanes) === NoLanes) {\n            var nextLane = getHighestPriorityLane(nextLanes);\n            var wipLane = getHighestPriorityLane(wipLanes);\n            if (\n              // Tests whether the next lane is equal or lower priority than the wip\n              // one. This works because the bits decrease in priority as you go left.\n              nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n              // only difference between default updates and transition updates is that\n              // default updates do not support refresh transitions.\n              nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes\n            ) {\n              return wipLanes;\n            }\n          }\n          if ((nextLanes & InputContinuousLane) !== NoLanes) {\n            nextLanes |= pendingLanes & DefaultLane;\n          }\n          var entangledLanes = root2.entangledLanes;\n          if (entangledLanes !== NoLanes) {\n            var entanglements = root2.entanglements;\n            var lanes = nextLanes & entangledLanes;\n            while (lanes > 0) {\n              var index2 = pickArbitraryLaneIndex(lanes);\n              var lane = 1 << index2;\n              nextLanes |= entanglements[index2];\n              lanes &= ~lane;\n            }\n          }\n          return nextLanes;\n        }\n        function getMostRecentEventTime(root2, lanes) {\n          var eventTimes = root2.eventTimes;\n          var mostRecentEventTime = NoTimestamp;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            var eventTime = eventTimes[index2];\n            if (eventTime > mostRecentEventTime) {\n              mostRecentEventTime = eventTime;\n            }\n            lanes &= ~lane;\n          }\n          return mostRecentEventTime;\n        }\n        function computeExpirationTime(lane, currentTime) {\n          switch (lane) {\n            case SyncLane:\n            case InputContinuousHydrationLane:\n            case InputContinuousLane:\n              return currentTime + 250;\n            case DefaultHydrationLane:\n            case DefaultLane:\n            case TransitionHydrationLane:\n            case TransitionLane1:\n            case TransitionLane2:\n            case TransitionLane3:\n            case TransitionLane4:\n            case TransitionLane5:\n            case TransitionLane6:\n            case TransitionLane7:\n            case TransitionLane8:\n            case TransitionLane9:\n            case TransitionLane10:\n            case TransitionLane11:\n            case TransitionLane12:\n            case TransitionLane13:\n            case TransitionLane14:\n            case TransitionLane15:\n            case TransitionLane16:\n              return currentTime + 5e3;\n            case RetryLane1:\n            case RetryLane2:\n            case RetryLane3:\n            case RetryLane4:\n            case RetryLane5:\n              return NoTimestamp;\n            case SelectiveHydrationLane:\n            case IdleHydrationLane:\n            case IdleLane:\n            case OffscreenLane:\n              return NoTimestamp;\n            default:\n              {\n                error(\"Should have found matching lanes. This is a bug in React.\");\n              }\n              return NoTimestamp;\n          }\n        }\n        function markStarvedLanesAsExpired(root2, currentTime) {\n          var pendingLanes = root2.pendingLanes;\n          var suspendedLanes = root2.suspendedLanes;\n          var pingedLanes = root2.pingedLanes;\n          var expirationTimes = root2.expirationTimes;\n          var lanes = pendingLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            var expirationTime = expirationTimes[index2];\n            if (expirationTime === NoTimestamp) {\n              if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                expirationTimes[index2] = computeExpirationTime(lane, currentTime);\n              }\n            } else if (expirationTime <= currentTime) {\n              root2.expiredLanes |= lane;\n            }\n            lanes &= ~lane;\n          }\n        }\n        function getHighestPriorityPendingLanes(root2) {\n          return getHighestPriorityLanes(root2.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root2) {\n          var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;\n          if (everythingButOffscreen !== NoLanes) {\n            return everythingButOffscreen;\n          }\n          if (everythingButOffscreen & OffscreenLane) {\n            return OffscreenLane;\n          }\n          return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n          return (lanes & SyncLane) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n          return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n          return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyNonUrgentLanes(lanes) {\n          var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n          return (lanes & UrgentLanes) === NoLanes;\n        }\n        function includesOnlyTransitions(lanes) {\n          return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root2, lanes) {\n          var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n          return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root2, lanes) {\n          return (lanes & root2.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n          return (lane & TransitionLanes) !== NoLanes;\n        }\n        function claimNextTransitionLane() {\n          var lane = nextTransitionLane;\n          nextTransitionLane <<= 1;\n          if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n            nextTransitionLane = TransitionLane1;\n          }\n          return lane;\n        }\n        function claimNextRetryLane() {\n          var lane = nextRetryLane;\n          nextRetryLane <<= 1;\n          if ((nextRetryLane & RetryLanes) === NoLanes) {\n            nextRetryLane = RetryLane1;\n          }\n          return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n          return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n          return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n          return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n          return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n          return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set2, subset) {\n          return (set2 & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n          return a | b;\n        }\n        function removeLanes(set2, subset) {\n          return set2 & ~subset;\n        }\n        function intersectLanes(a, b) {\n          return a & b;\n        }\n        function laneToLanes(lane) {\n          return lane;\n        }\n        function higherPriorityLane(a, b) {\n          return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n          var laneMap = [];\n          for (var i = 0; i < TotalLanes; i++) {\n            laneMap.push(initial);\n          }\n          return laneMap;\n        }\n        function markRootUpdated(root2, updateLane, eventTime) {\n          root2.pendingLanes |= updateLane;\n          if (updateLane !== IdleLane) {\n            root2.suspendedLanes = NoLanes;\n            root2.pingedLanes = NoLanes;\n          }\n          var eventTimes = root2.eventTimes;\n          var index2 = laneToIndex(updateLane);\n          eventTimes[index2] = eventTime;\n        }\n        function markRootSuspended(root2, suspendedLanes) {\n          root2.suspendedLanes |= suspendedLanes;\n          root2.pingedLanes &= ~suspendedLanes;\n          var expirationTimes = root2.expirationTimes;\n          var lanes = suspendedLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            expirationTimes[index2] = NoTimestamp;\n            lanes &= ~lane;\n          }\n        }\n        function markRootPinged(root2, pingedLanes, eventTime) {\n          root2.pingedLanes |= root2.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root2, remainingLanes) {\n          var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;\n          root2.pendingLanes = remainingLanes;\n          root2.suspendedLanes = NoLanes;\n          root2.pingedLanes = NoLanes;\n          root2.expiredLanes &= remainingLanes;\n          root2.mutableReadLanes &= remainingLanes;\n          root2.entangledLanes &= remainingLanes;\n          var entanglements = root2.entanglements;\n          var eventTimes = root2.eventTimes;\n          var expirationTimes = root2.expirationTimes;\n          var lanes = noLongerPendingLanes;\n          while (lanes > 0) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            entanglements[index2] = NoLanes;\n            eventTimes[index2] = NoTimestamp;\n            expirationTimes[index2] = NoTimestamp;\n            lanes &= ~lane;\n          }\n        }\n        function markRootEntangled(root2, entangledLanes) {\n          var rootEntangledLanes = root2.entangledLanes |= entangledLanes;\n          var entanglements = root2.entanglements;\n          var lanes = rootEntangledLanes;\n          while (lanes) {\n            var index2 = pickArbitraryLaneIndex(lanes);\n            var lane = 1 << index2;\n            if (\n              // Is this one of the newly entangled lanes?\n              lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n              entanglements[index2] & entangledLanes\n            ) {\n              entanglements[index2] |= entangledLanes;\n            }\n            lanes &= ~lane;\n          }\n        }\n        function getBumpedLaneForHydration(root2, renderLanes2) {\n          var renderLane = getHighestPriorityLane(renderLanes2);\n          var lane;\n          switch (renderLane) {\n            case InputContinuousLane:\n              lane = InputContinuousHydrationLane;\n              break;\n            case DefaultLane:\n              lane = DefaultHydrationLane;\n              break;\n            case TransitionLane1:\n            case TransitionLane2:\n            case TransitionLane3:\n            case TransitionLane4:\n            case TransitionLane5:\n            case TransitionLane6:\n            case TransitionLane7:\n            case TransitionLane8:\n            case TransitionLane9:\n            case TransitionLane10:\n            case TransitionLane11:\n            case TransitionLane12:\n            case TransitionLane13:\n            case TransitionLane14:\n            case TransitionLane15:\n            case TransitionLane16:\n            case RetryLane1:\n            case RetryLane2:\n            case RetryLane3:\n            case RetryLane4:\n            case RetryLane5:\n              lane = TransitionHydrationLane;\n              break;\n            case IdleLane:\n              lane = IdleHydrationLane;\n              break;\n            default:\n              lane = NoLane;\n              break;\n          }\n          if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {\n            return NoLane;\n          }\n          return lane;\n        }\n        function addFiberToLanesMap(root2, fiber, lanes) {\n          if (!isDevToolsPresent) {\n            return;\n          }\n          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\n          while (lanes > 0) {\n            var index2 = laneToIndex(lanes);\n            var lane = 1 << index2;\n            var updaters = pendingUpdatersLaneMap[index2];\n            updaters.add(fiber);\n            lanes &= ~lane;\n          }\n        }\n        function movePendingFibersToMemoized(root2, lanes) {\n          if (!isDevToolsPresent) {\n            return;\n          }\n          var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;\n          var memoizedUpdaters = root2.memoizedUpdaters;\n          while (lanes > 0) {\n            var index2 = laneToIndex(lanes);\n            var lane = 1 << index2;\n            var updaters = pendingUpdatersLaneMap[index2];\n            if (updaters.size > 0) {\n              updaters.forEach(function(fiber) {\n                var alternate = fiber.alternate;\n                if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                  memoizedUpdaters.add(fiber);\n                }\n              });\n              updaters.clear();\n            }\n            lanes &= ~lane;\n          }\n        }\n        function getTransitionsForLanes(root2, lanes) {\n          {\n            return null;\n          }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        var currentUpdatePriority = NoLane;\n        function getCurrentUpdatePriority() {\n          return currentUpdatePriority;\n        }\n        function setCurrentUpdatePriority(newPriority) {\n          currentUpdatePriority = newPriority;\n        }\n        function runWithPriority(priority, fn) {\n          var previousPriority = currentUpdatePriority;\n          try {\n            currentUpdatePriority = priority;\n            return fn();\n          } finally {\n            currentUpdatePriority = previousPriority;\n          }\n        }\n        function higherEventPriority(a, b) {\n          return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n          return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n          return a !== 0 && a < b;\n        }\n        function lanesToEventPriority(lanes) {\n          var lane = getHighestPriorityLane(lanes);\n          if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n            return DiscreteEventPriority;\n          }\n          if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n            return ContinuousEventPriority;\n          }\n          if (includesNonIdleWork(lane)) {\n            return DefaultEventPriority;\n          }\n          return IdleEventPriority;\n        }\n        function isRootDehydrated(root2) {\n          var currentState = root2.current.memoizedState;\n          return currentState.isDehydrated;\n        }\n        var _attemptSynchronousHydration;\n        function setAttemptSynchronousHydration(fn) {\n          _attemptSynchronousHydration = fn;\n        }\n        function attemptSynchronousHydration(fiber) {\n          _attemptSynchronousHydration(fiber);\n        }\n        var attemptContinuousHydration;\n        function setAttemptContinuousHydration(fn) {\n          attemptContinuousHydration = fn;\n        }\n        var attemptHydrationAtCurrentPriority;\n        function setAttemptHydrationAtCurrentPriority(fn) {\n          attemptHydrationAtCurrentPriority = fn;\n        }\n        var getCurrentUpdatePriority$1;\n        function setGetCurrentUpdatePriority(fn) {\n          getCurrentUpdatePriority$1 = fn;\n        }\n        var attemptHydrationAtPriority;\n        function setAttemptHydrationAtPriority(fn) {\n          attemptHydrationAtPriority = fn;\n        }\n        var hasScheduledReplayAttempt = false;\n        var queuedDiscreteEvents = [];\n        var queuedFocus = null;\n        var queuedDrag = null;\n        var queuedMouse = null;\n        var queuedPointers = /* @__PURE__ */ new Map();\n        var queuedPointerCaptures = /* @__PURE__ */ new Map();\n        var queuedExplicitHydrationTargets = [];\n        var discreteReplayableEvents = [\n          \"mousedown\",\n          \"mouseup\",\n          \"touchcancel\",\n          \"touchend\",\n          \"touchstart\",\n          \"auxclick\",\n          \"dblclick\",\n          \"pointercancel\",\n          \"pointerdown\",\n          \"pointerup\",\n          \"dragend\",\n          \"dragstart\",\n          \"drop\",\n          \"compositionend\",\n          \"compositionstart\",\n          \"keydown\",\n          \"keypress\",\n          \"keyup\",\n          \"input\",\n          \"textInput\",\n          // Intentionally camelCase\n          \"copy\",\n          \"cut\",\n          \"paste\",\n          \"click\",\n          \"change\",\n          \"contextmenu\",\n          \"reset\",\n          \"submit\"\n        ];\n        function isDiscreteEventThatRequiresHydration(eventType) {\n          return discreteReplayableEvents.indexOf(eventType) > -1;\n        }\n        function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          return {\n            blockedOn,\n            domEventName,\n            eventSystemFlags,\n            nativeEvent,\n            targetContainers: [targetContainer]\n          };\n        }\n        function clearIfContinuousEvent(domEventName, nativeEvent) {\n          switch (domEventName) {\n            case \"focusin\":\n            case \"focusout\":\n              queuedFocus = null;\n              break;\n            case \"dragenter\":\n            case \"dragleave\":\n              queuedDrag = null;\n              break;\n            case \"mouseover\":\n            case \"mouseout\":\n              queuedMouse = null;\n              break;\n            case \"pointerover\":\n            case \"pointerout\": {\n              var pointerId = nativeEvent.pointerId;\n              queuedPointers.delete(pointerId);\n              break;\n            }\n            case \"gotpointercapture\":\n            case \"lostpointercapture\": {\n              var _pointerId = nativeEvent.pointerId;\n              queuedPointerCaptures.delete(_pointerId);\n              break;\n            }\n          }\n        }\n        function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {\n            var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);\n            if (blockedOn !== null) {\n              var _fiber2 = getInstanceFromNode(blockedOn);\n              if (_fiber2 !== null) {\n                attemptContinuousHydration(_fiber2);\n              }\n            }\n            return queuedEvent;\n          }\n          existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n          var targetContainers = existingQueuedEvent.targetContainers;\n          if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {\n            targetContainers.push(targetContainer);\n          }\n          return existingQueuedEvent;\n        }\n        function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          switch (domEventName) {\n            case \"focusin\": {\n              var focusEvent = nativeEvent;\n              queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);\n              return true;\n            }\n            case \"dragenter\": {\n              var dragEvent = nativeEvent;\n              queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);\n              return true;\n            }\n            case \"mouseover\": {\n              var mouseEvent = nativeEvent;\n              queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);\n              return true;\n            }\n            case \"pointerover\": {\n              var pointerEvent = nativeEvent;\n              var pointerId = pointerEvent.pointerId;\n              queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));\n              return true;\n            }\n            case \"gotpointercapture\": {\n              var _pointerEvent = nativeEvent;\n              var _pointerId2 = _pointerEvent.pointerId;\n              queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));\n              return true;\n            }\n          }\n          return false;\n        }\n        function attemptExplicitHydrationTarget(queuedTarget) {\n          var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n          if (targetInst !== null) {\n            var nearestMounted = getNearestMountedFiber(targetInst);\n            if (nearestMounted !== null) {\n              var tag = nearestMounted.tag;\n              if (tag === SuspenseComponent) {\n                var instance = getSuspenseInstanceFromFiber(nearestMounted);\n                if (instance !== null) {\n                  queuedTarget.blockedOn = instance;\n                  attemptHydrationAtPriority(queuedTarget.priority, function() {\n                    attemptHydrationAtCurrentPriority(nearestMounted);\n                  });\n                  return;\n                }\n              } else if (tag === HostRoot) {\n                var root2 = nearestMounted.stateNode;\n                if (isRootDehydrated(root2)) {\n                  queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);\n                  return;\n                }\n              }\n            }\n          }\n          queuedTarget.blockedOn = null;\n        }\n        function queueExplicitHydrationTarget(target) {\n          var updatePriority = getCurrentUpdatePriority$1();\n          var queuedTarget = {\n            blockedOn: null,\n            target,\n            priority: updatePriority\n          };\n          var i = 0;\n          for (; i < queuedExplicitHydrationTargets.length; i++) {\n            if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {\n              break;\n            }\n          }\n          queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);\n          if (i === 0) {\n            attemptExplicitHydrationTarget(queuedTarget);\n          }\n        }\n        function attemptReplayContinuousQueuedEvent(queuedEvent) {\n          if (queuedEvent.blockedOn !== null) {\n            return false;\n          }\n          var targetContainers = queuedEvent.targetContainers;\n          while (targetContainers.length > 0) {\n            var targetContainer = targetContainers[0];\n            var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);\n            if (nextBlockedOn === null) {\n              {\n                var nativeEvent = queuedEvent.nativeEvent;\n                var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);\n                setReplayingEvent(nativeEventClone);\n                nativeEvent.target.dispatchEvent(nativeEventClone);\n                resetReplayingEvent();\n              }\n            } else {\n              var _fiber3 = getInstanceFromNode(nextBlockedOn);\n              if (_fiber3 !== null) {\n                attemptContinuousHydration(_fiber3);\n              }\n              queuedEvent.blockedOn = nextBlockedOn;\n              return false;\n            }\n            targetContainers.shift();\n          }\n          return true;\n        }\n        function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n          if (attemptReplayContinuousQueuedEvent(queuedEvent)) {\n            map.delete(key);\n          }\n        }\n        function replayUnblockedEvents() {\n          hasScheduledReplayAttempt = false;\n          if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {\n            queuedFocus = null;\n          }\n          if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {\n            queuedDrag = null;\n          }\n          if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {\n            queuedMouse = null;\n          }\n          queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n          queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n        }\n        function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n          if (queuedEvent.blockedOn === unblocked) {\n            queuedEvent.blockedOn = null;\n            if (!hasScheduledReplayAttempt) {\n              hasScheduledReplayAttempt = true;\n              Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);\n            }\n          }\n        }\n        function retryIfBlockedOn(unblocked) {\n          if (queuedDiscreteEvents.length > 0) {\n            scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);\n            for (var i = 1; i < queuedDiscreteEvents.length; i++) {\n              var queuedEvent = queuedDiscreteEvents[i];\n              if (queuedEvent.blockedOn === unblocked) {\n                queuedEvent.blockedOn = null;\n              }\n            }\n          }\n          if (queuedFocus !== null) {\n            scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n          }\n          if (queuedDrag !== null) {\n            scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n          }\n          if (queuedMouse !== null) {\n            scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n          }\n          var unblock = function(queuedEvent2) {\n            return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);\n          };\n          queuedPointers.forEach(unblock);\n          queuedPointerCaptures.forEach(unblock);\n          for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {\n            var queuedTarget = queuedExplicitHydrationTargets[_i];\n            if (queuedTarget.blockedOn === unblocked) {\n              queuedTarget.blockedOn = null;\n            }\n          }\n          while (queuedExplicitHydrationTargets.length > 0) {\n            var nextExplicitTarget = queuedExplicitHydrationTargets[0];\n            if (nextExplicitTarget.blockedOn !== null) {\n              break;\n            } else {\n              attemptExplicitHydrationTarget(nextExplicitTarget);\n              if (nextExplicitTarget.blockedOn === null) {\n                queuedExplicitHydrationTargets.shift();\n              }\n            }\n          }\n        }\n        var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\n        var _enabled = true;\n        function setEnabled(enabled) {\n          _enabled = !!enabled;\n        }\n        function isEnabled() {\n          return _enabled;\n        }\n        function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {\n          var eventPriority = getEventPriority(domEventName);\n          var listenerWrapper;\n          switch (eventPriority) {\n            case DiscreteEventPriority:\n              listenerWrapper = dispatchDiscreteEvent;\n              break;\n            case ContinuousEventPriority:\n              listenerWrapper = dispatchContinuousEvent;\n              break;\n            case DefaultEventPriority:\n            default:\n              listenerWrapper = dispatchEvent;\n              break;\n          }\n          return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);\n        }\n        function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n          var previousPriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = null;\n          try {\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig.transition = prevTransition;\n          }\n        }\n        function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {\n          var previousPriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig.transition;\n          ReactCurrentBatchConfig.transition = null;\n          try {\n            setCurrentUpdatePriority(ContinuousEventPriority);\n            dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig.transition = prevTransition;\n          }\n        }\n        function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          if (!_enabled) {\n            return;\n          }\n          {\n            dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n          }\n        }\n        function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n          if (blockedOn === null) {\n            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n            clearIfContinuousEvent(domEventName, nativeEvent);\n            return;\n          }\n          if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {\n            nativeEvent.stopPropagation();\n            return;\n          }\n          clearIfContinuousEvent(domEventName, nativeEvent);\n          if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {\n            while (blockedOn !== null) {\n              var fiber = getInstanceFromNode(blockedOn);\n              if (fiber !== null) {\n                attemptSynchronousHydration(fiber);\n              }\n              var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);\n              if (nextBlockedOn === null) {\n                dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);\n              }\n              if (nextBlockedOn === blockedOn) {\n                break;\n              }\n              blockedOn = nextBlockedOn;\n            }\n            if (blockedOn !== null) {\n              nativeEvent.stopPropagation();\n            }\n            return;\n          }\n          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);\n        }\n        var return_targetInst = null;\n        function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {\n          return_targetInst = null;\n          var nativeEventTarget = getEventTarget(nativeEvent);\n          var targetInst = getClosestInstanceFromNode(nativeEventTarget);\n          if (targetInst !== null) {\n            var nearestMounted = getNearestMountedFiber(targetInst);\n            if (nearestMounted === null) {\n              targetInst = null;\n            } else {\n              var tag = nearestMounted.tag;\n              if (tag === SuspenseComponent) {\n                var instance = getSuspenseInstanceFromFiber(nearestMounted);\n                if (instance !== null) {\n                  return instance;\n                }\n                targetInst = null;\n              } else if (tag === HostRoot) {\n                var root2 = nearestMounted.stateNode;\n                if (isRootDehydrated(root2)) {\n                  return getContainerFromFiber(nearestMounted);\n                }\n                targetInst = null;\n              } else if (nearestMounted !== targetInst) {\n                targetInst = null;\n              }\n            }\n          }\n          return_targetInst = targetInst;\n          return null;\n        }\n        function getEventPriority(domEventName) {\n          switch (domEventName) {\n            case \"cancel\":\n            case \"click\":\n            case \"close\":\n            case \"contextmenu\":\n            case \"copy\":\n            case \"cut\":\n            case \"auxclick\":\n            case \"dblclick\":\n            case \"dragend\":\n            case \"dragstart\":\n            case \"drop\":\n            case \"focusin\":\n            case \"focusout\":\n            case \"input\":\n            case \"invalid\":\n            case \"keydown\":\n            case \"keypress\":\n            case \"keyup\":\n            case \"mousedown\":\n            case \"mouseup\":\n            case \"paste\":\n            case \"pause\":\n            case \"play\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointerup\":\n            case \"ratechange\":\n            case \"reset\":\n            case \"resize\":\n            case \"seeked\":\n            case \"submit\":\n            case \"touchcancel\":\n            case \"touchend\":\n            case \"touchstart\":\n            case \"volumechange\":\n            case \"change\":\n            case \"selectionchange\":\n            case \"textInput\":\n            case \"compositionstart\":\n            case \"compositionend\":\n            case \"compositionupdate\":\n            case \"beforeblur\":\n            case \"afterblur\":\n            case \"beforeinput\":\n            case \"blur\":\n            case \"fullscreenchange\":\n            case \"focus\":\n            case \"hashchange\":\n            case \"popstate\":\n            case \"select\":\n            case \"selectstart\":\n              return DiscreteEventPriority;\n            case \"drag\":\n            case \"dragenter\":\n            case \"dragexit\":\n            case \"dragleave\":\n            case \"dragover\":\n            case \"mousemove\":\n            case \"mouseout\":\n            case \"mouseover\":\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"scroll\":\n            case \"toggle\":\n            case \"touchmove\":\n            case \"wheel\":\n            case \"mouseenter\":\n            case \"mouseleave\":\n            case \"pointerenter\":\n            case \"pointerleave\":\n              return ContinuousEventPriority;\n            case \"message\": {\n              var schedulerPriority = getCurrentPriorityLevel();\n              switch (schedulerPriority) {\n                case ImmediatePriority:\n                  return DiscreteEventPriority;\n                case UserBlockingPriority:\n                  return ContinuousEventPriority;\n                case NormalPriority:\n                case LowPriority:\n                  return DefaultEventPriority;\n                case IdlePriority:\n                  return IdleEventPriority;\n                default:\n                  return DefaultEventPriority;\n              }\n            }\n            default:\n              return DefaultEventPriority;\n          }\n        }\n        function addEventBubbleListener(target, eventType, listener) {\n          target.addEventListener(eventType, listener, false);\n          return listener;\n        }\n        function addEventCaptureListener(target, eventType, listener) {\n          target.addEventListener(eventType, listener, true);\n          return listener;\n        }\n        function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {\n          target.addEventListener(eventType, listener, {\n            capture: true,\n            passive\n          });\n          return listener;\n        }\n        function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {\n          target.addEventListener(eventType, listener, {\n            passive\n          });\n          return listener;\n        }\n        var root = null;\n        var startText = null;\n        var fallbackText = null;\n        function initialize(nativeEventTarget) {\n          root = nativeEventTarget;\n          startText = getText();\n          return true;\n        }\n        function reset() {\n          root = null;\n          startText = null;\n          fallbackText = null;\n        }\n        function getData() {\n          if (fallbackText) {\n            return fallbackText;\n          }\n          var start;\n          var startValue = startText;\n          var startLength = startValue.length;\n          var end;\n          var endValue = getText();\n          var endLength = endValue.length;\n          for (start = 0; start < startLength; start++) {\n            if (startValue[start] !== endValue[start]) {\n              break;\n            }\n          }\n          var minEnd = startLength - start;\n          for (end = 1; end <= minEnd; end++) {\n            if (startValue[startLength - end] !== endValue[endLength - end]) {\n              break;\n            }\n          }\n          var sliceTail = end > 1 ? 1 - end : void 0;\n          fallbackText = endValue.slice(start, sliceTail);\n          return fallbackText;\n        }\n        function getText() {\n          if (\"value\" in root) {\n            return root.value;\n          }\n          return root.textContent;\n        }\n        function getEventCharCode(nativeEvent) {\n          var charCode;\n          var keyCode = nativeEvent.keyCode;\n          if (\"charCode\" in nativeEvent) {\n            charCode = nativeEvent.charCode;\n            if (charCode === 0 && keyCode === 13) {\n              charCode = 13;\n            }\n          } else {\n            charCode = keyCode;\n          }\n          if (charCode === 10) {\n            charCode = 13;\n          }\n          if (charCode >= 32 || charCode === 13) {\n            return charCode;\n          }\n          return 0;\n        }\n        function functionThatReturnsTrue() {\n          return true;\n        }\n        function functionThatReturnsFalse() {\n          return false;\n        }\n        function createSyntheticEvent(Interface) {\n          function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {\n            this._reactName = reactName;\n            this._targetInst = targetInst;\n            this.type = reactEventType;\n            this.nativeEvent = nativeEvent;\n            this.target = nativeEventTarget;\n            this.currentTarget = null;\n            for (var _propName in Interface) {\n              if (!Interface.hasOwnProperty(_propName)) {\n                continue;\n              }\n              var normalize = Interface[_propName];\n              if (normalize) {\n                this[_propName] = normalize(nativeEvent);\n              } else {\n                this[_propName] = nativeEvent[_propName];\n              }\n            }\n            var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;\n            if (defaultPrevented) {\n              this.isDefaultPrevented = functionThatReturnsTrue;\n            } else {\n              this.isDefaultPrevented = functionThatReturnsFalse;\n            }\n            this.isPropagationStopped = functionThatReturnsFalse;\n            return this;\n          }\n          assign(SyntheticBaseEvent.prototype, {\n            preventDefault: function() {\n              this.defaultPrevented = true;\n              var event = this.nativeEvent;\n              if (!event) {\n                return;\n              }\n              if (event.preventDefault) {\n                event.preventDefault();\n              } else if (typeof event.returnValue !== \"unknown\") {\n                event.returnValue = false;\n              }\n              this.isDefaultPrevented = functionThatReturnsTrue;\n            },\n            stopPropagation: function() {\n              var event = this.nativeEvent;\n              if (!event) {\n                return;\n              }\n              if (event.stopPropagation) {\n                event.stopPropagation();\n              } else if (typeof event.cancelBubble !== \"unknown\") {\n                event.cancelBubble = true;\n              }\n              this.isPropagationStopped = functionThatReturnsTrue;\n            },\n            /**\n             * We release all dispatched `SyntheticEvent`s after each event loop, adding\n             * them back into the pool. This allows a way to hold onto a reference that\n             * won't be added back into the pool.\n             */\n            persist: function() {\n            },\n            /**\n             * Checks if this event should be released back into the pool.\n             *\n             * @return {boolean} True if this should not be released, false otherwise.\n             */\n            isPersistent: functionThatReturnsTrue\n          });\n          return SyntheticBaseEvent;\n        }\n        var EventInterface = {\n          eventPhase: 0,\n          bubbles: 0,\n          cancelable: 0,\n          timeStamp: function(event) {\n            return event.timeStamp || Date.now();\n          },\n          defaultPrevented: 0,\n          isTrusted: 0\n        };\n        var SyntheticEvent = createSyntheticEvent(EventInterface);\n        var UIEventInterface = assign({}, EventInterface, {\n          view: 0,\n          detail: 0\n        });\n        var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);\n        var lastMovementX;\n        var lastMovementY;\n        var lastMouseEvent;\n        function updateMouseMovementPolyfillState(event) {\n          if (event !== lastMouseEvent) {\n            if (lastMouseEvent && event.type === \"mousemove\") {\n              lastMovementX = event.screenX - lastMouseEvent.screenX;\n              lastMovementY = event.screenY - lastMouseEvent.screenY;\n            } else {\n              lastMovementX = 0;\n              lastMovementY = 0;\n            }\n            lastMouseEvent = event;\n          }\n        }\n        var MouseEventInterface = assign({}, UIEventInterface, {\n          screenX: 0,\n          screenY: 0,\n          clientX: 0,\n          clientY: 0,\n          pageX: 0,\n          pageY: 0,\n          ctrlKey: 0,\n          shiftKey: 0,\n          altKey: 0,\n          metaKey: 0,\n          getModifierState: getEventModifierState,\n          button: 0,\n          buttons: 0,\n          relatedTarget: function(event) {\n            if (event.relatedTarget === void 0) return event.fromElement === event.srcElement ? event.toElement : event.fromElement;\n            return event.relatedTarget;\n          },\n          movementX: function(event) {\n            if (\"movementX\" in event) {\n              return event.movementX;\n            }\n            updateMouseMovementPolyfillState(event);\n            return lastMovementX;\n          },\n          movementY: function(event) {\n            if (\"movementY\" in event) {\n              return event.movementY;\n            }\n            return lastMovementY;\n          }\n        });\n        var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);\n        var DragEventInterface = assign({}, MouseEventInterface, {\n          dataTransfer: 0\n        });\n        var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);\n        var FocusEventInterface = assign({}, UIEventInterface, {\n          relatedTarget: 0\n        });\n        var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);\n        var AnimationEventInterface = assign({}, EventInterface, {\n          animationName: 0,\n          elapsedTime: 0,\n          pseudoElement: 0\n        });\n        var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);\n        var ClipboardEventInterface = assign({}, EventInterface, {\n          clipboardData: function(event) {\n            return \"clipboardData\" in event ? event.clipboardData : window.clipboardData;\n          }\n        });\n        var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);\n        var CompositionEventInterface = assign({}, EventInterface, {\n          data: 0\n        });\n        var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);\n        var SyntheticInputEvent = SyntheticCompositionEvent;\n        var normalizeKey = {\n          Esc: \"Escape\",\n          Spacebar: \" \",\n          Left: \"ArrowLeft\",\n          Up: \"ArrowUp\",\n          Right: \"ArrowRight\",\n          Down: \"ArrowDown\",\n          Del: \"Delete\",\n          Win: \"OS\",\n          Menu: \"ContextMenu\",\n          Apps: \"ContextMenu\",\n          Scroll: \"ScrollLock\",\n          MozPrintableKey: \"Unidentified\"\n        };\n        var translateToKey = {\n          \"8\": \"Backspace\",\n          \"9\": \"Tab\",\n          \"12\": \"Clear\",\n          \"13\": \"Enter\",\n          \"16\": \"Shift\",\n          \"17\": \"Control\",\n          \"18\": \"Alt\",\n          \"19\": \"Pause\",\n          \"20\": \"CapsLock\",\n          \"27\": \"Escape\",\n          \"32\": \" \",\n          \"33\": \"PageUp\",\n          \"34\": \"PageDown\",\n          \"35\": \"End\",\n          \"36\": \"Home\",\n          \"37\": \"ArrowLeft\",\n          \"38\": \"ArrowUp\",\n          \"39\": \"ArrowRight\",\n          \"40\": \"ArrowDown\",\n          \"45\": \"Insert\",\n          \"46\": \"Delete\",\n          \"112\": \"F1\",\n          \"113\": \"F2\",\n          \"114\": \"F3\",\n          \"115\": \"F4\",\n          \"116\": \"F5\",\n          \"117\": \"F6\",\n          \"118\": \"F7\",\n          \"119\": \"F8\",\n          \"120\": \"F9\",\n          \"121\": \"F10\",\n          \"122\": \"F11\",\n          \"123\": \"F12\",\n          \"144\": \"NumLock\",\n          \"145\": \"ScrollLock\",\n          \"224\": \"Meta\"\n        };\n        function getEventKey(nativeEvent) {\n          if (nativeEvent.key) {\n            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n            if (key !== \"Unidentified\") {\n              return key;\n            }\n          }\n          if (nativeEvent.type === \"keypress\") {\n            var charCode = getEventCharCode(nativeEvent);\n            return charCode === 13 ? \"Enter\" : String.fromCharCode(charCode);\n          }\n          if (nativeEvent.type === \"keydown\" || nativeEvent.type === \"keyup\") {\n            return translateToKey[nativeEvent.keyCode] || \"Unidentified\";\n          }\n          return \"\";\n        }\n        var modifierKeyToProp = {\n          Alt: \"altKey\",\n          Control: \"ctrlKey\",\n          Meta: \"metaKey\",\n          Shift: \"shiftKey\"\n        };\n        function modifierStateGetter(keyArg) {\n          var syntheticEvent = this;\n          var nativeEvent = syntheticEvent.nativeEvent;\n          if (nativeEvent.getModifierState) {\n            return nativeEvent.getModifierState(keyArg);\n          }\n          var keyProp = modifierKeyToProp[keyArg];\n          return keyProp ? !!nativeEvent[keyProp] : false;\n        }\n        function getEventModifierState(nativeEvent) {\n          return modifierStateGetter;\n        }\n        var KeyboardEventInterface = assign({}, UIEventInterface, {\n          key: getEventKey,\n          code: 0,\n          location: 0,\n          ctrlKey: 0,\n          shiftKey: 0,\n          altKey: 0,\n          metaKey: 0,\n          repeat: 0,\n          locale: 0,\n          getModifierState: getEventModifierState,\n          // Legacy Interface\n          charCode: function(event) {\n            if (event.type === \"keypress\") {\n              return getEventCharCode(event);\n            }\n            return 0;\n          },\n          keyCode: function(event) {\n            if (event.type === \"keydown\" || event.type === \"keyup\") {\n              return event.keyCode;\n            }\n            return 0;\n          },\n          which: function(event) {\n            if (event.type === \"keypress\") {\n              return getEventCharCode(event);\n            }\n            if (event.type === \"keydown\" || event.type === \"keyup\") {\n              return event.keyCode;\n            }\n            return 0;\n          }\n        });\n        var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);\n        var PointerEventInterface = assign({}, MouseEventInterface, {\n          pointerId: 0,\n          width: 0,\n          height: 0,\n          pressure: 0,\n          tangentialPressure: 0,\n          tiltX: 0,\n          tiltY: 0,\n          twist: 0,\n          pointerType: 0,\n          isPrimary: 0\n        });\n        var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);\n        var TouchEventInterface = assign({}, UIEventInterface, {\n          touches: 0,\n          targetTouches: 0,\n          changedTouches: 0,\n          altKey: 0,\n          metaKey: 0,\n          ctrlKey: 0,\n          shiftKey: 0,\n          getModifierState: getEventModifierState\n        });\n        var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);\n        var TransitionEventInterface = assign({}, EventInterface, {\n          propertyName: 0,\n          elapsedTime: 0,\n          pseudoElement: 0\n        });\n        var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);\n        var WheelEventInterface = assign({}, MouseEventInterface, {\n          deltaX: function(event) {\n            return \"deltaX\" in event ? event.deltaX : (\n              // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n              \"wheelDeltaX\" in event ? -event.wheelDeltaX : 0\n            );\n          },\n          deltaY: function(event) {\n            return \"deltaY\" in event ? event.deltaY : (\n              // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n              \"wheelDeltaY\" in event ? -event.wheelDeltaY : (\n                // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n                \"wheelDelta\" in event ? -event.wheelDelta : 0\n              )\n            );\n          },\n          deltaZ: 0,\n          // Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n          // notch on the scroll is always +/- 120, roughly equivalent to pixels.\n          // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n          // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n          deltaMode: 0\n        });\n        var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);\n        var END_KEYCODES = [9, 13, 27, 32];\n        var START_KEYCODE = 229;\n        var canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window;\n        var documentMode = null;\n        if (canUseDOM && \"documentMode\" in document) {\n          documentMode = document.documentMode;\n        }\n        var canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode;\n        var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);\n        var SPACEBAR_CODE = 32;\n        var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);\n        function registerEvents() {\n          registerTwoPhaseEvent(\"onBeforeInput\", [\"compositionend\", \"keypress\", \"textInput\", \"paste\"]);\n          registerTwoPhaseEvent(\"onCompositionEnd\", [\"compositionend\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n          registerTwoPhaseEvent(\"onCompositionStart\", [\"compositionstart\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n          registerTwoPhaseEvent(\"onCompositionUpdate\", [\"compositionupdate\", \"focusout\", \"keydown\", \"keypress\", \"keyup\", \"mousedown\"]);\n        }\n        var hasSpaceKeypress = false;\n        function isKeypressCommand(nativeEvent) {\n          return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.\n          !(nativeEvent.ctrlKey && nativeEvent.altKey);\n        }\n        function getCompositionEventType(domEventName) {\n          switch (domEventName) {\n            case \"compositionstart\":\n              return \"onCompositionStart\";\n            case \"compositionend\":\n              return \"onCompositionEnd\";\n            case \"compositionupdate\":\n              return \"onCompositionUpdate\";\n          }\n        }\n        function isFallbackCompositionStart(domEventName, nativeEvent) {\n          return domEventName === \"keydown\" && nativeEvent.keyCode === START_KEYCODE;\n        }\n        function isFallbackCompositionEnd(domEventName, nativeEvent) {\n          switch (domEventName) {\n            case \"keyup\":\n              return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;\n            case \"keydown\":\n              return nativeEvent.keyCode !== START_KEYCODE;\n            case \"keypress\":\n            case \"mousedown\":\n            case \"focusout\":\n              return true;\n            default:\n              return false;\n          }\n        }\n        function getDataFromCustomEvent(nativeEvent) {\n          var detail = nativeEvent.detail;\n          if (typeof detail === \"object\" && \"data\" in detail) {\n            return detail.data;\n          }\n          return null;\n        }\n        function isUsingKoreanIME(nativeEvent) {\n          return nativeEvent.locale === \"ko\";\n        }\n        var isComposing = false;\n        function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n          var eventType;\n          var fallbackData;\n          if (canUseCompositionEvent) {\n            eventType = getCompositionEventType(domEventName);\n          } else if (!isComposing) {\n            if (isFallbackCompositionStart(domEventName, nativeEvent)) {\n              eventType = \"onCompositionStart\";\n            }\n          } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {\n            eventType = \"onCompositionEnd\";\n          }\n          if (!eventType) {\n            return null;\n          }\n          if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {\n            if (!isComposing && eventType === \"onCompositionStart\") {\n              isComposing = initialize(nativeEventTarget);\n            } else if (eventType === \"onCompositionEnd\") {\n              if (isComposing) {\n                fallbackData = getData();\n              }\n            }\n          }\n          var listeners = accumulateTwoPhaseListeners(targetInst, eventType);\n          if (listeners.length > 0) {\n            var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n            if (fallbackData) {\n              event.data = fallbackData;\n            } else {\n              var customData = getDataFromCustomEvent(nativeEvent);\n              if (customData !== null) {\n                event.data = customData;\n              }\n            }\n          }\n        }\n        function getNativeBeforeInputChars(domEventName, nativeEvent) {\n          switch (domEventName) {\n            case \"compositionend\":\n              return getDataFromCustomEvent(nativeEvent);\n            case \"keypress\":\n              var which = nativeEvent.which;\n              if (which !== SPACEBAR_CODE) {\n                return null;\n              }\n              hasSpaceKeypress = true;\n              return SPACEBAR_CHAR;\n            case \"textInput\":\n              var chars = nativeEvent.data;\n              if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {\n                return null;\n              }\n              return chars;\n            default:\n              return null;\n          }\n        }\n        function getFallbackBeforeInputChars(domEventName, nativeEvent) {\n          if (isComposing) {\n            if (domEventName === \"compositionend\" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {\n              var chars = getData();\n              reset();\n              isComposing = false;\n              return chars;\n            }\n            return null;\n          }\n          switch (domEventName) {\n            case \"paste\":\n              return null;\n            case \"keypress\":\n              if (!isKeypressCommand(nativeEvent)) {\n                if (nativeEvent.char && nativeEvent.char.length > 1) {\n                  return nativeEvent.char;\n                } else if (nativeEvent.which) {\n                  return String.fromCharCode(nativeEvent.which);\n                }\n              }\n              return null;\n            case \"compositionend\":\n              return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;\n            default:\n              return null;\n          }\n        }\n        function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {\n          var chars;\n          if (canUseTextInputEvent) {\n            chars = getNativeBeforeInputChars(domEventName, nativeEvent);\n          } else {\n            chars = getFallbackBeforeInputChars(domEventName, nativeEvent);\n          }\n          if (!chars) {\n            return null;\n          }\n          var listeners = accumulateTwoPhaseListeners(targetInst, \"onBeforeInput\");\n          if (listeners.length > 0) {\n            var event = new SyntheticInputEvent(\"onBeforeInput\", \"beforeinput\", null, nativeEvent, nativeEventTarget);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n            event.data = chars;\n          }\n        }\n        function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n        }\n        var supportedInputTypes = {\n          color: true,\n          date: true,\n          datetime: true,\n          \"datetime-local\": true,\n          email: true,\n          month: true,\n          number: true,\n          password: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true\n        };\n        function isTextInputElement(elem) {\n          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n          if (nodeName === \"input\") {\n            return !!supportedInputTypes[elem.type];\n          }\n          if (nodeName === \"textarea\") {\n            return true;\n          }\n          return false;\n        }\n        function isEventSupported(eventNameSuffix) {\n          if (!canUseDOM) {\n            return false;\n          }\n          var eventName = \"on\" + eventNameSuffix;\n          var isSupported = eventName in document;\n          if (!isSupported) {\n            var element = document.createElement(\"div\");\n            element.setAttribute(eventName, \"return;\");\n            isSupported = typeof element[eventName] === \"function\";\n          }\n          return isSupported;\n        }\n        function registerEvents$1() {\n          registerTwoPhaseEvent(\"onChange\", [\"change\", \"click\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"selectionchange\"]);\n        }\n        function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {\n          enqueueStateRestore(target);\n          var listeners = accumulateTwoPhaseListeners(inst, \"onChange\");\n          if (listeners.length > 0) {\n            var event = new SyntheticEvent(\"onChange\", \"change\", null, nativeEvent, target);\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n          }\n        }\n        var activeElement = null;\n        var activeElementInst = null;\n        function shouldUseChangeEvent(elem) {\n          var nodeName = elem.nodeName && elem.nodeName.toLowerCase();\n          return nodeName === \"select\" || nodeName === \"input\" && elem.type === \"file\";\n        }\n        function manualDispatchChangeEvent(nativeEvent) {\n          var dispatchQueue = [];\n          createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));\n          batchedUpdates(runEventInBatch, dispatchQueue);\n        }\n        function runEventInBatch(dispatchQueue) {\n          processDispatchQueue(dispatchQueue, 0);\n        }\n        function getInstIfValueChanged(targetInst) {\n          var targetNode = getNodeFromInstance(targetInst);\n          if (updateValueIfChanged(targetNode)) {\n            return targetInst;\n          }\n        }\n        function getTargetInstForChangeEvent(domEventName, targetInst) {\n          if (domEventName === \"change\") {\n            return targetInst;\n          }\n        }\n        var isInputEventSupported = false;\n        if (canUseDOM) {\n          isInputEventSupported = isEventSupported(\"input\") && (!document.documentMode || document.documentMode > 9);\n        }\n        function startWatchingForValueChange(target, targetInst) {\n          activeElement = target;\n          activeElementInst = targetInst;\n          activeElement.attachEvent(\"onpropertychange\", handlePropertyChange);\n        }\n        function stopWatchingForValueChange() {\n          if (!activeElement) {\n            return;\n          }\n          activeElement.detachEvent(\"onpropertychange\", handlePropertyChange);\n          activeElement = null;\n          activeElementInst = null;\n        }\n        function handlePropertyChange(nativeEvent) {\n          if (nativeEvent.propertyName !== \"value\") {\n            return;\n          }\n          if (getInstIfValueChanged(activeElementInst)) {\n            manualDispatchChangeEvent(nativeEvent);\n          }\n        }\n        function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n          if (domEventName === \"focusin\") {\n            stopWatchingForValueChange();\n            startWatchingForValueChange(target, targetInst);\n          } else if (domEventName === \"focusout\") {\n            stopWatchingForValueChange();\n          }\n        }\n        function getTargetInstForInputEventPolyfill(domEventName, targetInst) {\n          if (domEventName === \"selectionchange\" || domEventName === \"keyup\" || domEventName === \"keydown\") {\n            return getInstIfValueChanged(activeElementInst);\n          }\n        }\n        function shouldUseClickEvent(elem) {\n          var nodeName = elem.nodeName;\n          return nodeName && nodeName.toLowerCase() === \"input\" && (elem.type === \"checkbox\" || elem.type === \"radio\");\n        }\n        function getTargetInstForClickEvent(domEventName, targetInst) {\n          if (domEventName === \"click\") {\n            return getInstIfValueChanged(targetInst);\n          }\n        }\n        function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n          if (domEventName === \"input\" || domEventName === \"change\") {\n            return getInstIfValueChanged(targetInst);\n          }\n        }\n        function handleControlledInputBlur(node) {\n          var state = node._wrapperState;\n          if (!state || !state.controlled || node.type !== \"number\") {\n            return;\n          }\n          {\n            setDefaultValue(node, \"number\", node.value);\n          }\n        }\n        function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n          var getTargetInstFunc, handleEventFunc;\n          if (shouldUseChangeEvent(targetNode)) {\n            getTargetInstFunc = getTargetInstForChangeEvent;\n          } else if (isTextInputElement(targetNode)) {\n            if (isInputEventSupported) {\n              getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n            } else {\n              getTargetInstFunc = getTargetInstForInputEventPolyfill;\n              handleEventFunc = handleEventsForInputEventPolyfill;\n            }\n          } else if (shouldUseClickEvent(targetNode)) {\n            getTargetInstFunc = getTargetInstForClickEvent;\n          }\n          if (getTargetInstFunc) {\n            var inst = getTargetInstFunc(domEventName, targetInst);\n            if (inst) {\n              createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);\n              return;\n            }\n          }\n          if (handleEventFunc) {\n            handleEventFunc(domEventName, targetNode, targetInst);\n          }\n          if (domEventName === \"focusout\") {\n            handleControlledInputBlur(targetNode);\n          }\n        }\n        function registerEvents$2() {\n          registerDirectEvent(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\n          registerDirectEvent(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\n          registerDirectEvent(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\n          registerDirectEvent(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\n        }\n        function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var isOverEvent = domEventName === \"mouseover\" || domEventName === \"pointerover\";\n          var isOutEvent = domEventName === \"mouseout\" || domEventName === \"pointerout\";\n          if (isOverEvent && !isReplayingEvent(nativeEvent)) {\n            var related = nativeEvent.relatedTarget || nativeEvent.fromElement;\n            if (related) {\n              if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {\n                return;\n              }\n            }\n          }\n          if (!isOutEvent && !isOverEvent) {\n            return;\n          }\n          var win;\n          if (nativeEventTarget.window === nativeEventTarget) {\n            win = nativeEventTarget;\n          } else {\n            var doc = nativeEventTarget.ownerDocument;\n            if (doc) {\n              win = doc.defaultView || doc.parentWindow;\n            } else {\n              win = window;\n            }\n          }\n          var from;\n          var to;\n          if (isOutEvent) {\n            var _related = nativeEvent.relatedTarget || nativeEvent.toElement;\n            from = targetInst;\n            to = _related ? getClosestInstanceFromNode(_related) : null;\n            if (to !== null) {\n              var nearestMounted = getNearestMountedFiber(to);\n              if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {\n                to = null;\n              }\n            }\n          } else {\n            from = null;\n            to = targetInst;\n          }\n          if (from === to) {\n            return;\n          }\n          var SyntheticEventCtor = SyntheticMouseEvent;\n          var leaveEventType = \"onMouseLeave\";\n          var enterEventType = \"onMouseEnter\";\n          var eventTypePrefix = \"mouse\";\n          if (domEventName === \"pointerout\" || domEventName === \"pointerover\") {\n            SyntheticEventCtor = SyntheticPointerEvent;\n            leaveEventType = \"onPointerLeave\";\n            enterEventType = \"onPointerEnter\";\n            eventTypePrefix = \"pointer\";\n          }\n          var fromNode = from == null ? win : getNodeFromInstance(from);\n          var toNode = to == null ? win : getNodeFromInstance(to);\n          var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + \"leave\", from, nativeEvent, nativeEventTarget);\n          leave.target = fromNode;\n          leave.relatedTarget = toNode;\n          var enter = null;\n          var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);\n          if (nativeTargetInst === targetInst) {\n            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + \"enter\", to, nativeEvent, nativeEventTarget);\n            enterEvent.target = toNode;\n            enterEvent.relatedTarget = fromNode;\n            enter = enterEvent;\n          }\n          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);\n        }\n        function is(x, y) {\n          return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;\n        }\n        var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n        function shallowEqual(objA, objB) {\n          if (objectIs(objA, objB)) {\n            return true;\n          }\n          if (typeof objA !== \"object\" || objA === null || typeof objB !== \"object\" || objB === null) {\n            return false;\n          }\n          var keysA = Object.keys(objA);\n          var keysB = Object.keys(objB);\n          if (keysA.length !== keysB.length) {\n            return false;\n          }\n          for (var i = 0; i < keysA.length; i++) {\n            var currentKey = keysA[i];\n            if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n              return false;\n            }\n          }\n          return true;\n        }\n        function getLeafNode(node) {\n          while (node && node.firstChild) {\n            node = node.firstChild;\n          }\n          return node;\n        }\n        function getSiblingNode(node) {\n          while (node) {\n            if (node.nextSibling) {\n              return node.nextSibling;\n            }\n            node = node.parentNode;\n          }\n        }\n        function getNodeForCharacterOffset(root2, offset) {\n          var node = getLeafNode(root2);\n          var nodeStart = 0;\n          var nodeEnd = 0;\n          while (node) {\n            if (node.nodeType === TEXT_NODE) {\n              nodeEnd = nodeStart + node.textContent.length;\n              if (nodeStart <= offset && nodeEnd >= offset) {\n                return {\n                  node,\n                  offset: offset - nodeStart\n                };\n              }\n              nodeStart = nodeEnd;\n            }\n            node = getLeafNode(getSiblingNode(node));\n          }\n        }\n        function getOffsets(outerNode) {\n          var ownerDocument = outerNode.ownerDocument;\n          var win = ownerDocument && ownerDocument.defaultView || window;\n          var selection = win.getSelection && win.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          }\n          var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;\n          try {\n            anchorNode.nodeType;\n            focusNode.nodeType;\n          } catch (e) {\n            return null;\n          }\n          return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);\n        }\n        function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {\n          var length = 0;\n          var start = -1;\n          var end = -1;\n          var indexWithinAnchor = 0;\n          var indexWithinFocus = 0;\n          var node = outerNode;\n          var parentNode = null;\n          outer: while (true) {\n            var next = null;\n            while (true) {\n              if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {\n                start = length + anchorOffset;\n              }\n              if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {\n                end = length + focusOffset;\n              }\n              if (node.nodeType === TEXT_NODE) {\n                length += node.nodeValue.length;\n              }\n              if ((next = node.firstChild) === null) {\n                break;\n              }\n              parentNode = node;\n              node = next;\n            }\n            while (true) {\n              if (node === outerNode) {\n                break outer;\n              }\n              if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {\n                start = length;\n              }\n              if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {\n                end = length;\n              }\n              if ((next = node.nextSibling) !== null) {\n                break;\n              }\n              node = parentNode;\n              parentNode = node.parentNode;\n            }\n            node = next;\n          }\n          if (start === -1 || end === -1) {\n            return null;\n          }\n          return {\n            start,\n            end\n          };\n        }\n        function setOffsets(node, offsets) {\n          var doc = node.ownerDocument || document;\n          var win = doc && doc.defaultView || window;\n          if (!win.getSelection) {\n            return;\n          }\n          var selection = win.getSelection();\n          var length = node.textContent.length;\n          var start = Math.min(offsets.start, length);\n          var end = offsets.end === void 0 ? start : Math.min(offsets.end, length);\n          if (!selection.extend && start > end) {\n            var temp = end;\n            end = start;\n            start = temp;\n          }\n          var startMarker = getNodeForCharacterOffset(node, start);\n          var endMarker = getNodeForCharacterOffset(node, end);\n          if (startMarker && endMarker) {\n            if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {\n              return;\n            }\n            var range = doc.createRange();\n            range.setStart(startMarker.node, startMarker.offset);\n            selection.removeAllRanges();\n            if (start > end) {\n              selection.addRange(range);\n              selection.extend(endMarker.node, endMarker.offset);\n            } else {\n              range.setEnd(endMarker.node, endMarker.offset);\n              selection.addRange(range);\n            }\n          }\n        }\n        function isTextNode(node) {\n          return node && node.nodeType === TEXT_NODE;\n        }\n        function containsNode(outerNode, innerNode) {\n          if (!outerNode || !innerNode) {\n            return false;\n          } else if (outerNode === innerNode) {\n            return true;\n          } else if (isTextNode(outerNode)) {\n            return false;\n          } else if (isTextNode(innerNode)) {\n            return containsNode(outerNode, innerNode.parentNode);\n          } else if (\"contains\" in outerNode) {\n            return outerNode.contains(innerNode);\n          } else if (outerNode.compareDocumentPosition) {\n            return !!(outerNode.compareDocumentPosition(innerNode) & 16);\n          } else {\n            return false;\n          }\n        }\n        function isInDocument(node) {\n          return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);\n        }\n        function isSameOriginFrame(iframe) {\n          try {\n            return typeof iframe.contentWindow.location.href === \"string\";\n          } catch (err) {\n            return false;\n          }\n        }\n        function getActiveElementDeep() {\n          var win = window;\n          var element = getActiveElement();\n          while (element instanceof win.HTMLIFrameElement) {\n            if (isSameOriginFrame(element)) {\n              win = element.contentWindow;\n            } else {\n              return element;\n            }\n            element = getActiveElement(win.document);\n          }\n          return element;\n        }\n        function hasSelectionCapabilities(elem) {\n          var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n          return nodeName && (nodeName === \"input\" && (elem.type === \"text\" || elem.type === \"search\" || elem.type === \"tel\" || elem.type === \"url\" || elem.type === \"password\") || nodeName === \"textarea\" || elem.contentEditable === \"true\");\n        }\n        function getSelectionInformation() {\n          var focusedElem = getActiveElementDeep();\n          return {\n            focusedElem,\n            selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null\n          };\n        }\n        function restoreSelection(priorSelectionInformation) {\n          var curFocusedElem = getActiveElementDeep();\n          var priorFocusedElem = priorSelectionInformation.focusedElem;\n          var priorSelectionRange = priorSelectionInformation.selectionRange;\n          if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {\n            if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {\n              setSelection(priorFocusedElem, priorSelectionRange);\n            }\n            var ancestors = [];\n            var ancestor = priorFocusedElem;\n            while (ancestor = ancestor.parentNode) {\n              if (ancestor.nodeType === ELEMENT_NODE) {\n                ancestors.push({\n                  element: ancestor,\n                  left: ancestor.scrollLeft,\n                  top: ancestor.scrollTop\n                });\n              }\n            }\n            if (typeof priorFocusedElem.focus === \"function\") {\n              priorFocusedElem.focus();\n            }\n            for (var i = 0; i < ancestors.length; i++) {\n              var info = ancestors[i];\n              info.element.scrollLeft = info.left;\n              info.element.scrollTop = info.top;\n            }\n          }\n        }\n        function getSelection(input) {\n          var selection;\n          if (\"selectionStart\" in input) {\n            selection = {\n              start: input.selectionStart,\n              end: input.selectionEnd\n            };\n          } else {\n            selection = getOffsets(input);\n          }\n          return selection || {\n            start: 0,\n            end: 0\n          };\n        }\n        function setSelection(input, offsets) {\n          var start = offsets.start;\n          var end = offsets.end;\n          if (end === void 0) {\n            end = start;\n          }\n          if (\"selectionStart\" in input) {\n            input.selectionStart = start;\n            input.selectionEnd = Math.min(end, input.value.length);\n          } else {\n            setOffsets(input, offsets);\n          }\n        }\n        var skipSelectionChangeEvent = canUseDOM && \"documentMode\" in document && document.documentMode <= 11;\n        function registerEvents$3() {\n          registerTwoPhaseEvent(\"onSelect\", [\"focusout\", \"contextmenu\", \"dragend\", \"focusin\", \"keydown\", \"keyup\", \"mousedown\", \"mouseup\", \"selectionchange\"]);\n        }\n        var activeElement$1 = null;\n        var activeElementInst$1 = null;\n        var lastSelection = null;\n        var mouseDown = false;\n        function getSelection$1(node) {\n          if (\"selectionStart\" in node && hasSelectionCapabilities(node)) {\n            return {\n              start: node.selectionStart,\n              end: node.selectionEnd\n            };\n          } else {\n            var win = node.ownerDocument && node.ownerDocument.defaultView || window;\n            var selection = win.getSelection();\n            return {\n              anchorNode: selection.anchorNode,\n              anchorOffset: selection.anchorOffset,\n              focusNode: selection.focusNode,\n              focusOffset: selection.focusOffset\n            };\n          }\n        }\n        function getEventTargetDocument(eventTarget) {\n          return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;\n        }\n        function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n          var doc = getEventTargetDocument(nativeEventTarget);\n          if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {\n            return;\n          }\n          var currentSelection = getSelection$1(activeElement$1);\n          if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {\n            lastSelection = currentSelection;\n            var listeners = accumulateTwoPhaseListeners(activeElementInst$1, \"onSelect\");\n            if (listeners.length > 0) {\n              var event = new SyntheticEvent(\"onSelect\", \"select\", null, nativeEvent, nativeEventTarget);\n              dispatchQueue.push({\n                event,\n                listeners\n              });\n              event.target = activeElement$1;\n            }\n          }\n        }\n        function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;\n          switch (domEventName) {\n            case \"focusin\":\n              if (isTextInputElement(targetNode) || targetNode.contentEditable === \"true\") {\n                activeElement$1 = targetNode;\n                activeElementInst$1 = targetInst;\n                lastSelection = null;\n              }\n              break;\n            case \"focusout\":\n              activeElement$1 = null;\n              activeElementInst$1 = null;\n              lastSelection = null;\n              break;\n            case \"mousedown\":\n              mouseDown = true;\n              break;\n            case \"contextmenu\":\n            case \"mouseup\":\n            case \"dragend\":\n              mouseDown = false;\n              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n              break;\n            case \"selectionchange\":\n              if (skipSelectionChangeEvent) {\n                break;\n              }\n            case \"keydown\":\n            case \"keyup\":\n              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n          }\n        }\n        function makePrefixMap(styleProp, eventName) {\n          var prefixes2 = {};\n          prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();\n          prefixes2[\"Webkit\" + styleProp] = \"webkit\" + eventName;\n          prefixes2[\"Moz\" + styleProp] = \"moz\" + eventName;\n          return prefixes2;\n        }\n        var vendorPrefixes = {\n          animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n          animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\n          animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\n          transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n        };\n        var prefixedEventNames = {};\n        var style = {};\n        if (canUseDOM) {\n          style = document.createElement(\"div\").style;\n          if (!(\"AnimationEvent\" in window)) {\n            delete vendorPrefixes.animationend.animation;\n            delete vendorPrefixes.animationiteration.animation;\n            delete vendorPrefixes.animationstart.animation;\n          }\n          if (!(\"TransitionEvent\" in window)) {\n            delete vendorPrefixes.transitionend.transition;\n          }\n        }\n        function getVendorPrefixedEventName(eventName) {\n          if (prefixedEventNames[eventName]) {\n            return prefixedEventNames[eventName];\n          } else if (!vendorPrefixes[eventName]) {\n            return eventName;\n          }\n          var prefixMap = vendorPrefixes[eventName];\n          for (var styleProp in prefixMap) {\n            if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {\n              return prefixedEventNames[eventName] = prefixMap[styleProp];\n            }\n          }\n          return eventName;\n        }\n        var ANIMATION_END = getVendorPrefixedEventName(\"animationend\");\n        var ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\");\n        var ANIMATION_START = getVendorPrefixedEventName(\"animationstart\");\n        var TRANSITION_END = getVendorPrefixedEventName(\"transitionend\");\n        var topLevelEventsToReactNames = /* @__PURE__ */ new Map();\n        var simpleEventPluginEvents = [\"abort\", \"auxClick\", \"cancel\", \"canPlay\", \"canPlayThrough\", \"click\", \"close\", \"contextMenu\", \"copy\", \"cut\", \"drag\", \"dragEnd\", \"dragEnter\", \"dragExit\", \"dragLeave\", \"dragOver\", \"dragStart\", \"drop\", \"durationChange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"gotPointerCapture\", \"input\", \"invalid\", \"keyDown\", \"keyPress\", \"keyUp\", \"load\", \"loadedData\", \"loadedMetadata\", \"loadStart\", \"lostPointerCapture\", \"mouseDown\", \"mouseMove\", \"mouseOut\", \"mouseOver\", \"mouseUp\", \"paste\", \"pause\", \"play\", \"playing\", \"pointerCancel\", \"pointerDown\", \"pointerMove\", \"pointerOut\", \"pointerOver\", \"pointerUp\", \"progress\", \"rateChange\", \"reset\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"submit\", \"suspend\", \"timeUpdate\", \"touchCancel\", \"touchEnd\", \"touchStart\", \"volumeChange\", \"scroll\", \"toggle\", \"touchMove\", \"waiting\", \"wheel\"];\n        function registerSimpleEvent(domEventName, reactName) {\n          topLevelEventsToReactNames.set(domEventName, reactName);\n          registerTwoPhaseEvent(reactName, [domEventName]);\n        }\n        function registerSimpleEvents() {\n          for (var i = 0; i < simpleEventPluginEvents.length; i++) {\n            var eventName = simpleEventPluginEvents[i];\n            var domEventName = eventName.toLowerCase();\n            var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);\n            registerSimpleEvent(domEventName, \"on\" + capitalizedEvent);\n          }\n          registerSimpleEvent(ANIMATION_END, \"onAnimationEnd\");\n          registerSimpleEvent(ANIMATION_ITERATION, \"onAnimationIteration\");\n          registerSimpleEvent(ANIMATION_START, \"onAnimationStart\");\n          registerSimpleEvent(\"dblclick\", \"onDoubleClick\");\n          registerSimpleEvent(\"focusin\", \"onFocus\");\n          registerSimpleEvent(\"focusout\", \"onBlur\");\n          registerSimpleEvent(TRANSITION_END, \"onTransitionEnd\");\n        }\n        function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          var reactName = topLevelEventsToReactNames.get(domEventName);\n          if (reactName === void 0) {\n            return;\n          }\n          var SyntheticEventCtor = SyntheticEvent;\n          var reactEventType = domEventName;\n          switch (domEventName) {\n            case \"keypress\":\n              if (getEventCharCode(nativeEvent) === 0) {\n                return;\n              }\n            case \"keydown\":\n            case \"keyup\":\n              SyntheticEventCtor = SyntheticKeyboardEvent;\n              break;\n            case \"focusin\":\n              reactEventType = \"focus\";\n              SyntheticEventCtor = SyntheticFocusEvent;\n              break;\n            case \"focusout\":\n              reactEventType = \"blur\";\n              SyntheticEventCtor = SyntheticFocusEvent;\n              break;\n            case \"beforeblur\":\n            case \"afterblur\":\n              SyntheticEventCtor = SyntheticFocusEvent;\n              break;\n            case \"click\":\n              if (nativeEvent.button === 2) {\n                return;\n              }\n            case \"auxclick\":\n            case \"dblclick\":\n            case \"mousedown\":\n            case \"mousemove\":\n            case \"mouseup\":\n            case \"mouseout\":\n            case \"mouseover\":\n            case \"contextmenu\":\n              SyntheticEventCtor = SyntheticMouseEvent;\n              break;\n            case \"drag\":\n            case \"dragend\":\n            case \"dragenter\":\n            case \"dragexit\":\n            case \"dragleave\":\n            case \"dragover\":\n            case \"dragstart\":\n            case \"drop\":\n              SyntheticEventCtor = SyntheticDragEvent;\n              break;\n            case \"touchcancel\":\n            case \"touchend\":\n            case \"touchmove\":\n            case \"touchstart\":\n              SyntheticEventCtor = SyntheticTouchEvent;\n              break;\n            case ANIMATION_END:\n            case ANIMATION_ITERATION:\n            case ANIMATION_START:\n              SyntheticEventCtor = SyntheticAnimationEvent;\n              break;\n            case TRANSITION_END:\n              SyntheticEventCtor = SyntheticTransitionEvent;\n              break;\n            case \"scroll\":\n              SyntheticEventCtor = SyntheticUIEvent;\n              break;\n            case \"wheel\":\n              SyntheticEventCtor = SyntheticWheelEvent;\n              break;\n            case \"copy\":\n            case \"cut\":\n            case \"paste\":\n              SyntheticEventCtor = SyntheticClipboardEvent;\n              break;\n            case \"gotpointercapture\":\n            case \"lostpointercapture\":\n            case \"pointercancel\":\n            case \"pointerdown\":\n            case \"pointermove\":\n            case \"pointerout\":\n            case \"pointerover\":\n            case \"pointerup\":\n              SyntheticEventCtor = SyntheticPointerEvent;\n              break;\n          }\n          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n          {\n            var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from\n            // nonDelegatedEvents list in DOMPluginEventSystem.\n            // Then we can remove this special list.\n            // This is a breaking change that can wait until React 18.\n            domEventName === \"scroll\";\n            var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);\n            if (_listeners.length > 0) {\n              var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);\n              dispatchQueue.push({\n                event: _event,\n                listeners: _listeners\n              });\n            }\n          }\n        }\n        registerSimpleEvents();\n        registerEvents$2();\n        registerEvents$1();\n        registerEvents$3();\n        registerEvents();\n        function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {\n          extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n          var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;\n          if (shouldProcessPolyfillPlugins) {\n            extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n            extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);\n          }\n        }\n        var mediaEventTypes = [\"abort\", \"canplay\", \"canplaythrough\", \"durationchange\", \"emptied\", \"encrypted\", \"ended\", \"error\", \"loadeddata\", \"loadedmetadata\", \"loadstart\", \"pause\", \"play\", \"playing\", \"progress\", \"ratechange\", \"resize\", \"seeked\", \"seeking\", \"stalled\", \"suspend\", \"timeupdate\", \"volumechange\", \"waiting\"];\n        var nonDelegatedEvents = new Set([\"cancel\", \"close\", \"invalid\", \"load\", \"scroll\", \"toggle\"].concat(mediaEventTypes));\n        function executeDispatch(event, listener, currentTarget) {\n          var type = event.type || \"unknown-event\";\n          event.currentTarget = currentTarget;\n          invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);\n          event.currentTarget = null;\n        }\n        function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {\n          var previousInstance;\n          if (inCapturePhase) {\n            for (var i = dispatchListeners.length - 1; i >= 0; i--) {\n              var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;\n              if (instance !== previousInstance && event.isPropagationStopped()) {\n                return;\n              }\n              executeDispatch(event, listener, currentTarget);\n              previousInstance = instance;\n            }\n          } else {\n            for (var _i = 0; _i < dispatchListeners.length; _i++) {\n              var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;\n              if (_instance !== previousInstance && event.isPropagationStopped()) {\n                return;\n              }\n              executeDispatch(event, _listener, _currentTarget);\n              previousInstance = _instance;\n            }\n          }\n        }\n        function processDispatchQueue(dispatchQueue, eventSystemFlags) {\n          var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;\n          for (var i = 0; i < dispatchQueue.length; i++) {\n            var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;\n            processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);\n          }\n          rethrowCaughtError();\n        }\n        function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n          var nativeEventTarget = getEventTarget(nativeEvent);\n          var dispatchQueue = [];\n          extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);\n          processDispatchQueue(dispatchQueue, eventSystemFlags);\n        }\n        function listenToNonDelegatedEvent(domEventName, targetElement) {\n          {\n            if (!nonDelegatedEvents.has(domEventName)) {\n              error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". This is a bug in React. Please file an issue.', domEventName);\n            }\n          }\n          var isCapturePhaseListener = false;\n          var listenerSet = getEventListenerSet(targetElement);\n          var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);\n          if (!listenerSet.has(listenerSetKey)) {\n            addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);\n            listenerSet.add(listenerSetKey);\n          }\n        }\n        function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n          {\n            if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {\n              error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);\n            }\n          }\n          var eventSystemFlags = 0;\n          if (isCapturePhaseListener) {\n            eventSystemFlags |= IS_CAPTURE_PHASE;\n          }\n          addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);\n        }\n        var listeningMarker = \"_reactListening\" + Math.random().toString(36).slice(2);\n        function listenToAllSupportedEvents(rootContainerElement) {\n          if (!rootContainerElement[listeningMarker]) {\n            rootContainerElement[listeningMarker] = true;\n            allNativeEvents.forEach(function(domEventName) {\n              if (domEventName !== \"selectionchange\") {\n                if (!nonDelegatedEvents.has(domEventName)) {\n                  listenToNativeEvent(domEventName, false, rootContainerElement);\n                }\n                listenToNativeEvent(domEventName, true, rootContainerElement);\n              }\n            });\n            var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n            if (ownerDocument !== null) {\n              if (!ownerDocument[listeningMarker]) {\n                ownerDocument[listeningMarker] = true;\n                listenToNativeEvent(\"selectionchange\", false, ownerDocument);\n              }\n            }\n          }\n        }\n        function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {\n          var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);\n          var isPassiveListener = void 0;\n          if (passiveBrowserEventsSupported) {\n            if (domEventName === \"touchstart\" || domEventName === \"touchmove\" || domEventName === \"wheel\") {\n              isPassiveListener = true;\n            }\n          }\n          targetContainer = targetContainer;\n          var unsubscribeListener;\n          if (isCapturePhaseListener) {\n            if (isPassiveListener !== void 0) {\n              unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n            } else {\n              unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);\n            }\n          } else {\n            if (isPassiveListener !== void 0) {\n              unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);\n            } else {\n              unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);\n            }\n          }\n        }\n        function isMatchingRootContainer(grandContainer, targetContainer) {\n          return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;\n        }\n        function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {\n          var ancestorInst = targetInst;\n          if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {\n            var targetContainerNode = targetContainer;\n            if (targetInst !== null) {\n              var node = targetInst;\n              mainLoop: while (true) {\n                if (node === null) {\n                  return;\n                }\n                var nodeTag = node.tag;\n                if (nodeTag === HostRoot || nodeTag === HostPortal) {\n                  var container = node.stateNode.containerInfo;\n                  if (isMatchingRootContainer(container, targetContainerNode)) {\n                    break;\n                  }\n                  if (nodeTag === HostPortal) {\n                    var grandNode = node.return;\n                    while (grandNode !== null) {\n                      var grandTag = grandNode.tag;\n                      if (grandTag === HostRoot || grandTag === HostPortal) {\n                        var grandContainer = grandNode.stateNode.containerInfo;\n                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {\n                          return;\n                        }\n                      }\n                      grandNode = grandNode.return;\n                    }\n                  }\n                  while (container !== null) {\n                    var parentNode = getClosestInstanceFromNode(container);\n                    if (parentNode === null) {\n                      return;\n                    }\n                    var parentTag = parentNode.tag;\n                    if (parentTag === HostComponent || parentTag === HostText) {\n                      node = ancestorInst = parentNode;\n                      continue mainLoop;\n                    }\n                    container = container.parentNode;\n                  }\n                }\n                node = node.return;\n              }\n            }\n          }\n          batchedUpdates(function() {\n            return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);\n          });\n        }\n        function createDispatchListener(instance, listener, currentTarget) {\n          return {\n            instance,\n            listener,\n            currentTarget\n          };\n        }\n        function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {\n          var captureName = reactName !== null ? reactName + \"Capture\" : null;\n          var reactEventName = inCapturePhase ? captureName : reactName;\n          var listeners = [];\n          var instance = targetFiber;\n          var lastHostComponent = null;\n          while (instance !== null) {\n            var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;\n            if (tag === HostComponent && stateNode !== null) {\n              lastHostComponent = stateNode;\n              if (reactEventName !== null) {\n                var listener = getListener(instance, reactEventName);\n                if (listener != null) {\n                  listeners.push(createDispatchListener(instance, listener, lastHostComponent));\n                }\n              }\n            }\n            if (accumulateTargetOnly) {\n              break;\n            }\n            instance = instance.return;\n          }\n          return listeners;\n        }\n        function accumulateTwoPhaseListeners(targetFiber, reactName) {\n          var captureName = reactName + \"Capture\";\n          var listeners = [];\n          var instance = targetFiber;\n          while (instance !== null) {\n            var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;\n            if (tag === HostComponent && stateNode !== null) {\n              var currentTarget = stateNode;\n              var captureListener = getListener(instance, captureName);\n              if (captureListener != null) {\n                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n              }\n              var bubbleListener = getListener(instance, reactName);\n              if (bubbleListener != null) {\n                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n              }\n            }\n            instance = instance.return;\n          }\n          return listeners;\n        }\n        function getParent(inst) {\n          if (inst === null) {\n            return null;\n          }\n          do {\n            inst = inst.return;\n          } while (inst && inst.tag !== HostComponent);\n          if (inst) {\n            return inst;\n          }\n          return null;\n        }\n        function getLowestCommonAncestor(instA, instB) {\n          var nodeA = instA;\n          var nodeB = instB;\n          var depthA = 0;\n          for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {\n            depthA++;\n          }\n          var depthB = 0;\n          for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {\n            depthB++;\n          }\n          while (depthA - depthB > 0) {\n            nodeA = getParent(nodeA);\n            depthA--;\n          }\n          while (depthB - depthA > 0) {\n            nodeB = getParent(nodeB);\n            depthB--;\n          }\n          var depth = depthA;\n          while (depth--) {\n            if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {\n              return nodeA;\n            }\n            nodeA = getParent(nodeA);\n            nodeB = getParent(nodeB);\n          }\n          return null;\n        }\n        function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {\n          var registrationName = event._reactName;\n          var listeners = [];\n          var instance = target;\n          while (instance !== null) {\n            if (instance === common) {\n              break;\n            }\n            var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;\n            if (alternate !== null && alternate === common) {\n              break;\n            }\n            if (tag === HostComponent && stateNode !== null) {\n              var currentTarget = stateNode;\n              if (inCapturePhase) {\n                var captureListener = getListener(instance, registrationName);\n                if (captureListener != null) {\n                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));\n                }\n              } else if (!inCapturePhase) {\n                var bubbleListener = getListener(instance, registrationName);\n                if (bubbleListener != null) {\n                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));\n                }\n              }\n            }\n            instance = instance.return;\n          }\n          if (listeners.length !== 0) {\n            dispatchQueue.push({\n              event,\n              listeners\n            });\n          }\n        }\n        function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {\n          var common = from && to ? getLowestCommonAncestor(from, to) : null;\n          if (from !== null) {\n            accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);\n          }\n          if (to !== null && enterEvent !== null) {\n            accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);\n          }\n        }\n        function getListenerSetKey(domEventName, capture) {\n          return domEventName + \"__\" + (capture ? \"capture\" : \"bubble\");\n        }\n        var didWarnInvalidHydration = false;\n        var DANGEROUSLY_SET_INNER_HTML = \"dangerouslySetInnerHTML\";\n        var SUPPRESS_CONTENT_EDITABLE_WARNING = \"suppressContentEditableWarning\";\n        var SUPPRESS_HYDRATION_WARNING = \"suppressHydrationWarning\";\n        var AUTOFOCUS = \"autoFocus\";\n        var CHILDREN = \"children\";\n        var STYLE = \"style\";\n        var HTML$1 = \"__html\";\n        var warnedUnknownTags;\n        var validatePropertiesInDevelopment;\n        var warnForPropDifference;\n        var warnForExtraAttributes;\n        var warnForInvalidEventListener;\n        var canDiffStyleForHydrationWarning;\n        var normalizeHTML;\n        {\n          warnedUnknownTags = {\n            // There are working polyfills for <dialog>. Let people use it.\n            dialog: true,\n            // Electron ships a custom <webview> tag to display external web content in\n            // an isolated frame and process.\n            // This tag is not present in non Electron environments such as JSDom which\n            // is often used for testing purposes.\n            // @see https://electronjs.org/docs/api/webview-tag\n            webview: true\n          };\n          validatePropertiesInDevelopment = function(type, props) {\n            validateProperties(type, props);\n            validateProperties$1(type, props);\n            validateProperties$2(type, props, {\n              registrationNameDependencies,\n              possibleRegistrationNames\n            });\n          };\n          canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;\n          warnForPropDifference = function(propName, serverValue, clientValue) {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);\n            var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);\n            if (normalizedServerValue === normalizedClientValue) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error(\"Prop `%s` did not match. Server: %s Client: %s\", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));\n          };\n          warnForExtraAttributes = function(attributeNames) {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            var names = [];\n            attributeNames.forEach(function(name) {\n              names.push(name);\n            });\n            error(\"Extra attributes from the server: %s\", names);\n          };\n          warnForInvalidEventListener = function(registrationName, listener) {\n            if (listener === false) {\n              error(\"Expected `%s` listener to be a function, instead got `false`.\\n\\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.\", registrationName, registrationName, registrationName);\n            } else {\n              error(\"Expected `%s` listener to be a function, instead got a value of `%s` type.\", registrationName, typeof listener);\n            }\n          };\n          normalizeHTML = function(parent, html) {\n            var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);\n            testElement.innerHTML = html;\n            return testElement.innerHTML;\n          };\n        }\n        var NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g;\n        var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\n        function normalizeMarkupForTextOrAttribute(markup) {\n          {\n            checkHtmlStringCoercion(markup);\n          }\n          var markupString = typeof markup === \"string\" ? markup : \"\" + markup;\n          return markupString.replace(NORMALIZE_NEWLINES_REGEX, \"\\n\").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \"\");\n        }\n        function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {\n          var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);\n          var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);\n          if (normalizedServerText === normalizedClientText) {\n            return;\n          }\n          if (shouldWarnDev) {\n            {\n              if (!didWarnInvalidHydration) {\n                didWarnInvalidHydration = true;\n                error('Text content did not match. Server: \"%s\" Client: \"%s\"', normalizedServerText, normalizedClientText);\n              }\n            }\n          }\n          if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {\n            throw new Error(\"Text content does not match server-rendered HTML.\");\n          }\n        }\n        function getOwnerDocumentFromRootContainer(rootContainerElement) {\n          return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;\n        }\n        function noop() {\n        }\n        function trapClickOnNonInteractiveElement(node) {\n          node.onclick = noop;\n        }\n        function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {\n          for (var propKey in nextProps) {\n            if (!nextProps.hasOwnProperty(propKey)) {\n              continue;\n            }\n            var nextProp = nextProps[propKey];\n            if (propKey === STYLE) {\n              {\n                if (nextProp) {\n                  Object.freeze(nextProp);\n                }\n              }\n              setValueForStyles(domElement, nextProp);\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\n              if (nextHtml != null) {\n                setInnerHTML(domElement, nextHtml);\n              }\n            } else if (propKey === CHILDREN) {\n              if (typeof nextProp === \"string\") {\n                var canSetTextContent = tag !== \"textarea\" || nextProp !== \"\";\n                if (canSetTextContent) {\n                  setTextContent(domElement, nextProp);\n                }\n              } else if (typeof nextProp === \"number\") {\n                setTextContent(domElement, \"\" + nextProp);\n              }\n            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;\n            else if (propKey === AUTOFOCUS) ;\n            else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (nextProp != null) {\n                if (typeof nextProp !== \"function\") {\n                  warnForInvalidEventListener(propKey, nextProp);\n                }\n                if (propKey === \"onScroll\") {\n                  listenToNonDelegatedEvent(\"scroll\", domElement);\n                }\n              }\n            } else if (nextProp != null) {\n              setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);\n            }\n          }\n        }\n        function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {\n          for (var i = 0; i < updatePayload.length; i += 2) {\n            var propKey = updatePayload[i];\n            var propValue = updatePayload[i + 1];\n            if (propKey === STYLE) {\n              setValueForStyles(domElement, propValue);\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              setInnerHTML(domElement, propValue);\n            } else if (propKey === CHILDREN) {\n              setTextContent(domElement, propValue);\n            } else {\n              setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);\n            }\n          }\n        }\n        function createElement(type, props, rootContainerElement, parentNamespace) {\n          var isCustomComponentTag;\n          var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);\n          var domElement;\n          var namespaceURI = parentNamespace;\n          if (namespaceURI === HTML_NAMESPACE) {\n            namespaceURI = getIntrinsicNamespace(type);\n          }\n          if (namespaceURI === HTML_NAMESPACE) {\n            {\n              isCustomComponentTag = isCustomComponent(type, props);\n              if (!isCustomComponentTag && type !== type.toLowerCase()) {\n                error(\"<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.\", type);\n              }\n            }\n            if (type === \"script\") {\n              var div = ownerDocument.createElement(\"div\");\n              div.innerHTML = \"<script><\\/script>\";\n              var firstChild = div.firstChild;\n              domElement = div.removeChild(firstChild);\n            } else if (typeof props.is === \"string\") {\n              domElement = ownerDocument.createElement(type, {\n                is: props.is\n              });\n            } else {\n              domElement = ownerDocument.createElement(type);\n              if (type === \"select\") {\n                var node = domElement;\n                if (props.multiple) {\n                  node.multiple = true;\n                } else if (props.size) {\n                  node.size = props.size;\n                }\n              }\n            }\n          } else {\n            domElement = ownerDocument.createElementNS(namespaceURI, type);\n          }\n          {\n            if (namespaceURI === HTML_NAMESPACE) {\n              if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === \"[object HTMLUnknownElement]\" && !hasOwnProperty.call(warnedUnknownTags, type)) {\n                warnedUnknownTags[type] = true;\n                error(\"The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.\", type);\n              }\n            }\n          }\n          return domElement;\n        }\n        function createTextNode(text, rootContainerElement) {\n          return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);\n        }\n        function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {\n          var isCustomComponentTag = isCustomComponent(tag, rawProps);\n          {\n            validatePropertiesInDevelopment(tag, rawProps);\n          }\n          var props;\n          switch (tag) {\n            case \"dialog\":\n              listenToNonDelegatedEvent(\"cancel\", domElement);\n              listenToNonDelegatedEvent(\"close\", domElement);\n              props = rawProps;\n              break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n              listenToNonDelegatedEvent(\"load\", domElement);\n              props = rawProps;\n              break;\n            case \"video\":\n            case \"audio\":\n              for (var i = 0; i < mediaEventTypes.length; i++) {\n                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\n              }\n              props = rawProps;\n              break;\n            case \"source\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              props = rawProps;\n              break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              listenToNonDelegatedEvent(\"load\", domElement);\n              props = rawProps;\n              break;\n            case \"details\":\n              listenToNonDelegatedEvent(\"toggle\", domElement);\n              props = rawProps;\n              break;\n            case \"input\":\n              initWrapperState(domElement, rawProps);\n              props = getHostProps(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"option\":\n              validateProps(domElement, rawProps);\n              props = rawProps;\n              break;\n            case \"select\":\n              initWrapperState$1(domElement, rawProps);\n              props = getHostProps$1(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"textarea\":\n              initWrapperState$2(domElement, rawProps);\n              props = getHostProps$2(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            default:\n              props = rawProps;\n          }\n          assertValidProps(tag, props);\n          setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);\n          switch (tag) {\n            case \"input\":\n              track(domElement);\n              postMountWrapper(domElement, rawProps, false);\n              break;\n            case \"textarea\":\n              track(domElement);\n              postMountWrapper$3(domElement);\n              break;\n            case \"option\":\n              postMountWrapper$1(domElement, rawProps);\n              break;\n            case \"select\":\n              postMountWrapper$2(domElement, rawProps);\n              break;\n            default:\n              if (typeof props.onClick === \"function\") {\n                trapClickOnNonInteractiveElement(domElement);\n              }\n              break;\n          }\n        }\n        function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {\n          {\n            validatePropertiesInDevelopment(tag, nextRawProps);\n          }\n          var updatePayload = null;\n          var lastProps;\n          var nextProps;\n          switch (tag) {\n            case \"input\":\n              lastProps = getHostProps(domElement, lastRawProps);\n              nextProps = getHostProps(domElement, nextRawProps);\n              updatePayload = [];\n              break;\n            case \"select\":\n              lastProps = getHostProps$1(domElement, lastRawProps);\n              nextProps = getHostProps$1(domElement, nextRawProps);\n              updatePayload = [];\n              break;\n            case \"textarea\":\n              lastProps = getHostProps$2(domElement, lastRawProps);\n              nextProps = getHostProps$2(domElement, nextRawProps);\n              updatePayload = [];\n              break;\n            default:\n              lastProps = lastRawProps;\n              nextProps = nextRawProps;\n              if (typeof lastProps.onClick !== \"function\" && typeof nextProps.onClick === \"function\") {\n                trapClickOnNonInteractiveElement(domElement);\n              }\n              break;\n          }\n          assertValidProps(tag, nextProps);\n          var propKey;\n          var styleName;\n          var styleUpdates = null;\n          for (propKey in lastProps) {\n            if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {\n              continue;\n            }\n            if (propKey === STYLE) {\n              var lastStyle = lastProps[propKey];\n              for (styleName in lastStyle) {\n                if (lastStyle.hasOwnProperty(styleName)) {\n                  if (!styleUpdates) {\n                    styleUpdates = {};\n                  }\n                  styleUpdates[styleName] = \"\";\n                }\n              }\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ;\n            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;\n            else if (propKey === AUTOFOCUS) ;\n            else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (!updatePayload) {\n                updatePayload = [];\n              }\n            } else {\n              (updatePayload = updatePayload || []).push(propKey, null);\n            }\n          }\n          for (propKey in nextProps) {\n            var nextProp = nextProps[propKey];\n            var lastProp = lastProps != null ? lastProps[propKey] : void 0;\n            if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {\n              continue;\n            }\n            if (propKey === STYLE) {\n              {\n                if (nextProp) {\n                  Object.freeze(nextProp);\n                }\n              }\n              if (lastProp) {\n                for (styleName in lastProp) {\n                  if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {\n                    if (!styleUpdates) {\n                      styleUpdates = {};\n                    }\n                    styleUpdates[styleName] = \"\";\n                  }\n                }\n                for (styleName in nextProp) {\n                  if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {\n                    if (!styleUpdates) {\n                      styleUpdates = {};\n                    }\n                    styleUpdates[styleName] = nextProp[styleName];\n                  }\n                }\n              } else {\n                if (!styleUpdates) {\n                  if (!updatePayload) {\n                    updatePayload = [];\n                  }\n                  updatePayload.push(propKey, styleUpdates);\n                }\n                styleUpdates = nextProp;\n              }\n            } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n              var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\n              var lastHtml = lastProp ? lastProp[HTML$1] : void 0;\n              if (nextHtml != null) {\n                if (lastHtml !== nextHtml) {\n                  (updatePayload = updatePayload || []).push(propKey, nextHtml);\n                }\n              }\n            } else if (propKey === CHILDREN) {\n              if (typeof nextProp === \"string\" || typeof nextProp === \"number\") {\n                (updatePayload = updatePayload || []).push(propKey, \"\" + nextProp);\n              }\n            } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ;\n            else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (nextProp != null) {\n                if (typeof nextProp !== \"function\") {\n                  warnForInvalidEventListener(propKey, nextProp);\n                }\n                if (propKey === \"onScroll\") {\n                  listenToNonDelegatedEvent(\"scroll\", domElement);\n                }\n              }\n              if (!updatePayload && lastProp !== nextProp) {\n                updatePayload = [];\n              }\n            } else {\n              (updatePayload = updatePayload || []).push(propKey, nextProp);\n            }\n          }\n          if (styleUpdates) {\n            {\n              validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);\n            }\n            (updatePayload = updatePayload || []).push(STYLE, styleUpdates);\n          }\n          return updatePayload;\n        }\n        function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {\n          if (tag === \"input\" && nextRawProps.type === \"radio\" && nextRawProps.name != null) {\n            updateChecked(domElement, nextRawProps);\n          }\n          var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);\n          var isCustomComponentTag = isCustomComponent(tag, nextRawProps);\n          updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);\n          switch (tag) {\n            case \"input\":\n              updateWrapper(domElement, nextRawProps);\n              break;\n            case \"textarea\":\n              updateWrapper$1(domElement, nextRawProps);\n              break;\n            case \"select\":\n              postUpdateWrapper(domElement, nextRawProps);\n              break;\n          }\n        }\n        function getPossibleStandardName(propName) {\n          {\n            var lowerCasedName = propName.toLowerCase();\n            if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {\n              return null;\n            }\n            return possibleStandardNames[lowerCasedName] || null;\n          }\n        }\n        function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {\n          var isCustomComponentTag;\n          var extraAttributeNames;\n          {\n            isCustomComponentTag = isCustomComponent(tag, rawProps);\n            validatePropertiesInDevelopment(tag, rawProps);\n          }\n          switch (tag) {\n            case \"dialog\":\n              listenToNonDelegatedEvent(\"cancel\", domElement);\n              listenToNonDelegatedEvent(\"close\", domElement);\n              break;\n            case \"iframe\":\n            case \"object\":\n            case \"embed\":\n              listenToNonDelegatedEvent(\"load\", domElement);\n              break;\n            case \"video\":\n            case \"audio\":\n              for (var i = 0; i < mediaEventTypes.length; i++) {\n                listenToNonDelegatedEvent(mediaEventTypes[i], domElement);\n              }\n              break;\n            case \"source\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              break;\n            case \"img\":\n            case \"image\":\n            case \"link\":\n              listenToNonDelegatedEvent(\"error\", domElement);\n              listenToNonDelegatedEvent(\"load\", domElement);\n              break;\n            case \"details\":\n              listenToNonDelegatedEvent(\"toggle\", domElement);\n              break;\n            case \"input\":\n              initWrapperState(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"option\":\n              validateProps(domElement, rawProps);\n              break;\n            case \"select\":\n              initWrapperState$1(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n            case \"textarea\":\n              initWrapperState$2(domElement, rawProps);\n              listenToNonDelegatedEvent(\"invalid\", domElement);\n              break;\n          }\n          assertValidProps(tag, rawProps);\n          {\n            extraAttributeNames = /* @__PURE__ */ new Set();\n            var attributes = domElement.attributes;\n            for (var _i = 0; _i < attributes.length; _i++) {\n              var name = attributes[_i].name.toLowerCase();\n              switch (name) {\n                case \"value\":\n                  break;\n                case \"checked\":\n                  break;\n                case \"selected\":\n                  break;\n                default:\n                  extraAttributeNames.add(attributes[_i].name);\n              }\n            }\n          }\n          var updatePayload = null;\n          for (var propKey in rawProps) {\n            if (!rawProps.hasOwnProperty(propKey)) {\n              continue;\n            }\n            var nextProp = rawProps[propKey];\n            if (propKey === CHILDREN) {\n              if (typeof nextProp === \"string\") {\n                if (domElement.textContent !== nextProp) {\n                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);\n                  }\n                  updatePayload = [CHILDREN, nextProp];\n                }\n              } else if (typeof nextProp === \"number\") {\n                if (domElement.textContent !== \"\" + nextProp) {\n                  if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {\n                    checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);\n                  }\n                  updatePayload = [CHILDREN, \"\" + nextProp];\n                }\n              }\n            } else if (registrationNameDependencies.hasOwnProperty(propKey)) {\n              if (nextProp != null) {\n                if (typeof nextProp !== \"function\") {\n                  warnForInvalidEventListener(propKey, nextProp);\n                }\n                if (propKey === \"onScroll\") {\n                  listenToNonDelegatedEvent(\"scroll\", domElement);\n                }\n              }\n            } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)\n            typeof isCustomComponentTag === \"boolean\") {\n              var serverValue = void 0;\n              var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);\n              if (rawProps[SUPPRESS_HYDRATION_WARNING] === true) ;\n              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated\n              // TODO: Only ignore them on controlled tags.\n              propKey === \"value\" || propKey === \"checked\" || propKey === \"selected\") ;\n              else if (propKey === DANGEROUSLY_SET_INNER_HTML) {\n                var serverHTML = domElement.innerHTML;\n                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;\n                if (nextHtml != null) {\n                  var expectedHTML = normalizeHTML(domElement, nextHtml);\n                  if (expectedHTML !== serverHTML) {\n                    warnForPropDifference(propKey, serverHTML, expectedHTML);\n                  }\n                }\n              } else if (propKey === STYLE) {\n                extraAttributeNames.delete(propKey);\n                if (canDiffStyleForHydrationWarning) {\n                  var expectedStyle = createDangerousStringForStyles(nextProp);\n                  serverValue = domElement.getAttribute(\"style\");\n                  if (expectedStyle !== serverValue) {\n                    warnForPropDifference(propKey, serverValue, expectedStyle);\n                  }\n                }\n              } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {\n                extraAttributeNames.delete(propKey.toLowerCase());\n                serverValue = getValueForAttribute(domElement, propKey, nextProp);\n                if (nextProp !== serverValue) {\n                  warnForPropDifference(propKey, serverValue, nextProp);\n                }\n              } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {\n                var isMismatchDueToBadCasing = false;\n                if (propertyInfo !== null) {\n                  extraAttributeNames.delete(propertyInfo.attributeName);\n                  serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);\n                } else {\n                  var ownNamespace = parentNamespace;\n                  if (ownNamespace === HTML_NAMESPACE) {\n                    ownNamespace = getIntrinsicNamespace(tag);\n                  }\n                  if (ownNamespace === HTML_NAMESPACE) {\n                    extraAttributeNames.delete(propKey.toLowerCase());\n                  } else {\n                    var standardName = getPossibleStandardName(propKey);\n                    if (standardName !== null && standardName !== propKey) {\n                      isMismatchDueToBadCasing = true;\n                      extraAttributeNames.delete(standardName);\n                    }\n                    extraAttributeNames.delete(propKey);\n                  }\n                  serverValue = getValueForAttribute(domElement, propKey, nextProp);\n                }\n                var dontWarnCustomElement = enableCustomElementPropertySupport;\n                if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {\n                  warnForPropDifference(propKey, serverValue, nextProp);\n                }\n              }\n            }\n          }\n          {\n            if (shouldWarnDev) {\n              if (\n                // $FlowFixMe - Should be inferred as not undefined.\n                extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true\n              ) {\n                warnForExtraAttributes(extraAttributeNames);\n              }\n            }\n          }\n          switch (tag) {\n            case \"input\":\n              track(domElement);\n              postMountWrapper(domElement, rawProps, true);\n              break;\n            case \"textarea\":\n              track(domElement);\n              postMountWrapper$3(domElement);\n              break;\n            case \"select\":\n            case \"option\":\n              break;\n            default:\n              if (typeof rawProps.onClick === \"function\") {\n                trapClickOnNonInteractiveElement(domElement);\n              }\n              break;\n          }\n          return updatePayload;\n        }\n        function diffHydratedText(textNode, text, isConcurrentMode) {\n          var isDifferent = textNode.nodeValue !== text;\n          return isDifferent;\n        }\n        function warnForDeletedHydratableElement(parentNode, child) {\n          {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error(\"Did not expect server HTML to contain a <%s> in <%s>.\", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());\n          }\n        }\n        function warnForDeletedHydratableText(parentNode, child) {\n          {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error('Did not expect server HTML to contain the text node \"%s\" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());\n          }\n        }\n        function warnForInsertedHydratedElement(parentNode, tag, props) {\n          {\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error(\"Expected server HTML to contain a matching <%s> in <%s>.\", tag, parentNode.nodeName.toLowerCase());\n          }\n        }\n        function warnForInsertedHydratedText(parentNode, text) {\n          {\n            if (text === \"\") {\n              return;\n            }\n            if (didWarnInvalidHydration) {\n              return;\n            }\n            didWarnInvalidHydration = true;\n            error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.', text, parentNode.nodeName.toLowerCase());\n          }\n        }\n        function restoreControlledState$3(domElement, tag, props) {\n          switch (tag) {\n            case \"input\":\n              restoreControlledState(domElement, props);\n              return;\n            case \"textarea\":\n              restoreControlledState$2(domElement, props);\n              return;\n            case \"select\":\n              restoreControlledState$1(domElement, props);\n              return;\n          }\n        }\n        var validateDOMNesting = function() {\n        };\n        var updatedAncestorInfo = function() {\n        };\n        {\n          var specialTags = [\"address\", \"applet\", \"area\", \"article\", \"aside\", \"base\", \"basefont\", \"bgsound\", \"blockquote\", \"body\", \"br\", \"button\", \"caption\", \"center\", \"col\", \"colgroup\", \"dd\", \"details\", \"dir\", \"div\", \"dl\", \"dt\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"form\", \"frame\", \"frameset\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"head\", \"header\", \"hgroup\", \"hr\", \"html\", \"iframe\", \"img\", \"input\", \"isindex\", \"li\", \"link\", \"listing\", \"main\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"nav\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"p\", \"param\", \"plaintext\", \"pre\", \"script\", \"section\", \"select\", \"source\", \"style\", \"summary\", \"table\", \"tbody\", \"td\", \"template\", \"textarea\", \"tfoot\", \"th\", \"thead\", \"title\", \"tr\", \"track\", \"ul\", \"wbr\", \"xmp\"];\n          var inScopeTags = [\n            \"applet\",\n            \"caption\",\n            \"html\",\n            \"table\",\n            \"td\",\n            \"th\",\n            \"marquee\",\n            \"object\",\n            \"template\",\n            // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n            // TODO: Distinguish by namespace here -- for <title>, including it here\n            // errs on the side of fewer warnings\n            \"foreignObject\",\n            \"desc\",\n            \"title\"\n          ];\n          var buttonScopeTags = inScopeTags.concat([\"button\"]);\n          var impliedEndTags = [\"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"];\n          var emptyAncestorInfo = {\n            current: null,\n            formTag: null,\n            aTagInScope: null,\n            buttonTagInScope: null,\n            nobrTagInScope: null,\n            pTagInButtonScope: null,\n            listItemTagAutoclosing: null,\n            dlItemTagAutoclosing: null\n          };\n          updatedAncestorInfo = function(oldInfo, tag) {\n            var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);\n            var info = {\n              tag\n            };\n            if (inScopeTags.indexOf(tag) !== -1) {\n              ancestorInfo.aTagInScope = null;\n              ancestorInfo.buttonTagInScope = null;\n              ancestorInfo.nobrTagInScope = null;\n            }\n            if (buttonScopeTags.indexOf(tag) !== -1) {\n              ancestorInfo.pTagInButtonScope = null;\n            }\n            if (specialTags.indexOf(tag) !== -1 && tag !== \"address\" && tag !== \"div\" && tag !== \"p\") {\n              ancestorInfo.listItemTagAutoclosing = null;\n              ancestorInfo.dlItemTagAutoclosing = null;\n            }\n            ancestorInfo.current = info;\n            if (tag === \"form\") {\n              ancestorInfo.formTag = info;\n            }\n            if (tag === \"a\") {\n              ancestorInfo.aTagInScope = info;\n            }\n            if (tag === \"button\") {\n              ancestorInfo.buttonTagInScope = info;\n            }\n            if (tag === \"nobr\") {\n              ancestorInfo.nobrTagInScope = info;\n            }\n            if (tag === \"p\") {\n              ancestorInfo.pTagInButtonScope = info;\n            }\n            if (tag === \"li\") {\n              ancestorInfo.listItemTagAutoclosing = info;\n            }\n            if (tag === \"dd\" || tag === \"dt\") {\n              ancestorInfo.dlItemTagAutoclosing = info;\n            }\n            return ancestorInfo;\n          };\n          var isTagValidWithParent = function(tag, parentTag) {\n            switch (parentTag) {\n              case \"select\":\n                return tag === \"option\" || tag === \"optgroup\" || tag === \"#text\";\n              case \"optgroup\":\n                return tag === \"option\" || tag === \"#text\";\n              case \"option\":\n                return tag === \"#text\";\n              case \"tr\":\n                return tag === \"th\" || tag === \"td\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"tbody\":\n              case \"thead\":\n              case \"tfoot\":\n                return tag === \"tr\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"colgroup\":\n                return tag === \"col\" || tag === \"template\";\n              case \"table\":\n                return tag === \"caption\" || tag === \"colgroup\" || tag === \"tbody\" || tag === \"tfoot\" || tag === \"thead\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"head\":\n                return tag === \"base\" || tag === \"basefont\" || tag === \"bgsound\" || tag === \"link\" || tag === \"meta\" || tag === \"title\" || tag === \"noscript\" || tag === \"noframes\" || tag === \"style\" || tag === \"script\" || tag === \"template\";\n              case \"html\":\n                return tag === \"head\" || tag === \"body\" || tag === \"frameset\";\n              case \"frameset\":\n                return tag === \"frame\";\n              case \"#document\":\n                return tag === \"html\";\n            }\n            switch (tag) {\n              case \"h1\":\n              case \"h2\":\n              case \"h3\":\n              case \"h4\":\n              case \"h5\":\n              case \"h6\":\n                return parentTag !== \"h1\" && parentTag !== \"h2\" && parentTag !== \"h3\" && parentTag !== \"h4\" && parentTag !== \"h5\" && parentTag !== \"h6\";\n              case \"rp\":\n              case \"rt\":\n                return impliedEndTags.indexOf(parentTag) === -1;\n              case \"body\":\n              case \"caption\":\n              case \"col\":\n              case \"colgroup\":\n              case \"frameset\":\n              case \"frame\":\n              case \"head\":\n              case \"html\":\n              case \"tbody\":\n              case \"td\":\n              case \"tfoot\":\n              case \"th\":\n              case \"thead\":\n              case \"tr\":\n                return parentTag == null;\n            }\n            return true;\n          };\n          var findInvalidAncestorForTag = function(tag, ancestorInfo) {\n            switch (tag) {\n              case \"address\":\n              case \"article\":\n              case \"aside\":\n              case \"blockquote\":\n              case \"center\":\n              case \"details\":\n              case \"dialog\":\n              case \"dir\":\n              case \"div\":\n              case \"dl\":\n              case \"fieldset\":\n              case \"figcaption\":\n              case \"figure\":\n              case \"footer\":\n              case \"header\":\n              case \"hgroup\":\n              case \"main\":\n              case \"menu\":\n              case \"nav\":\n              case \"ol\":\n              case \"p\":\n              case \"section\":\n              case \"summary\":\n              case \"ul\":\n              case \"pre\":\n              case \"listing\":\n              case \"table\":\n              case \"hr\":\n              case \"xmp\":\n              case \"h1\":\n              case \"h2\":\n              case \"h3\":\n              case \"h4\":\n              case \"h5\":\n              case \"h6\":\n                return ancestorInfo.pTagInButtonScope;\n              case \"form\":\n                return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;\n              case \"li\":\n                return ancestorInfo.listItemTagAutoclosing;\n              case \"dd\":\n              case \"dt\":\n                return ancestorInfo.dlItemTagAutoclosing;\n              case \"button\":\n                return ancestorInfo.buttonTagInScope;\n              case \"a\":\n                return ancestorInfo.aTagInScope;\n              case \"nobr\":\n                return ancestorInfo.nobrTagInScope;\n            }\n            return null;\n          };\n          var didWarn$1 = {};\n          validateDOMNesting = function(childTag, childText, ancestorInfo) {\n            ancestorInfo = ancestorInfo || emptyAncestorInfo;\n            var parentInfo = ancestorInfo.current;\n            var parentTag = parentInfo && parentInfo.tag;\n            if (childText != null) {\n              if (childTag != null) {\n                error(\"validateDOMNesting: when childText is passed, childTag should be null\");\n              }\n              childTag = \"#text\";\n            }\n            var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;\n            var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);\n            var invalidParentOrAncestor = invalidParent || invalidAncestor;\n            if (!invalidParentOrAncestor) {\n              return;\n            }\n            var ancestorTag = invalidParentOrAncestor.tag;\n            var warnKey = !!invalidParent + \"|\" + childTag + \"|\" + ancestorTag;\n            if (didWarn$1[warnKey]) {\n              return;\n            }\n            didWarn$1[warnKey] = true;\n            var tagDisplayName = childTag;\n            var whitespaceInfo = \"\";\n            if (childTag === \"#text\") {\n              if (/\\S/.test(childText)) {\n                tagDisplayName = \"Text nodes\";\n              } else {\n                tagDisplayName = \"Whitespace text nodes\";\n                whitespaceInfo = \" Make sure you don't have any extra whitespace between tags on each line of your source code.\";\n              }\n            } else {\n              tagDisplayName = \"<\" + childTag + \">\";\n            }\n            if (invalidParent) {\n              var info = \"\";\n              if (ancestorTag === \"table\" && childTag === \"tr\") {\n                info += \" Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.\";\n              }\n              error(\"validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s\", tagDisplayName, ancestorTag, whitespaceInfo, info);\n            } else {\n              error(\"validateDOMNesting(...): %s cannot appear as a descendant of <%s>.\", tagDisplayName, ancestorTag);\n            }\n          };\n        }\n        var SUPPRESS_HYDRATION_WARNING$1 = \"suppressHydrationWarning\";\n        var SUSPENSE_START_DATA = \"$\";\n        var SUSPENSE_END_DATA = \"/$\";\n        var SUSPENSE_PENDING_START_DATA = \"$?\";\n        var SUSPENSE_FALLBACK_START_DATA = \"$!\";\n        var STYLE$1 = \"style\";\n        var eventsEnabled = null;\n        var selectionInformation = null;\n        function getRootHostContext(rootContainerInstance) {\n          var type;\n          var namespace;\n          var nodeType = rootContainerInstance.nodeType;\n          switch (nodeType) {\n            case DOCUMENT_NODE:\n            case DOCUMENT_FRAGMENT_NODE: {\n              type = nodeType === DOCUMENT_NODE ? \"#document\" : \"#fragment\";\n              var root2 = rootContainerInstance.documentElement;\n              namespace = root2 ? root2.namespaceURI : getChildNamespace(null, \"\");\n              break;\n            }\n            default: {\n              var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;\n              var ownNamespace = container.namespaceURI || null;\n              type = container.tagName;\n              namespace = getChildNamespace(ownNamespace, type);\n              break;\n            }\n          }\n          {\n            var validatedTag = type.toLowerCase();\n            var ancestorInfo = updatedAncestorInfo(null, validatedTag);\n            return {\n              namespace,\n              ancestorInfo\n            };\n          }\n        }\n        function getChildHostContext(parentHostContext, type, rootContainerInstance) {\n          {\n            var parentHostContextDev = parentHostContext;\n            var namespace = getChildNamespace(parentHostContextDev.namespace, type);\n            var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);\n            return {\n              namespace,\n              ancestorInfo\n            };\n          }\n        }\n        function getPublicInstance(instance) {\n          return instance;\n        }\n        function prepareForCommit(containerInfo) {\n          eventsEnabled = isEnabled();\n          selectionInformation = getSelectionInformation();\n          var activeInstance = null;\n          setEnabled(false);\n          return activeInstance;\n        }\n        function resetAfterCommit(containerInfo) {\n          restoreSelection(selectionInformation);\n          setEnabled(eventsEnabled);\n          eventsEnabled = null;\n          selectionInformation = null;\n        }\n        function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {\n          var parentNamespace;\n          {\n            var hostContextDev = hostContext;\n            validateDOMNesting(type, null, hostContextDev.ancestorInfo);\n            if (typeof props.children === \"string\" || typeof props.children === \"number\") {\n              var string = \"\" + props.children;\n              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n              validateDOMNesting(null, string, ownAncestorInfo);\n            }\n            parentNamespace = hostContextDev.namespace;\n          }\n          var domElement = createElement(type, props, rootContainerInstance, parentNamespace);\n          precacheFiberNode(internalInstanceHandle, domElement);\n          updateFiberProps(domElement, props);\n          return domElement;\n        }\n        function appendInitialChild(parentInstance, child) {\n          parentInstance.appendChild(child);\n        }\n        function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {\n          setInitialProperties(domElement, type, props, rootContainerInstance);\n          switch (type) {\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n              return !!props.autoFocus;\n            case \"img\":\n              return true;\n            default:\n              return false;\n          }\n        }\n        function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {\n          {\n            var hostContextDev = hostContext;\n            if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === \"string\" || typeof newProps.children === \"number\")) {\n              var string = \"\" + newProps.children;\n              var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);\n              validateDOMNesting(null, string, ownAncestorInfo);\n            }\n          }\n          return diffProperties(domElement, type, oldProps, newProps);\n        }\n        function shouldSetTextContent(type, props) {\n          return type === \"textarea\" || type === \"noscript\" || typeof props.children === \"string\" || typeof props.children === \"number\" || typeof props.dangerouslySetInnerHTML === \"object\" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;\n        }\n        function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {\n          {\n            var hostContextDev = hostContext;\n            validateDOMNesting(null, text, hostContextDev.ancestorInfo);\n          }\n          var textNode = createTextNode(text, rootContainerInstance);\n          precacheFiberNode(internalInstanceHandle, textNode);\n          return textNode;\n        }\n        function getCurrentEventPriority() {\n          var currentEvent = window.event;\n          if (currentEvent === void 0) {\n            return DefaultEventPriority;\n          }\n          return getEventPriority(currentEvent.type);\n        }\n        var scheduleTimeout = typeof setTimeout === \"function\" ? setTimeout : void 0;\n        var cancelTimeout = typeof clearTimeout === \"function\" ? clearTimeout : void 0;\n        var noTimeout = -1;\n        var localPromise = typeof Promise === \"function\" ? Promise : void 0;\n        var scheduleMicrotask = typeof queueMicrotask === \"function\" ? queueMicrotask : typeof localPromise !== \"undefined\" ? function(callback) {\n          return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);\n        } : scheduleTimeout;\n        function handleErrorInNextTick(error2) {\n          setTimeout(function() {\n            throw error2;\n          });\n        }\n        function commitMount(domElement, type, newProps, internalInstanceHandle) {\n          switch (type) {\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n              if (newProps.autoFocus) {\n                domElement.focus();\n              }\n              return;\n            case \"img\": {\n              if (newProps.src) {\n                domElement.src = newProps.src;\n              }\n              return;\n            }\n          }\n        }\n        function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {\n          updateProperties(domElement, updatePayload, type, oldProps, newProps);\n          updateFiberProps(domElement, newProps);\n        }\n        function resetTextContent(domElement) {\n          setTextContent(domElement, \"\");\n        }\n        function commitTextUpdate(textInstance, oldText, newText) {\n          textInstance.nodeValue = newText;\n        }\n        function appendChild(parentInstance, child) {\n          parentInstance.appendChild(child);\n        }\n        function appendChildToContainer(container, child) {\n          var parentNode;\n          if (container.nodeType === COMMENT_NODE) {\n            parentNode = container.parentNode;\n            parentNode.insertBefore(child, container);\n          } else {\n            parentNode = container;\n            parentNode.appendChild(child);\n          }\n          var reactRootContainer = container._reactRootContainer;\n          if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {\n            trapClickOnNonInteractiveElement(parentNode);\n          }\n        }\n        function insertBefore(parentInstance, child, beforeChild) {\n          parentInstance.insertBefore(child, beforeChild);\n        }\n        function insertInContainerBefore(container, child, beforeChild) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.insertBefore(child, beforeChild);\n          } else {\n            container.insertBefore(child, beforeChild);\n          }\n        }\n        function removeChild(parentInstance, child) {\n          parentInstance.removeChild(child);\n        }\n        function removeChildFromContainer(container, child) {\n          if (container.nodeType === COMMENT_NODE) {\n            container.parentNode.removeChild(child);\n          } else {\n            container.removeChild(child);\n          }\n        }\n        function clearSuspenseBoundary(parentInstance, suspenseInstance) {\n          var node = suspenseInstance;\n          var depth = 0;\n          do {\n            var nextNode = node.nextSibling;\n            parentInstance.removeChild(node);\n            if (nextNode && nextNode.nodeType === COMMENT_NODE) {\n              var data = nextNode.data;\n              if (data === SUSPENSE_END_DATA) {\n                if (depth === 0) {\n                  parentInstance.removeChild(nextNode);\n                  retryIfBlockedOn(suspenseInstance);\n                  return;\n                } else {\n                  depth--;\n                }\n              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {\n                depth++;\n              }\n            }\n            node = nextNode;\n          } while (node);\n          retryIfBlockedOn(suspenseInstance);\n        }\n        function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {\n          if (container.nodeType === COMMENT_NODE) {\n            clearSuspenseBoundary(container.parentNode, suspenseInstance);\n          } else if (container.nodeType === ELEMENT_NODE) {\n            clearSuspenseBoundary(container, suspenseInstance);\n          }\n          retryIfBlockedOn(container);\n        }\n        function hideInstance(instance) {\n          instance = instance;\n          var style2 = instance.style;\n          if (typeof style2.setProperty === \"function\") {\n            style2.setProperty(\"display\", \"none\", \"important\");\n          } else {\n            style2.display = \"none\";\n          }\n        }\n        function hideTextInstance(textInstance) {\n          textInstance.nodeValue = \"\";\n        }\n        function unhideInstance(instance, props) {\n          instance = instance;\n          var styleProp = props[STYLE$1];\n          var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty(\"display\") ? styleProp.display : null;\n          instance.style.display = dangerousStyleValue(\"display\", display);\n        }\n        function unhideTextInstance(textInstance, text) {\n          textInstance.nodeValue = text;\n        }\n        function clearContainer(container) {\n          if (container.nodeType === ELEMENT_NODE) {\n            container.textContent = \"\";\n          } else if (container.nodeType === DOCUMENT_NODE) {\n            if (container.documentElement) {\n              container.removeChild(container.documentElement);\n            }\n          }\n        }\n        function canHydrateInstance(instance, type, props) {\n          if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {\n            return null;\n          }\n          return instance;\n        }\n        function canHydrateTextInstance(instance, text) {\n          if (text === \"\" || instance.nodeType !== TEXT_NODE) {\n            return null;\n          }\n          return instance;\n        }\n        function canHydrateSuspenseInstance(instance) {\n          if (instance.nodeType !== COMMENT_NODE) {\n            return null;\n          }\n          return instance;\n        }\n        function isSuspenseInstancePending(instance) {\n          return instance.data === SUSPENSE_PENDING_START_DATA;\n        }\n        function isSuspenseInstanceFallback(instance) {\n          return instance.data === SUSPENSE_FALLBACK_START_DATA;\n        }\n        function getSuspenseInstanceFallbackErrorDetails(instance) {\n          var dataset = instance.nextSibling && instance.nextSibling.dataset;\n          var digest, message, stack;\n          if (dataset) {\n            digest = dataset.dgst;\n            {\n              message = dataset.msg;\n              stack = dataset.stck;\n            }\n          }\n          {\n            return {\n              message,\n              digest,\n              stack\n            };\n          }\n        }\n        function registerSuspenseInstanceRetry(instance, callback) {\n          instance._reactRetry = callback;\n        }\n        function getNextHydratable(node) {\n          for (; node != null; node = node.nextSibling) {\n            var nodeType = node.nodeType;\n            if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {\n              break;\n            }\n            if (nodeType === COMMENT_NODE) {\n              var nodeData = node.data;\n              if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {\n                break;\n              }\n              if (nodeData === SUSPENSE_END_DATA) {\n                return null;\n              }\n            }\n          }\n          return node;\n        }\n        function getNextHydratableSibling(instance) {\n          return getNextHydratable(instance.nextSibling);\n        }\n        function getFirstHydratableChild(parentInstance) {\n          return getNextHydratable(parentInstance.firstChild);\n        }\n        function getFirstHydratableChildWithinContainer(parentContainer) {\n          return getNextHydratable(parentContainer.firstChild);\n        }\n        function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {\n          return getNextHydratable(parentInstance.nextSibling);\n        }\n        function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {\n          precacheFiberNode(internalInstanceHandle, instance);\n          updateFiberProps(instance, props);\n          var parentNamespace;\n          {\n            var hostContextDev = hostContext;\n            parentNamespace = hostContextDev.namespace;\n          }\n          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n          return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);\n        }\n        function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {\n          precacheFiberNode(internalInstanceHandle, textInstance);\n          var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;\n          return diffHydratedText(textInstance, text);\n        }\n        function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {\n          precacheFiberNode(internalInstanceHandle, suspenseInstance);\n        }\n        function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {\n          var node = suspenseInstance.nextSibling;\n          var depth = 0;\n          while (node) {\n            if (node.nodeType === COMMENT_NODE) {\n              var data = node.data;\n              if (data === SUSPENSE_END_DATA) {\n                if (depth === 0) {\n                  return getNextHydratableSibling(node);\n                } else {\n                  depth--;\n                }\n              } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n                depth++;\n              }\n            }\n            node = node.nextSibling;\n          }\n          return null;\n        }\n        function getParentSuspenseInstance(targetInstance) {\n          var node = targetInstance.previousSibling;\n          var depth = 0;\n          while (node) {\n            if (node.nodeType === COMMENT_NODE) {\n              var data = node.data;\n              if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {\n                if (depth === 0) {\n                  return node;\n                } else {\n                  depth--;\n                }\n              } else if (data === SUSPENSE_END_DATA) {\n                depth++;\n              }\n            }\n            node = node.previousSibling;\n          }\n          return null;\n        }\n        function commitHydratedContainer(container) {\n          retryIfBlockedOn(container);\n        }\n        function commitHydratedSuspenseInstance(suspenseInstance) {\n          retryIfBlockedOn(suspenseInstance);\n        }\n        function shouldDeleteUnhydratedTailInstances(parentType) {\n          return parentType !== \"head\" && parentType !== \"body\";\n        }\n        function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {\n          var shouldWarnDev = true;\n          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n        }\n        function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {\n          if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n            var shouldWarnDev = true;\n            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);\n          }\n        }\n        function didNotHydrateInstanceWithinContainer(parentContainer, instance) {\n          {\n            if (instance.nodeType === ELEMENT_NODE) {\n              warnForDeletedHydratableElement(parentContainer, instance);\n            } else if (instance.nodeType === COMMENT_NODE) ;\n            else {\n              warnForDeletedHydratableText(parentContainer, instance);\n            }\n          }\n        }\n        function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {\n          {\n            var parentNode = parentInstance.parentNode;\n            if (parentNode !== null) {\n              if (instance.nodeType === ELEMENT_NODE) {\n                warnForDeletedHydratableElement(parentNode, instance);\n              } else if (instance.nodeType === COMMENT_NODE) ;\n              else {\n                warnForDeletedHydratableText(parentNode, instance);\n              }\n            }\n          }\n        }\n        function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {\n          {\n            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n              if (instance.nodeType === ELEMENT_NODE) {\n                warnForDeletedHydratableElement(parentInstance, instance);\n              } else if (instance.nodeType === COMMENT_NODE) ;\n              else {\n                warnForDeletedHydratableText(parentInstance, instance);\n              }\n            }\n          }\n        }\n        function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {\n          {\n            warnForInsertedHydratedElement(parentContainer, type);\n          }\n        }\n        function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {\n          {\n            warnForInsertedHydratedText(parentContainer, text);\n          }\n        }\n        function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {\n          {\n            var parentNode = parentInstance.parentNode;\n            if (parentNode !== null) warnForInsertedHydratedElement(parentNode, type);\n          }\n        }\n        function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {\n          {\n            var parentNode = parentInstance.parentNode;\n            if (parentNode !== null) warnForInsertedHydratedText(parentNode, text);\n          }\n        }\n        function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {\n          {\n            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n              warnForInsertedHydratedElement(parentInstance, type);\n            }\n          }\n        }\n        function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {\n          {\n            if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {\n              warnForInsertedHydratedText(parentInstance, text);\n            }\n          }\n        }\n        function errorHydratingContainer(parentContainer) {\n          {\n            error(\"An error occurred during hydration. The server HTML was replaced with client content in <%s>.\", parentContainer.nodeName.toLowerCase());\n          }\n        }\n        function preparePortalMount(portalInstance) {\n          listenToAllSupportedEvents(portalInstance);\n        }\n        var randomKey = Math.random().toString(36).slice(2);\n        var internalInstanceKey = \"__reactFiber$\" + randomKey;\n        var internalPropsKey = \"__reactProps$\" + randomKey;\n        var internalContainerInstanceKey = \"__reactContainer$\" + randomKey;\n        var internalEventHandlersKey = \"__reactEvents$\" + randomKey;\n        var internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey;\n        var internalEventHandlesSetKey = \"__reactHandles$\" + randomKey;\n        function detachDeletedInstance(node) {\n          delete node[internalInstanceKey];\n          delete node[internalPropsKey];\n          delete node[internalEventHandlersKey];\n          delete node[internalEventHandlerListenersKey];\n          delete node[internalEventHandlesSetKey];\n        }\n        function precacheFiberNode(hostInst, node) {\n          node[internalInstanceKey] = hostInst;\n        }\n        function markContainerAsRoot(hostRoot, node) {\n          node[internalContainerInstanceKey] = hostRoot;\n        }\n        function unmarkContainerAsRoot(node) {\n          node[internalContainerInstanceKey] = null;\n        }\n        function isContainerMarkedAsRoot(node) {\n          return !!node[internalContainerInstanceKey];\n        }\n        function getClosestInstanceFromNode(targetNode) {\n          var targetInst = targetNode[internalInstanceKey];\n          if (targetInst) {\n            return targetInst;\n          }\n          var parentNode = targetNode.parentNode;\n          while (parentNode) {\n            targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];\n            if (targetInst) {\n              var alternate = targetInst.alternate;\n              if (targetInst.child !== null || alternate !== null && alternate.child !== null) {\n                var suspenseInstance = getParentSuspenseInstance(targetNode);\n                while (suspenseInstance !== null) {\n                  var targetSuspenseInst = suspenseInstance[internalInstanceKey];\n                  if (targetSuspenseInst) {\n                    return targetSuspenseInst;\n                  }\n                  suspenseInstance = getParentSuspenseInstance(suspenseInstance);\n                }\n              }\n              return targetInst;\n            }\n            targetNode = parentNode;\n            parentNode = targetNode.parentNode;\n          }\n          return null;\n        }\n        function getInstanceFromNode(node) {\n          var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];\n          if (inst) {\n            if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {\n              return inst;\n            } else {\n              return null;\n            }\n          }\n          return null;\n        }\n        function getNodeFromInstance(inst) {\n          if (inst.tag === HostComponent || inst.tag === HostText) {\n            return inst.stateNode;\n          }\n          throw new Error(\"getNodeFromInstance: Invalid argument.\");\n        }\n        function getFiberCurrentPropsFromNode(node) {\n          return node[internalPropsKey] || null;\n        }\n        function updateFiberProps(node, props) {\n          node[internalPropsKey] = props;\n        }\n        function getEventListenerSet(node) {\n          var elementListenerSet = node[internalEventHandlersKey];\n          if (elementListenerSet === void 0) {\n            elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();\n          }\n          return elementListenerSet;\n        }\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has2 = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has2(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        var valueStack = [];\n        var fiberStack;\n        {\n          fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n          return {\n            current: defaultValue\n          };\n        }\n        function pop(cursor, fiber) {\n          if (index < 0) {\n            {\n              error(\"Unexpected pop.\");\n            }\n            return;\n          }\n          {\n            if (fiber !== fiberStack[index]) {\n              error(\"Unexpected Fiber popped.\");\n            }\n          }\n          cursor.current = valueStack[index];\n          valueStack[index] = null;\n          {\n            fiberStack[index] = null;\n          }\n          index--;\n        }\n        function push(cursor, value, fiber) {\n          index++;\n          valueStack[index] = cursor.current;\n          {\n            fiberStack[index] = fiber;\n          }\n          cursor.current = value;\n        }\n        var warnedAboutMissingGetChildContext;\n        {\n          warnedAboutMissingGetChildContext = {};\n        }\n        var emptyContextObject = {};\n        {\n          Object.freeze(emptyContextObject);\n        }\n        var contextStackCursor = createCursor(emptyContextObject);\n        var didPerformWorkStackCursor = createCursor(false);\n        var previousContext = emptyContextObject;\n        function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {\n          {\n            if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n              return previousContext;\n            }\n            return contextStackCursor.current;\n          }\n        }\n        function cacheContext(workInProgress2, unmaskedContext, maskedContext) {\n          {\n            var instance = workInProgress2.stateNode;\n            instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n            instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n          }\n        }\n        function getMaskedContext(workInProgress2, unmaskedContext) {\n          {\n            var type = workInProgress2.type;\n            var contextTypes = type.contextTypes;\n            if (!contextTypes) {\n              return emptyContextObject;\n            }\n            var instance = workInProgress2.stateNode;\n            if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n              return instance.__reactInternalMemoizedMaskedChildContext;\n            }\n            var context = {};\n            for (var key in contextTypes) {\n              context[key] = unmaskedContext[key];\n            }\n            {\n              var name = getComponentNameFromFiber(workInProgress2) || \"Unknown\";\n              checkPropTypes(contextTypes, context, \"context\", name);\n            }\n            if (instance) {\n              cacheContext(workInProgress2, unmaskedContext, context);\n            }\n            return context;\n          }\n        }\n        function hasContextChanged() {\n          {\n            return didPerformWorkStackCursor.current;\n          }\n        }\n        function isContextProvider(type) {\n          {\n            var childContextTypes = type.childContextTypes;\n            return childContextTypes !== null && childContextTypes !== void 0;\n          }\n        }\n        function popContext(fiber) {\n          {\n            pop(didPerformWorkStackCursor, fiber);\n            pop(contextStackCursor, fiber);\n          }\n        }\n        function popTopLevelContextObject(fiber) {\n          {\n            pop(didPerformWorkStackCursor, fiber);\n            pop(contextStackCursor, fiber);\n          }\n        }\n        function pushTopLevelContextObject(fiber, context, didChange) {\n          {\n            if (contextStackCursor.current !== emptyContextObject) {\n              throw new Error(\"Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            push(contextStackCursor, context, fiber);\n            push(didPerformWorkStackCursor, didChange, fiber);\n          }\n        }\n        function processChildContext(fiber, type, parentContext) {\n          {\n            var instance = fiber.stateNode;\n            var childContextTypes = type.childContextTypes;\n            if (typeof instance.getChildContext !== \"function\") {\n              {\n                var componentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                if (!warnedAboutMissingGetChildContext[componentName]) {\n                  warnedAboutMissingGetChildContext[componentName] = true;\n                  error(\"%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.\", componentName, componentName);\n                }\n              }\n              return parentContext;\n            }\n            var childContext = instance.getChildContext();\n            for (var contextKey in childContext) {\n              if (!(contextKey in childContextTypes)) {\n                throw new Error((getComponentNameFromFiber(fiber) || \"Unknown\") + '.getChildContext(): key \"' + contextKey + '\" is not defined in childContextTypes.');\n              }\n            }\n            {\n              var name = getComponentNameFromFiber(fiber) || \"Unknown\";\n              checkPropTypes(childContextTypes, childContext, \"child context\", name);\n            }\n            return assign({}, parentContext, childContext);\n          }\n        }\n        function pushContextProvider(workInProgress2) {\n          {\n            var instance = workInProgress2.stateNode;\n            var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;\n            previousContext = contextStackCursor.current;\n            push(contextStackCursor, memoizedMergedChildContext, workInProgress2);\n            push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);\n            return true;\n          }\n        }\n        function invalidateContextProvider(workInProgress2, type, didChange) {\n          {\n            var instance = workInProgress2.stateNode;\n            if (!instance) {\n              throw new Error(\"Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            if (didChange) {\n              var mergedContext = processChildContext(workInProgress2, type, previousContext);\n              instance.__reactInternalMemoizedMergedChildContext = mergedContext;\n              pop(didPerformWorkStackCursor, workInProgress2);\n              pop(contextStackCursor, workInProgress2);\n              push(contextStackCursor, mergedContext, workInProgress2);\n              push(didPerformWorkStackCursor, didChange, workInProgress2);\n            } else {\n              pop(didPerformWorkStackCursor, workInProgress2);\n              push(didPerformWorkStackCursor, didChange, workInProgress2);\n            }\n          }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n          {\n            if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n              throw new Error(\"Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            var node = fiber;\n            do {\n              switch (node.tag) {\n                case HostRoot:\n                  return node.stateNode.context;\n                case ClassComponent: {\n                  var Component = node.type;\n                  if (isContextProvider(Component)) {\n                    return node.stateNode.__reactInternalMemoizedMergedChildContext;\n                  }\n                  break;\n                }\n              }\n              node = node.return;\n            } while (node !== null);\n            throw new Error(\"Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        var syncQueue = null;\n        var includesLegacySyncCallbacks = false;\n        var isFlushingSyncQueue = false;\n        function scheduleSyncCallback(callback) {\n          if (syncQueue === null) {\n            syncQueue = [callback];\n          } else {\n            syncQueue.push(callback);\n          }\n        }\n        function scheduleLegacySyncCallback(callback) {\n          includesLegacySyncCallbacks = true;\n          scheduleSyncCallback(callback);\n        }\n        function flushSyncCallbacksOnlyInLegacyMode() {\n          if (includesLegacySyncCallbacks) {\n            flushSyncCallbacks();\n          }\n        }\n        function flushSyncCallbacks() {\n          if (!isFlushingSyncQueue && syncQueue !== null) {\n            isFlushingSyncQueue = true;\n            var i = 0;\n            var previousUpdatePriority = getCurrentUpdatePriority();\n            try {\n              var isSync = true;\n              var queue = syncQueue;\n              setCurrentUpdatePriority(DiscreteEventPriority);\n              for (; i < queue.length; i++) {\n                var callback = queue[i];\n                do {\n                  callback = callback(isSync);\n                } while (callback !== null);\n              }\n              syncQueue = null;\n              includesLegacySyncCallbacks = false;\n            } catch (error2) {\n              if (syncQueue !== null) {\n                syncQueue = syncQueue.slice(i + 1);\n              }\n              scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n              throw error2;\n            } finally {\n              setCurrentUpdatePriority(previousUpdatePriority);\n              isFlushingSyncQueue = false;\n            }\n          }\n          return null;\n        }\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = \"\";\n        function isForkedChild(workInProgress2) {\n          warnIfNotHydrating();\n          return (workInProgress2.flags & Forked) !== NoFlags;\n        }\n        function getForksAtLevel(workInProgress2) {\n          warnIfNotHydrating();\n          return treeForkCount;\n        }\n        function getTreeId() {\n          var overflow = treeContextOverflow;\n          var idWithLeadingBit = treeContextId;\n          var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n          return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress2, totalChildren) {\n          warnIfNotHydrating();\n          forkStack[forkStackIndex++] = treeForkCount;\n          forkStack[forkStackIndex++] = treeForkProvider;\n          treeForkProvider = workInProgress2;\n          treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress2, totalChildren, index2) {\n          warnIfNotHydrating();\n          idStack[idStackIndex++] = treeContextId;\n          idStack[idStackIndex++] = treeContextOverflow;\n          idStack[idStackIndex++] = treeContextProvider;\n          treeContextProvider = workInProgress2;\n          var baseIdWithLeadingBit = treeContextId;\n          var baseOverflow = treeContextOverflow;\n          var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n          var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n          var slot = index2 + 1;\n          var length = getBitLength(totalChildren) + baseLength;\n          if (length > 30) {\n            var numberOfOverflowBits = baseLength - baseLength % 5;\n            var newOverflowBits = (1 << numberOfOverflowBits) - 1;\n            var newOverflow = (baseId & newOverflowBits).toString(32);\n            var restOfBaseId = baseId >> numberOfOverflowBits;\n            var restOfBaseLength = baseLength - numberOfOverflowBits;\n            var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n            var restOfNewBits = slot << restOfBaseLength;\n            var id = restOfNewBits | restOfBaseId;\n            var overflow = newOverflow + baseOverflow;\n            treeContextId = 1 << restOfLength | id;\n            treeContextOverflow = overflow;\n          } else {\n            var newBits = slot << baseLength;\n            var _id = newBits | baseId;\n            var _overflow = baseOverflow;\n            treeContextId = 1 << length | _id;\n            treeContextOverflow = _overflow;\n          }\n        }\n        function pushMaterializedTreeId(workInProgress2) {\n          warnIfNotHydrating();\n          var returnFiber = workInProgress2.return;\n          if (returnFiber !== null) {\n            var numberOfForks = 1;\n            var slotIndex = 0;\n            pushTreeFork(workInProgress2, numberOfForks);\n            pushTreeId(workInProgress2, numberOfForks, slotIndex);\n          }\n        }\n        function getBitLength(number) {\n          return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n          return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress2) {\n          while (workInProgress2 === treeForkProvider) {\n            treeForkProvider = forkStack[--forkStackIndex];\n            forkStack[forkStackIndex] = null;\n            treeForkCount = forkStack[--forkStackIndex];\n            forkStack[forkStackIndex] = null;\n          }\n          while (workInProgress2 === treeContextProvider) {\n            treeContextProvider = idStack[--idStackIndex];\n            idStack[idStackIndex] = null;\n            treeContextOverflow = idStack[--idStackIndex];\n            idStack[idStackIndex] = null;\n            treeContextId = idStack[--idStackIndex];\n            idStack[idStackIndex] = null;\n          }\n        }\n        function getSuspendedTreeContext() {\n          warnIfNotHydrating();\n          if (treeContextProvider !== null) {\n            return {\n              id: treeContextId,\n              overflow: treeContextOverflow\n            };\n          } else {\n            return null;\n          }\n        }\n        function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {\n          warnIfNotHydrating();\n          idStack[idStackIndex++] = treeContextId;\n          idStack[idStackIndex++] = treeContextOverflow;\n          idStack[idStackIndex++] = treeContextProvider;\n          treeContextId = suspendedContext.id;\n          treeContextOverflow = suspendedContext.overflow;\n          treeContextProvider = workInProgress2;\n        }\n        function warnIfNotHydrating() {\n          {\n            if (!getIsHydrating()) {\n              error(\"Expected to be hydrating. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false;\n        var didSuspendOrErrorDEV = false;\n        var hydrationErrors = null;\n        function warnIfHydrating() {\n          {\n            if (isHydrating) {\n              error(\"We should not be hydrating here. This is a bug in React. Please file a bug.\");\n            }\n          }\n        }\n        function markDidThrowWhileHydratingDEV() {\n          {\n            didSuspendOrErrorDEV = true;\n          }\n        }\n        function didSuspendOrErrorWhileHydratingDEV() {\n          {\n            return didSuspendOrErrorDEV;\n          }\n        }\n        function enterHydrationState(fiber) {\n          var parentInstance = fiber.stateNode.containerInfo;\n          nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n          hydrationParentFiber = fiber;\n          isHydrating = true;\n          hydrationErrors = null;\n          didSuspendOrErrorDEV = false;\n          return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n          nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n          hydrationParentFiber = fiber;\n          isHydrating = true;\n          hydrationErrors = null;\n          didSuspendOrErrorDEV = false;\n          if (treeContext !== null) {\n            restoreSuspendedTreeContext(fiber, treeContext);\n          }\n          return true;\n        }\n        function warnUnhydratedInstance(returnFiber, instance) {\n          {\n            switch (returnFiber.tag) {\n              case HostRoot: {\n                didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n                break;\n              }\n              case HostComponent: {\n                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                didNotHydrateInstance(\n                  returnFiber.type,\n                  returnFiber.memoizedProps,\n                  returnFiber.stateNode,\n                  instance,\n                  // TODO: Delete this argument when we remove the legacy root API.\n                  isConcurrentMode\n                );\n                break;\n              }\n              case SuspenseComponent: {\n                var suspenseState = returnFiber.memoizedState;\n                if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n                break;\n              }\n            }\n          }\n        }\n        function deleteHydratableInstance(returnFiber, instance) {\n          warnUnhydratedInstance(returnFiber, instance);\n          var childToDelete = createFiberFromHostInstanceForDeletion();\n          childToDelete.stateNode = instance;\n          childToDelete.return = returnFiber;\n          var deletions = returnFiber.deletions;\n          if (deletions === null) {\n            returnFiber.deletions = [childToDelete];\n            returnFiber.flags |= ChildDeletion;\n          } else {\n            deletions.push(childToDelete);\n          }\n        }\n        function warnNonhydratedInstance(returnFiber, fiber) {\n          {\n            if (didSuspendOrErrorDEV) {\n              return;\n            }\n            switch (returnFiber.tag) {\n              case HostRoot: {\n                var parentContainer = returnFiber.stateNode.containerInfo;\n                switch (fiber.tag) {\n                  case HostComponent:\n                    var type = fiber.type;\n                    var props = fiber.pendingProps;\n                    didNotFindHydratableInstanceWithinContainer(parentContainer, type);\n                    break;\n                  case HostText:\n                    var text = fiber.pendingProps;\n                    didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n                    break;\n                }\n                break;\n              }\n              case HostComponent: {\n                var parentType = returnFiber.type;\n                var parentProps = returnFiber.memoizedProps;\n                var parentInstance = returnFiber.stateNode;\n                switch (fiber.tag) {\n                  case HostComponent: {\n                    var _type = fiber.type;\n                    var _props = fiber.pendingProps;\n                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    didNotFindHydratableInstance(\n                      parentType,\n                      parentProps,\n                      parentInstance,\n                      _type,\n                      _props,\n                      // TODO: Delete this argument when we remove the legacy root API.\n                      isConcurrentMode\n                    );\n                    break;\n                  }\n                  case HostText: {\n                    var _text = fiber.pendingProps;\n                    var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                    didNotFindHydratableTextInstance(\n                      parentType,\n                      parentProps,\n                      parentInstance,\n                      _text,\n                      // TODO: Delete this argument when we remove the legacy root API.\n                      _isConcurrentMode\n                    );\n                    break;\n                  }\n                }\n                break;\n              }\n              case SuspenseComponent: {\n                var suspenseState = returnFiber.memoizedState;\n                var _parentInstance = suspenseState.dehydrated;\n                if (_parentInstance !== null) switch (fiber.tag) {\n                  case HostComponent:\n                    var _type2 = fiber.type;\n                    var _props2 = fiber.pendingProps;\n                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);\n                    break;\n                  case HostText:\n                    var _text2 = fiber.pendingProps;\n                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n                    break;\n                }\n                break;\n              }\n              default:\n                return;\n            }\n          }\n        }\n        function insertNonHydratedInstance(returnFiber, fiber) {\n          fiber.flags = fiber.flags & ~Hydrating | Placement;\n          warnNonhydratedInstance(returnFiber, fiber);\n        }\n        function tryHydrate(fiber, nextInstance) {\n          switch (fiber.tag) {\n            case HostComponent: {\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              var instance = canHydrateInstance(nextInstance, type);\n              if (instance !== null) {\n                fiber.stateNode = instance;\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n                return true;\n              }\n              return false;\n            }\n            case HostText: {\n              var text = fiber.pendingProps;\n              var textInstance = canHydrateTextInstance(nextInstance, text);\n              if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = null;\n                return true;\n              }\n              return false;\n            }\n            case SuspenseComponent: {\n              var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n              if (suspenseInstance !== null) {\n                var suspenseState = {\n                  dehydrated: suspenseInstance,\n                  treeContext: getSuspendedTreeContext(),\n                  retryLane: OffscreenLane\n                };\n                fiber.memoizedState = suspenseState;\n                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                dehydratedFragment.return = fiber;\n                fiber.child = dehydratedFragment;\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = null;\n                return true;\n              }\n              return false;\n            }\n            default:\n              return false;\n          }\n        }\n        function shouldClientRenderOnMismatch(fiber) {\n          return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n        }\n        function throwOnHydrationMismatch(fiber) {\n          throw new Error(\"Hydration failed because the initial UI does not match what was rendered on the server.\");\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n          if (!isHydrating) {\n            return;\n          }\n          var nextInstance = nextHydratableInstance;\n          if (!nextInstance) {\n            if (shouldClientRenderOnMismatch(fiber)) {\n              warnNonhydratedInstance(hydrationParentFiber, fiber);\n              throwOnHydrationMismatch();\n            }\n            insertNonHydratedInstance(hydrationParentFiber, fiber);\n            isHydrating = false;\n            hydrationParentFiber = fiber;\n            return;\n          }\n          var firstAttemptedInstance = nextInstance;\n          if (!tryHydrate(fiber, nextInstance)) {\n            if (shouldClientRenderOnMismatch(fiber)) {\n              warnNonhydratedInstance(hydrationParentFiber, fiber);\n              throwOnHydrationMismatch();\n            }\n            nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n            var prevHydrationParentFiber = hydrationParentFiber;\n            if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n              insertNonHydratedInstance(hydrationParentFiber, fiber);\n              isHydrating = false;\n              hydrationParentFiber = fiber;\n              return;\n            }\n            deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n          }\n        }\n        function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n          var instance = fiber.stateNode;\n          var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n          var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);\n          fiber.updateQueue = updatePayload;\n          if (updatePayload !== null) {\n            return true;\n          }\n          return false;\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n          var textInstance = fiber.stateNode;\n          var textContent = fiber.memoizedProps;\n          var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);\n          if (shouldUpdate) {\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n              switch (returnFiber.tag) {\n                case HostRoot: {\n                  var parentContainer = returnFiber.stateNode.containerInfo;\n                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                  didNotMatchHydratedContainerTextInstance(\n                    parentContainer,\n                    textInstance,\n                    textContent,\n                    // TODO: Delete this argument when we remove the legacy root API.\n                    isConcurrentMode\n                  );\n                  break;\n                }\n                case HostComponent: {\n                  var parentType = returnFiber.type;\n                  var parentProps = returnFiber.memoizedProps;\n                  var parentInstance = returnFiber.stateNode;\n                  var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;\n                  didNotMatchHydratedTextInstance(\n                    parentType,\n                    parentProps,\n                    parentInstance,\n                    textInstance,\n                    textContent,\n                    // TODO: Delete this argument when we remove the legacy root API.\n                    _isConcurrentMode2\n                  );\n                  break;\n                }\n              }\n            }\n          }\n          return shouldUpdate;\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n          var suspenseState = fiber.memoizedState;\n          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n          if (!suspenseInstance) {\n            throw new Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n          var suspenseState = fiber.memoizedState;\n          var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n          if (!suspenseInstance) {\n            throw new Error(\"Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n          var parent = fiber.return;\n          while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n            parent = parent.return;\n          }\n          hydrationParentFiber = parent;\n        }\n        function popHydrationState(fiber) {\n          if (fiber !== hydrationParentFiber) {\n            return false;\n          }\n          if (!isHydrating) {\n            popToNextHostParent(fiber);\n            isHydrating = true;\n            return false;\n          }\n          if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n            var nextInstance = nextHydratableInstance;\n            if (nextInstance) {\n              if (shouldClientRenderOnMismatch(fiber)) {\n                warnIfUnhydratedTailNodes(fiber);\n                throwOnHydrationMismatch();\n              } else {\n                while (nextInstance) {\n                  deleteHydratableInstance(fiber, nextInstance);\n                  nextInstance = getNextHydratableSibling(nextInstance);\n                }\n              }\n            }\n          }\n          popToNextHostParent(fiber);\n          if (fiber.tag === SuspenseComponent) {\n            nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n          } else {\n            nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n          }\n          return true;\n        }\n        function hasUnhydratedTailNodes() {\n          return isHydrating && nextHydratableInstance !== null;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n          var nextInstance = nextHydratableInstance;\n          while (nextInstance) {\n            warnUnhydratedInstance(fiber, nextInstance);\n            nextInstance = getNextHydratableSibling(nextInstance);\n          }\n        }\n        function resetHydrationState() {\n          hydrationParentFiber = null;\n          nextHydratableInstance = null;\n          isHydrating = false;\n          didSuspendOrErrorDEV = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n          if (hydrationErrors !== null) {\n            queueRecoverableErrors(hydrationErrors);\n            hydrationErrors = null;\n          }\n        }\n        function getIsHydrating() {\n          return isHydrating;\n        }\n        function queueHydrationError(error2) {\n          if (hydrationErrors === null) {\n            hydrationErrors = [error2];\n          } else {\n            hydrationErrors.push(error2);\n          }\n        }\n        var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var NoTransition = null;\n        function requestCurrentTransition() {\n          return ReactCurrentBatchConfig$1.transition;\n        }\n        var ReactStrictModeWarnings = {\n          recordUnsafeLifecycleWarnings: function(fiber, instance) {\n          },\n          flushPendingUnsafeLifecycleWarnings: function() {\n          },\n          recordLegacyContextWarning: function(fiber, instance) {\n          },\n          flushLegacyContextWarning: function() {\n          },\n          discardPendingWarnings: function() {\n          }\n        };\n        {\n          var findStrictRoot = function(fiber) {\n            var maybeStrictRoot = null;\n            var node = fiber;\n            while (node !== null) {\n              if (node.mode & StrictLegacyMode) {\n                maybeStrictRoot = node;\n              }\n              node = node.return;\n            }\n            return maybeStrictRoot;\n          };\n          var setToSortedString = function(set2) {\n            var array = [];\n            set2.forEach(function(value) {\n              array.push(value);\n            });\n            return array.sort().join(\", \");\n          };\n          var pendingComponentWillMountWarnings = [];\n          var pendingUNSAFE_ComponentWillMountWarnings = [];\n          var pendingComponentWillReceivePropsWarnings = [];\n          var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n          var pendingComponentWillUpdateWarnings = [];\n          var pendingUNSAFE_ComponentWillUpdateWarnings = [];\n          var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();\n          ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n            if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n              return;\n            }\n            if (typeof instance.componentWillMount === \"function\" && // Don't warn about react-lifecycles-compat polyfilled components.\n            instance.componentWillMount.__suppressDeprecationWarning !== true) {\n              pendingComponentWillMountWarnings.push(fiber);\n            }\n            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === \"function\") {\n              pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n            }\n            if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n              pendingComponentWillReceivePropsWarnings.push(fiber);\n            }\n            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n              pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n            }\n            if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n              pendingComponentWillUpdateWarnings.push(fiber);\n            }\n            if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n              pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n            }\n          };\n          ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n            var componentWillMountUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingComponentWillMountWarnings.length > 0) {\n              pendingComponentWillMountWarnings.forEach(function(fiber) {\n                componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingComponentWillMountWarnings = [];\n            }\n            var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n              pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingUNSAFE_ComponentWillMountWarnings = [];\n            }\n            var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingComponentWillReceivePropsWarnings.length > 0) {\n              pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingComponentWillReceivePropsWarnings = [];\n            }\n            var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n              pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            }\n            var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingComponentWillUpdateWarnings.length > 0) {\n              pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingComponentWillUpdateWarnings = [];\n            }\n            var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();\n            if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n              pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutUnsafeLifecycles.add(fiber.type);\n              });\n              pendingUNSAFE_ComponentWillUpdateWarnings = [];\n            }\n            if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n              var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n              error(\"Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n\\nPlease update the following components: %s\", sortedNames);\n            }\n            if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n              var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n              error(\"Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n\\nPlease update the following components: %s\", _sortedNames);\n            }\n            if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n              var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n              error(\"Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n\\nPlease update the following components: %s\", _sortedNames2);\n            }\n            if (componentWillMountUniqueNames.size > 0) {\n              var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n              warn(\"componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", _sortedNames3);\n            }\n            if (componentWillReceivePropsUniqueNames.size > 0) {\n              var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n              warn(\"componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", _sortedNames4);\n            }\n            if (componentWillUpdateUniqueNames.size > 0) {\n              var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n              warn(\"componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n* Move data fetching code or side effects to componentDidUpdate.\\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n\\nPlease update the following components: %s\", _sortedNames5);\n            }\n          };\n          var pendingLegacyContextWarning = /* @__PURE__ */ new Map();\n          var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();\n          ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n            var strictRoot = findStrictRoot(fiber);\n            if (strictRoot === null) {\n              error(\"Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.\");\n              return;\n            }\n            if (didWarnAboutLegacyContext.has(fiber.type)) {\n              return;\n            }\n            var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n            if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === \"function\") {\n              if (warningsForRoot === void 0) {\n                warningsForRoot = [];\n                pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n              }\n              warningsForRoot.push(fiber);\n            }\n          };\n          ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n            pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n              if (fiberArray.length === 0) {\n                return;\n              }\n              var firstFiber = fiberArray[0];\n              var uniqueNames = /* @__PURE__ */ new Set();\n              fiberArray.forEach(function(fiber) {\n                uniqueNames.add(getComponentNameFromFiber(fiber) || \"Component\");\n                didWarnAboutLegacyContext.add(fiber.type);\n              });\n              var sortedNames = setToSortedString(uniqueNames);\n              try {\n                setCurrentFiber(firstFiber);\n                error(\"Legacy context API has been detected within a strict-mode tree.\\n\\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\\n\\nPlease update the following components: %s\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context\", sortedNames);\n              } finally {\n                resetCurrentFiber();\n              }\n            });\n          };\n          ReactStrictModeWarnings.discardPendingWarnings = function() {\n            pendingComponentWillMountWarnings = [];\n            pendingUNSAFE_ComponentWillMountWarnings = [];\n            pendingComponentWillReceivePropsWarnings = [];\n            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            pendingComponentWillUpdateWarnings = [];\n            pendingUNSAFE_ComponentWillUpdateWarnings = [];\n            pendingLegacyContextWarning = /* @__PURE__ */ new Map();\n          };\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var didWarnAboutStringRefs;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {\n        };\n        {\n          didWarnAboutMaps = false;\n          didWarnAboutGenerators = false;\n          didWarnAboutStringRefs = {};\n          ownerHasKeyUseWarning = {};\n          ownerHasFunctionTypeWarning = {};\n          warnForMissingKey = function(child, returnFiber) {\n            if (child === null || typeof child !== \"object\") {\n              return;\n            }\n            if (!child._store || child._store.validated || child.key != null) {\n              return;\n            }\n            if (typeof child._store !== \"object\") {\n              throw new Error(\"React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            child._store.validated = true;\n            var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n            if (ownerHasKeyUseWarning[componentName]) {\n              return;\n            }\n            ownerHasKeyUseWarning[componentName] = true;\n            error('Each child in a list should have a unique \"key\" prop. See https://reactjs.org/link/warning-keys for more information.');\n          };\n        }\n        function isReactClass(type) {\n          return type.prototype && type.prototype.isReactComponent;\n        }\n        function coerceRef(returnFiber, current2, element) {\n          var mixedRef = element.ref;\n          if (mixedRef !== null && typeof mixedRef !== \"function\" && typeof mixedRef !== \"object\") {\n            {\n              if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n              // because these cannot be automatically converted to an arrow function\n              // using a codemod. Therefore, we don't have to warn about string refs again.\n              !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with \"Function components cannot have string refs\"\n              !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with \"Function components cannot be given refs\"\n              !(typeof element.type === \"function\" && !isReactClass(element.type)) && // Will already throw with \"Element ref was specified as a string (someStringRef) but no owner was set\"\n              element._owner) {\n                var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n                if (!didWarnAboutStringRefs[componentName]) {\n                  {\n                    error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef);\n                  }\n                  didWarnAboutStringRefs[componentName] = true;\n                }\n              }\n            }\n            if (element._owner) {\n              var owner = element._owner;\n              var inst;\n              if (owner) {\n                var ownerFiber = owner;\n                if (ownerFiber.tag !== ClassComponent) {\n                  throw new Error(\"Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref\");\n                }\n                inst = ownerFiber.stateNode;\n              }\n              if (!inst) {\n                throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a bug in React. Please file an issue.\");\n              }\n              var resolvedInst = inst;\n              {\n                checkPropStringCoercion(mixedRef, \"ref\");\n              }\n              var stringRef = \"\" + mixedRef;\n              if (current2 !== null && current2.ref !== null && typeof current2.ref === \"function\" && current2.ref._stringRef === stringRef) {\n                return current2.ref;\n              }\n              var ref = function(value) {\n                var refs = resolvedInst.refs;\n                if (value === null) {\n                  delete refs[stringRef];\n                } else {\n                  refs[stringRef] = value;\n                }\n              };\n              ref._stringRef = stringRef;\n              return ref;\n            } else {\n              if (typeof mixedRef !== \"string\") {\n                throw new Error(\"Expected ref to be a function, a string, an object returned by React.createRef(), or null.\");\n              }\n              if (!element._owner) {\n                throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of the following reasons:\\n1. You may be adding a ref to a function component\\n2. You may be adding a ref to a component that was not created inside a component's render method\\n3. You have multiple copies of React loaded\\nSee https://reactjs.org/link/refs-must-have-owner for more information.\");\n              }\n            }\n          }\n          return mixedRef;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n          var childString = Object.prototype.toString.call(newChild);\n          throw new Error(\"Objects are not valid as a React child (found: \" + (childString === \"[object Object]\" ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\" : childString) + \"). If you meant to render a collection of children, use an array instead.\");\n        }\n        function warnOnFunctionType(returnFiber) {\n          {\n            var componentName = getComponentNameFromFiber(returnFiber) || \"Component\";\n            if (ownerHasFunctionTypeWarning[componentName]) {\n              return;\n            }\n            ownerHasFunctionTypeWarning[componentName] = true;\n            error(\"Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.\");\n          }\n        }\n        function resolveLazy(lazyType) {\n          var payload = lazyType._payload;\n          var init = lazyType._init;\n          return init(payload);\n        }\n        function ChildReconciler(shouldTrackSideEffects) {\n          function deleteChild(returnFiber, childToDelete) {\n            if (!shouldTrackSideEffects) {\n              return;\n            }\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n              returnFiber.deletions = [childToDelete];\n              returnFiber.flags |= ChildDeletion;\n            } else {\n              deletions.push(childToDelete);\n            }\n          }\n          function deleteRemainingChildren(returnFiber, currentFirstChild) {\n            if (!shouldTrackSideEffects) {\n              return null;\n            }\n            var childToDelete = currentFirstChild;\n            while (childToDelete !== null) {\n              deleteChild(returnFiber, childToDelete);\n              childToDelete = childToDelete.sibling;\n            }\n            return null;\n          }\n          function mapRemainingChildren(returnFiber, currentFirstChild) {\n            var existingChildren = /* @__PURE__ */ new Map();\n            var existingChild = currentFirstChild;\n            while (existingChild !== null) {\n              if (existingChild.key !== null) {\n                existingChildren.set(existingChild.key, existingChild);\n              } else {\n                existingChildren.set(existingChild.index, existingChild);\n              }\n              existingChild = existingChild.sibling;\n            }\n            return existingChildren;\n          }\n          function useFiber(fiber, pendingProps) {\n            var clone = createWorkInProgress(fiber, pendingProps);\n            clone.index = 0;\n            clone.sibling = null;\n            return clone;\n          }\n          function placeChild(newFiber, lastPlacedIndex, newIndex) {\n            newFiber.index = newIndex;\n            if (!shouldTrackSideEffects) {\n              newFiber.flags |= Forked;\n              return lastPlacedIndex;\n            }\n            var current2 = newFiber.alternate;\n            if (current2 !== null) {\n              var oldIndex = current2.index;\n              if (oldIndex < lastPlacedIndex) {\n                newFiber.flags |= Placement;\n                return lastPlacedIndex;\n              } else {\n                return oldIndex;\n              }\n            } else {\n              newFiber.flags |= Placement;\n              return lastPlacedIndex;\n            }\n          }\n          function placeSingleChild(newFiber) {\n            if (shouldTrackSideEffects && newFiber.alternate === null) {\n              newFiber.flags |= Placement;\n            }\n            return newFiber;\n          }\n          function updateTextNode(returnFiber, current2, textContent, lanes) {\n            if (current2 === null || current2.tag !== HostText) {\n              var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var existing = useFiber(current2, textContent);\n              existing.return = returnFiber;\n              return existing;\n            }\n          }\n          function updateElement(returnFiber, current2, element, lanes) {\n            var elementType = element.type;\n            if (elementType === REACT_FRAGMENT_TYPE) {\n              return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);\n            }\n            if (current2 !== null) {\n              if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:\n              isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.\n              // We need to do this after the Hot Reloading check above,\n              // because hot reloading has different semantics than prod because\n              // it doesn't resuspend. So we can't let the call below suspend.\n              typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {\n                var existing = useFiber(current2, element.props);\n                existing.ref = coerceRef(returnFiber, current2, element);\n                existing.return = returnFiber;\n                {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n                return existing;\n              }\n            }\n            var created = createFiberFromElement(element, returnFiber.mode, lanes);\n            created.ref = coerceRef(returnFiber, current2, element);\n            created.return = returnFiber;\n            return created;\n          }\n          function updatePortal(returnFiber, current2, portal, lanes) {\n            if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {\n              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var existing = useFiber(current2, portal.children || []);\n              existing.return = returnFiber;\n              return existing;\n            }\n          }\n          function updateFragment2(returnFiber, current2, fragment, lanes, key) {\n            if (current2 === null || current2.tag !== Fragment) {\n              var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var existing = useFiber(current2, fragment);\n              existing.return = returnFiber;\n              return existing;\n            }\n          }\n          function createChild(returnFiber, newChild, lanes) {\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              var created = createFiberFromText(\"\" + newChild, returnFiber.mode, lanes);\n              created.return = returnFiber;\n              return created;\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE: {\n                  var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                  _created.ref = coerceRef(returnFiber, null, newChild);\n                  _created.return = returnFiber;\n                  return _created;\n                }\n                case REACT_PORTAL_TYPE: {\n                  var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                  _created2.return = returnFiber;\n                  return _created2;\n                }\n                case REACT_LAZY_TYPE: {\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return createChild(returnFiber, init(payload), lanes);\n                }\n              }\n              if (isArray(newChild) || getIteratorFn(newChild)) {\n                var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                _created3.return = returnFiber;\n                return _created3;\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return null;\n          }\n          function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n            var key = oldFiber !== null ? oldFiber.key : null;\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              if (key !== null) {\n                return null;\n              }\n              return updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE: {\n                  if (newChild.key === key) {\n                    return updateElement(returnFiber, oldFiber, newChild, lanes);\n                  } else {\n                    return null;\n                  }\n                }\n                case REACT_PORTAL_TYPE: {\n                  if (newChild.key === key) {\n                    return updatePortal(returnFiber, oldFiber, newChild, lanes);\n                  } else {\n                    return null;\n                  }\n                }\n                case REACT_LAZY_TYPE: {\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n                }\n              }\n              if (isArray(newChild) || getIteratorFn(newChild)) {\n                if (key !== null) {\n                  return null;\n                }\n                return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return null;\n          }\n          function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              var matchedFiber = existingChildren.get(newIdx) || null;\n              return updateTextNode(returnFiber, matchedFiber, \"\" + newChild, lanes);\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE: {\n                  var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                  return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n                }\n                case REACT_PORTAL_TYPE: {\n                  var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                  return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n                }\n                case REACT_LAZY_TYPE:\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n              }\n              if (isArray(newChild) || getIteratorFn(newChild)) {\n                var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return null;\n          }\n          function warnOnInvalidKey(child, knownKeys, returnFiber) {\n            {\n              if (typeof child !== \"object\" || child === null) {\n                return knownKeys;\n              }\n              switch (child.$$typeof) {\n                case REACT_ELEMENT_TYPE:\n                case REACT_PORTAL_TYPE:\n                  warnForMissingKey(child, returnFiber);\n                  var key = child.key;\n                  if (typeof key !== \"string\") {\n                    break;\n                  }\n                  if (knownKeys === null) {\n                    knownKeys = /* @__PURE__ */ new Set();\n                    knownKeys.add(key);\n                    break;\n                  }\n                  if (!knownKeys.has(key)) {\n                    knownKeys.add(key);\n                    break;\n                  }\n                  error(\"Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.\", key);\n                  break;\n                case REACT_LAZY_TYPE:\n                  var payload = child._payload;\n                  var init = child._init;\n                  warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                  break;\n              }\n            }\n            return knownKeys;\n          }\n          function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n            {\n              var knownKeys = null;\n              for (var i = 0; i < newChildren.length; i++) {\n                var child = newChildren[i];\n                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n              }\n            }\n            var resultingFirstChild = null;\n            var previousNewFiber = null;\n            var oldFiber = currentFirstChild;\n            var lastPlacedIndex = 0;\n            var newIdx = 0;\n            var nextOldFiber = null;\n            for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n              if (oldFiber.index > newIdx) {\n                nextOldFiber = oldFiber;\n                oldFiber = null;\n              } else {\n                nextOldFiber = oldFiber.sibling;\n              }\n              var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n              if (newFiber === null) {\n                if (oldFiber === null) {\n                  oldFiber = nextOldFiber;\n                }\n                break;\n              }\n              if (shouldTrackSideEffects) {\n                if (oldFiber && newFiber.alternate === null) {\n                  deleteChild(returnFiber, oldFiber);\n                }\n              }\n              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = newFiber;\n              } else {\n                previousNewFiber.sibling = newFiber;\n              }\n              previousNewFiber = newFiber;\n              oldFiber = nextOldFiber;\n            }\n            if (newIdx === newChildren.length) {\n              deleteRemainingChildren(returnFiber, oldFiber);\n              if (getIsHydrating()) {\n                var numberOfForks = newIdx;\n                pushTreeFork(returnFiber, numberOfForks);\n              }\n              return resultingFirstChild;\n            }\n            if (oldFiber === null) {\n              for (; newIdx < newChildren.length; newIdx++) {\n                var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n                if (_newFiber === null) {\n                  continue;\n                }\n                lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber;\n                } else {\n                  previousNewFiber.sibling = _newFiber;\n                }\n                previousNewFiber = _newFiber;\n              }\n              if (getIsHydrating()) {\n                var _numberOfForks = newIdx;\n                pushTreeFork(returnFiber, _numberOfForks);\n              }\n              return resultingFirstChild;\n            }\n            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n            for (; newIdx < newChildren.length; newIdx++) {\n              var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n              if (_newFiber2 !== null) {\n                if (shouldTrackSideEffects) {\n                  if (_newFiber2.alternate !== null) {\n                    existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                  }\n                }\n                lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber2;\n                } else {\n                  previousNewFiber.sibling = _newFiber2;\n                }\n                previousNewFiber = _newFiber2;\n              }\n            }\n            if (shouldTrackSideEffects) {\n              existingChildren.forEach(function(child2) {\n                return deleteChild(returnFiber, child2);\n              });\n            }\n            if (getIsHydrating()) {\n              var _numberOfForks2 = newIdx;\n              pushTreeFork(returnFiber, _numberOfForks2);\n            }\n            return resultingFirstChild;\n          }\n          function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n            var iteratorFn = getIteratorFn(newChildrenIterable);\n            if (typeof iteratorFn !== \"function\") {\n              throw new Error(\"An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            {\n              if (typeof Symbol === \"function\" && // $FlowFixMe Flow doesn't know about toStringTag\n              newChildrenIterable[Symbol.toStringTag] === \"Generator\") {\n                if (!didWarnAboutGenerators) {\n                  error(\"Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.\");\n                }\n                didWarnAboutGenerators = true;\n              }\n              if (newChildrenIterable.entries === iteratorFn) {\n                if (!didWarnAboutMaps) {\n                  error(\"Using Maps as children is not supported. Use an array of keyed ReactElements instead.\");\n                }\n                didWarnAboutMaps = true;\n              }\n              var _newChildren = iteratorFn.call(newChildrenIterable);\n              if (_newChildren) {\n                var knownKeys = null;\n                var _step = _newChildren.next();\n                for (; !_step.done; _step = _newChildren.next()) {\n                  var child = _step.value;\n                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                }\n              }\n            }\n            var newChildren = iteratorFn.call(newChildrenIterable);\n            if (newChildren == null) {\n              throw new Error(\"An iterable object provided no iterator.\");\n            }\n            var resultingFirstChild = null;\n            var previousNewFiber = null;\n            var oldFiber = currentFirstChild;\n            var lastPlacedIndex = 0;\n            var newIdx = 0;\n            var nextOldFiber = null;\n            var step = newChildren.next();\n            for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n              if (oldFiber.index > newIdx) {\n                nextOldFiber = oldFiber;\n                oldFiber = null;\n              } else {\n                nextOldFiber = oldFiber.sibling;\n              }\n              var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n              if (newFiber === null) {\n                if (oldFiber === null) {\n                  oldFiber = nextOldFiber;\n                }\n                break;\n              }\n              if (shouldTrackSideEffects) {\n                if (oldFiber && newFiber.alternate === null) {\n                  deleteChild(returnFiber, oldFiber);\n                }\n              }\n              lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n              if (previousNewFiber === null) {\n                resultingFirstChild = newFiber;\n              } else {\n                previousNewFiber.sibling = newFiber;\n              }\n              previousNewFiber = newFiber;\n              oldFiber = nextOldFiber;\n            }\n            if (step.done) {\n              deleteRemainingChildren(returnFiber, oldFiber);\n              if (getIsHydrating()) {\n                var numberOfForks = newIdx;\n                pushTreeFork(returnFiber, numberOfForks);\n              }\n              return resultingFirstChild;\n            }\n            if (oldFiber === null) {\n              for (; !step.done; newIdx++, step = newChildren.next()) {\n                var _newFiber3 = createChild(returnFiber, step.value, lanes);\n                if (_newFiber3 === null) {\n                  continue;\n                }\n                lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber3;\n                } else {\n                  previousNewFiber.sibling = _newFiber3;\n                }\n                previousNewFiber = _newFiber3;\n              }\n              if (getIsHydrating()) {\n                var _numberOfForks3 = newIdx;\n                pushTreeFork(returnFiber, _numberOfForks3);\n              }\n              return resultingFirstChild;\n            }\n            var existingChildren = mapRemainingChildren(returnFiber, oldFiber);\n            for (; !step.done; newIdx++, step = newChildren.next()) {\n              var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n              if (_newFiber4 !== null) {\n                if (shouldTrackSideEffects) {\n                  if (_newFiber4.alternate !== null) {\n                    existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                  }\n                }\n                lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                if (previousNewFiber === null) {\n                  resultingFirstChild = _newFiber4;\n                } else {\n                  previousNewFiber.sibling = _newFiber4;\n                }\n                previousNewFiber = _newFiber4;\n              }\n            }\n            if (shouldTrackSideEffects) {\n              existingChildren.forEach(function(child2) {\n                return deleteChild(returnFiber, child2);\n              });\n            }\n            if (getIsHydrating()) {\n              var _numberOfForks4 = newIdx;\n              pushTreeFork(returnFiber, _numberOfForks4);\n            }\n            return resultingFirstChild;\n          }\n          function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n            if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n              deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n              var existing = useFiber(currentFirstChild, textContent);\n              existing.return = returnFiber;\n              return existing;\n            }\n            deleteRemainingChildren(returnFiber, currentFirstChild);\n            var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n          function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n            var key = element.key;\n            var child = currentFirstChild;\n            while (child !== null) {\n              if (child.key === key) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                  if (child.tag === Fragment) {\n                    deleteRemainingChildren(returnFiber, child.sibling);\n                    var existing = useFiber(child, element.props.children);\n                    existing.return = returnFiber;\n                    {\n                      existing._debugSource = element._source;\n                      existing._debugOwner = element._owner;\n                    }\n                    return existing;\n                  }\n                } else {\n                  if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:\n                  isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                  // We need to do this after the Hot Reloading check above,\n                  // because hot reloading has different semantics than prod because\n                  // it doesn't resuspend. So we can't let the call below suspend.\n                  typeof elementType === \"object\" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                    deleteRemainingChildren(returnFiber, child.sibling);\n                    var _existing = useFiber(child, element.props);\n                    _existing.ref = coerceRef(returnFiber, child, element);\n                    _existing.return = returnFiber;\n                    {\n                      _existing._debugSource = element._source;\n                      _existing._debugOwner = element._owner;\n                    }\n                    return _existing;\n                  }\n                }\n                deleteRemainingChildren(returnFiber, child);\n                break;\n              } else {\n                deleteChild(returnFiber, child);\n              }\n              child = child.sibling;\n            }\n            if (element.type === REACT_FRAGMENT_TYPE) {\n              var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n              created.return = returnFiber;\n              return created;\n            } else {\n              var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n              _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n              _created4.return = returnFiber;\n              return _created4;\n            }\n          }\n          function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n            var key = portal.key;\n            var child = currentFirstChild;\n            while (child !== null) {\n              if (child.key === key) {\n                if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                  deleteRemainingChildren(returnFiber, child.sibling);\n                  var existing = useFiber(child, portal.children || []);\n                  existing.return = returnFiber;\n                  return existing;\n                } else {\n                  deleteRemainingChildren(returnFiber, child);\n                  break;\n                }\n              } else {\n                deleteChild(returnFiber, child);\n              }\n              child = child.sibling;\n            }\n            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n            created.return = returnFiber;\n            return created;\n          }\n          function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {\n            var isUnkeyedTopLevelFragment = typeof newChild === \"object\" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n            if (isUnkeyedTopLevelFragment) {\n              newChild = newChild.props.children;\n            }\n            if (typeof newChild === \"object\" && newChild !== null) {\n              switch (newChild.$$typeof) {\n                case REACT_ELEMENT_TYPE:\n                  return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n                case REACT_PORTAL_TYPE:\n                  return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                case REACT_LAZY_TYPE:\n                  var payload = newChild._payload;\n                  var init = newChild._init;\n                  return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);\n              }\n              if (isArray(newChild)) {\n                return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n              }\n              if (getIteratorFn(newChild)) {\n                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n              }\n              throwOnInvalidObjectType(returnFiber, newChild);\n            }\n            if (typeof newChild === \"string\" && newChild !== \"\" || typeof newChild === \"number\") {\n              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, \"\" + newChild, lanes));\n            }\n            {\n              if (typeof newChild === \"function\") {\n                warnOnFunctionType(returnFiber);\n              }\n            }\n            return deleteRemainingChildren(returnFiber, currentFirstChild);\n          }\n          return reconcileChildFibers2;\n        }\n        var reconcileChildFibers = ChildReconciler(true);\n        var mountChildFibers = ChildReconciler(false);\n        function cloneChildFibers(current2, workInProgress2) {\n          if (current2 !== null && workInProgress2.child !== current2.child) {\n            throw new Error(\"Resuming work not yet implemented.\");\n          }\n          if (workInProgress2.child === null) {\n            return;\n          }\n          var currentChild = workInProgress2.child;\n          var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n          workInProgress2.child = newChild;\n          newChild.return = workInProgress2;\n          while (currentChild.sibling !== null) {\n            currentChild = currentChild.sibling;\n            newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n            newChild.return = workInProgress2;\n          }\n          newChild.sibling = null;\n        }\n        function resetChildFibers(workInProgress2, lanes) {\n          var child = workInProgress2.child;\n          while (child !== null) {\n            resetWorkInProgress(child, lanes);\n            child = child.sibling;\n          }\n        }\n        var valueCursor = createCursor(null);\n        var rendererSigil;\n        {\n          rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n          currentlyRenderingFiber = null;\n          lastContextDependency = null;\n          lastFullyObservedContext = null;\n          {\n            isDisallowedContextReadInDEV = false;\n          }\n        }\n        function enterDisallowedContextReadInDEV() {\n          {\n            isDisallowedContextReadInDEV = true;\n          }\n        }\n        function exitDisallowedContextReadInDEV() {\n          {\n            isDisallowedContextReadInDEV = false;\n          }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n          {\n            push(valueCursor, context._currentValue, providerFiber);\n            context._currentValue = nextValue;\n            {\n              if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                error(\"Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.\");\n              }\n              context._currentRenderer = rendererSigil;\n            }\n          }\n        }\n        function popProvider(context, providerFiber) {\n          var currentValue = valueCursor.current;\n          pop(valueCursor, providerFiber);\n          {\n            {\n              context._currentValue = currentValue;\n            }\n          }\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {\n          var node = parent;\n          while (node !== null) {\n            var alternate = node.alternate;\n            if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {\n              node.childLanes = mergeLanes(node.childLanes, renderLanes2);\n              if (alternate !== null) {\n                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);\n              }\n            } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {\n              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);\n            }\n            if (node === propagationRoot) {\n              break;\n            }\n            node = node.return;\n          }\n          {\n            if (node !== propagationRoot) {\n              error(\"Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        function propagateContextChange(workInProgress2, context, renderLanes2) {\n          {\n            propagateContextChange_eager(workInProgress2, context, renderLanes2);\n          }\n        }\n        function propagateContextChange_eager(workInProgress2, context, renderLanes2) {\n          var fiber = workInProgress2.child;\n          if (fiber !== null) {\n            fiber.return = workInProgress2;\n          }\n          while (fiber !== null) {\n            var nextFiber = void 0;\n            var list = fiber.dependencies;\n            if (list !== null) {\n              nextFiber = fiber.child;\n              var dependency = list.firstContext;\n              while (dependency !== null) {\n                if (dependency.context === context) {\n                  if (fiber.tag === ClassComponent) {\n                    var lane = pickArbitraryLane(renderLanes2);\n                    var update = createUpdate(NoTimestamp, lane);\n                    update.tag = ForceUpdate;\n                    var updateQueue = fiber.updateQueue;\n                    if (updateQueue === null) ;\n                    else {\n                      var sharedQueue = updateQueue.shared;\n                      var pending = sharedQueue.pending;\n                      if (pending === null) {\n                        update.next = update;\n                      } else {\n                        update.next = pending.next;\n                        pending.next = update;\n                      }\n                      sharedQueue.pending = update;\n                    }\n                  }\n                  fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);\n                  var alternate = fiber.alternate;\n                  if (alternate !== null) {\n                    alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);\n                  }\n                  scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);\n                  list.lanes = mergeLanes(list.lanes, renderLanes2);\n                  break;\n                }\n                dependency = dependency.next;\n              }\n            } else if (fiber.tag === ContextProvider) {\n              nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;\n            } else if (fiber.tag === DehydratedFragment) {\n              var parentSuspense = fiber.return;\n              if (parentSuspense === null) {\n                throw new Error(\"We just came from a parent so we must have had a parent. This is a bug in React.\");\n              }\n              parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);\n              var _alternate = parentSuspense.alternate;\n              if (_alternate !== null) {\n                _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);\n              }\n              scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);\n              nextFiber = fiber.sibling;\n            } else {\n              nextFiber = fiber.child;\n            }\n            if (nextFiber !== null) {\n              nextFiber.return = fiber;\n            } else {\n              nextFiber = fiber;\n              while (nextFiber !== null) {\n                if (nextFiber === workInProgress2) {\n                  nextFiber = null;\n                  break;\n                }\n                var sibling = nextFiber.sibling;\n                if (sibling !== null) {\n                  sibling.return = nextFiber.return;\n                  nextFiber = sibling;\n                  break;\n                }\n                nextFiber = nextFiber.return;\n              }\n            }\n            fiber = nextFiber;\n          }\n        }\n        function prepareToReadContext(workInProgress2, renderLanes2) {\n          currentlyRenderingFiber = workInProgress2;\n          lastContextDependency = null;\n          lastFullyObservedContext = null;\n          var dependencies = workInProgress2.dependencies;\n          if (dependencies !== null) {\n            {\n              var firstContext = dependencies.firstContext;\n              if (firstContext !== null) {\n                if (includesSomeLane(dependencies.lanes, renderLanes2)) {\n                  markWorkInProgressReceivedUpdate();\n                }\n                dependencies.firstContext = null;\n              }\n            }\n          }\n        }\n        function readContext(context) {\n          {\n            if (isDisallowedContextReadInDEV) {\n              error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n            }\n          }\n          var value = context._currentValue;\n          if (lastFullyObservedContext === context) ;\n          else {\n            var contextItem = {\n              context,\n              memoizedValue: value,\n              next: null\n            };\n            if (lastContextDependency === null) {\n              if (currentlyRenderingFiber === null) {\n                throw new Error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n              }\n              lastContextDependency = contextItem;\n              currentlyRenderingFiber.dependencies = {\n                lanes: NoLanes,\n                firstContext: contextItem\n              };\n            } else {\n              lastContextDependency = lastContextDependency.next = contextItem;\n            }\n          }\n          return value;\n        }\n        var concurrentQueues = null;\n        function pushConcurrentUpdateQueue(queue) {\n          if (concurrentQueues === null) {\n            concurrentQueues = [queue];\n          } else {\n            concurrentQueues.push(queue);\n          }\n        }\n        function finishQueueingConcurrentUpdates() {\n          if (concurrentQueues !== null) {\n            for (var i = 0; i < concurrentQueues.length; i++) {\n              var queue = concurrentQueues[i];\n              var lastInterleavedUpdate = queue.interleaved;\n              if (lastInterleavedUpdate !== null) {\n                queue.interleaved = null;\n                var firstInterleavedUpdate = lastInterleavedUpdate.next;\n                var lastPendingUpdate = queue.pending;\n                if (lastPendingUpdate !== null) {\n                  var firstPendingUpdate = lastPendingUpdate.next;\n                  lastPendingUpdate.next = firstInterleavedUpdate;\n                  lastInterleavedUpdate.next = firstPendingUpdate;\n                }\n                queue.pending = lastInterleavedUpdate;\n              }\n            }\n            concurrentQueues = null;\n          }\n        }\n        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n          var interleaved = queue.interleaved;\n          if (interleaved === null) {\n            update.next = update;\n            pushConcurrentUpdateQueue(queue);\n          } else {\n            update.next = interleaved.next;\n            interleaved.next = update;\n          }\n          queue.interleaved = update;\n          return markUpdateLaneFromFiberToRoot(fiber, lane);\n        }\n        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {\n          var interleaved = queue.interleaved;\n          if (interleaved === null) {\n            update.next = update;\n            pushConcurrentUpdateQueue(queue);\n          } else {\n            update.next = interleaved.next;\n            interleaved.next = update;\n          }\n          queue.interleaved = update;\n        }\n        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n          var interleaved = queue.interleaved;\n          if (interleaved === null) {\n            update.next = update;\n            pushConcurrentUpdateQueue(queue);\n          } else {\n            update.next = interleaved.next;\n            interleaved.next = update;\n          }\n          queue.interleaved = update;\n          return markUpdateLaneFromFiberToRoot(fiber, lane);\n        }\n        function enqueueConcurrentRenderForLane(fiber, lane) {\n          return markUpdateLaneFromFiberToRoot(fiber, lane);\n        }\n        var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;\n        function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n          var alternate = sourceFiber.alternate;\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, lane);\n          }\n          {\n            if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n              warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n            }\n          }\n          var node = sourceFiber;\n          var parent = sourceFiber.return;\n          while (parent !== null) {\n            parent.childLanes = mergeLanes(parent.childLanes, lane);\n            alternate = parent.alternate;\n            if (alternate !== null) {\n              alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n            } else {\n              {\n                if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n                  warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n              }\n            }\n            node = parent;\n            parent = parent.return;\n          }\n          if (node.tag === HostRoot) {\n            var root2 = node.stateNode;\n            return root2;\n          } else {\n            return null;\n          }\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3;\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n          didWarnUpdateInsideUpdate = false;\n          currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n          var queue = {\n            baseState: fiber.memoizedState,\n            firstBaseUpdate: null,\n            lastBaseUpdate: null,\n            shared: {\n              pending: null,\n              interleaved: null,\n              lanes: NoLanes\n            },\n            effects: null\n          };\n          fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current2, workInProgress2) {\n          var queue = workInProgress2.updateQueue;\n          var currentQueue = current2.updateQueue;\n          if (queue === currentQueue) {\n            var clone = {\n              baseState: currentQueue.baseState,\n              firstBaseUpdate: currentQueue.firstBaseUpdate,\n              lastBaseUpdate: currentQueue.lastBaseUpdate,\n              shared: currentQueue.shared,\n              effects: currentQueue.effects\n            };\n            workInProgress2.updateQueue = clone;\n          }\n        }\n        function createUpdate(eventTime, lane) {\n          var update = {\n            eventTime,\n            lane,\n            tag: UpdateState,\n            payload: null,\n            callback: null,\n            next: null\n          };\n          return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n          var updateQueue = fiber.updateQueue;\n          if (updateQueue === null) {\n            return null;\n          }\n          var sharedQueue = updateQueue.shared;\n          {\n            if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n              error(\"An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\");\n              didWarnUpdateInsideUpdate = true;\n            }\n          }\n          if (isUnsafeClassRenderPhaseUpdate()) {\n            var pending = sharedQueue.pending;\n            if (pending === null) {\n              update.next = update;\n            } else {\n              update.next = pending.next;\n              pending.next = update;\n            }\n            sharedQueue.pending = update;\n            return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n          } else {\n            return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n          }\n        }\n        function entangleTransitions(root2, fiber, lane) {\n          var updateQueue = fiber.updateQueue;\n          if (updateQueue === null) {\n            return;\n          }\n          var sharedQueue = updateQueue.shared;\n          if (isTransitionLane(lane)) {\n            var queueLanes = sharedQueue.lanes;\n            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);\n            var newQueueLanes = mergeLanes(queueLanes, lane);\n            sharedQueue.lanes = newQueueLanes;\n            markRootEntangled(root2, newQueueLanes);\n          }\n        }\n        function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {\n          var queue = workInProgress2.updateQueue;\n          var current2 = workInProgress2.alternate;\n          if (current2 !== null) {\n            var currentQueue = current2.updateQueue;\n            if (queue === currentQueue) {\n              var newFirst = null;\n              var newLast = null;\n              var firstBaseUpdate = queue.firstBaseUpdate;\n              if (firstBaseUpdate !== null) {\n                var update = firstBaseUpdate;\n                do {\n                  var clone = {\n                    eventTime: update.eventTime,\n                    lane: update.lane,\n                    tag: update.tag,\n                    payload: update.payload,\n                    callback: update.callback,\n                    next: null\n                  };\n                  if (newLast === null) {\n                    newFirst = newLast = clone;\n                  } else {\n                    newLast.next = clone;\n                    newLast = clone;\n                  }\n                  update = update.next;\n                } while (update !== null);\n                if (newLast === null) {\n                  newFirst = newLast = capturedUpdate;\n                } else {\n                  newLast.next = capturedUpdate;\n                  newLast = capturedUpdate;\n                }\n              } else {\n                newFirst = newLast = capturedUpdate;\n              }\n              queue = {\n                baseState: currentQueue.baseState,\n                firstBaseUpdate: newFirst,\n                lastBaseUpdate: newLast,\n                shared: currentQueue.shared,\n                effects: currentQueue.effects\n              };\n              workInProgress2.updateQueue = queue;\n              return;\n            }\n          }\n          var lastBaseUpdate = queue.lastBaseUpdate;\n          if (lastBaseUpdate === null) {\n            queue.firstBaseUpdate = capturedUpdate;\n          } else {\n            lastBaseUpdate.next = capturedUpdate;\n          }\n          queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {\n          switch (update.tag) {\n            case ReplaceState: {\n              var payload = update.payload;\n              if (typeof payload === \"function\") {\n                {\n                  enterDisallowedContextReadInDEV();\n                }\n                var nextState = payload.call(instance, prevState, nextProps);\n                {\n                  if (workInProgress2.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                      payload.call(instance, prevState, nextProps);\n                    } finally {\n                      setIsStrictModeForDevtools(false);\n                    }\n                  }\n                  exitDisallowedContextReadInDEV();\n                }\n                return nextState;\n              }\n              return payload;\n            }\n            case CaptureUpdate: {\n              workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;\n            }\n            case UpdateState: {\n              var _payload = update.payload;\n              var partialState;\n              if (typeof _payload === \"function\") {\n                {\n                  enterDisallowedContextReadInDEV();\n                }\n                partialState = _payload.call(instance, prevState, nextProps);\n                {\n                  if (workInProgress2.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                      _payload.call(instance, prevState, nextProps);\n                    } finally {\n                      setIsStrictModeForDevtools(false);\n                    }\n                  }\n                  exitDisallowedContextReadInDEV();\n                }\n              } else {\n                partialState = _payload;\n              }\n              if (partialState === null || partialState === void 0) {\n                return prevState;\n              }\n              return assign({}, prevState, partialState);\n            }\n            case ForceUpdate: {\n              hasForceUpdate = true;\n              return prevState;\n            }\n          }\n          return prevState;\n        }\n        function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {\n          var queue = workInProgress2.updateQueue;\n          hasForceUpdate = false;\n          {\n            currentlyProcessingQueue = queue.shared;\n          }\n          var firstBaseUpdate = queue.firstBaseUpdate;\n          var lastBaseUpdate = queue.lastBaseUpdate;\n          var pendingQueue = queue.shared.pending;\n          if (pendingQueue !== null) {\n            queue.shared.pending = null;\n            var lastPendingUpdate = pendingQueue;\n            var firstPendingUpdate = lastPendingUpdate.next;\n            lastPendingUpdate.next = null;\n            if (lastBaseUpdate === null) {\n              firstBaseUpdate = firstPendingUpdate;\n            } else {\n              lastBaseUpdate.next = firstPendingUpdate;\n            }\n            lastBaseUpdate = lastPendingUpdate;\n            var current2 = workInProgress2.alternate;\n            if (current2 !== null) {\n              var currentQueue = current2.updateQueue;\n              var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n              if (currentLastBaseUpdate !== lastBaseUpdate) {\n                if (currentLastBaseUpdate === null) {\n                  currentQueue.firstBaseUpdate = firstPendingUpdate;\n                } else {\n                  currentLastBaseUpdate.next = firstPendingUpdate;\n                }\n                currentQueue.lastBaseUpdate = lastPendingUpdate;\n              }\n            }\n          }\n          if (firstBaseUpdate !== null) {\n            var newState = queue.baseState;\n            var newLanes = NoLanes;\n            var newBaseState = null;\n            var newFirstBaseUpdate = null;\n            var newLastBaseUpdate = null;\n            var update = firstBaseUpdate;\n            do {\n              var updateLane = update.lane;\n              var updateEventTime = update.eventTime;\n              if (!isSubsetOfLanes(renderLanes2, updateLane)) {\n                var clone = {\n                  eventTime: updateEventTime,\n                  lane: updateLane,\n                  tag: update.tag,\n                  payload: update.payload,\n                  callback: update.callback,\n                  next: null\n                };\n                if (newLastBaseUpdate === null) {\n                  newFirstBaseUpdate = newLastBaseUpdate = clone;\n                  newBaseState = newState;\n                } else {\n                  newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                }\n                newLanes = mergeLanes(newLanes, updateLane);\n              } else {\n                if (newLastBaseUpdate !== null) {\n                  var _clone = {\n                    eventTime: updateEventTime,\n                    // This update is going to be committed so we never want uncommit\n                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                    // this will never be skipped by the check above.\n                    lane: NoLane,\n                    tag: update.tag,\n                    payload: update.payload,\n                    callback: update.callback,\n                    next: null\n                  };\n                  newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                }\n                newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);\n                var callback = update.callback;\n                if (callback !== null && // If the update was already committed, we should not queue its\n                // callback again.\n                update.lane !== NoLane) {\n                  workInProgress2.flags |= Callback;\n                  var effects = queue.effects;\n                  if (effects === null) {\n                    queue.effects = [update];\n                  } else {\n                    effects.push(update);\n                  }\n                }\n              }\n              update = update.next;\n              if (update === null) {\n                pendingQueue = queue.shared.pending;\n                if (pendingQueue === null) {\n                  break;\n                } else {\n                  var _lastPendingUpdate = pendingQueue;\n                  var _firstPendingUpdate = _lastPendingUpdate.next;\n                  _lastPendingUpdate.next = null;\n                  update = _firstPendingUpdate;\n                  queue.lastBaseUpdate = _lastPendingUpdate;\n                  queue.shared.pending = null;\n                }\n              }\n            } while (true);\n            if (newLastBaseUpdate === null) {\n              newBaseState = newState;\n            }\n            queue.baseState = newBaseState;\n            queue.firstBaseUpdate = newFirstBaseUpdate;\n            queue.lastBaseUpdate = newLastBaseUpdate;\n            var lastInterleaved = queue.shared.interleaved;\n            if (lastInterleaved !== null) {\n              var interleaved = lastInterleaved;\n              do {\n                newLanes = mergeLanes(newLanes, interleaved.lane);\n                interleaved = interleaved.next;\n              } while (interleaved !== lastInterleaved);\n            } else if (firstBaseUpdate === null) {\n              queue.shared.lanes = NoLanes;\n            }\n            markSkippedUpdateLanes(newLanes);\n            workInProgress2.lanes = newLanes;\n            workInProgress2.memoizedState = newState;\n          }\n          {\n            currentlyProcessingQueue = null;\n          }\n        }\n        function callCallback(callback, context) {\n          if (typeof callback !== \"function\") {\n            throw new Error(\"Invalid argument passed as callback. Expected a function. Instead \" + (\"received: \" + callback));\n          }\n          callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n          hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n          return hasForceUpdate;\n        }\n        function commitUpdateQueue(finishedWork, finishedQueue, instance) {\n          var effects = finishedQueue.effects;\n          finishedQueue.effects = null;\n          if (effects !== null) {\n            for (var i = 0; i < effects.length; i++) {\n              var effect = effects[i];\n              var callback = effect.callback;\n              if (callback !== null) {\n                effect.callback = null;\n                callCallback(callback, instance);\n              }\n            }\n          }\n        }\n        var NO_CONTEXT = {};\n        var contextStackCursor$1 = createCursor(NO_CONTEXT);\n        var contextFiberStackCursor = createCursor(NO_CONTEXT);\n        var rootInstanceStackCursor = createCursor(NO_CONTEXT);\n        function requiredContext(c) {\n          if (c === NO_CONTEXT) {\n            throw new Error(\"Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          return c;\n        }\n        function getRootHostContainer() {\n          var rootInstance = requiredContext(rootInstanceStackCursor.current);\n          return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n          push(rootInstanceStackCursor, nextRootInstance, fiber);\n          push(contextFiberStackCursor, fiber, fiber);\n          push(contextStackCursor$1, NO_CONTEXT, fiber);\n          var nextRootContext = getRootHostContext(nextRootInstance);\n          pop(contextStackCursor$1, fiber);\n          push(contextStackCursor$1, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n          pop(contextStackCursor$1, fiber);\n          pop(contextFiberStackCursor, fiber);\n          pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n          var context = requiredContext(contextStackCursor$1.current);\n          return context;\n        }\n        function pushHostContext(fiber) {\n          var rootInstance = requiredContext(rootInstanceStackCursor.current);\n          var context = requiredContext(contextStackCursor$1.current);\n          var nextContext = getChildHostContext(context, fiber.type);\n          if (context === nextContext) {\n            return;\n          }\n          push(contextFiberStackCursor, fiber, fiber);\n          push(contextStackCursor$1, nextContext, fiber);\n        }\n        function popHostContext(fiber) {\n          if (contextFiberStackCursor.current !== fiber) {\n            return;\n          }\n          pop(contextStackCursor$1, fiber);\n          pop(contextFiberStackCursor, fiber);\n        }\n        var DefaultSuspenseContext = 0;\n        var SubtreeSuspenseContextMask = 1;\n        var InvisibleParentSuspenseContext = 1;\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseContext(parentContext, flag) {\n          return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseContext(parentContext) {\n          return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseContext(parentContext, shallowContext) {\n          return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function addSubtreeSuspenseContext(parentContext, subtreeContext) {\n          return parentContext | subtreeContext;\n        }\n        function pushSuspenseContext(fiber, newContext) {\n          push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseContext(fiber) {\n          pop(suspenseStackCursor, fiber);\n        }\n        function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {\n          var nextState = workInProgress2.memoizedState;\n          if (nextState !== null) {\n            if (nextState.dehydrated !== null) {\n              return true;\n            }\n            return false;\n          }\n          var props = workInProgress2.memoizedProps;\n          {\n            return true;\n          }\n        }\n        function findFirstSuspended(row) {\n          var node = row;\n          while (node !== null) {\n            if (node.tag === SuspenseComponent) {\n              var state = node.memoizedState;\n              if (state !== null) {\n                var dehydrated = state.dehydrated;\n                if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                  return node;\n                }\n              }\n            } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n            // keep track of whether it suspended or not.\n            node.memoizedProps.revealOrder !== void 0) {\n              var didSuspend = (node.flags & DidCapture) !== NoFlags;\n              if (didSuspend) {\n                return node;\n              }\n            } else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === row) {\n              return null;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === row) {\n                return null;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n          return null;\n        }\n        var NoFlags$1 = (\n          /*   */\n          0\n        );\n        var HasEffect = (\n          /* */\n          1\n        );\n        var Insertion = (\n          /*  */\n          2\n        );\n        var Layout = (\n          /*    */\n          4\n        );\n        var Passive$1 = (\n          /*   */\n          8\n        );\n        var workInProgressSources = [];\n        function resetWorkInProgressVersions() {\n          for (var i = 0; i < workInProgressSources.length; i++) {\n            var mutableSource = workInProgressSources[i];\n            {\n              mutableSource._workInProgressVersionPrimary = null;\n            }\n          }\n          workInProgressSources.length = 0;\n        }\n        function registerMutableSourceForHydration(root2, mutableSource) {\n          var getVersion = mutableSource._getVersion;\n          var version = getVersion(mutableSource._source);\n          if (root2.mutableSourceEagerHydrationData == null) {\n            root2.mutableSourceEagerHydrationData = [mutableSource, version];\n          } else {\n            root2.mutableSourceEagerHydrationData.push(mutableSource, version);\n          }\n        }\n        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        {\n          didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();\n        }\n        var renderLanes = NoLanes;\n        var currentlyRenderingFiber$1 = null;\n        var currentHook = null;\n        var workInProgressHook = null;\n        var didScheduleRenderPhaseUpdate = false;\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\n        var localIdCounter = 0;\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25;\n        var currentHookNameInDev = null;\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1;\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n          {\n            var hookName = currentHookNameInDev;\n            if (hookTypesDev === null) {\n              hookTypesDev = [hookName];\n            } else {\n              hookTypesDev.push(hookName);\n            }\n          }\n        }\n        function updateHookTypesDev() {\n          {\n            var hookName = currentHookNameInDev;\n            if (hookTypesDev !== null) {\n              hookTypesUpdateIndexDev++;\n              if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                warnOnHookMismatchInDev(hookName);\n              }\n            }\n          }\n        }\n        function checkDepsAreArrayDev(deps) {\n          {\n            if (deps !== void 0 && deps !== null && !isArray(deps)) {\n              error(\"%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.\", currentHookNameInDev, typeof deps);\n            }\n          }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n          {\n            var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n            if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n              didWarnAboutMismatchedHooksForComponent.add(componentName);\n              if (hookTypesDev !== null) {\n                var table = \"\";\n                var secondColumnStart = 30;\n                for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\n                  var oldHookName = hookTypesDev[i];\n                  var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                  var row = i + 1 + \". \" + oldHookName;\n                  while (row.length < secondColumnStart) {\n                    row += \" \";\n                  }\n                  row += newHookName + \"\\n\";\n                  table += row;\n                }\n                error(\"React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n   Previous render            Next render\\n   ------------------------------------------------------\\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n\", componentName, table);\n              }\n            }\n          }\n        }\n        function throwInvalidHookError() {\n          throw new Error(\"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\");\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n          {\n            if (ignorePreviousDependencies) {\n              return false;\n            }\n          }\n          if (prevDeps === null) {\n            {\n              error(\"%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.\", currentHookNameInDev);\n            }\n            return false;\n          }\n          {\n            if (nextDeps.length !== prevDeps.length) {\n              error(\"The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\\n\\nPrevious: %s\\nIncoming: %s\", currentHookNameInDev, \"[\" + prevDeps.join(\", \") + \"]\", \"[\" + nextDeps.join(\", \") + \"]\");\n            }\n          }\n          for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n            if (objectIs(nextDeps[i], prevDeps[i])) {\n              continue;\n            }\n            return false;\n          }\n          return true;\n        }\n        function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {\n          renderLanes = nextRenderLanes;\n          currentlyRenderingFiber$1 = workInProgress2;\n          {\n            hookTypesDev = current2 !== null ? current2._debugHookTypes : null;\n            hookTypesUpdateIndexDev = -1;\n            ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;\n          }\n          workInProgress2.memoizedState = null;\n          workInProgress2.updateQueue = null;\n          workInProgress2.lanes = NoLanes;\n          {\n            if (current2 !== null && current2.memoizedState !== null) {\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n            } else if (hookTypesDev !== null) {\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n            } else {\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n            }\n          }\n          var children = Component(props, secondArg);\n          if (didScheduleRenderPhaseUpdateDuringThisPass) {\n            var numberOfReRenders = 0;\n            do {\n              didScheduleRenderPhaseUpdateDuringThisPass = false;\n              localIdCounter = 0;\n              if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                throw new Error(\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\");\n              }\n              numberOfReRenders += 1;\n              {\n                ignorePreviousDependencies = false;\n              }\n              currentHook = null;\n              workInProgressHook = null;\n              workInProgress2.updateQueue = null;\n              {\n                hookTypesUpdateIndexDev = -1;\n              }\n              ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;\n              children = Component(props, secondArg);\n            } while (didScheduleRenderPhaseUpdateDuringThisPass);\n          }\n          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n          {\n            workInProgress2._debugHookTypes = hookTypesDev;\n          }\n          var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n          renderLanes = NoLanes;\n          currentlyRenderingFiber$1 = null;\n          currentHook = null;\n          workInProgressHook = null;\n          {\n            currentHookNameInDev = null;\n            hookTypesDev = null;\n            hookTypesUpdateIndexDev = -1;\n            if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n            // and creates false positives. To make this work in legacy mode, we'd\n            // need to mark fibers that commit in an incomplete state, somehow. For\n            // now I'll disable the warning that most of the bugs that would trigger\n            // it are either exclusive to concurrent mode or exist in both.\n            (current2.mode & ConcurrentMode) !== NoMode) {\n              error(\"Internal React error: Expected static flag was missing. Please notify the React team.\");\n            }\n          }\n          didScheduleRenderPhaseUpdate = false;\n          if (didRenderTooFewHooks) {\n            throw new Error(\"Rendered fewer hooks than expected. This may be caused by an accidental early return statement.\");\n          }\n          return children;\n        }\n        function checkDidRenderIdHook() {\n          var didRenderIdHook = localIdCounter !== 0;\n          localIdCounter = 0;\n          return didRenderIdHook;\n        }\n        function bailoutHooks(current2, workInProgress2, lanes) {\n          workInProgress2.updateQueue = current2.updateQueue;\n          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n            workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n          } else {\n            workInProgress2.flags &= ~(Passive | Update);\n          }\n          current2.lanes = removeLanes(current2.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n          ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n          if (didScheduleRenderPhaseUpdate) {\n            var hook = currentlyRenderingFiber$1.memoizedState;\n            while (hook !== null) {\n              var queue = hook.queue;\n              if (queue !== null) {\n                queue.pending = null;\n              }\n              hook = hook.next;\n            }\n            didScheduleRenderPhaseUpdate = false;\n          }\n          renderLanes = NoLanes;\n          currentlyRenderingFiber$1 = null;\n          currentHook = null;\n          workInProgressHook = null;\n          {\n            hookTypesDev = null;\n            hookTypesUpdateIndexDev = -1;\n            currentHookNameInDev = null;\n            isUpdatingOpaqueValueInRenderPhase = false;\n          }\n          didScheduleRenderPhaseUpdateDuringThisPass = false;\n          localIdCounter = 0;\n        }\n        function mountWorkInProgressHook() {\n          var hook = {\n            memoizedState: null,\n            baseState: null,\n            baseQueue: null,\n            queue: null,\n            next: null\n          };\n          if (workInProgressHook === null) {\n            currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n          } else {\n            workInProgressHook = workInProgressHook.next = hook;\n          }\n          return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n          var nextCurrentHook;\n          if (currentHook === null) {\n            var current2 = currentlyRenderingFiber$1.alternate;\n            if (current2 !== null) {\n              nextCurrentHook = current2.memoizedState;\n            } else {\n              nextCurrentHook = null;\n            }\n          } else {\n            nextCurrentHook = currentHook.next;\n          }\n          var nextWorkInProgressHook;\n          if (workInProgressHook === null) {\n            nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n          } else {\n            nextWorkInProgressHook = workInProgressHook.next;\n          }\n          if (nextWorkInProgressHook !== null) {\n            workInProgressHook = nextWorkInProgressHook;\n            nextWorkInProgressHook = workInProgressHook.next;\n            currentHook = nextCurrentHook;\n          } else {\n            if (nextCurrentHook === null) {\n              throw new Error(\"Rendered more hooks than during the previous render.\");\n            }\n            currentHook = nextCurrentHook;\n            var newHook = {\n              memoizedState: currentHook.memoizedState,\n              baseState: currentHook.baseState,\n              baseQueue: currentHook.baseQueue,\n              queue: currentHook.queue,\n              next: null\n            };\n            if (workInProgressHook === null) {\n              currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n            } else {\n              workInProgressHook = workInProgressHook.next = newHook;\n            }\n          }\n          return workInProgressHook;\n        }\n        function createFunctionComponentUpdateQueue() {\n          return {\n            lastEffect: null,\n            stores: null\n          };\n        }\n        function basicStateReducer(state, action) {\n          return typeof action === \"function\" ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n          var hook = mountWorkInProgressHook();\n          var initialState;\n          if (init !== void 0) {\n            initialState = init(initialArg);\n          } else {\n            initialState = initialArg;\n          }\n          hook.memoizedState = hook.baseState = initialState;\n          var queue = {\n            pending: null,\n            interleaved: null,\n            lanes: NoLanes,\n            dispatch: null,\n            lastRenderedReducer: reducer,\n            lastRenderedState: initialState\n          };\n          hook.queue = queue;\n          var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n          return [hook.memoizedState, dispatch];\n        }\n        function updateReducer(reducer, initialArg, init) {\n          var hook = updateWorkInProgressHook();\n          var queue = hook.queue;\n          if (queue === null) {\n            throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n          }\n          queue.lastRenderedReducer = reducer;\n          var current2 = currentHook;\n          var baseQueue = current2.baseQueue;\n          var pendingQueue = queue.pending;\n          if (pendingQueue !== null) {\n            if (baseQueue !== null) {\n              var baseFirst = baseQueue.next;\n              var pendingFirst = pendingQueue.next;\n              baseQueue.next = pendingFirst;\n              pendingQueue.next = baseFirst;\n            }\n            {\n              if (current2.baseQueue !== baseQueue) {\n                error(\"Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.\");\n              }\n            }\n            current2.baseQueue = baseQueue = pendingQueue;\n            queue.pending = null;\n          }\n          if (baseQueue !== null) {\n            var first = baseQueue.next;\n            var newState = current2.baseState;\n            var newBaseState = null;\n            var newBaseQueueFirst = null;\n            var newBaseQueueLast = null;\n            var update = first;\n            do {\n              var updateLane = update.lane;\n              if (!isSubsetOfLanes(renderLanes, updateLane)) {\n                var clone = {\n                  lane: updateLane,\n                  action: update.action,\n                  hasEagerState: update.hasEagerState,\n                  eagerState: update.eagerState,\n                  next: null\n                };\n                if (newBaseQueueLast === null) {\n                  newBaseQueueFirst = newBaseQueueLast = clone;\n                  newBaseState = newState;\n                } else {\n                  newBaseQueueLast = newBaseQueueLast.next = clone;\n                }\n                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                markSkippedUpdateLanes(updateLane);\n              } else {\n                if (newBaseQueueLast !== null) {\n                  var _clone = {\n                    // This update is going to be committed so we never want uncommit\n                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                    // this will never be skipped by the check above.\n                    lane: NoLane,\n                    action: update.action,\n                    hasEagerState: update.hasEagerState,\n                    eagerState: update.eagerState,\n                    next: null\n                  };\n                  newBaseQueueLast = newBaseQueueLast.next = _clone;\n                }\n                if (update.hasEagerState) {\n                  newState = update.eagerState;\n                } else {\n                  var action = update.action;\n                  newState = reducer(newState, action);\n                }\n              }\n              update = update.next;\n            } while (update !== null && update !== first);\n            if (newBaseQueueLast === null) {\n              newBaseState = newState;\n            } else {\n              newBaseQueueLast.next = newBaseQueueFirst;\n            }\n            if (!objectIs(newState, hook.memoizedState)) {\n              markWorkInProgressReceivedUpdate();\n            }\n            hook.memoizedState = newState;\n            hook.baseState = newBaseState;\n            hook.baseQueue = newBaseQueueLast;\n            queue.lastRenderedState = newState;\n          }\n          var lastInterleaved = queue.interleaved;\n          if (lastInterleaved !== null) {\n            var interleaved = lastInterleaved;\n            do {\n              var interleavedLane = interleaved.lane;\n              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n              markSkippedUpdateLanes(interleavedLane);\n              interleaved = interleaved.next;\n            } while (interleaved !== lastInterleaved);\n          } else if (baseQueue === null) {\n            queue.lanes = NoLanes;\n          }\n          var dispatch = queue.dispatch;\n          return [hook.memoizedState, dispatch];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n          var hook = updateWorkInProgressHook();\n          var queue = hook.queue;\n          if (queue === null) {\n            throw new Error(\"Should have a queue. This is likely a bug in React. Please file an issue.\");\n          }\n          queue.lastRenderedReducer = reducer;\n          var dispatch = queue.dispatch;\n          var lastRenderPhaseUpdate = queue.pending;\n          var newState = hook.memoizedState;\n          if (lastRenderPhaseUpdate !== null) {\n            queue.pending = null;\n            var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n            var update = firstRenderPhaseUpdate;\n            do {\n              var action = update.action;\n              newState = reducer(newState, action);\n              update = update.next;\n            } while (update !== firstRenderPhaseUpdate);\n            if (!objectIs(newState, hook.memoizedState)) {\n              markWorkInProgressReceivedUpdate();\n            }\n            hook.memoizedState = newState;\n            if (hook.baseQueue === null) {\n              hook.baseState = newState;\n            }\n            queue.lastRenderedState = newState;\n          }\n          return [newState, dispatch];\n        }\n        function mountMutableSource(source, getSnapshot, subscribe) {\n          {\n            return void 0;\n          }\n        }\n        function updateMutableSource(source, getSnapshot, subscribe) {\n          {\n            return void 0;\n          }\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var fiber = currentlyRenderingFiber$1;\n          var hook = mountWorkInProgressHook();\n          var nextSnapshot;\n          var isHydrating2 = getIsHydrating();\n          if (isHydrating2) {\n            if (getServerSnapshot === void 0) {\n              throw new Error(\"Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.\");\n            }\n            nextSnapshot = getServerSnapshot();\n            {\n              if (!didWarnUncachedGetSnapshot) {\n                if (nextSnapshot !== getServerSnapshot()) {\n                  error(\"The result of getServerSnapshot should be cached to avoid an infinite loop\");\n                  didWarnUncachedGetSnapshot = true;\n                }\n              }\n            }\n          } else {\n            nextSnapshot = getSnapshot();\n            {\n              if (!didWarnUncachedGetSnapshot) {\n                var cachedSnapshot = getSnapshot();\n                if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                  error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                  didWarnUncachedGetSnapshot = true;\n                }\n              }\n            }\n            var root2 = getWorkInProgressRoot();\n            if (root2 === null) {\n              throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            }\n            if (!includesBlockingLane(root2, renderLanes)) {\n              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n            }\n          }\n          hook.memoizedState = nextSnapshot;\n          var inst = {\n            value: nextSnapshot,\n            getSnapshot\n          };\n          hook.queue = inst;\n          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n          fiber.flags |= Passive;\n          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);\n          return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n          var fiber = currentlyRenderingFiber$1;\n          var hook = updateWorkInProgressHook();\n          var nextSnapshot = getSnapshot();\n          {\n            if (!didWarnUncachedGetSnapshot) {\n              var cachedSnapshot = getSnapshot();\n              if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                didWarnUncachedGetSnapshot = true;\n              }\n            }\n          }\n          var prevSnapshot = hook.memoizedState;\n          var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n          if (snapshotChanged) {\n            hook.memoizedState = nextSnapshot;\n            markWorkInProgressReceivedUpdate();\n          }\n          var inst = hook.queue;\n          updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);\n          if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n          // checking whether we scheduled a subscription effect above.\n          workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n            fiber.flags |= Passive;\n            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);\n            var root2 = getWorkInProgressRoot();\n            if (root2 === null) {\n              throw new Error(\"Expected a work-in-progress root. This is a bug in React. Please file an issue.\");\n            }\n            if (!includesBlockingLane(root2, renderLanes)) {\n              pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n            }\n          }\n          return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n          fiber.flags |= StoreConsistency;\n          var check = {\n            getSnapshot,\n            value: renderedSnapshot\n          };\n          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n          if (componentUpdateQueue === null) {\n            componentUpdateQueue = createFunctionComponentUpdateQueue();\n            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n            componentUpdateQueue.stores = [check];\n          } else {\n            var stores = componentUpdateQueue.stores;\n            if (stores === null) {\n              componentUpdateQueue.stores = [check];\n            } else {\n              stores.push(check);\n            }\n          }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n          inst.value = nextSnapshot;\n          inst.getSnapshot = getSnapshot;\n          if (checkIfSnapshotChanged(inst)) {\n            forceStoreRerender(fiber);\n          }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n          var handleStoreChange = function() {\n            if (checkIfSnapshotChanged(inst)) {\n              forceStoreRerender(fiber);\n            }\n          };\n          return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n          var latestGetSnapshot = inst.getSnapshot;\n          var prevValue = inst.value;\n          try {\n            var nextValue = latestGetSnapshot();\n            return !objectIs(prevValue, nextValue);\n          } catch (error2) {\n            return true;\n          }\n        }\n        function forceStoreRerender(fiber) {\n          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n          }\n        }\n        function mountState(initialState) {\n          var hook = mountWorkInProgressHook();\n          if (typeof initialState === \"function\") {\n            initialState = initialState();\n          }\n          hook.memoizedState = hook.baseState = initialState;\n          var queue = {\n            pending: null,\n            interleaved: null,\n            lanes: NoLanes,\n            dispatch: null,\n            lastRenderedReducer: basicStateReducer,\n            lastRenderedState: initialState\n          };\n          hook.queue = queue;\n          var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n          return [hook.memoizedState, dispatch];\n        }\n        function updateState(initialState) {\n          return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n          return rerenderReducer(basicStateReducer);\n        }\n        function pushEffect(tag, create, destroy, deps) {\n          var effect = {\n            tag,\n            create,\n            destroy,\n            deps,\n            // Circular\n            next: null\n          };\n          var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n          if (componentUpdateQueue === null) {\n            componentUpdateQueue = createFunctionComponentUpdateQueue();\n            currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n            componentUpdateQueue.lastEffect = effect.next = effect;\n          } else {\n            var lastEffect = componentUpdateQueue.lastEffect;\n            if (lastEffect === null) {\n              componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n              var firstEffect = lastEffect.next;\n              lastEffect.next = effect;\n              effect.next = firstEffect;\n              componentUpdateQueue.lastEffect = effect;\n            }\n          }\n          return effect;\n        }\n        function mountRef(initialValue) {\n          var hook = mountWorkInProgressHook();\n          {\n            var _ref2 = {\n              current: initialValue\n            };\n            hook.memoizedState = _ref2;\n            return _ref2;\n          }\n        }\n        function updateRef(initialValue) {\n          var hook = updateWorkInProgressHook();\n          return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n          var hook = mountWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          currentlyRenderingFiber$1.flags |= fiberFlags;\n          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, void 0, nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n          var hook = updateWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var destroy = void 0;\n          if (currentHook !== null) {\n            var prevEffect = currentHook.memoizedState;\n            destroy = prevEffect.destroy;\n            if (nextDeps !== null) {\n              var prevDeps = prevEffect.deps;\n              if (areHookInputsEqual(nextDeps, prevDeps)) {\n                hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n                return;\n              }\n            }\n          }\n          currentlyRenderingFiber$1.flags |= fiberFlags;\n          hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n        }\n        function mountEffect(create, deps) {\n          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n            return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n          } else {\n            return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n          }\n        }\n        function updateEffect(create, deps) {\n          return updateEffectImpl(Passive, Passive$1, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n          return mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n          return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n          var fiberFlags = Update;\n          {\n            fiberFlags |= LayoutStatic;\n          }\n          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n            fiberFlags |= MountLayoutDev;\n          }\n          return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n          return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n          if (typeof ref === \"function\") {\n            var refCallback = ref;\n            var _inst = create();\n            refCallback(_inst);\n            return function() {\n              refCallback(null);\n            };\n          } else if (ref !== null && ref !== void 0) {\n            var refObject = ref;\n            {\n              if (!refObject.hasOwnProperty(\"current\")) {\n                error(\"Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.\", \"an object with keys {\" + Object.keys(refObject).join(\", \") + \"}\");\n              }\n            }\n            var _inst2 = create();\n            refObject.current = _inst2;\n            return function() {\n              refObject.current = null;\n            };\n          }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n          {\n            if (typeof create !== \"function\") {\n              error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n            }\n          }\n          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;\n          var fiberFlags = Update;\n          {\n            fiberFlags |= LayoutStatic;\n          }\n          if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n            fiberFlags |= MountLayoutDev;\n          }\n          return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n          {\n            if (typeof create !== \"function\") {\n              error(\"Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.\", create !== null ? typeof create : \"null\");\n            }\n          }\n          var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;\n          return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n          var hook = mountWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          hook.memoizedState = [callback, nextDeps];\n          return callback;\n        }\n        function updateCallback(callback, deps) {\n          var hook = updateWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var prevState = hook.memoizedState;\n          if (prevState !== null) {\n            if (nextDeps !== null) {\n              var prevDeps = prevState[1];\n              if (areHookInputsEqual(nextDeps, prevDeps)) {\n                return prevState[0];\n              }\n            }\n          }\n          hook.memoizedState = [callback, nextDeps];\n          return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n          var hook = mountWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var nextValue = nextCreate();\n          hook.memoizedState = [nextValue, nextDeps];\n          return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n          var hook = updateWorkInProgressHook();\n          var nextDeps = deps === void 0 ? null : deps;\n          var prevState = hook.memoizedState;\n          if (prevState !== null) {\n            if (nextDeps !== null) {\n              var prevDeps = prevState[1];\n              if (areHookInputsEqual(nextDeps, prevDeps)) {\n                return prevState[0];\n              }\n            }\n          }\n          var nextValue = nextCreate();\n          hook.memoizedState = [nextValue, nextDeps];\n          return nextValue;\n        }\n        function mountDeferredValue(value) {\n          var hook = mountWorkInProgressHook();\n          hook.memoizedState = value;\n          return value;\n        }\n        function updateDeferredValue(value) {\n          var hook = updateWorkInProgressHook();\n          var resolvedCurrentHook = currentHook;\n          var prevValue = resolvedCurrentHook.memoizedState;\n          return updateDeferredValueImpl(hook, prevValue, value);\n        }\n        function rerenderDeferredValue(value) {\n          var hook = updateWorkInProgressHook();\n          if (currentHook === null) {\n            hook.memoizedState = value;\n            return value;\n          } else {\n            var prevValue = currentHook.memoizedState;\n            return updateDeferredValueImpl(hook, prevValue, value);\n          }\n        }\n        function updateDeferredValueImpl(hook, prevValue, value) {\n          var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n          if (shouldDeferValue) {\n            if (!objectIs(value, prevValue)) {\n              var deferredLane = claimNextTransitionLane();\n              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n              markSkippedUpdateLanes(deferredLane);\n              hook.baseState = true;\n            }\n            return prevValue;\n          } else {\n            if (hook.baseState) {\n              hook.baseState = false;\n              markWorkInProgressReceivedUpdate();\n            }\n            hook.memoizedState = value;\n            return value;\n          }\n        }\n        function startTransition(setPending, callback, options2) {\n          var previousPriority = getCurrentUpdatePriority();\n          setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n          setPending(true);\n          var prevTransition = ReactCurrentBatchConfig$2.transition;\n          ReactCurrentBatchConfig$2.transition = {};\n          var currentTransition = ReactCurrentBatchConfig$2.transition;\n          {\n            ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();\n          }\n          try {\n            setPending(false);\n            callback();\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$2.transition = prevTransition;\n            {\n              if (prevTransition === null && currentTransition._updatedFibers) {\n                var updatedFibersCount = currentTransition._updatedFibers.size;\n                if (updatedFibersCount > 10) {\n                  warn(\"Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.\");\n                }\n                currentTransition._updatedFibers.clear();\n              }\n            }\n          }\n        }\n        function mountTransition() {\n          var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];\n          var start = startTransition.bind(null, setPending);\n          var hook = mountWorkInProgressHook();\n          hook.memoizedState = start;\n          return [isPending, start];\n        }\n        function updateTransition() {\n          var _updateState = updateState(), isPending = _updateState[0];\n          var hook = updateWorkInProgressHook();\n          var start = hook.memoizedState;\n          return [isPending, start];\n        }\n        function rerenderTransition() {\n          var _rerenderState = rerenderState(), isPending = _rerenderState[0];\n          var hook = updateWorkInProgressHook();\n          var start = hook.memoizedState;\n          return [isPending, start];\n        }\n        var isUpdatingOpaqueValueInRenderPhase = false;\n        function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n          {\n            return isUpdatingOpaqueValueInRenderPhase;\n          }\n        }\n        function mountId() {\n          var hook = mountWorkInProgressHook();\n          var root2 = getWorkInProgressRoot();\n          var identifierPrefix = root2.identifierPrefix;\n          var id;\n          if (getIsHydrating()) {\n            var treeId = getTreeId();\n            id = \":\" + identifierPrefix + \"R\" + treeId;\n            var localId = localIdCounter++;\n            if (localId > 0) {\n              id += \"H\" + localId.toString(32);\n            }\n            id += \":\";\n          } else {\n            var globalClientId = globalClientIdCounter++;\n            id = \":\" + identifierPrefix + \"r\" + globalClientId.toString(32) + \":\";\n          }\n          hook.memoizedState = id;\n          return id;\n        }\n        function updateId() {\n          var hook = updateWorkInProgressHook();\n          var id = hook.memoizedState;\n          return id;\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n          {\n            if (typeof arguments[3] === \"function\") {\n              error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n            }\n          }\n          var lane = requestUpdateLane(fiber);\n          var update = {\n            lane,\n            action,\n            hasEagerState: false,\n            eagerState: null,\n            next: null\n          };\n          if (isRenderPhaseUpdate(fiber)) {\n            enqueueRenderPhaseUpdate(queue, update);\n          } else {\n            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (root2 !== null) {\n              var eventTime = requestEventTime();\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitionUpdate(root2, queue, lane);\n            }\n          }\n          markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n          {\n            if (typeof arguments[3] === \"function\") {\n              error(\"State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().\");\n            }\n          }\n          var lane = requestUpdateLane(fiber);\n          var update = {\n            lane,\n            action,\n            hasEagerState: false,\n            eagerState: null,\n            next: null\n          };\n          if (isRenderPhaseUpdate(fiber)) {\n            enqueueRenderPhaseUpdate(queue, update);\n          } else {\n            var alternate = fiber.alternate;\n            if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n              var lastRenderedReducer = queue.lastRenderedReducer;\n              if (lastRenderedReducer !== null) {\n                var prevDispatcher;\n                {\n                  prevDispatcher = ReactCurrentDispatcher$1.current;\n                  ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                }\n                try {\n                  var currentState = queue.lastRenderedState;\n                  var eagerState = lastRenderedReducer(currentState, action);\n                  update.hasEagerState = true;\n                  update.eagerState = eagerState;\n                  if (objectIs(eagerState, currentState)) {\n                    enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);\n                    return;\n                  }\n                } catch (error2) {\n                } finally {\n                  {\n                    ReactCurrentDispatcher$1.current = prevDispatcher;\n                  }\n                }\n              }\n            }\n            var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n            if (root2 !== null) {\n              var eventTime = requestEventTime();\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitionUpdate(root2, queue, lane);\n            }\n          }\n          markUpdateInDevTools(fiber, lane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n          var alternate = fiber.alternate;\n          return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n          didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n          var pending = queue.pending;\n          if (pending === null) {\n            update.next = update;\n          } else {\n            update.next = pending.next;\n            pending.next = update;\n          }\n          queue.pending = update;\n        }\n        function entangleTransitionUpdate(root2, queue, lane) {\n          if (isTransitionLane(lane)) {\n            var queueLanes = queue.lanes;\n            queueLanes = intersectLanes(queueLanes, root2.pendingLanes);\n            var newQueueLanes = mergeLanes(queueLanes, lane);\n            queue.lanes = newQueueLanes;\n            markRootEntangled(root2, newQueueLanes);\n          }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n          {\n            markStateUpdateScheduled(fiber, lane);\n          }\n        }\n        var ContextOnlyDispatcher = {\n          readContext,\n          useCallback: throwInvalidHookError,\n          useContext: throwInvalidHookError,\n          useEffect: throwInvalidHookError,\n          useImperativeHandle: throwInvalidHookError,\n          useInsertionEffect: throwInvalidHookError,\n          useLayoutEffect: throwInvalidHookError,\n          useMemo: throwInvalidHookError,\n          useReducer: throwInvalidHookError,\n          useRef: throwInvalidHookError,\n          useState: throwInvalidHookError,\n          useDebugValue: throwInvalidHookError,\n          useDeferredValue: throwInvalidHookError,\n          useTransition: throwInvalidHookError,\n          useMutableSource: throwInvalidHookError,\n          useSyncExternalStore: throwInvalidHookError,\n          useId: throwInvalidHookError,\n          unstable_isNewReconciler: enableNewReconciler\n        };\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n          var warnInvalidContextAccess = function() {\n            error(\"Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().\");\n          };\n          var warnInvalidHookAccess = function() {\n            error(\"Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks\");\n          };\n          HooksDispatcherOnMountInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              mountHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              return mountLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              mountHookTypesDev();\n              checkDepsAreArrayDev(deps);\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              mountHookTypesDev();\n              return mountRef(initialValue);\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              mountHookTypesDev();\n              return mountDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              mountHookTypesDev();\n              return mountDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              mountHookTypesDev();\n              return mountTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              mountHookTypesDev();\n              return mountMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              mountHookTypesDev();\n              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              mountHookTypesDev();\n              return mountId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          HooksDispatcherOnMountWithHookTypesInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              updateHookTypesDev();\n              return mountCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              updateHookTypesDev();\n              return mountEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              updateHookTypesDev();\n              return mountImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              updateHookTypesDev();\n              return mountInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              updateHookTypesDev();\n              return mountLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              updateHookTypesDev();\n              return mountRef(initialValue);\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              updateHookTypesDev();\n              return mountDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              updateHookTypesDev();\n              return mountDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              updateHookTypesDev();\n              return mountTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              updateHookTypesDev();\n              return mountMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              updateHookTypesDev();\n              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              updateHookTypesDev();\n              return mountId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          HooksDispatcherOnUpdateInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              updateHookTypesDev();\n              return updateDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              updateHookTypesDev();\n              return updateTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          HooksDispatcherOnRerenderInDEV = {\n            readContext: function(context) {\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n              try {\n                return rerenderReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n              try {\n                return rerenderState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              updateHookTypesDev();\n              return rerenderDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              updateHookTypesDev();\n              return rerenderTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          InvalidNestedHooksDispatcherOnMountInDEV = {\n            readContext: function(context) {\n              warnInvalidContextAccess();\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountRef(initialValue);\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n              try {\n                return mountState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              warnInvalidHookAccess();\n              mountHookTypesDev();\n              return mountId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          InvalidNestedHooksDispatcherOnUpdateInDEV = {\n            readContext: function(context) {\n              warnInvalidContextAccess();\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n          InvalidNestedHooksDispatcherOnRerenderInDEV = {\n            readContext: function(context) {\n              warnInvalidContextAccess();\n              return readContext(context);\n            },\n            useCallback: function(callback, deps) {\n              currentHookNameInDev = \"useCallback\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateCallback(callback, deps);\n            },\n            useContext: function(context) {\n              currentHookNameInDev = \"useContext\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return readContext(context);\n            },\n            useEffect: function(create, deps) {\n              currentHookNameInDev = \"useEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateEffect(create, deps);\n            },\n            useImperativeHandle: function(ref, create, deps) {\n              currentHookNameInDev = \"useImperativeHandle\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateImperativeHandle(ref, create, deps);\n            },\n            useInsertionEffect: function(create, deps) {\n              currentHookNameInDev = \"useInsertionEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateInsertionEffect(create, deps);\n            },\n            useLayoutEffect: function(create, deps) {\n              currentHookNameInDev = \"useLayoutEffect\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateLayoutEffect(create, deps);\n            },\n            useMemo: function(create, deps) {\n              currentHookNameInDev = \"useMemo\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return updateMemo(create, deps);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useReducer: function(reducer, initialArg, init) {\n              currentHookNameInDev = \"useReducer\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return rerenderReducer(reducer, initialArg, init);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useRef: function(initialValue) {\n              currentHookNameInDev = \"useRef\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateRef();\n            },\n            useState: function(initialState) {\n              currentHookNameInDev = \"useState\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              var prevDispatcher = ReactCurrentDispatcher$1.current;\n              ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n              try {\n                return rerenderState(initialState);\n              } finally {\n                ReactCurrentDispatcher$1.current = prevDispatcher;\n              }\n            },\n            useDebugValue: function(value, formatterFn) {\n              currentHookNameInDev = \"useDebugValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateDebugValue();\n            },\n            useDeferredValue: function(value) {\n              currentHookNameInDev = \"useDeferredValue\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return rerenderDeferredValue(value);\n            },\n            useTransition: function() {\n              currentHookNameInDev = \"useTransition\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return rerenderTransition();\n            },\n            useMutableSource: function(source, getSnapshot, subscribe) {\n              currentHookNameInDev = \"useMutableSource\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateMutableSource();\n            },\n            useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n              currentHookNameInDev = \"useSyncExternalStore\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateSyncExternalStore(subscribe, getSnapshot);\n            },\n            useId: function() {\n              currentHookNameInDev = \"useId\";\n              warnInvalidHookAccess();\n              updateHookTypesDev();\n              return updateId();\n            },\n            unstable_isNewReconciler: enableNewReconciler\n          };\n        }\n        var now$1 = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n          return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n          {\n            nestedUpdateScheduled = true;\n          }\n        }\n        function resetNestedUpdateFlag() {\n          {\n            currentUpdateIsNested = false;\n            nestedUpdateScheduled = false;\n          }\n        }\n        function syncNestedUpdateFlag() {\n          {\n            currentUpdateIsNested = nestedUpdateScheduled;\n            nestedUpdateScheduled = false;\n          }\n        }\n        function getCommitTime() {\n          return commitTime;\n        }\n        function recordCommitTime() {\n          commitTime = now$1();\n        }\n        function startProfilerTimer(fiber) {\n          profilerStartTime = now$1();\n          if (fiber.actualStartTime < 0) {\n            fiber.actualStartTime = now$1();\n          }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n          profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n          if (profilerStartTime >= 0) {\n            var elapsedTime = now$1() - profilerStartTime;\n            fiber.actualDuration += elapsedTime;\n            if (overrideBaseTime) {\n              fiber.selfBaseDuration = elapsedTime;\n            }\n            profilerStartTime = -1;\n          }\n        }\n        function recordLayoutEffectDuration(fiber) {\n          if (layoutEffectStartTime >= 0) {\n            var elapsedTime = now$1() - layoutEffectStartTime;\n            layoutEffectStartTime = -1;\n            var parentFiber = fiber.return;\n            while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root2 = parentFiber.stateNode;\n                  root2.effectDuration += elapsedTime;\n                  return;\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  parentStateNode.effectDuration += elapsedTime;\n                  return;\n              }\n              parentFiber = parentFiber.return;\n            }\n          }\n        }\n        function recordPassiveEffectDuration(fiber) {\n          if (passiveEffectStartTime >= 0) {\n            var elapsedTime = now$1() - passiveEffectStartTime;\n            passiveEffectStartTime = -1;\n            var parentFiber = fiber.return;\n            while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root2 = parentFiber.stateNode;\n                  if (root2 !== null) {\n                    root2.passiveEffectDuration += elapsedTime;\n                  }\n                  return;\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  if (parentStateNode !== null) {\n                    parentStateNode.passiveEffectDuration += elapsedTime;\n                  }\n                  return;\n              }\n              parentFiber = parentFiber.return;\n            }\n          }\n        }\n        function startLayoutEffectTimer() {\n          layoutEffectStartTime = now$1();\n        }\n        function startPassiveEffectTimer() {\n          passiveEffectStartTime = now$1();\n        }\n        function transferActualDuration(fiber) {\n          var child = fiber.child;\n          while (child) {\n            fiber.actualDuration += child.actualDuration;\n            child = child.sibling;\n          }\n        }\n        function resolveDefaultProps(Component, baseProps) {\n          if (Component && Component.defaultProps) {\n            var props = assign({}, baseProps);\n            var defaultProps = Component.defaultProps;\n            for (var propName in defaultProps) {\n              if (props[propName] === void 0) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n            return props;\n          }\n          return baseProps;\n        }\n        var fakeInternalInstance = {};\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var warnOnUndefinedDerivedState;\n        var warnOnInvalidCallback;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutContextTypeAndContextTypes;\n        var didWarnAboutInvalidateContextType;\n        var didWarnAboutLegacyContext$1;\n        {\n          didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();\n          didWarnAboutUninitializedState = /* @__PURE__ */ new Set();\n          didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();\n          didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();\n          didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();\n          didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();\n          didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();\n          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();\n          didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();\n          var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();\n          warnOnInvalidCallback = function(callback, callerName) {\n            if (callback === null || typeof callback === \"function\") {\n              return;\n            }\n            var key = callerName + \"_\" + callback;\n            if (!didWarnOnInvalidCallback.has(key)) {\n              didWarnOnInvalidCallback.add(key);\n              error(\"%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\", callerName, callback);\n            }\n          };\n          warnOnUndefinedDerivedState = function(type, partialState) {\n            if (partialState === void 0) {\n              var componentName = getComponentNameFromType(type) || \"Component\";\n              if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                didWarnAboutUndefinedDerivedState.add(componentName);\n                error(\"%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.\", componentName);\n              }\n            }\n          };\n          Object.defineProperty(fakeInternalInstance, \"_processChildContext\", {\n            enumerable: false,\n            value: function() {\n              throw new Error(\"_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).\");\n            }\n          });\n          Object.freeze(fakeInternalInstance);\n        }\n        function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {\n          var prevState = workInProgress2.memoizedState;\n          var partialState = getDerivedStateFromProps(nextProps, prevState);\n          {\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                partialState = getDerivedStateFromProps(nextProps, prevState);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            warnOnUndefinedDerivedState(ctor, partialState);\n          }\n          var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);\n          workInProgress2.memoizedState = memoizedState;\n          if (workInProgress2.lanes === NoLanes) {\n            var updateQueue = workInProgress2.updateQueue;\n            updateQueue.baseState = memoizedState;\n          }\n        }\n        var classComponentUpdater = {\n          isMounted,\n          enqueueSetState: function(inst, payload, callback) {\n            var fiber = get(inst);\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            var update = createUpdate(eventTime, lane);\n            update.payload = payload;\n            if (callback !== void 0 && callback !== null) {\n              {\n                warnOnInvalidCallback(callback, \"setState\");\n              }\n              update.callback = callback;\n            }\n            var root2 = enqueueUpdate(fiber, update, lane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitions(root2, fiber, lane);\n            }\n            {\n              markStateUpdateScheduled(fiber, lane);\n            }\n          },\n          enqueueReplaceState: function(inst, payload, callback) {\n            var fiber = get(inst);\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            var update = createUpdate(eventTime, lane);\n            update.tag = ReplaceState;\n            update.payload = payload;\n            if (callback !== void 0 && callback !== null) {\n              {\n                warnOnInvalidCallback(callback, \"replaceState\");\n              }\n              update.callback = callback;\n            }\n            var root2 = enqueueUpdate(fiber, update, lane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitions(root2, fiber, lane);\n            }\n            {\n              markStateUpdateScheduled(fiber, lane);\n            }\n          },\n          enqueueForceUpdate: function(inst, callback) {\n            var fiber = get(inst);\n            var eventTime = requestEventTime();\n            var lane = requestUpdateLane(fiber);\n            var update = createUpdate(eventTime, lane);\n            update.tag = ForceUpdate;\n            if (callback !== void 0 && callback !== null) {\n              {\n                warnOnInvalidCallback(callback, \"forceUpdate\");\n              }\n              update.callback = callback;\n            }\n            var root2 = enqueueUpdate(fiber, update, lane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n              entangleTransitions(root2, fiber, lane);\n            }\n            {\n              markForceUpdateScheduled(fiber, lane);\n            }\n          }\n        };\n        function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {\n          var instance = workInProgress2.stateNode;\n          if (typeof instance.shouldComponentUpdate === \"function\") {\n            var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n            {\n              if (workInProgress2.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(true);\n                try {\n                  shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                } finally {\n                  setIsStrictModeForDevtools(false);\n                }\n              }\n              if (shouldUpdate === void 0) {\n                error(\"%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.\", getComponentNameFromType(ctor) || \"Component\");\n              }\n            }\n            return shouldUpdate;\n          }\n          if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n            return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n          }\n          return true;\n        }\n        function checkClassInstance(workInProgress2, ctor, newProps) {\n          var instance = workInProgress2.stateNode;\n          {\n            var name = getComponentNameFromType(ctor) || \"Component\";\n            var renderPresent = instance.render;\n            if (!renderPresent) {\n              if (ctor.prototype && typeof ctor.prototype.render === \"function\") {\n                error(\"%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?\", name);\n              } else {\n                error(\"%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.\", name);\n              }\n            }\n            if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n              error(\"getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?\", name);\n            }\n            if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.\", name);\n            }\n            if (instance.propTypes) {\n              error(\"propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.\", name);\n            }\n            if (instance.contextType) {\n              error(\"contextType was defined as an instance property on %s. Use a static property to define contextType instead.\", name);\n            }\n            {\n              if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip\n              // this one.\n              (workInProgress2.mode & StrictLegacyMode) === NoMode) {\n                didWarnAboutLegacyContext$1.add(ctor);\n                error(\"%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead\\n\\n.Learn more about this warning here: https://reactjs.org/link/legacy-context\", name);\n              }\n              if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip\n              // this one.\n              (workInProgress2.mode & StrictLegacyMode) === NoMode) {\n                didWarnAboutLegacyContext$1.add(ctor);\n                error(\"%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context\", name);\n              }\n              if (instance.contextTypes) {\n                error(\"contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.\", name);\n              }\n              if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n                didWarnAboutContextTypeAndContextTypes.add(ctor);\n                error(\"%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.\", name);\n              }\n            }\n            if (typeof instance.componentShouldUpdate === \"function\") {\n              error(\"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.\", name);\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== \"undefined\") {\n              error(\"%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.\", getComponentNameFromType(ctor) || \"A pure component\");\n            }\n            if (typeof instance.componentDidUnmount === \"function\") {\n              error(\"%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?\", name);\n            }\n            if (typeof instance.componentDidReceiveProps === \"function\") {\n              error(\"%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().\", name);\n            }\n            if (typeof instance.componentWillRecieveProps === \"function\") {\n              error(\"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?\", name);\n            }\n            if (typeof instance.UNSAFE_componentWillRecieveProps === \"function\") {\n              error(\"%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?\", name);\n            }\n            var hasMutatedProps = instance.props !== newProps;\n            if (instance.props !== void 0 && hasMutatedProps) {\n              error(\"%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.\", name, name);\n            }\n            if (instance.defaultProps) {\n              error(\"Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.\", name, name);\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\" && typeof instance.componentDidUpdate !== \"function\" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n              didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n              error(\"%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.\", getComponentNameFromType(ctor));\n            }\n            if (typeof instance.getDerivedStateFromProps === \"function\") {\n              error(\"%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", name);\n            }\n            if (typeof instance.getDerivedStateFromError === \"function\") {\n              error(\"%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.\", name);\n            }\n            if (typeof ctor.getSnapshotBeforeUpdate === \"function\") {\n              error(\"%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.\", name);\n            }\n            var _state = instance.state;\n            if (_state && (typeof _state !== \"object\" || isArray(_state))) {\n              error(\"%s.state: must be set to an object or null\", name);\n            }\n            if (typeof instance.getChildContext === \"function\" && typeof ctor.childContextTypes !== \"object\") {\n              error(\"%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().\", name);\n            }\n          }\n        }\n        function adoptClassInstance(workInProgress2, instance) {\n          instance.updater = classComponentUpdater;\n          workInProgress2.stateNode = instance;\n          set(instance, workInProgress2);\n          {\n            instance._reactInternalInstance = fakeInternalInstance;\n          }\n        }\n        function constructClassInstance(workInProgress2, ctor, props) {\n          var isLegacyContextConsumer = false;\n          var unmaskedContext = emptyContextObject;\n          var context = emptyContextObject;\n          var contextType = ctor.contextType;\n          {\n            if (\"contextType\" in ctor) {\n              var isValid = (\n                // Allow null for conditional declaration\n                contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0\n              );\n              if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                didWarnAboutInvalidateContextType.add(ctor);\n                var addendum = \"\";\n                if (contextType === void 0) {\n                  addendum = \" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.\";\n                } else if (typeof contextType !== \"object\") {\n                  addendum = \" However, it is set to a \" + typeof contextType + \".\";\n                } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n                  addendum = \" Did you accidentally pass the Context.Provider instead?\";\n                } else if (contextType._context !== void 0) {\n                  addendum = \" Did you accidentally pass the Context.Consumer instead?\";\n                } else {\n                  addendum = \" However, it is set to an object with keys {\" + Object.keys(contextType).join(\", \") + \"}.\";\n                }\n                error(\"%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s\", getComponentNameFromType(ctor) || \"Component\", addendum);\n              }\n            }\n          }\n          if (typeof contextType === \"object\" && contextType !== null) {\n            context = readContext(contextType);\n          } else {\n            unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            var contextTypes = ctor.contextTypes;\n            isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;\n            context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;\n          }\n          var instance = new ctor(props, context);\n          {\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                instance = new ctor(props, context);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n          }\n          var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;\n          adoptClassInstance(workInProgress2, instance);\n          {\n            if (typeof ctor.getDerivedStateFromProps === \"function\" && state === null) {\n              var componentName = getComponentNameFromType(ctor) || \"Component\";\n              if (!didWarnAboutUninitializedState.has(componentName)) {\n                didWarnAboutUninitializedState.add(componentName);\n                error(\"`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.\", componentName, instance.state === null ? \"null\" : \"undefined\", componentName);\n              }\n            }\n            if (typeof ctor.getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              var foundWillMountName = null;\n              var foundWillReceivePropsName = null;\n              var foundWillUpdateName = null;\n              if (typeof instance.componentWillMount === \"function\" && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                foundWillMountName = \"componentWillMount\";\n              } else if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                foundWillMountName = \"UNSAFE_componentWillMount\";\n              }\n              if (typeof instance.componentWillReceiveProps === \"function\" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                foundWillReceivePropsName = \"componentWillReceiveProps\";\n              } else if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n                foundWillReceivePropsName = \"UNSAFE_componentWillReceiveProps\";\n              }\n              if (typeof instance.componentWillUpdate === \"function\" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                foundWillUpdateName = \"componentWillUpdate\";\n              } else if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                foundWillUpdateName = \"UNSAFE_componentWillUpdate\";\n              }\n              if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                var _componentName = getComponentNameFromType(ctor) || \"Component\";\n                var newApiName = typeof ctor.getDerivedStateFromProps === \"function\" ? \"getDerivedStateFromProps()\" : \"getSnapshotBeforeUpdate()\";\n                if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                  didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                  error(\"Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\nThe above lifecycles should be removed. Learn more about this warning here:\\nhttps://reactjs.org/link/unsafe-component-lifecycles\", _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : \"\", foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : \"\", foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : \"\");\n                }\n              }\n            }\n          }\n          if (isLegacyContextConsumer) {\n            cacheContext(workInProgress2, unmaskedContext, context);\n          }\n          return instance;\n        }\n        function callComponentWillMount(workInProgress2, instance) {\n          var oldState = instance.state;\n          if (typeof instance.componentWillMount === \"function\") {\n            instance.componentWillMount();\n          }\n          if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n            instance.UNSAFE_componentWillMount();\n          }\n          if (oldState !== instance.state) {\n            {\n              error(\"%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", getComponentNameFromFiber(workInProgress2) || \"Component\");\n            }\n            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n          }\n        }\n        function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {\n          var oldState = instance.state;\n          if (typeof instance.componentWillReceiveProps === \"function\") {\n            instance.componentWillReceiveProps(newProps, nextContext);\n          }\n          if (typeof instance.UNSAFE_componentWillReceiveProps === \"function\") {\n            instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n          }\n          if (instance.state !== oldState) {\n            {\n              var componentName = getComponentNameFromFiber(workInProgress2) || \"Component\";\n              if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                didWarnAboutStateAssignmentForComponent.add(componentName);\n                error(\"%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.\", componentName);\n              }\n            }\n            classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n          }\n        }\n        function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {\n          {\n            checkClassInstance(workInProgress2, ctor, newProps);\n          }\n          var instance = workInProgress2.stateNode;\n          instance.props = newProps;\n          instance.state = workInProgress2.memoizedState;\n          instance.refs = {};\n          initializeUpdateQueue(workInProgress2);\n          var contextType = ctor.contextType;\n          if (typeof contextType === \"object\" && contextType !== null) {\n            instance.context = readContext(contextType);\n          } else {\n            var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            instance.context = getMaskedContext(workInProgress2, unmaskedContext);\n          }\n          {\n            if (instance.state === newProps) {\n              var componentName = getComponentNameFromType(ctor) || \"Component\";\n              if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                error(\"%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.\", componentName);\n              }\n            }\n            if (workInProgress2.mode & StrictLegacyMode) {\n              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);\n            }\n            {\n              ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);\n            }\n          }\n          instance.state = workInProgress2.memoizedState;\n          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n          if (typeof getDerivedStateFromProps === \"function\") {\n            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n            instance.state = workInProgress2.memoizedState;\n          }\n          if (typeof ctor.getDerivedStateFromProps !== \"function\" && typeof instance.getSnapshotBeforeUpdate !== \"function\" && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n            callComponentWillMount(workInProgress2, instance);\n            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n            instance.state = workInProgress2.memoizedState;\n          }\n          if (typeof instance.componentDidMount === \"function\") {\n            var fiberFlags = Update;\n            {\n              fiberFlags |= LayoutStatic;\n            }\n            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n              fiberFlags |= MountLayoutDev;\n            }\n            workInProgress2.flags |= fiberFlags;\n          }\n        }\n        function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {\n          var instance = workInProgress2.stateNode;\n          var oldProps = workInProgress2.memoizedProps;\n          instance.props = oldProps;\n          var oldContext = instance.context;\n          var contextType = ctor.contextType;\n          var nextContext = emptyContextObject;\n          if (typeof contextType === \"object\" && contextType !== null) {\n            nextContext = readContext(contextType);\n          } else {\n            var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);\n          }\n          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n          var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n            if (oldProps !== newProps || oldContext !== nextContext) {\n              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);\n            }\n          }\n          resetHasForceUpdateBeforeProcessing();\n          var oldState = workInProgress2.memoizedState;\n          var newState = instance.state = oldState;\n          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n          newState = workInProgress2.memoizedState;\n          if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n            if (typeof instance.componentDidMount === \"function\") {\n              var fiberFlags = Update;\n              {\n                fiberFlags |= LayoutStatic;\n              }\n              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n              }\n              workInProgress2.flags |= fiberFlags;\n            }\n            return false;\n          }\n          if (typeof getDerivedStateFromProps === \"function\") {\n            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n            newState = workInProgress2.memoizedState;\n          }\n          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);\n          if (shouldUpdate) {\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === \"function\" || typeof instance.componentWillMount === \"function\")) {\n              if (typeof instance.componentWillMount === \"function\") {\n                instance.componentWillMount();\n              }\n              if (typeof instance.UNSAFE_componentWillMount === \"function\") {\n                instance.UNSAFE_componentWillMount();\n              }\n            }\n            if (typeof instance.componentDidMount === \"function\") {\n              var _fiberFlags = Update;\n              {\n                _fiberFlags |= LayoutStatic;\n              }\n              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n                _fiberFlags |= MountLayoutDev;\n              }\n              workInProgress2.flags |= _fiberFlags;\n            }\n          } else {\n            if (typeof instance.componentDidMount === \"function\") {\n              var _fiberFlags2 = Update;\n              {\n                _fiberFlags2 |= LayoutStatic;\n              }\n              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {\n                _fiberFlags2 |= MountLayoutDev;\n              }\n              workInProgress2.flags |= _fiberFlags2;\n            }\n            workInProgress2.memoizedProps = newProps;\n            workInProgress2.memoizedState = newState;\n          }\n          instance.props = newProps;\n          instance.state = newState;\n          instance.context = nextContext;\n          return shouldUpdate;\n        }\n        function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {\n          var instance = workInProgress2.stateNode;\n          cloneUpdateQueue(current2, workInProgress2);\n          var unresolvedOldProps = workInProgress2.memoizedProps;\n          var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);\n          instance.props = oldProps;\n          var unresolvedNewProps = workInProgress2.pendingProps;\n          var oldContext = instance.context;\n          var contextType = ctor.contextType;\n          var nextContext = emptyContextObject;\n          if (typeof contextType === \"object\" && contextType !== null) {\n            nextContext = readContext(contextType);\n          } else {\n            var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);\n            nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);\n          }\n          var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n          var hasNewLifecycles = typeof getDerivedStateFromProps === \"function\" || typeof instance.getSnapshotBeforeUpdate === \"function\";\n          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === \"function\" || typeof instance.componentWillReceiveProps === \"function\")) {\n            if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n              callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);\n            }\n          }\n          resetHasForceUpdateBeforeProcessing();\n          var oldState = workInProgress2.memoizedState;\n          var newState = instance.state = oldState;\n          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);\n          newState = workInProgress2.memoizedState;\n          if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n            if (typeof instance.componentDidUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Update;\n              }\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Snapshot;\n              }\n            }\n            return false;\n          }\n          if (typeof getDerivedStateFromProps === \"function\") {\n            applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);\n            newState = workInProgress2.memoizedState;\n          }\n          var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n          // both before and after `shouldComponentUpdate` has been called. Not ideal,\n          // but I'm loath to refactor this function. This only happens for memoized\n          // components so it's not that common.\n          enableLazyContextPropagation;\n          if (shouldUpdate) {\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === \"function\" || typeof instance.componentWillUpdate === \"function\")) {\n              if (typeof instance.componentWillUpdate === \"function\") {\n                instance.componentWillUpdate(newProps, newState, nextContext);\n              }\n              if (typeof instance.UNSAFE_componentWillUpdate === \"function\") {\n                instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n              }\n            }\n            if (typeof instance.componentDidUpdate === \"function\") {\n              workInProgress2.flags |= Update;\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              workInProgress2.flags |= Snapshot;\n            }\n          } else {\n            if (typeof instance.componentDidUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Update;\n              }\n            }\n            if (typeof instance.getSnapshotBeforeUpdate === \"function\") {\n              if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {\n                workInProgress2.flags |= Snapshot;\n              }\n            }\n            workInProgress2.memoizedProps = newProps;\n            workInProgress2.memoizedState = newState;\n          }\n          instance.props = newProps;\n          instance.state = newState;\n          instance.context = nextContext;\n          return shouldUpdate;\n        }\n        function createCapturedValueAtFiber(value, source) {\n          return {\n            value,\n            source,\n            stack: getStackByFiberInDevAndProd(source),\n            digest: null\n          };\n        }\n        function createCapturedValue(value, digest, stack) {\n          return {\n            value,\n            source: null,\n            stack: stack != null ? stack : null,\n            digest: digest != null ? digest : null\n          };\n        }\n        function showErrorDialog(boundary, errorInfo) {\n          return true;\n        }\n        function logCapturedError(boundary, errorInfo) {\n          try {\n            var logError = showErrorDialog(boundary, errorInfo);\n            if (logError === false) {\n              return;\n            }\n            var error2 = errorInfo.value;\n            if (true) {\n              var source = errorInfo.source;\n              var stack = errorInfo.stack;\n              var componentStack = stack !== null ? stack : \"\";\n              if (error2 != null && error2._suppressLogging) {\n                if (boundary.tag === ClassComponent) {\n                  return;\n                }\n                console[\"error\"](error2);\n              }\n              var componentName = source ? getComponentNameFromFiber(source) : null;\n              var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : \"The above error occurred in one of your React components:\";\n              var errorBoundaryMessage;\n              if (boundary.tag === HostRoot) {\n                errorBoundaryMessage = \"Consider adding an error boundary to your tree to customize error handling behavior.\\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.\";\n              } else {\n                var errorBoundaryName = getComponentNameFromFiber(boundary) || \"Anonymous\";\n                errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n              }\n              var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage);\n              console[\"error\"](combinedMessage);\n            } else {\n              console[\"error\"](error2);\n            }\n          } catch (e) {\n            setTimeout(function() {\n              throw e;\n            });\n          }\n        }\n        var PossiblyWeakMap$1 = typeof WeakMap === \"function\" ? WeakMap : Map;\n        function createRootErrorUpdate(fiber, errorInfo, lane) {\n          var update = createUpdate(NoTimestamp, lane);\n          update.tag = CaptureUpdate;\n          update.payload = {\n            element: null\n          };\n          var error2 = errorInfo.value;\n          update.callback = function() {\n            onUncaughtError(error2);\n            logCapturedError(fiber, errorInfo);\n          };\n          return update;\n        }\n        function createClassErrorUpdate(fiber, errorInfo, lane) {\n          var update = createUpdate(NoTimestamp, lane);\n          update.tag = CaptureUpdate;\n          var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n          if (typeof getDerivedStateFromError === \"function\") {\n            var error$1 = errorInfo.value;\n            update.payload = function() {\n              return getDerivedStateFromError(error$1);\n            };\n            update.callback = function() {\n              {\n                markFailedErrorBoundaryForHotReloading(fiber);\n              }\n              logCapturedError(fiber, errorInfo);\n            };\n          }\n          var inst = fiber.stateNode;\n          if (inst !== null && typeof inst.componentDidCatch === \"function\") {\n            update.callback = function callback() {\n              {\n                markFailedErrorBoundaryForHotReloading(fiber);\n              }\n              logCapturedError(fiber, errorInfo);\n              if (typeof getDerivedStateFromError !== \"function\") {\n                markLegacyErrorBoundaryAsFailed(this);\n              }\n              var error$12 = errorInfo.value;\n              var stack = errorInfo.stack;\n              this.componentDidCatch(error$12, {\n                componentStack: stack !== null ? stack : \"\"\n              });\n              {\n                if (typeof getDerivedStateFromError !== \"function\") {\n                  if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                    error(\"%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.\", getComponentNameFromFiber(fiber) || \"Unknown\");\n                  }\n                }\n              }\n            };\n          }\n          return update;\n        }\n        function attachPingListener(root2, wakeable, lanes) {\n          var pingCache = root2.pingCache;\n          var threadIDs;\n          if (pingCache === null) {\n            pingCache = root2.pingCache = new PossiblyWeakMap$1();\n            threadIDs = /* @__PURE__ */ new Set();\n            pingCache.set(wakeable, threadIDs);\n          } else {\n            threadIDs = pingCache.get(wakeable);\n            if (threadIDs === void 0) {\n              threadIDs = /* @__PURE__ */ new Set();\n              pingCache.set(wakeable, threadIDs);\n            }\n          }\n          if (!threadIDs.has(lanes)) {\n            threadIDs.add(lanes);\n            var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);\n            {\n              if (isDevToolsPresent) {\n                restorePendingUpdaters(root2, lanes);\n              }\n            }\n            wakeable.then(ping, ping);\n          }\n        }\n        function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {\n          var wakeables = suspenseBoundary.updateQueue;\n          if (wakeables === null) {\n            var updateQueue = /* @__PURE__ */ new Set();\n            updateQueue.add(wakeable);\n            suspenseBoundary.updateQueue = updateQueue;\n          } else {\n            wakeables.add(wakeable);\n          }\n        }\n        function resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n          var tag = sourceFiber.tag;\n          if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n            var currentSource = sourceFiber.alternate;\n            if (currentSource) {\n              sourceFiber.updateQueue = currentSource.updateQueue;\n              sourceFiber.memoizedState = currentSource.memoizedState;\n              sourceFiber.lanes = currentSource.lanes;\n            } else {\n              sourceFiber.updateQueue = null;\n              sourceFiber.memoizedState = null;\n            }\n          }\n        }\n        function getNearestSuspenseBoundaryToCapture(returnFiber) {\n          var node = returnFiber;\n          do {\n            if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n              return node;\n            }\n            node = node.return;\n          } while (node !== null);\n          return null;\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {\n          if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n            if (suspenseBoundary === returnFiber) {\n              suspenseBoundary.flags |= ShouldCapture;\n            } else {\n              suspenseBoundary.flags |= DidCapture;\n              sourceFiber.flags |= ForceUpdateForLegacySuspense;\n              sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n              if (sourceFiber.tag === ClassComponent) {\n                var currentSourceFiber = sourceFiber.alternate;\n                if (currentSourceFiber === null) {\n                  sourceFiber.tag = IncompleteClassComponent;\n                } else {\n                  var update = createUpdate(NoTimestamp, SyncLane);\n                  update.tag = ForceUpdate;\n                  enqueueUpdate(sourceFiber, update, SyncLane);\n                }\n              }\n              sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n            }\n            return suspenseBoundary;\n          }\n          suspenseBoundary.flags |= ShouldCapture;\n          suspenseBoundary.lanes = rootRenderLanes;\n          return suspenseBoundary;\n        }\n        function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {\n          sourceFiber.flags |= Incomplete;\n          {\n            if (isDevToolsPresent) {\n              restorePendingUpdaters(root2, rootRenderLanes);\n            }\n          }\n          if (value !== null && typeof value === \"object\" && typeof value.then === \"function\") {\n            var wakeable = value;\n            resetSuspendedComponent(sourceFiber);\n            {\n              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n                markDidThrowWhileHydratingDEV();\n              }\n            }\n            var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n            if (suspenseBoundary !== null) {\n              suspenseBoundary.flags &= ~ForceClientRender;\n              markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);\n              if (suspenseBoundary.mode & ConcurrentMode) {\n                attachPingListener(root2, wakeable, rootRenderLanes);\n              }\n              attachRetryListener(suspenseBoundary, root2, wakeable);\n              return;\n            } else {\n              if (!includesSyncLane(rootRenderLanes)) {\n                attachPingListener(root2, wakeable, rootRenderLanes);\n                renderDidSuspendDelayIfPossible();\n                return;\n              }\n              var uncaughtSuspenseError = new Error(\"A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.\");\n              value = uncaughtSuspenseError;\n            }\n          } else {\n            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n              markDidThrowWhileHydratingDEV();\n              var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n              if (_suspenseBoundary !== null) {\n                if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n                  _suspenseBoundary.flags |= ForceClientRender;\n                }\n                markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);\n                queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));\n                return;\n              }\n            }\n          }\n          value = createCapturedValueAtFiber(value, sourceFiber);\n          renderDidError(value);\n          var workInProgress2 = returnFiber;\n          do {\n            switch (workInProgress2.tag) {\n              case HostRoot: {\n                var _errorInfo = value;\n                workInProgress2.flags |= ShouldCapture;\n                var lane = pickArbitraryLane(rootRenderLanes);\n                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);\n                var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);\n                enqueueCapturedUpdate(workInProgress2, update);\n                return;\n              }\n              case ClassComponent:\n                var errorInfo = value;\n                var ctor = workInProgress2.type;\n                var instance = workInProgress2.stateNode;\n                if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === \"function\" || instance !== null && typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                  workInProgress2.flags |= ShouldCapture;\n                  var _lane = pickArbitraryLane(rootRenderLanes);\n                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);\n                  var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);\n                  enqueueCapturedUpdate(workInProgress2, _update);\n                  return;\n                }\n                break;\n            }\n            workInProgress2 = workInProgress2.return;\n          } while (workInProgress2 !== null);\n        }\n        function getSuspendedCache() {\n          {\n            return null;\n          }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutModulePatternComponent;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutFunctionRefs;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        var didWarnAboutDefaultPropsOnFunctionComponent;\n        {\n          didWarnAboutBadClass = {};\n          didWarnAboutModulePatternComponent = {};\n          didWarnAboutContextTypeOnFunctionComponent = {};\n          didWarnAboutGetDerivedStateOnFunctionComponent = {};\n          didWarnAboutFunctionRefs = {};\n          didWarnAboutReassigningProps = false;\n          didWarnAboutRevealOrder = {};\n          didWarnAboutTailOptions = {};\n          didWarnAboutDefaultPropsOnFunctionComponent = {};\n        }\n        function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {\n          if (current2 === null) {\n            workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n          } else {\n            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);\n          }\n        }\n        function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {\n          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n        }\n        function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var innerPropTypes = Component.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(Component)\n                );\n              }\n            }\n          }\n          var render2 = Component.render;\n          var ref = workInProgress2.ref;\n          var nextChildren;\n          var hasId;\n          prepareToReadContext(workInProgress2, renderLanes2);\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            ReactCurrentOwner$1.current = workInProgress2;\n            setIsRendering(true);\n            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);\n            hasId = checkDidRenderIdHook();\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);\n                hasId = checkDidRenderIdHook();\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          if (current2 !== null && !didReceiveUpdate) {\n            bailoutHooks(current2, workInProgress2, renderLanes2);\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          if (getIsHydrating() && hasId) {\n            pushMaterializedTreeId(workInProgress2);\n          }\n          workInProgress2.flags |= PerformedWork;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          if (current2 === null) {\n            var type = Component.type;\n            if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n            Component.defaultProps === void 0) {\n              var resolvedType = type;\n              {\n                resolvedType = resolveFunctionForHotReloading(type);\n              }\n              workInProgress2.tag = SimpleMemoComponent;\n              workInProgress2.type = resolvedType;\n              {\n                validateFunctionComponentInDev(workInProgress2, type);\n              }\n              return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);\n            }\n            {\n              var innerPropTypes = type.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(type)\n                );\n              }\n              if (Component.defaultProps !== void 0) {\n                var componentName = getComponentNameFromType(type) || \"Unknown\";\n                if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                  error(\"%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.\", componentName);\n                  didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n                }\n              }\n            }\n            var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);\n            child.ref = workInProgress2.ref;\n            child.return = workInProgress2;\n            workInProgress2.child = child;\n            return child;\n          }\n          {\n            var _type = Component.type;\n            var _innerPropTypes = _type.propTypes;\n            if (_innerPropTypes) {\n              checkPropTypes(\n                _innerPropTypes,\n                nextProps,\n                // Resolved props\n                \"prop\",\n                getComponentNameFromType(_type)\n              );\n            }\n          }\n          var currentChild = current2.child;\n          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);\n          if (!hasScheduledUpdateOrContext) {\n            var prevProps = currentChild.memoizedProps;\n            var compare = Component.compare;\n            compare = compare !== null ? compare : shallowEqual;\n            if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {\n              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n            }\n          }\n          workInProgress2.flags |= PerformedWork;\n          var newChild = createWorkInProgress(currentChild, nextProps);\n          newChild.ref = workInProgress2.ref;\n          newChild.return = workInProgress2;\n          workInProgress2.child = newChild;\n          return newChild;\n        }\n        function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var outerMemoType = workInProgress2.elementType;\n              if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n                var lazyComponent = outerMemoType;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  outerMemoType = init(payload);\n                } catch (x) {\n                  outerMemoType = null;\n                }\n                var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n                if (outerPropTypes) {\n                  checkPropTypes(\n                    outerPropTypes,\n                    nextProps,\n                    // Resolved (SimpleMemoComponent has no defaultProps)\n                    \"prop\",\n                    getComponentNameFromType(outerMemoType)\n                  );\n                }\n              }\n            }\n          }\n          if (current2 !== null) {\n            var prevProps = current2.memoizedProps;\n            if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.\n            workInProgress2.type === current2.type) {\n              didReceiveUpdate = false;\n              workInProgress2.pendingProps = nextProps = prevProps;\n              if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {\n                workInProgress2.lanes = current2.lanes;\n                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n              } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                didReceiveUpdate = true;\n              }\n            }\n          }\n          return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);\n        }\n        function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {\n          var nextProps = workInProgress2.pendingProps;\n          var nextChildren = nextProps.children;\n          var prevState = current2 !== null ? current2.memoizedState : null;\n          if (nextProps.mode === \"hidden\" || enableLegacyHidden) {\n            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n              var nextState = {\n                baseLanes: NoLanes,\n                cachePool: null,\n                transitions: null\n              };\n              workInProgress2.memoizedState = nextState;\n              pushRenderLanes(workInProgress2, renderLanes2);\n            } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {\n              var spawnedCachePool = null;\n              var nextBaseLanes;\n              if (prevState !== null) {\n                var prevBaseLanes = prevState.baseLanes;\n                nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);\n              } else {\n                nextBaseLanes = renderLanes2;\n              }\n              workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);\n              var _nextState = {\n                baseLanes: nextBaseLanes,\n                cachePool: spawnedCachePool,\n                transitions: null\n              };\n              workInProgress2.memoizedState = _nextState;\n              workInProgress2.updateQueue = null;\n              pushRenderLanes(workInProgress2, nextBaseLanes);\n              return null;\n            } else {\n              var _nextState2 = {\n                baseLanes: NoLanes,\n                cachePool: null,\n                transitions: null\n              };\n              workInProgress2.memoizedState = _nextState2;\n              var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;\n              pushRenderLanes(workInProgress2, subtreeRenderLanes2);\n            }\n          } else {\n            var _subtreeRenderLanes;\n            if (prevState !== null) {\n              _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);\n              workInProgress2.memoizedState = null;\n            } else {\n              _subtreeRenderLanes = renderLanes2;\n            }\n            pushRenderLanes(workInProgress2, _subtreeRenderLanes);\n          }\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateFragment(current2, workInProgress2, renderLanes2) {\n          var nextChildren = workInProgress2.pendingProps;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateMode(current2, workInProgress2, renderLanes2) {\n          var nextChildren = workInProgress2.pendingProps.children;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateProfiler(current2, workInProgress2, renderLanes2) {\n          {\n            workInProgress2.flags |= Update;\n            {\n              var stateNode = workInProgress2.stateNode;\n              stateNode.effectDuration = 0;\n              stateNode.passiveEffectDuration = 0;\n            }\n          }\n          var nextProps = workInProgress2.pendingProps;\n          var nextChildren = nextProps.children;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function markRef(current2, workInProgress2) {\n          var ref = workInProgress2.ref;\n          if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {\n            workInProgress2.flags |= Ref;\n            {\n              workInProgress2.flags |= RefStatic;\n            }\n          }\n        }\n        function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var innerPropTypes = Component.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(Component)\n                );\n              }\n            }\n          }\n          var context;\n          {\n            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);\n            context = getMaskedContext(workInProgress2, unmaskedContext);\n          }\n          var nextChildren;\n          var hasId;\n          prepareToReadContext(workInProgress2, renderLanes2);\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            ReactCurrentOwner$1.current = workInProgress2;\n            setIsRendering(true);\n            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);\n            hasId = checkDidRenderIdHook();\n            if (workInProgress2.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n              try {\n                nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);\n                hasId = checkDidRenderIdHook();\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          if (current2 !== null && !didReceiveUpdate) {\n            bailoutHooks(current2, workInProgress2, renderLanes2);\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          if (getIsHydrating() && hasId) {\n            pushMaterializedTreeId(workInProgress2);\n          }\n          workInProgress2.flags |= PerformedWork;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {\n          {\n            switch (shouldError(workInProgress2)) {\n              case false: {\n                var _instance = workInProgress2.stateNode;\n                var ctor = workInProgress2.type;\n                var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);\n                var state = tempInstance.state;\n                _instance.updater.enqueueSetState(_instance, state, null);\n                break;\n              }\n              case true: {\n                workInProgress2.flags |= DidCapture;\n                workInProgress2.flags |= ShouldCapture;\n                var error$1 = new Error(\"Simulated error coming from DevTools\");\n                var lane = pickArbitraryLane(renderLanes2);\n                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);\n                var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);\n                enqueueCapturedUpdate(workInProgress2, update);\n                break;\n              }\n            }\n            if (workInProgress2.type !== workInProgress2.elementType) {\n              var innerPropTypes = Component.propTypes;\n              if (innerPropTypes) {\n                checkPropTypes(\n                  innerPropTypes,\n                  nextProps,\n                  // Resolved props\n                  \"prop\",\n                  getComponentNameFromType(Component)\n                );\n              }\n            }\n          }\n          var hasContext;\n          if (isContextProvider(Component)) {\n            hasContext = true;\n            pushContextProvider(workInProgress2);\n          } else {\n            hasContext = false;\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          var instance = workInProgress2.stateNode;\n          var shouldUpdate;\n          if (instance === null) {\n            resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);\n            constructClassInstance(workInProgress2, Component, nextProps);\n            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n            shouldUpdate = true;\n          } else if (current2 === null) {\n            shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n          } else {\n            shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);\n          }\n          var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);\n          {\n            var inst = workInProgress2.stateNode;\n            if (shouldUpdate && inst.props !== nextProps) {\n              if (!didWarnAboutReassigningProps) {\n                error(\"It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.\", getComponentNameFromFiber(workInProgress2) || \"a component\");\n              }\n              didWarnAboutReassigningProps = true;\n            }\n          }\n          return nextUnitOfWork;\n        }\n        function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {\n          markRef(current2, workInProgress2);\n          var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;\n          if (!shouldUpdate && !didCaptureError) {\n            if (hasContext) {\n              invalidateContextProvider(workInProgress2, Component, false);\n            }\n            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n          }\n          var instance = workInProgress2.stateNode;\n          ReactCurrentOwner$1.current = workInProgress2;\n          var nextChildren;\n          if (didCaptureError && typeof Component.getDerivedStateFromError !== \"function\") {\n            nextChildren = null;\n            {\n              stopProfilerTimerIfRunning();\n            }\n          } else {\n            {\n              markComponentRenderStarted(workInProgress2);\n            }\n            {\n              setIsRendering(true);\n              nextChildren = instance.render();\n              if (workInProgress2.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(true);\n                try {\n                  instance.render();\n                } finally {\n                  setIsStrictModeForDevtools(false);\n                }\n              }\n              setIsRendering(false);\n            }\n            {\n              markComponentRenderStopped();\n            }\n          }\n          workInProgress2.flags |= PerformedWork;\n          if (current2 !== null && didCaptureError) {\n            forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);\n          } else {\n            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          }\n          workInProgress2.memoizedState = instance.state;\n          if (hasContext) {\n            invalidateContextProvider(workInProgress2, Component, true);\n          }\n          return workInProgress2.child;\n        }\n        function pushHostRootContext(workInProgress2) {\n          var root2 = workInProgress2.stateNode;\n          if (root2.pendingContext) {\n            pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);\n          } else if (root2.context) {\n            pushTopLevelContextObject(workInProgress2, root2.context, false);\n          }\n          pushHostContainer(workInProgress2, root2.containerInfo);\n        }\n        function updateHostRoot(current2, workInProgress2, renderLanes2) {\n          pushHostRootContext(workInProgress2);\n          if (current2 === null) {\n            throw new Error(\"Should have a current fiber. This is a bug in React.\");\n          }\n          var nextProps = workInProgress2.pendingProps;\n          var prevState = workInProgress2.memoizedState;\n          var prevChildren = prevState.element;\n          cloneUpdateQueue(current2, workInProgress2);\n          processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);\n          var nextState = workInProgress2.memoizedState;\n          var root2 = workInProgress2.stateNode;\n          var nextChildren = nextState.element;\n          if (prevState.isDehydrated) {\n            var overrideState = {\n              element: nextChildren,\n              isDehydrated: false,\n              cache: nextState.cache,\n              pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,\n              transitions: nextState.transitions\n            };\n            var updateQueue = workInProgress2.updateQueue;\n            updateQueue.baseState = overrideState;\n            workInProgress2.memoizedState = overrideState;\n            if (workInProgress2.flags & ForceClientRender) {\n              var recoverableError = createCapturedValueAtFiber(new Error(\"There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.\"), workInProgress2);\n              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);\n            } else if (nextChildren !== prevChildren) {\n              var _recoverableError = createCapturedValueAtFiber(new Error(\"This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.\"), workInProgress2);\n              return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);\n            } else {\n              enterHydrationState(workInProgress2);\n              var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n              workInProgress2.child = child;\n              var node = child;\n              while (node) {\n                node.flags = node.flags & ~Placement | Hydrating;\n                node = node.sibling;\n              }\n            }\n          } else {\n            resetHydrationState();\n            if (nextChildren === prevChildren) {\n              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n            }\n            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          }\n          return workInProgress2.child;\n        }\n        function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {\n          resetHydrationState();\n          queueHydrationError(recoverableError);\n          workInProgress2.flags |= ForceClientRender;\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateHostComponent(current2, workInProgress2, renderLanes2) {\n          pushHostContext(workInProgress2);\n          if (current2 === null) {\n            tryToClaimNextHydratableInstance(workInProgress2);\n          }\n          var type = workInProgress2.type;\n          var nextProps = workInProgress2.pendingProps;\n          var prevProps = current2 !== null ? current2.memoizedProps : null;\n          var nextChildren = nextProps.children;\n          var isDirectTextChild = shouldSetTextContent(type, nextProps);\n          if (isDirectTextChild) {\n            nextChildren = null;\n          } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n            workInProgress2.flags |= ContentReset;\n          }\n          markRef(current2, workInProgress2);\n          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function updateHostText(current2, workInProgress2) {\n          if (current2 === null) {\n            tryToClaimNextHydratableInstance(workInProgress2);\n          }\n          return null;\n        }\n        function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {\n          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n          var props = workInProgress2.pendingProps;\n          var lazyComponent = elementType;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n          var Component = init(payload);\n          workInProgress2.type = Component;\n          var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);\n          var resolvedProps = resolveDefaultProps(Component, props);\n          var child;\n          switch (resolvedTag) {\n            case FunctionComponent: {\n              {\n                validateFunctionComponentInDev(workInProgress2, Component);\n                workInProgress2.type = Component = resolveFunctionForHotReloading(Component);\n              }\n              child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);\n              return child;\n            }\n            case ClassComponent: {\n              {\n                workInProgress2.type = Component = resolveClassForHotReloading(Component);\n              }\n              child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);\n              return child;\n            }\n            case ForwardRef: {\n              {\n                workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);\n              }\n              child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);\n              return child;\n            }\n            case MemoComponent: {\n              {\n                if (workInProgress2.type !== workInProgress2.elementType) {\n                  var outerPropTypes = Component.propTypes;\n                  if (outerPropTypes) {\n                    checkPropTypes(\n                      outerPropTypes,\n                      resolvedProps,\n                      // Resolved for outer only\n                      \"prop\",\n                      getComponentNameFromType(Component)\n                    );\n                  }\n                }\n              }\n              child = updateMemoComponent(\n                null,\n                workInProgress2,\n                Component,\n                resolveDefaultProps(Component.type, resolvedProps),\n                // The inner type can have defaults too\n                renderLanes2\n              );\n              return child;\n            }\n          }\n          var hint = \"\";\n          {\n            if (Component !== null && typeof Component === \"object\" && Component.$$typeof === REACT_LAZY_TYPE) {\n              hint = \" Did you wrap a component in React.lazy() more than once?\";\n            }\n          }\n          throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {\n          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n          workInProgress2.tag = ClassComponent;\n          var hasContext;\n          if (isContextProvider(Component)) {\n            hasContext = true;\n            pushContextProvider(workInProgress2);\n          } else {\n            hasContext = false;\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          constructClassInstance(workInProgress2, Component, nextProps);\n          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);\n          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);\n        }\n        function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {\n          resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);\n          var props = workInProgress2.pendingProps;\n          var context;\n          {\n            var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);\n            context = getMaskedContext(workInProgress2, unmaskedContext);\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          var value;\n          var hasId;\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          {\n            if (Component.prototype && typeof Component.prototype.render === \"function\") {\n              var componentName = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutBadClass[componentName]) {\n                error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.\", componentName, componentName);\n                didWarnAboutBadClass[componentName] = true;\n              }\n            }\n            if (workInProgress2.mode & StrictLegacyMode) {\n              ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);\n            }\n            setIsRendering(true);\n            ReactCurrentOwner$1.current = workInProgress2;\n            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);\n            hasId = checkDidRenderIdHook();\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          workInProgress2.flags |= PerformedWork;\n          {\n            if (typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === void 0) {\n              var _componentName = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutModulePatternComponent[_componentName]) {\n                error(\"The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.\", _componentName, _componentName, _componentName);\n                didWarnAboutModulePatternComponent[_componentName] = true;\n              }\n            }\n          }\n          if (\n            // Run these checks in production only if the flag is off.\n            // Eventually we'll delete this branch altogether.\n            typeof value === \"object\" && value !== null && typeof value.render === \"function\" && value.$$typeof === void 0\n          ) {\n            {\n              var _componentName2 = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutModulePatternComponent[_componentName2]) {\n                error(\"The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.\", _componentName2, _componentName2, _componentName2);\n                didWarnAboutModulePatternComponent[_componentName2] = true;\n              }\n            }\n            workInProgress2.tag = ClassComponent;\n            workInProgress2.memoizedState = null;\n            workInProgress2.updateQueue = null;\n            var hasContext = false;\n            if (isContextProvider(Component)) {\n              hasContext = true;\n              pushContextProvider(workInProgress2);\n            } else {\n              hasContext = false;\n            }\n            workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;\n            initializeUpdateQueue(workInProgress2);\n            adoptClassInstance(workInProgress2, value);\n            mountClassInstance(workInProgress2, Component, props, renderLanes2);\n            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);\n          } else {\n            workInProgress2.tag = FunctionComponent;\n            {\n              if (workInProgress2.mode & StrictLegacyMode) {\n                setIsStrictModeForDevtools(true);\n                try {\n                  value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);\n                  hasId = checkDidRenderIdHook();\n                } finally {\n                  setIsStrictModeForDevtools(false);\n                }\n              }\n            }\n            if (getIsHydrating() && hasId) {\n              pushMaterializedTreeId(workInProgress2);\n            }\n            reconcileChildren(null, workInProgress2, value, renderLanes2);\n            {\n              validateFunctionComponentInDev(workInProgress2, Component);\n            }\n            return workInProgress2.child;\n          }\n        }\n        function validateFunctionComponentInDev(workInProgress2, Component) {\n          {\n            if (Component) {\n              if (Component.childContextTypes) {\n                error(\"%s(...): childContextTypes cannot be defined on a function component.\", Component.displayName || Component.name || \"Component\");\n              }\n            }\n            if (workInProgress2.ref !== null) {\n              var info = \"\";\n              var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n              if (ownerName) {\n                info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n              }\n              var warningKey = ownerName || \"\";\n              var debugSource = workInProgress2._debugSource;\n              if (debugSource) {\n                warningKey = debugSource.fileName + \":\" + debugSource.lineNumber;\n              }\n              if (!didWarnAboutFunctionRefs[warningKey]) {\n                didWarnAboutFunctionRefs[warningKey] = true;\n                error(\"Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s\", info);\n              }\n            }\n            if (Component.defaultProps !== void 0) {\n              var componentName = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {\n                error(\"%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.\", componentName);\n                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;\n              }\n            }\n            if (typeof Component.getDerivedStateFromProps === \"function\") {\n              var _componentName3 = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n                error(\"%s: Function components do not support getDerivedStateFromProps.\", _componentName3);\n                didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n              }\n            }\n            if (typeof Component.contextType === \"object\" && Component.contextType !== null) {\n              var _componentName4 = getComponentNameFromType(Component) || \"Unknown\";\n              if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n                error(\"%s: Function components do not support contextType.\", _componentName4);\n                didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n              }\n            }\n          }\n        }\n        var SUSPENDED_MARKER = {\n          dehydrated: null,\n          treeContext: null,\n          retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes2) {\n          return {\n            baseLanes: renderLanes2,\n            cachePool: getSuspendedCache(),\n            transitions: null\n          };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {\n          var cachePool = null;\n          return {\n            baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),\n            cachePool,\n            transitions: prevOffscreenState.transitions\n          };\n        }\n        function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {\n          if (current2 !== null) {\n            var suspenseState = current2.memoizedState;\n            if (suspenseState === null) {\n              return false;\n            }\n          }\n          return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current2, renderLanes2) {\n          return removeLanes(current2.childLanes, renderLanes2);\n        }\n        function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {\n          var nextProps = workInProgress2.pendingProps;\n          {\n            if (shouldSuspend(workInProgress2)) {\n              workInProgress2.flags |= DidCapture;\n            }\n          }\n          var suspenseContext = suspenseStackCursor.current;\n          var showFallback = false;\n          var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;\n          if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {\n            showFallback = true;\n            workInProgress2.flags &= ~DidCapture;\n          } else {\n            if (current2 === null || current2.memoizedState !== null) {\n              {\n                suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n              }\n            }\n          }\n          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          pushSuspenseContext(workInProgress2, suspenseContext);\n          if (current2 === null) {\n            tryToClaimNextHydratableInstance(workInProgress2);\n            var suspenseState = workInProgress2.memoizedState;\n            if (suspenseState !== null) {\n              var dehydrated = suspenseState.dehydrated;\n              if (dehydrated !== null) {\n                return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);\n              }\n            }\n            var nextPrimaryChildren = nextProps.children;\n            var nextFallbackChildren = nextProps.fallback;\n            if (showFallback) {\n              var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);\n              var primaryChildFragment = workInProgress2.child;\n              primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);\n              workInProgress2.memoizedState = SUSPENDED_MARKER;\n              return fallbackFragment;\n            } else {\n              return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);\n            }\n          } else {\n            var prevState = current2.memoizedState;\n            if (prevState !== null) {\n              var _dehydrated = prevState.dehydrated;\n              if (_dehydrated !== null) {\n                return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);\n              }\n            }\n            if (showFallback) {\n              var _nextFallbackChildren = nextProps.fallback;\n              var _nextPrimaryChildren = nextProps.children;\n              var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);\n              var _primaryChildFragment2 = workInProgress2.child;\n              var prevOffscreenState = current2.child.memoizedState;\n              _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);\n              _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);\n              workInProgress2.memoizedState = SUSPENDED_MARKER;\n              return fallbackChildFragment;\n            } else {\n              var _nextPrimaryChildren2 = nextProps.children;\n              var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);\n              workInProgress2.memoizedState = null;\n              return _primaryChildFragment3;\n            }\n          }\n        }\n        function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {\n          var mode = workInProgress2.mode;\n          var primaryChildProps = {\n            mode: \"visible\",\n            children: primaryChildren\n          };\n          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n          primaryChildFragment.return = workInProgress2;\n          workInProgress2.child = primaryChildFragment;\n          return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n          var mode = workInProgress2.mode;\n          var progressedPrimaryFragment = workInProgress2.child;\n          var primaryChildProps = {\n            mode: \"hidden\",\n            children: primaryChildren\n          };\n          var primaryChildFragment;\n          var fallbackChildFragment;\n          if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n            primaryChildFragment = progressedPrimaryFragment;\n            primaryChildFragment.childLanes = NoLanes;\n            primaryChildFragment.pendingProps = primaryChildProps;\n            if (workInProgress2.mode & ProfileMode) {\n              primaryChildFragment.actualDuration = 0;\n              primaryChildFragment.actualStartTime = -1;\n              primaryChildFragment.selfBaseDuration = 0;\n              primaryChildFragment.treeBaseDuration = 0;\n            }\n            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n          } else {\n            primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n          }\n          primaryChildFragment.return = workInProgress2;\n          fallbackChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = fallbackChildFragment;\n          workInProgress2.child = primaryChildFragment;\n          return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {\n          return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {\n          return createWorkInProgress(current2, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {\n          var currentPrimaryChildFragment = current2.child;\n          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n          var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n            mode: \"visible\",\n            children: primaryChildren\n          });\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            primaryChildFragment.lanes = renderLanes2;\n          }\n          primaryChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = null;\n          if (currentFallbackChildFragment !== null) {\n            var deletions = workInProgress2.deletions;\n            if (deletions === null) {\n              workInProgress2.deletions = [currentFallbackChildFragment];\n              workInProgress2.flags |= ChildDeletion;\n            } else {\n              deletions.push(currentFallbackChildFragment);\n            }\n          }\n          workInProgress2.child = primaryChildFragment;\n          return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n          var mode = workInProgress2.mode;\n          var currentPrimaryChildFragment = current2.child;\n          var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n          var primaryChildProps = {\n            mode: \"hidden\",\n            children: primaryChildren\n          };\n          var primaryChildFragment;\n          if (\n            // In legacy mode, we commit the primary tree as if it successfully\n            // completed, even though it's in an inconsistent state.\n            (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n            // already cloned. In legacy mode, the only case where this isn't true is\n            // when DevTools forces us to display a fallback; we skip the first render\n            // pass entirely and go straight to rendering the fallback. (In Concurrent\n            // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n            // only codepath.)\n            workInProgress2.child !== currentPrimaryChildFragment\n          ) {\n            var progressedPrimaryFragment = workInProgress2.child;\n            primaryChildFragment = progressedPrimaryFragment;\n            primaryChildFragment.childLanes = NoLanes;\n            primaryChildFragment.pendingProps = primaryChildProps;\n            if (workInProgress2.mode & ProfileMode) {\n              primaryChildFragment.actualDuration = 0;\n              primaryChildFragment.actualStartTime = -1;\n              primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n              primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n            }\n            workInProgress2.deletions = null;\n          } else {\n            primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n            primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n          }\n          var fallbackChildFragment;\n          if (currentFallbackChildFragment !== null) {\n            fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n          } else {\n            fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);\n            fallbackChildFragment.flags |= Placement;\n          }\n          fallbackChildFragment.return = workInProgress2;\n          primaryChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = fallbackChildFragment;\n          workInProgress2.child = primaryChildFragment;\n          return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {\n          if (recoverableError !== null) {\n            queueHydrationError(recoverableError);\n          }\n          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n          var nextProps = workInProgress2.pendingProps;\n          var primaryChildren = nextProps.children;\n          var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);\n          primaryChildFragment.flags |= Placement;\n          workInProgress2.memoizedState = null;\n          return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {\n          var fiberMode = workInProgress2.mode;\n          var primaryChildProps = {\n            mode: \"visible\",\n            children: primaryChildren\n          };\n          var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n          var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);\n          fallbackChildFragment.flags |= Placement;\n          primaryChildFragment.return = workInProgress2;\n          fallbackChildFragment.return = workInProgress2;\n          primaryChildFragment.sibling = fallbackChildFragment;\n          workInProgress2.child = primaryChildFragment;\n          if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {\n            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);\n          }\n          return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            {\n              error(\"Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.\");\n            }\n            workInProgress2.lanes = laneToLanes(SyncLane);\n          } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n            workInProgress2.lanes = laneToLanes(DefaultHydrationLane);\n          } else {\n            workInProgress2.lanes = laneToLanes(OffscreenLane);\n          }\n          return null;\n        }\n        function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {\n          if (!didSuspend) {\n            warnIfHydrating();\n            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n              return retrySuspenseComponentWithoutHydrating(\n                current2,\n                workInProgress2,\n                renderLanes2,\n                // TODO: When we delete legacy mode, we should make this error argument\n                // required  every concurrent mode path that causes hydration to\n                // de-opt to client rendering should have an error message.\n                null\n              );\n            }\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n              var digest, message, stack;\n              {\n                var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n                digest = _getSuspenseInstanceF.digest;\n                message = _getSuspenseInstanceF.message;\n                stack = _getSuspenseInstanceF.stack;\n              }\n              var error2;\n              if (message) {\n                error2 = new Error(message);\n              } else {\n                error2 = new Error(\"The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.\");\n              }\n              var capturedValue = createCapturedValue(error2, digest, stack);\n              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);\n            }\n            var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);\n            if (didReceiveUpdate || hasContextChanged2) {\n              var root2 = getWorkInProgressRoot();\n              if (root2 !== null) {\n                var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);\n                if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                  suspenseState.retryLane = attemptHydrationAtLane;\n                  var eventTime = NoTimestamp;\n                  enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);\n                  scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);\n                }\n              }\n              renderDidSuspendDelayIfPossible();\n              var _capturedValue = createCapturedValue(new Error(\"This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition.\"));\n              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);\n            } else if (isSuspenseInstancePending(suspenseInstance)) {\n              workInProgress2.flags |= DidCapture;\n              workInProgress2.child = current2.child;\n              var retry = retryDehydratedSuspenseBoundary.bind(null, current2);\n              registerSuspenseInstanceRetry(suspenseInstance, retry);\n              return null;\n            } else {\n              reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);\n              var primaryChildren = nextProps.children;\n              var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);\n              primaryChildFragment.flags |= Hydrating;\n              return primaryChildFragment;\n            }\n          } else {\n            if (workInProgress2.flags & ForceClientRender) {\n              workInProgress2.flags &= ~ForceClientRender;\n              var _capturedValue2 = createCapturedValue(new Error(\"There was an error while hydrating this Suspense boundary. Switched to client rendering.\"));\n              return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);\n            } else if (workInProgress2.memoizedState !== null) {\n              workInProgress2.child = current2.child;\n              workInProgress2.flags |= DidCapture;\n              return null;\n            } else {\n              var nextPrimaryChildren = nextProps.children;\n              var nextFallbackChildren = nextProps.fallback;\n              var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);\n              var _primaryChildFragment4 = workInProgress2.child;\n              _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);\n              workInProgress2.memoizedState = SUSPENDED_MARKER;\n              return fallbackChildFragment;\n            }\n          }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {\n          fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);\n          var alternate = fiber.alternate;\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);\n          }\n          scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {\n          var node = firstChild;\n          while (node !== null) {\n            if (node.tag === SuspenseComponent) {\n              var state = node.memoizedState;\n              if (state !== null) {\n                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);\n              }\n            } else if (node.tag === SuspenseListComponent) {\n              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);\n            } else if (node.child !== null) {\n              node.child.return = node;\n              node = node.child;\n              continue;\n            }\n            if (node === workInProgress2) {\n              return;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === workInProgress2) {\n                return;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n        }\n        function findLastContentRow(firstChild) {\n          var row = firstChild;\n          var lastContentRow = null;\n          while (row !== null) {\n            var currentRow = row.alternate;\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              lastContentRow = row;\n            }\n            row = row.sibling;\n          }\n          return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n          {\n            if (revealOrder !== void 0 && revealOrder !== \"forwards\" && revealOrder !== \"backwards\" && revealOrder !== \"together\" && !didWarnAboutRevealOrder[revealOrder]) {\n              didWarnAboutRevealOrder[revealOrder] = true;\n              if (typeof revealOrder === \"string\") {\n                switch (revealOrder.toLowerCase()) {\n                  case \"together\":\n                  case \"forwards\":\n                  case \"backwards\": {\n                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                    break;\n                  }\n                  case \"forward\":\n                  case \"backward\": {\n                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                    break;\n                  }\n                  default:\n                    error('\"%s\" is not a supported revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    break;\n                }\n              } else {\n                error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n              }\n            }\n          }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n          {\n            if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {\n              if (tailMode !== \"collapsed\" && tailMode !== \"hidden\") {\n                didWarnAboutTailOptions[tailMode] = true;\n                error('\"%s\" is not a supported value for tail on <SuspenseList />. Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n              } else if (revealOrder !== \"forwards\" && revealOrder !== \"backwards\") {\n                didWarnAboutTailOptions[tailMode] = true;\n                error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is \"forwards\" or \"backwards\". Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n              }\n            }\n          }\n        }\n        function validateSuspenseListNestedChild(childSlot, index2) {\n          {\n            var isAnArray = isArray(childSlot);\n            var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === \"function\";\n            if (isAnArray || isIterable) {\n              var type = isAnArray ? \"array\" : \"iterable\";\n              error(\"A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>\", type, index2, type);\n              return false;\n            }\n          }\n          return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n          {\n            if ((revealOrder === \"forwards\" || revealOrder === \"backwards\") && children !== void 0 && children !== null && children !== false) {\n              if (isArray(children)) {\n                for (var i = 0; i < children.length; i++) {\n                  if (!validateSuspenseListNestedChild(children[i], i)) {\n                    return;\n                  }\n                }\n              } else {\n                var iteratorFn = getIteratorFn(children);\n                if (typeof iteratorFn === \"function\") {\n                  var childrenIterator = iteratorFn.call(children);\n                  if (childrenIterator) {\n                    var step = childrenIterator.next();\n                    var _i = 0;\n                    for (; !step.done; step = childrenIterator.next()) {\n                      if (!validateSuspenseListNestedChild(step.value, _i)) {\n                        return;\n                      }\n                      _i++;\n                    }\n                  }\n                } else {\n                  error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);\n                }\n              }\n            }\n          }\n        }\n        function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {\n          var renderState = workInProgress2.memoizedState;\n          if (renderState === null) {\n            workInProgress2.memoizedState = {\n              isBackwards,\n              rendering: null,\n              renderingStartTime: 0,\n              last: lastContentRow,\n              tail,\n              tailMode\n            };\n          } else {\n            renderState.isBackwards = isBackwards;\n            renderState.rendering = null;\n            renderState.renderingStartTime = 0;\n            renderState.last = lastContentRow;\n            renderState.tail = tail;\n            renderState.tailMode = tailMode;\n          }\n        }\n        function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {\n          var nextProps = workInProgress2.pendingProps;\n          var revealOrder = nextProps.revealOrder;\n          var tailMode = nextProps.tail;\n          var newChildren = nextProps.children;\n          validateRevealOrder(revealOrder);\n          validateTailOptions(tailMode, revealOrder);\n          validateSuspenseListChildren(newChildren, revealOrder);\n          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n          var suspenseContext = suspenseStackCursor.current;\n          var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          if (shouldForceFallback) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n            workInProgress2.flags |= DidCapture;\n          } else {\n            var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;\n            if (didSuspendBefore) {\n              propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);\n            }\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n          pushSuspenseContext(workInProgress2, suspenseContext);\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            workInProgress2.memoizedState = null;\n          } else {\n            switch (revealOrder) {\n              case \"forwards\": {\n                var lastContentRow = findLastContentRow(workInProgress2.child);\n                var tail;\n                if (lastContentRow === null) {\n                  tail = workInProgress2.child;\n                  workInProgress2.child = null;\n                } else {\n                  tail = lastContentRow.sibling;\n                  lastContentRow.sibling = null;\n                }\n                initSuspenseListRenderState(\n                  workInProgress2,\n                  false,\n                  // isBackwards\n                  tail,\n                  lastContentRow,\n                  tailMode\n                );\n                break;\n              }\n              case \"backwards\": {\n                var _tail = null;\n                var row = workInProgress2.child;\n                workInProgress2.child = null;\n                while (row !== null) {\n                  var currentRow = row.alternate;\n                  if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    workInProgress2.child = row;\n                    break;\n                  }\n                  var nextRow = row.sibling;\n                  row.sibling = _tail;\n                  _tail = row;\n                  row = nextRow;\n                }\n                initSuspenseListRenderState(\n                  workInProgress2,\n                  true,\n                  // isBackwards\n                  _tail,\n                  null,\n                  // last\n                  tailMode\n                );\n                break;\n              }\n              case \"together\": {\n                initSuspenseListRenderState(\n                  workInProgress2,\n                  false,\n                  // isBackwards\n                  null,\n                  // tail\n                  null,\n                  // last\n                  void 0\n                );\n                break;\n              }\n              default: {\n                workInProgress2.memoizedState = null;\n              }\n            }\n          }\n          return workInProgress2.child;\n        }\n        function updatePortalComponent(current2, workInProgress2, renderLanes2) {\n          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);\n          var nextChildren = workInProgress2.pendingProps;\n          if (current2 === null) {\n            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);\n          } else {\n            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);\n          }\n          return workInProgress2.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current2, workInProgress2, renderLanes2) {\n          var providerType = workInProgress2.type;\n          var context = providerType._context;\n          var newProps = workInProgress2.pendingProps;\n          var oldProps = workInProgress2.memoizedProps;\n          var newValue = newProps.value;\n          {\n            if (!(\"value\" in newProps)) {\n              if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                error(\"The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?\");\n              }\n            }\n            var providerPropTypes = workInProgress2.type.propTypes;\n            if (providerPropTypes) {\n              checkPropTypes(providerPropTypes, newProps, \"prop\", \"Context.Provider\");\n            }\n          }\n          pushProvider(workInProgress2, context, newValue);\n          {\n            if (oldProps !== null) {\n              var oldValue = oldProps.value;\n              if (objectIs(oldValue, newValue)) {\n                if (oldProps.children === newProps.children && !hasContextChanged()) {\n                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n                }\n              } else {\n                propagateContextChange(workInProgress2, context, renderLanes2);\n              }\n            }\n          }\n          var newChildren = newProps.children;\n          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        var hasWarnedAboutUsingContextAsConsumer = false;\n        function updateContextConsumer(current2, workInProgress2, renderLanes2) {\n          var context = workInProgress2.type;\n          {\n            if (context._context === void 0) {\n              if (context !== context.Consumer) {\n                if (!hasWarnedAboutUsingContextAsConsumer) {\n                  hasWarnedAboutUsingContextAsConsumer = true;\n                  error(\"Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?\");\n                }\n              }\n            } else {\n              context = context._context;\n            }\n          }\n          var newProps = workInProgress2.pendingProps;\n          var render2 = newProps.children;\n          {\n            if (typeof render2 !== \"function\") {\n              error(\"A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.\");\n            }\n          }\n          prepareToReadContext(workInProgress2, renderLanes2);\n          var newValue = readContext(context);\n          {\n            markComponentRenderStarted(workInProgress2);\n          }\n          var newChildren;\n          {\n            ReactCurrentOwner$1.current = workInProgress2;\n            setIsRendering(true);\n            newChildren = render2(newValue);\n            setIsRendering(false);\n          }\n          {\n            markComponentRenderStopped();\n          }\n          workInProgress2.flags |= PerformedWork;\n          reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);\n          return workInProgress2.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n          didReceiveUpdate = true;\n        }\n        function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {\n          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {\n            if (current2 !== null) {\n              current2.alternate = null;\n              workInProgress2.alternate = null;\n              workInProgress2.flags |= Placement;\n            }\n          }\n        }\n        function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {\n          if (current2 !== null) {\n            workInProgress2.dependencies = current2.dependencies;\n          }\n          {\n            stopProfilerTimerIfRunning();\n          }\n          markSkippedUpdateLanes(workInProgress2.lanes);\n          if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {\n            {\n              return null;\n            }\n          }\n          cloneChildFibers(current2, workInProgress2);\n          return workInProgress2.child;\n        }\n        function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {\n          {\n            var returnFiber = oldWorkInProgress.return;\n            if (returnFiber === null) {\n              throw new Error(\"Cannot swap the root fiber.\");\n            }\n            current2.alternate = null;\n            oldWorkInProgress.alternate = null;\n            newWorkInProgress.index = oldWorkInProgress.index;\n            newWorkInProgress.sibling = oldWorkInProgress.sibling;\n            newWorkInProgress.return = oldWorkInProgress.return;\n            newWorkInProgress.ref = oldWorkInProgress.ref;\n            if (oldWorkInProgress === returnFiber.child) {\n              returnFiber.child = newWorkInProgress;\n            } else {\n              var prevSibling = returnFiber.child;\n              if (prevSibling === null) {\n                throw new Error(\"Expected parent to have a child.\");\n              }\n              while (prevSibling.sibling !== oldWorkInProgress) {\n                prevSibling = prevSibling.sibling;\n                if (prevSibling === null) {\n                  throw new Error(\"Expected to find the previous sibling.\");\n                }\n              }\n              prevSibling.sibling = newWorkInProgress;\n            }\n            var deletions = returnFiber.deletions;\n            if (deletions === null) {\n              returnFiber.deletions = [current2];\n              returnFiber.flags |= ChildDeletion;\n            } else {\n              deletions.push(current2);\n            }\n            newWorkInProgress.flags |= Placement;\n            return newWorkInProgress;\n          }\n        }\n        function checkScheduledUpdateOrContext(current2, renderLanes2) {\n          var updateLanes = current2.lanes;\n          if (includesSomeLane(updateLanes, renderLanes2)) {\n            return true;\n          }\n          return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {\n          switch (workInProgress2.tag) {\n            case HostRoot:\n              pushHostRootContext(workInProgress2);\n              var root2 = workInProgress2.stateNode;\n              resetHydrationState();\n              break;\n            case HostComponent:\n              pushHostContext(workInProgress2);\n              break;\n            case ClassComponent: {\n              var Component = workInProgress2.type;\n              if (isContextProvider(Component)) {\n                pushContextProvider(workInProgress2);\n              }\n              break;\n            }\n            case HostPortal:\n              pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);\n              break;\n            case ContextProvider: {\n              var newValue = workInProgress2.memoizedProps.value;\n              var context = workInProgress2.type._context;\n              pushProvider(workInProgress2, context, newValue);\n              break;\n            }\n            case Profiler:\n              {\n                var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);\n                if (hasChildWork) {\n                  workInProgress2.flags |= Update;\n                }\n                {\n                  var stateNode = workInProgress2.stateNode;\n                  stateNode.effectDuration = 0;\n                  stateNode.passiveEffectDuration = 0;\n                }\n              }\n              break;\n            case SuspenseComponent: {\n              var state = workInProgress2.memoizedState;\n              if (state !== null) {\n                if (state.dehydrated !== null) {\n                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                  workInProgress2.flags |= DidCapture;\n                  return null;\n                }\n                var primaryChildFragment = workInProgress2.child;\n                var primaryChildLanes = primaryChildFragment.childLanes;\n                if (includesSomeLane(renderLanes2, primaryChildLanes)) {\n                  return updateSuspenseComponent(current2, workInProgress2, renderLanes2);\n                } else {\n                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n                  var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n                  if (child !== null) {\n                    return child.sibling;\n                  } else {\n                    return null;\n                  }\n                }\n              } else {\n                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n              }\n              break;\n            }\n            case SuspenseListComponent: {\n              var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;\n              var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);\n              if (didSuspendBefore) {\n                if (_hasChildWork) {\n                  return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);\n                }\n                workInProgress2.flags |= DidCapture;\n              }\n              var renderState = workInProgress2.memoizedState;\n              if (renderState !== null) {\n                renderState.rendering = null;\n                renderState.tail = null;\n                renderState.lastEffect = null;\n              }\n              pushSuspenseContext(workInProgress2, suspenseStackCursor.current);\n              if (_hasChildWork) {\n                break;\n              } else {\n                return null;\n              }\n            }\n            case OffscreenComponent:\n            case LegacyHiddenComponent: {\n              workInProgress2.lanes = NoLanes;\n              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);\n            }\n          }\n          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);\n        }\n        function beginWork(current2, workInProgress2, renderLanes2) {\n          {\n            if (workInProgress2._debugNeedsRemount && current2 !== null) {\n              return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));\n            }\n          }\n          if (current2 !== null) {\n            var oldProps = current2.memoizedProps;\n            var newProps = workInProgress2.pendingProps;\n            if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:\n            workInProgress2.type !== current2.type) {\n              didReceiveUpdate = true;\n            } else {\n              var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);\n              if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n              // may not be work scheduled on `current`, so we check for this flag.\n              (workInProgress2.flags & DidCapture) === NoFlags) {\n                didReceiveUpdate = false;\n                return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);\n              }\n              if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n                didReceiveUpdate = true;\n              } else {\n                didReceiveUpdate = false;\n              }\n            }\n          } else {\n            didReceiveUpdate = false;\n            if (getIsHydrating() && isForkedChild(workInProgress2)) {\n              var slotIndex = workInProgress2.index;\n              var numberOfForks = getForksAtLevel();\n              pushTreeId(workInProgress2, numberOfForks, slotIndex);\n            }\n          }\n          workInProgress2.lanes = NoLanes;\n          switch (workInProgress2.tag) {\n            case IndeterminateComponent: {\n              return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);\n            }\n            case LazyComponent: {\n              var elementType = workInProgress2.elementType;\n              return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);\n            }\n            case FunctionComponent: {\n              var Component = workInProgress2.type;\n              var unresolvedProps = workInProgress2.pendingProps;\n              var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n              return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);\n            }\n            case ClassComponent: {\n              var _Component = workInProgress2.type;\n              var _unresolvedProps = workInProgress2.pendingProps;\n              var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n              return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);\n            }\n            case HostRoot:\n              return updateHostRoot(current2, workInProgress2, renderLanes2);\n            case HostComponent:\n              return updateHostComponent(current2, workInProgress2, renderLanes2);\n            case HostText:\n              return updateHostText(current2, workInProgress2);\n            case SuspenseComponent:\n              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);\n            case HostPortal:\n              return updatePortalComponent(current2, workInProgress2, renderLanes2);\n            case ForwardRef: {\n              var type = workInProgress2.type;\n              var _unresolvedProps2 = workInProgress2.pendingProps;\n              var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n              return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);\n            }\n            case Fragment:\n              return updateFragment(current2, workInProgress2, renderLanes2);\n            case Mode:\n              return updateMode(current2, workInProgress2, renderLanes2);\n            case Profiler:\n              return updateProfiler(current2, workInProgress2, renderLanes2);\n            case ContextProvider:\n              return updateContextProvider(current2, workInProgress2, renderLanes2);\n            case ContextConsumer:\n              return updateContextConsumer(current2, workInProgress2, renderLanes2);\n            case MemoComponent: {\n              var _type2 = workInProgress2.type;\n              var _unresolvedProps3 = workInProgress2.pendingProps;\n              var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n              {\n                if (workInProgress2.type !== workInProgress2.elementType) {\n                  var outerPropTypes = _type2.propTypes;\n                  if (outerPropTypes) {\n                    checkPropTypes(\n                      outerPropTypes,\n                      _resolvedProps3,\n                      // Resolved for outer only\n                      \"prop\",\n                      getComponentNameFromType(_type2)\n                    );\n                  }\n                }\n              }\n              _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n              return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);\n            }\n            case SimpleMemoComponent: {\n              return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);\n            }\n            case IncompleteClassComponent: {\n              var _Component2 = workInProgress2.type;\n              var _unresolvedProps4 = workInProgress2.pendingProps;\n              var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n              return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);\n            }\n            case SuspenseListComponent: {\n              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);\n            }\n            case ScopeComponent: {\n              break;\n            }\n            case OffscreenComponent: {\n              return updateOffscreenComponent(current2, workInProgress2, renderLanes2);\n            }\n          }\n          throw new Error(\"Unknown unit of work tag (\" + workInProgress2.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        function markUpdate(workInProgress2) {\n          workInProgress2.flags |= Update;\n        }\n        function markRef$1(workInProgress2) {\n          workInProgress2.flags |= Ref;\n          {\n            workInProgress2.flags |= RefStatic;\n          }\n        }\n        var appendAllChildren;\n        var updateHostContainer;\n        var updateHostComponent$1;\n        var updateHostText$1;\n        {\n          appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {\n            var node = workInProgress2.child;\n            while (node !== null) {\n              if (node.tag === HostComponent || node.tag === HostText) {\n                appendInitialChild(parent, node.stateNode);\n              } else if (node.tag === HostPortal) ;\n              else if (node.child !== null) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n              }\n              if (node === workInProgress2) {\n                return;\n              }\n              while (node.sibling === null) {\n                if (node.return === null || node.return === workInProgress2) {\n                  return;\n                }\n                node = node.return;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n            }\n          };\n          updateHostContainer = function(current2, workInProgress2) {\n          };\n          updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {\n            var oldProps = current2.memoizedProps;\n            if (oldProps === newProps) {\n              return;\n            }\n            var instance = workInProgress2.stateNode;\n            var currentHostContext = getHostContext();\n            var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n            workInProgress2.updateQueue = updatePayload;\n            if (updatePayload) {\n              markUpdate(workInProgress2);\n            }\n          };\n          updateHostText$1 = function(current2, workInProgress2, oldText, newText) {\n            if (oldText !== newText) {\n              markUpdate(workInProgress2);\n            }\n          };\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n          if (getIsHydrating()) {\n            return;\n          }\n          switch (renderState.tailMode) {\n            case \"hidden\": {\n              var tailNode = renderState.tail;\n              var lastTailNode = null;\n              while (tailNode !== null) {\n                if (tailNode.alternate !== null) {\n                  lastTailNode = tailNode;\n                }\n                tailNode = tailNode.sibling;\n              }\n              if (lastTailNode === null) {\n                renderState.tail = null;\n              } else {\n                lastTailNode.sibling = null;\n              }\n              break;\n            }\n            case \"collapsed\": {\n              var _tailNode = renderState.tail;\n              var _lastTailNode = null;\n              while (_tailNode !== null) {\n                if (_tailNode.alternate !== null) {\n                  _lastTailNode = _tailNode;\n                }\n                _tailNode = _tailNode.sibling;\n              }\n              if (_lastTailNode === null) {\n                if (!hasRenderedATailFallback && renderState.tail !== null) {\n                  renderState.tail.sibling = null;\n                } else {\n                  renderState.tail = null;\n                }\n              } else {\n                _lastTailNode.sibling = null;\n              }\n              break;\n            }\n          }\n        }\n        function bubbleProperties(completedWork) {\n          var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n          var newChildLanes = NoLanes;\n          var subtreeFlags = NoFlags;\n          if (!didBailout) {\n            if ((completedWork.mode & ProfileMode) !== NoMode) {\n              var actualDuration = completedWork.actualDuration;\n              var treeBaseDuration = completedWork.selfBaseDuration;\n              var child = completedWork.child;\n              while (child !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                subtreeFlags |= child.subtreeFlags;\n                subtreeFlags |= child.flags;\n                actualDuration += child.actualDuration;\n                treeBaseDuration += child.treeBaseDuration;\n                child = child.sibling;\n              }\n              completedWork.actualDuration = actualDuration;\n              completedWork.treeBaseDuration = treeBaseDuration;\n            } else {\n              var _child = completedWork.child;\n              while (_child !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                subtreeFlags |= _child.subtreeFlags;\n                subtreeFlags |= _child.flags;\n                _child.return = completedWork;\n                _child = _child.sibling;\n              }\n            }\n            completedWork.subtreeFlags |= subtreeFlags;\n          } else {\n            if ((completedWork.mode & ProfileMode) !== NoMode) {\n              var _treeBaseDuration = completedWork.selfBaseDuration;\n              var _child2 = completedWork.child;\n              while (_child2 !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));\n                subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                subtreeFlags |= _child2.flags & StaticMask;\n                _treeBaseDuration += _child2.treeBaseDuration;\n                _child2 = _child2.sibling;\n              }\n              completedWork.treeBaseDuration = _treeBaseDuration;\n            } else {\n              var _child3 = completedWork.child;\n              while (_child3 !== null) {\n                newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));\n                subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                subtreeFlags |= _child3.flags & StaticMask;\n                _child3.return = completedWork;\n                _child3 = _child3.sibling;\n              }\n            }\n            completedWork.subtreeFlags |= subtreeFlags;\n          }\n          completedWork.childLanes = newChildLanes;\n          return didBailout;\n        }\n        function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {\n          if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {\n            warnIfUnhydratedTailNodes(workInProgress2);\n            resetHydrationState();\n            workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;\n            return false;\n          }\n          var wasHydrated = popHydrationState(workInProgress2);\n          if (nextState !== null && nextState.dehydrated !== null) {\n            if (current2 === null) {\n              if (!wasHydrated) {\n                throw new Error(\"A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.\");\n              }\n              prepareToHydrateHostSuspenseInstance(workInProgress2);\n              bubbleProperties(workInProgress2);\n              {\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  var isTimedOutSuspense = nextState !== null;\n                  if (isTimedOutSuspense) {\n                    var primaryChildFragment = workInProgress2.child;\n                    if (primaryChildFragment !== null) {\n                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n              return false;\n            } else {\n              resetHydrationState();\n              if ((workInProgress2.flags & DidCapture) === NoFlags) {\n                workInProgress2.memoizedState = null;\n              }\n              workInProgress2.flags |= Update;\n              bubbleProperties(workInProgress2);\n              {\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  var _isTimedOutSuspense = nextState !== null;\n                  if (_isTimedOutSuspense) {\n                    var _primaryChildFragment = workInProgress2.child;\n                    if (_primaryChildFragment !== null) {\n                      workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n              return false;\n            }\n          } else {\n            upgradeHydrationErrorsToRecoverable();\n            return true;\n          }\n        }\n        function completeWork(current2, workInProgress2, renderLanes2) {\n          var newProps = workInProgress2.pendingProps;\n          popTreeContext(workInProgress2);\n          switch (workInProgress2.tag) {\n            case IndeterminateComponent:\n            case LazyComponent:\n            case SimpleMemoComponent:\n            case FunctionComponent:\n            case ForwardRef:\n            case Fragment:\n            case Mode:\n            case Profiler:\n            case ContextConsumer:\n            case MemoComponent:\n              bubbleProperties(workInProgress2);\n              return null;\n            case ClassComponent: {\n              var Component = workInProgress2.type;\n              if (isContextProvider(Component)) {\n                popContext(workInProgress2);\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case HostRoot: {\n              var fiberRoot = workInProgress2.stateNode;\n              popHostContainer(workInProgress2);\n              popTopLevelContextObject(workInProgress2);\n              resetWorkInProgressVersions();\n              if (fiberRoot.pendingContext) {\n                fiberRoot.context = fiberRoot.pendingContext;\n                fiberRoot.pendingContext = null;\n              }\n              if (current2 === null || current2.child === null) {\n                var wasHydrated = popHydrationState(workInProgress2);\n                if (wasHydrated) {\n                  markUpdate(workInProgress2);\n                } else {\n                  if (current2 !== null) {\n                    var prevState = current2.memoizedState;\n                    if (\n                      // Check if this is a client root\n                      !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                      (workInProgress2.flags & ForceClientRender) !== NoFlags\n                    ) {\n                      workInProgress2.flags |= Snapshot;\n                      upgradeHydrationErrorsToRecoverable();\n                    }\n                  }\n                }\n              }\n              updateHostContainer(current2, workInProgress2);\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case HostComponent: {\n              popHostContext(workInProgress2);\n              var rootContainerInstance = getRootHostContainer();\n              var type = workInProgress2.type;\n              if (current2 !== null && workInProgress2.stateNode != null) {\n                updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);\n                if (current2.ref !== workInProgress2.ref) {\n                  markRef$1(workInProgress2);\n                }\n              } else {\n                if (!newProps) {\n                  if (workInProgress2.stateNode === null) {\n                    throw new Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                  }\n                  bubbleProperties(workInProgress2);\n                  return null;\n                }\n                var currentHostContext = getHostContext();\n                var _wasHydrated = popHydrationState(workInProgress2);\n                if (_wasHydrated) {\n                  if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {\n                    markUpdate(workInProgress2);\n                  }\n                } else {\n                  var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);\n                  appendAllChildren(instance, workInProgress2, false, false);\n                  workInProgress2.stateNode = instance;\n                  if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {\n                    markUpdate(workInProgress2);\n                  }\n                }\n                if (workInProgress2.ref !== null) {\n                  markRef$1(workInProgress2);\n                }\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case HostText: {\n              var newText = newProps;\n              if (current2 && workInProgress2.stateNode != null) {\n                var oldText = current2.memoizedProps;\n                updateHostText$1(current2, workInProgress2, oldText, newText);\n              } else {\n                if (typeof newText !== \"string\") {\n                  if (workInProgress2.stateNode === null) {\n                    throw new Error(\"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\");\n                  }\n                }\n                var _rootContainerInstance = getRootHostContainer();\n                var _currentHostContext = getHostContext();\n                var _wasHydrated2 = popHydrationState(workInProgress2);\n                if (_wasHydrated2) {\n                  if (prepareToHydrateHostTextInstance(workInProgress2)) {\n                    markUpdate(workInProgress2);\n                  }\n                } else {\n                  workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);\n                }\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case SuspenseComponent: {\n              popSuspenseContext(workInProgress2);\n              var nextState = workInProgress2.memoizedState;\n              if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {\n                var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);\n                if (!fallthroughToNormalSuspensePath) {\n                  if (workInProgress2.flags & ShouldCapture) {\n                    return workInProgress2;\n                  } else {\n                    return null;\n                  }\n                }\n              }\n              if ((workInProgress2.flags & DidCapture) !== NoFlags) {\n                workInProgress2.lanes = renderLanes2;\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  transferActualDuration(workInProgress2);\n                }\n                return workInProgress2;\n              }\n              var nextDidTimeout = nextState !== null;\n              var prevDidTimeout = current2 !== null && current2.memoizedState !== null;\n              if (nextDidTimeout !== prevDidTimeout) {\n                if (nextDidTimeout) {\n                  var _offscreenFiber2 = workInProgress2.child;\n                  _offscreenFiber2.flags |= Visibility;\n                  if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {\n                    var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n                    if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n                      renderDidSuspend();\n                    } else {\n                      renderDidSuspendDelayIfPossible();\n                    }\n                  }\n                }\n              }\n              var wakeables = workInProgress2.updateQueue;\n              if (wakeables !== null) {\n                workInProgress2.flags |= Update;\n              }\n              bubbleProperties(workInProgress2);\n              {\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  if (nextDidTimeout) {\n                    var primaryChildFragment = workInProgress2.child;\n                    if (primaryChildFragment !== null) {\n                      workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n              return null;\n            }\n            case HostPortal:\n              popHostContainer(workInProgress2);\n              updateHostContainer(current2, workInProgress2);\n              if (current2 === null) {\n                preparePortalMount(workInProgress2.stateNode.containerInfo);\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            case ContextProvider:\n              var context = workInProgress2.type._context;\n              popProvider(context, workInProgress2);\n              bubbleProperties(workInProgress2);\n              return null;\n            case IncompleteClassComponent: {\n              var _Component = workInProgress2.type;\n              if (isContextProvider(_Component)) {\n                popContext(workInProgress2);\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case SuspenseListComponent: {\n              popSuspenseContext(workInProgress2);\n              var renderState = workInProgress2.memoizedState;\n              if (renderState === null) {\n                bubbleProperties(workInProgress2);\n                return null;\n              }\n              var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;\n              var renderedTail = renderState.rendering;\n              if (renderedTail === null) {\n                if (!didSuspendAlready) {\n                  var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);\n                  if (!cannotBeSuspended) {\n                    var row = workInProgress2.child;\n                    while (row !== null) {\n                      var suspended = findFirstSuspended(row);\n                      if (suspended !== null) {\n                        didSuspendAlready = true;\n                        workInProgress2.flags |= DidCapture;\n                        cutOffTailIfNeeded(renderState, false);\n                        var newThenables = suspended.updateQueue;\n                        if (newThenables !== null) {\n                          workInProgress2.updateQueue = newThenables;\n                          workInProgress2.flags |= Update;\n                        }\n                        workInProgress2.subtreeFlags = NoFlags;\n                        resetChildFibers(workInProgress2, renderLanes2);\n                        pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));\n                        return workInProgress2.child;\n                      }\n                      row = row.sibling;\n                    }\n                  }\n                  if (renderState.tail !== null && now() > getRenderTargetTime()) {\n                    workInProgress2.flags |= DidCapture;\n                    didSuspendAlready = true;\n                    cutOffTailIfNeeded(renderState, false);\n                    workInProgress2.lanes = SomeRetryLane;\n                  }\n                } else {\n                  cutOffTailIfNeeded(renderState, false);\n                }\n              } else {\n                if (!didSuspendAlready) {\n                  var _suspended = findFirstSuspended(renderedTail);\n                  if (_suspended !== null) {\n                    workInProgress2.flags |= DidCapture;\n                    didSuspendAlready = true;\n                    var _newThenables = _suspended.updateQueue;\n                    if (_newThenables !== null) {\n                      workInProgress2.updateQueue = _newThenables;\n                      workInProgress2.flags |= Update;\n                    }\n                    cutOffTailIfNeeded(renderState, true);\n                    if (renderState.tail === null && renderState.tailMode === \"hidden\" && !renderedTail.alternate && !getIsHydrating()) {\n                      bubbleProperties(workInProgress2);\n                      return null;\n                    }\n                  } else if (\n                    // The time it took to render last row is greater than the remaining\n                    // time we have to render. So rendering one more row would likely\n                    // exceed it.\n                    now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane\n                  ) {\n                    workInProgress2.flags |= DidCapture;\n                    didSuspendAlready = true;\n                    cutOffTailIfNeeded(renderState, false);\n                    workInProgress2.lanes = SomeRetryLane;\n                  }\n                }\n                if (renderState.isBackwards) {\n                  renderedTail.sibling = workInProgress2.child;\n                  workInProgress2.child = renderedTail;\n                } else {\n                  var previousSibling = renderState.last;\n                  if (previousSibling !== null) {\n                    previousSibling.sibling = renderedTail;\n                  } else {\n                    workInProgress2.child = renderedTail;\n                  }\n                  renderState.last = renderedTail;\n                }\n              }\n              if (renderState.tail !== null) {\n                var next = renderState.tail;\n                renderState.rendering = next;\n                renderState.tail = next.sibling;\n                renderState.renderingStartTime = now();\n                next.sibling = null;\n                var suspenseContext = suspenseStackCursor.current;\n                if (didSuspendAlready) {\n                  suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n                } else {\n                  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n                }\n                pushSuspenseContext(workInProgress2, suspenseContext);\n                return next;\n              }\n              bubbleProperties(workInProgress2);\n              return null;\n            }\n            case ScopeComponent: {\n              break;\n            }\n            case OffscreenComponent:\n            case LegacyHiddenComponent: {\n              popRenderLanes(workInProgress2);\n              var _nextState = workInProgress2.memoizedState;\n              var nextIsHidden = _nextState !== null;\n              if (current2 !== null) {\n                var _prevState = current2.memoizedState;\n                var prevIsHidden = _prevState !== null;\n                if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.\n                !enableLegacyHidden) {\n                  workInProgress2.flags |= Visibility;\n                }\n              }\n              if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {\n                bubbleProperties(workInProgress2);\n              } else {\n                if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n                  bubbleProperties(workInProgress2);\n                  {\n                    if (workInProgress2.subtreeFlags & (Placement | Update)) {\n                      workInProgress2.flags |= Visibility;\n                    }\n                  }\n                }\n              }\n              return null;\n            }\n            case CacheComponent: {\n              return null;\n            }\n            case TracingMarkerComponent: {\n              return null;\n            }\n          }\n          throw new Error(\"Unknown unit of work tag (\" + workInProgress2.tag + \"). This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        function unwindWork(current2, workInProgress2, renderLanes2) {\n          popTreeContext(workInProgress2);\n          switch (workInProgress2.tag) {\n            case ClassComponent: {\n              var Component = workInProgress2.type;\n              if (isContextProvider(Component)) {\n                popContext(workInProgress2);\n              }\n              var flags = workInProgress2.flags;\n              if (flags & ShouldCapture) {\n                workInProgress2.flags = flags & ~ShouldCapture | DidCapture;\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  transferActualDuration(workInProgress2);\n                }\n                return workInProgress2;\n              }\n              return null;\n            }\n            case HostRoot: {\n              var root2 = workInProgress2.stateNode;\n              popHostContainer(workInProgress2);\n              popTopLevelContextObject(workInProgress2);\n              resetWorkInProgressVersions();\n              var _flags = workInProgress2.flags;\n              if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n                workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;\n                return workInProgress2;\n              }\n              return null;\n            }\n            case HostComponent: {\n              popHostContext(workInProgress2);\n              return null;\n            }\n            case SuspenseComponent: {\n              popSuspenseContext(workInProgress2);\n              var suspenseState = workInProgress2.memoizedState;\n              if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                if (workInProgress2.alternate === null) {\n                  throw new Error(\"Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.\");\n                }\n                resetHydrationState();\n              }\n              var _flags2 = workInProgress2.flags;\n              if (_flags2 & ShouldCapture) {\n                workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;\n                if ((workInProgress2.mode & ProfileMode) !== NoMode) {\n                  transferActualDuration(workInProgress2);\n                }\n                return workInProgress2;\n              }\n              return null;\n            }\n            case SuspenseListComponent: {\n              popSuspenseContext(workInProgress2);\n              return null;\n            }\n            case HostPortal:\n              popHostContainer(workInProgress2);\n              return null;\n            case ContextProvider:\n              var context = workInProgress2.type._context;\n              popProvider(context, workInProgress2);\n              return null;\n            case OffscreenComponent:\n            case LegacyHiddenComponent:\n              popRenderLanes(workInProgress2);\n              return null;\n            case CacheComponent:\n              return null;\n            default:\n              return null;\n          }\n        }\n        function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {\n          popTreeContext(interruptedWork);\n          switch (interruptedWork.tag) {\n            case ClassComponent: {\n              var childContextTypes = interruptedWork.type.childContextTypes;\n              if (childContextTypes !== null && childContextTypes !== void 0) {\n                popContext(interruptedWork);\n              }\n              break;\n            }\n            case HostRoot: {\n              var root2 = interruptedWork.stateNode;\n              popHostContainer(interruptedWork);\n              popTopLevelContextObject(interruptedWork);\n              resetWorkInProgressVersions();\n              break;\n            }\n            case HostComponent: {\n              popHostContext(interruptedWork);\n              break;\n            }\n            case HostPortal:\n              popHostContainer(interruptedWork);\n              break;\n            case SuspenseComponent:\n              popSuspenseContext(interruptedWork);\n              break;\n            case SuspenseListComponent:\n              popSuspenseContext(interruptedWork);\n              break;\n            case ContextProvider:\n              var context = interruptedWork.type._context;\n              popProvider(context, interruptedWork);\n              break;\n            case OffscreenComponent:\n            case LegacyHiddenComponent:\n              popRenderLanes(interruptedWork);\n              break;\n          }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n          didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();\n        }\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false;\n        var PossiblyWeakSet = typeof WeakSet === \"function\" ? WeakSet : Set;\n        var nextEffect = null;\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function reportUncaughtErrorInDEV(error2) {\n          {\n            invokeGuardedCallback(null, function() {\n              throw error2;\n            });\n            clearCaughtError();\n          }\n        }\n        var callComponentWillUnmountWithTimer = function(current2, instance) {\n          instance.props = current2.memoizedProps;\n          instance.state = current2.memoizedState;\n          if (current2.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              instance.componentWillUnmount();\n            } finally {\n              recordLayoutEffectDuration(current2);\n            }\n          } else {\n            instance.componentWillUnmount();\n          }\n        };\n        function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {\n          try {\n            commitHookEffectListMount(Layout, current2);\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {\n          try {\n            callComponentWillUnmountWithTimer(current2, instance);\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {\n          try {\n            instance.componentDidMount();\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyAttachRef(current2, nearestMountedAncestor) {\n          try {\n            commitAttachRef(current2);\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        function safelyDetachRef(current2, nearestMountedAncestor) {\n          var ref = current2.ref;\n          if (ref !== null) {\n            if (typeof ref === \"function\") {\n              var retVal;\n              try {\n                if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    retVal = ref(null);\n                  } finally {\n                    recordLayoutEffectDuration(current2);\n                  }\n                } else {\n                  retVal = ref(null);\n                }\n              } catch (error2) {\n                captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n              }\n              {\n                if (typeof retVal === \"function\") {\n                  error(\"Unexpected return value from a callback ref in %s. A callback ref should not return a function.\", getComponentNameFromFiber(current2));\n                }\n              }\n            } else {\n              ref.current = null;\n            }\n          }\n        }\n        function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {\n          try {\n            destroy();\n          } catch (error2) {\n            captureCommitPhaseError(current2, nearestMountedAncestor, error2);\n          }\n        }\n        var focusedInstanceHandle = null;\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root2, firstChild) {\n          focusedInstanceHandle = prepareForCommit(root2.containerInfo);\n          nextEffect = firstChild;\n          commitBeforeMutationEffects_begin();\n          var shouldFire = shouldFireAfterActiveInstanceBlur;\n          shouldFireAfterActiveInstanceBlur = false;\n          focusedInstanceHandle = null;\n          return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var child = fiber.child;\n            if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n              child.return = fiber;\n              nextEffect = child;\n            } else {\n              commitBeforeMutationEffects_complete();\n            }\n          }\n        }\n        function commitBeforeMutationEffects_complete() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            setCurrentFiber(fiber);\n            try {\n              commitBeforeMutationEffectsOnFiber(fiber);\n            } catch (error2) {\n              captureCommitPhaseError(fiber, fiber.return, error2);\n            }\n            resetCurrentFiber();\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n          var current2 = finishedWork.alternate;\n          var flags = finishedWork.flags;\n          if ((flags & Snapshot) !== NoFlags) {\n            setCurrentFiber(finishedWork);\n            switch (finishedWork.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                break;\n              }\n              case ClassComponent: {\n                if (current2 !== null) {\n                  var prevProps = current2.memoizedProps;\n                  var prevState = current2.memoizedState;\n                  var instance = finishedWork.stateNode;\n                  {\n                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                      if (instance.props !== finishedWork.memoizedProps) {\n                        error(\"Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                      if (instance.state !== finishedWork.memoizedState) {\n                        error(\"Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                    }\n                  }\n                  var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n                  {\n                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                    if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {\n                      didWarnSet.add(finishedWork.type);\n                      error(\"%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.\", getComponentNameFromFiber(finishedWork));\n                    }\n                  }\n                  instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                }\n                break;\n              }\n              case HostRoot: {\n                {\n                  var root2 = finishedWork.stateNode;\n                  clearContainer(root2.containerInfo);\n                }\n                break;\n              }\n              case HostComponent:\n              case HostText:\n              case HostPortal:\n              case IncompleteClassComponent:\n                break;\n              default: {\n                throw new Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n              }\n            }\n            resetCurrentFiber();\n          }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n          var updateQueue = finishedWork.updateQueue;\n          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n          if (lastEffect !== null) {\n            var firstEffect = lastEffect.next;\n            var effect = firstEffect;\n            do {\n              if ((effect.tag & flags) === flags) {\n                var destroy = effect.destroy;\n                effect.destroy = void 0;\n                if (destroy !== void 0) {\n                  {\n                    if ((flags & Passive$1) !== NoFlags$1) {\n                      markComponentPassiveEffectUnmountStarted(finishedWork);\n                    } else if ((flags & Layout) !== NoFlags$1) {\n                      markComponentLayoutEffectUnmountStarted(finishedWork);\n                    }\n                  }\n                  {\n                    if ((flags & Insertion) !== NoFlags$1) {\n                      setIsRunningInsertionEffect(true);\n                    }\n                  }\n                  safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                  {\n                    if ((flags & Insertion) !== NoFlags$1) {\n                      setIsRunningInsertionEffect(false);\n                    }\n                  }\n                  {\n                    if ((flags & Passive$1) !== NoFlags$1) {\n                      markComponentPassiveEffectUnmountStopped();\n                    } else if ((flags & Layout) !== NoFlags$1) {\n                      markComponentLayoutEffectUnmountStopped();\n                    }\n                  }\n                }\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n          var updateQueue = finishedWork.updateQueue;\n          var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n          if (lastEffect !== null) {\n            var firstEffect = lastEffect.next;\n            var effect = firstEffect;\n            do {\n              if ((effect.tag & flags) === flags) {\n                {\n                  if ((flags & Passive$1) !== NoFlags$1) {\n                    markComponentPassiveEffectMountStarted(finishedWork);\n                  } else if ((flags & Layout) !== NoFlags$1) {\n                    markComponentLayoutEffectMountStarted(finishedWork);\n                  }\n                }\n                var create = effect.create;\n                {\n                  if ((flags & Insertion) !== NoFlags$1) {\n                    setIsRunningInsertionEffect(true);\n                  }\n                }\n                effect.destroy = create();\n                {\n                  if ((flags & Insertion) !== NoFlags$1) {\n                    setIsRunningInsertionEffect(false);\n                  }\n                }\n                {\n                  if ((flags & Passive$1) !== NoFlags$1) {\n                    markComponentPassiveEffectMountStopped();\n                  } else if ((flags & Layout) !== NoFlags$1) {\n                    markComponentLayoutEffectMountStopped();\n                  }\n                }\n                {\n                  var destroy = effect.destroy;\n                  if (destroy !== void 0 && typeof destroy !== \"function\") {\n                    var hookName = void 0;\n                    if ((effect.tag & Layout) !== NoFlags) {\n                      hookName = \"useLayoutEffect\";\n                    } else if ((effect.tag & Insertion) !== NoFlags) {\n                      hookName = \"useInsertionEffect\";\n                    } else {\n                      hookName = \"useEffect\";\n                    }\n                    var addendum = void 0;\n                    if (destroy === null) {\n                      addendum = \" You returned null. If your effect does not require clean up, return undefined (or nothing).\";\n                    } else if (typeof destroy.then === \"function\") {\n                      addendum = \"\\n\\nIt looks like you wrote \" + hookName + \"(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\\n\\n\" + hookName + \"(() => {\\n  async function fetchData() {\\n    // You can await here\\n    const response = await MyAPI.getData(someId);\\n    // ...\\n  }\\n  fetchData();\\n}, [someId]); // Or [] if effect doesn't need props or state\\n\\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching\";\n                    } else {\n                      addendum = \" You returned: \" + destroy;\n                    }\n                    error(\"%s must not return anything besides a function, which is used for clean-up.%s\", hookName, addendum);\n                  }\n                }\n              }\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n          {\n            if ((finishedWork.flags & Update) !== NoFlags) {\n              switch (finishedWork.tag) {\n                case Profiler: {\n                  var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                  var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;\n                  var commitTime2 = getCommitTime();\n                  var phase = finishedWork.alternate === null ? \"mount\" : \"update\";\n                  {\n                    if (isCurrentUpdateNested()) {\n                      phase = \"nested-update\";\n                    }\n                  }\n                  if (typeof onPostCommit === \"function\") {\n                    onPostCommit(id, phase, passiveEffectDuration, commitTime2);\n                  }\n                  var parentFiber = finishedWork.return;\n                  outer: while (parentFiber !== null) {\n                    switch (parentFiber.tag) {\n                      case HostRoot:\n                        var root2 = parentFiber.stateNode;\n                        root2.passiveEffectDuration += passiveEffectDuration;\n                        break outer;\n                      case Profiler:\n                        var parentStateNode = parentFiber.stateNode;\n                        parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                        break outer;\n                    }\n                    parentFiber = parentFiber.return;\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {\n          if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n            switch (finishedWork.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                if (!offscreenSubtreeWasHidden) {\n                  if (finishedWork.mode & ProfileMode) {\n                    try {\n                      startLayoutEffectTimer();\n                      commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                    } finally {\n                      recordLayoutEffectDuration(finishedWork);\n                    }\n                  } else {\n                    commitHookEffectListMount(Layout | HasEffect, finishedWork);\n                  }\n                }\n                break;\n              }\n              case ClassComponent: {\n                var instance = finishedWork.stateNode;\n                if (finishedWork.flags & Update) {\n                  if (!offscreenSubtreeWasHidden) {\n                    if (current2 === null) {\n                      {\n                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                          if (instance.props !== finishedWork.memoizedProps) {\n                            error(\"Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                          if (instance.state !== finishedWork.memoizedState) {\n                            error(\"Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                        }\n                      }\n                      if (finishedWork.mode & ProfileMode) {\n                        try {\n                          startLayoutEffectTimer();\n                          instance.componentDidMount();\n                        } finally {\n                          recordLayoutEffectDuration(finishedWork);\n                        }\n                      } else {\n                        instance.componentDidMount();\n                      }\n                    } else {\n                      var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);\n                      var prevState = current2.memoizedState;\n                      {\n                        if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                          if (instance.props !== finishedWork.memoizedProps) {\n                            error(\"Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                          if (instance.state !== finishedWork.memoizedState) {\n                            error(\"Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                          }\n                        }\n                      }\n                      if (finishedWork.mode & ProfileMode) {\n                        try {\n                          startLayoutEffectTimer();\n                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                        } finally {\n                          recordLayoutEffectDuration(finishedWork);\n                        }\n                      } else {\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                      }\n                    }\n                  }\n                }\n                var updateQueue = finishedWork.updateQueue;\n                if (updateQueue !== null) {\n                  {\n                    if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                      if (instance.props !== finishedWork.memoizedProps) {\n                        error(\"Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                      if (instance.state !== finishedWork.memoizedState) {\n                        error(\"Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.\", getComponentNameFromFiber(finishedWork) || \"instance\");\n                      }\n                    }\n                  }\n                  commitUpdateQueue(finishedWork, updateQueue, instance);\n                }\n                break;\n              }\n              case HostRoot: {\n                var _updateQueue = finishedWork.updateQueue;\n                if (_updateQueue !== null) {\n                  var _instance = null;\n                  if (finishedWork.child !== null) {\n                    switch (finishedWork.child.tag) {\n                      case HostComponent:\n                        _instance = getPublicInstance(finishedWork.child.stateNode);\n                        break;\n                      case ClassComponent:\n                        _instance = finishedWork.child.stateNode;\n                        break;\n                    }\n                  }\n                  commitUpdateQueue(finishedWork, _updateQueue, _instance);\n                }\n                break;\n              }\n              case HostComponent: {\n                var _instance2 = finishedWork.stateNode;\n                if (current2 === null && finishedWork.flags & Update) {\n                  var type = finishedWork.type;\n                  var props = finishedWork.memoizedProps;\n                  commitMount(_instance2, type, props);\n                }\n                break;\n              }\n              case HostText: {\n                break;\n              }\n              case HostPortal: {\n                break;\n              }\n              case Profiler: {\n                {\n                  var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                  var effectDuration = finishedWork.stateNode.effectDuration;\n                  var commitTime2 = getCommitTime();\n                  var phase = current2 === null ? \"mount\" : \"update\";\n                  {\n                    if (isCurrentUpdateNested()) {\n                      phase = \"nested-update\";\n                    }\n                  }\n                  if (typeof onRender === \"function\") {\n                    onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);\n                  }\n                  {\n                    if (typeof onCommit === \"function\") {\n                      onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);\n                    }\n                    enqueuePendingPassiveProfilerEffect(finishedWork);\n                    var parentFiber = finishedWork.return;\n                    outer: while (parentFiber !== null) {\n                      switch (parentFiber.tag) {\n                        case HostRoot:\n                          var root2 = parentFiber.stateNode;\n                          root2.effectDuration += effectDuration;\n                          break outer;\n                        case Profiler:\n                          var parentStateNode = parentFiber.stateNode;\n                          parentStateNode.effectDuration += effectDuration;\n                          break outer;\n                      }\n                      parentFiber = parentFiber.return;\n                    }\n                  }\n                }\n                break;\n              }\n              case SuspenseComponent: {\n                commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                break;\n              }\n              case SuspenseListComponent:\n              case IncompleteClassComponent:\n              case ScopeComponent:\n              case OffscreenComponent:\n              case LegacyHiddenComponent:\n              case TracingMarkerComponent: {\n                break;\n              }\n              default:\n                throw new Error(\"This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n          }\n          if (!offscreenSubtreeWasHidden) {\n            {\n              if (finishedWork.flags & Ref) {\n                commitAttachRef(finishedWork);\n              }\n            }\n          }\n        }\n        function reappearLayoutEffectsOnFiber(node) {\n          switch (node.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (node.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  safelyCallCommitHookLayoutEffectListMount(node, node.return);\n                } finally {\n                  recordLayoutEffectDuration(node);\n                }\n              } else {\n                safelyCallCommitHookLayoutEffectListMount(node, node.return);\n              }\n              break;\n            }\n            case ClassComponent: {\n              var instance = node.stateNode;\n              if (typeof instance.componentDidMount === \"function\") {\n                safelyCallComponentDidMount(node, node.return, instance);\n              }\n              safelyAttachRef(node, node.return);\n              break;\n            }\n            case HostComponent: {\n              safelyAttachRef(node, node.return);\n              break;\n            }\n          }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n          var hostSubtreeRoot = null;\n          {\n            var node = finishedWork;\n            while (true) {\n              if (node.tag === HostComponent) {\n                if (hostSubtreeRoot === null) {\n                  hostSubtreeRoot = node;\n                  try {\n                    var instance = node.stateNode;\n                    if (isHidden) {\n                      hideInstance(instance);\n                    } else {\n                      unhideInstance(node.stateNode, node.memoizedProps);\n                    }\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              } else if (node.tag === HostText) {\n                if (hostSubtreeRoot === null) {\n                  try {\n                    var _instance3 = node.stateNode;\n                    if (isHidden) {\n                      hideTextInstance(_instance3);\n                    } else {\n                      unhideTextInstance(_instance3, node.memoizedProps);\n                    }\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n              else if (node.child !== null) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n              }\n              if (node === finishedWork) {\n                return;\n              }\n              while (node.sibling === null) {\n                if (node.return === null || node.return === finishedWork) {\n                  return;\n                }\n                if (hostSubtreeRoot === node) {\n                  hostSubtreeRoot = null;\n                }\n                node = node.return;\n              }\n              if (hostSubtreeRoot === node) {\n                hostSubtreeRoot = null;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n            }\n          }\n        }\n        function commitAttachRef(finishedWork) {\n          var ref = finishedWork.ref;\n          if (ref !== null) {\n            var instance = finishedWork.stateNode;\n            var instanceToUse;\n            switch (finishedWork.tag) {\n              case HostComponent:\n                instanceToUse = getPublicInstance(instance);\n                break;\n              default:\n                instanceToUse = instance;\n            }\n            if (typeof ref === \"function\") {\n              var retVal;\n              if (finishedWork.mode & ProfileMode) {\n                try {\n                  startLayoutEffectTimer();\n                  retVal = ref(instanceToUse);\n                } finally {\n                  recordLayoutEffectDuration(finishedWork);\n                }\n              } else {\n                retVal = ref(instanceToUse);\n              }\n              {\n                if (typeof retVal === \"function\") {\n                  error(\"Unexpected return value from a callback ref in %s. A callback ref should not return a function.\", getComponentNameFromFiber(finishedWork));\n                }\n              }\n            } else {\n              {\n                if (!ref.hasOwnProperty(\"current\")) {\n                  error(\"Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().\", getComponentNameFromFiber(finishedWork));\n                }\n              }\n              ref.current = instanceToUse;\n            }\n          }\n        }\n        function detachFiberMutation(fiber) {\n          var alternate = fiber.alternate;\n          if (alternate !== null) {\n            alternate.return = null;\n          }\n          fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n          var alternate = fiber.alternate;\n          if (alternate !== null) {\n            fiber.alternate = null;\n            detachFiberAfterEffects(alternate);\n          }\n          {\n            fiber.child = null;\n            fiber.deletions = null;\n            fiber.sibling = null;\n            if (fiber.tag === HostComponent) {\n              var hostInstance = fiber.stateNode;\n              if (hostInstance !== null) {\n                detachDeletedInstance(hostInstance);\n              }\n            }\n            fiber.stateNode = null;\n            {\n              fiber._debugOwner = null;\n            }\n            {\n              fiber.return = null;\n              fiber.dependencies = null;\n              fiber.memoizedProps = null;\n              fiber.memoizedState = null;\n              fiber.pendingProps = null;\n              fiber.stateNode = null;\n              fiber.updateQueue = null;\n            }\n          }\n        }\n        function getHostParentFiber(fiber) {\n          var parent = fiber.return;\n          while (parent !== null) {\n            if (isHostParent(parent)) {\n              return parent;\n            }\n            parent = parent.return;\n          }\n          throw new Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n        }\n        function isHostParent(fiber) {\n          return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n          var node = fiber;\n          siblings: while (true) {\n            while (node.sibling === null) {\n              if (node.return === null || isHostParent(node.return)) {\n                return null;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n            while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n              if (node.flags & Placement) {\n                continue siblings;\n              }\n              if (node.child === null || node.tag === HostPortal) {\n                continue siblings;\n              } else {\n                node.child.return = node;\n                node = node.child;\n              }\n            }\n            if (!(node.flags & Placement)) {\n              return node.stateNode;\n            }\n          }\n        }\n        function commitPlacement(finishedWork) {\n          var parentFiber = getHostParentFiber(finishedWork);\n          switch (parentFiber.tag) {\n            case HostComponent: {\n              var parent = parentFiber.stateNode;\n              if (parentFiber.flags & ContentReset) {\n                resetTextContent(parent);\n                parentFiber.flags &= ~ContentReset;\n              }\n              var before = getHostSibling(finishedWork);\n              insertOrAppendPlacementNode(finishedWork, before, parent);\n              break;\n            }\n            case HostRoot:\n            case HostPortal: {\n              var _parent = parentFiber.stateNode.containerInfo;\n              var _before = getHostSibling(finishedWork);\n              insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n              break;\n            }\n            default:\n              throw new Error(\"Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n          var tag = node.tag;\n          var isHost = tag === HostComponent || tag === HostText;\n          if (isHost) {\n            var stateNode = node.stateNode;\n            if (before) {\n              insertInContainerBefore(parent, stateNode, before);\n            } else {\n              appendChildToContainer(parent, stateNode);\n            }\n          } else if (tag === HostPortal) ;\n          else {\n            var child = node.child;\n            if (child !== null) {\n              insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n              var sibling = child.sibling;\n              while (sibling !== null) {\n                insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                sibling = sibling.sibling;\n              }\n            }\n          }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n          var tag = node.tag;\n          var isHost = tag === HostComponent || tag === HostText;\n          if (isHost) {\n            var stateNode = node.stateNode;\n            if (before) {\n              insertBefore(parent, stateNode, before);\n            } else {\n              appendChild(parent, stateNode);\n            }\n          } else if (tag === HostPortal) ;\n          else {\n            var child = node.child;\n            if (child !== null) {\n              insertOrAppendPlacementNode(child, before, parent);\n              var sibling = child.sibling;\n              while (sibling !== null) {\n                insertOrAppendPlacementNode(sibling, before, parent);\n                sibling = sibling.sibling;\n              }\n            }\n          }\n        }\n        var hostParent = null;\n        var hostParentIsContainer = false;\n        function commitDeletionEffects(root2, returnFiber, deletedFiber) {\n          {\n            var parent = returnFiber;\n            findParent: while (parent !== null) {\n              switch (parent.tag) {\n                case HostComponent: {\n                  hostParent = parent.stateNode;\n                  hostParentIsContainer = false;\n                  break findParent;\n                }\n                case HostRoot: {\n                  hostParent = parent.stateNode.containerInfo;\n                  hostParentIsContainer = true;\n                  break findParent;\n                }\n                case HostPortal: {\n                  hostParent = parent.stateNode.containerInfo;\n                  hostParentIsContainer = true;\n                  break findParent;\n                }\n              }\n              parent = parent.return;\n            }\n            if (hostParent === null) {\n              throw new Error(\"Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.\");\n            }\n            commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);\n            hostParent = null;\n            hostParentIsContainer = false;\n          }\n          detachFiberMutation(deletedFiber);\n        }\n        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n          var child = parent.child;\n          while (child !== null) {\n            commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n            child = child.sibling;\n          }\n        }\n        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n          onCommitUnmount(deletedFiber);\n          switch (deletedFiber.tag) {\n            case HostComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n              }\n            }\n            case HostText: {\n              {\n                var prevHostParent = hostParent;\n                var prevHostParentIsContainer = hostParentIsContainer;\n                hostParent = null;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                hostParent = prevHostParent;\n                hostParentIsContainer = prevHostParentIsContainer;\n                if (hostParent !== null) {\n                  if (hostParentIsContainer) {\n                    removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                  } else {\n                    removeChild(hostParent, deletedFiber.stateNode);\n                  }\n                }\n              }\n              return;\n            }\n            case DehydratedFragment: {\n              {\n                if (hostParent !== null) {\n                  if (hostParentIsContainer) {\n                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                  } else {\n                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                  }\n                }\n              }\n              return;\n            }\n            case HostPortal: {\n              {\n                var _prevHostParent = hostParent;\n                var _prevHostParentIsContainer = hostParentIsContainer;\n                hostParent = deletedFiber.stateNode.containerInfo;\n                hostParentIsContainer = true;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                hostParent = _prevHostParent;\n                hostParentIsContainer = _prevHostParentIsContainer;\n              }\n              return;\n            }\n            case FunctionComponent:\n            case ForwardRef:\n            case MemoComponent:\n            case SimpleMemoComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                var updateQueue = deletedFiber.updateQueue;\n                if (updateQueue !== null) {\n                  var lastEffect = updateQueue.lastEffect;\n                  if (lastEffect !== null) {\n                    var firstEffect = lastEffect.next;\n                    var effect = firstEffect;\n                    do {\n                      var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;\n                      if (destroy !== void 0) {\n                        if ((tag & Insertion) !== NoFlags$1) {\n                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                        } else if ((tag & Layout) !== NoFlags$1) {\n                          {\n                            markComponentLayoutEffectUnmountStarted(deletedFiber);\n                          }\n                          if (deletedFiber.mode & ProfileMode) {\n                            startLayoutEffectTimer();\n                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                            recordLayoutEffectDuration(deletedFiber);\n                          } else {\n                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                          }\n                          {\n                            markComponentLayoutEffectUnmountStopped();\n                          }\n                        }\n                      }\n                      effect = effect.next;\n                    } while (effect !== firstEffect);\n                  }\n                }\n              }\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n            case ClassComponent: {\n              if (!offscreenSubtreeWasHidden) {\n                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                var instance = deletedFiber.stateNode;\n                if (typeof instance.componentWillUnmount === \"function\") {\n                  safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n                }\n              }\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n            case ScopeComponent: {\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n            case OffscreenComponent: {\n              if (\n                // TODO: Remove this dead flag\n                deletedFiber.mode & ConcurrentMode\n              ) {\n                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n              } else {\n                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              }\n              break;\n            }\n            default: {\n              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n              return;\n            }\n          }\n        }\n        function commitSuspenseCallback(finishedWork) {\n          var newState = finishedWork.memoizedState;\n        }\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n          var newState = finishedWork.memoizedState;\n          if (newState === null) {\n            var current2 = finishedWork.alternate;\n            if (current2 !== null) {\n              var prevState = current2.memoizedState;\n              if (prevState !== null) {\n                var suspenseInstance = prevState.dehydrated;\n                if (suspenseInstance !== null) {\n                  commitHydratedSuspenseInstance(suspenseInstance);\n                }\n              }\n            }\n          }\n        }\n        function attachSuspenseRetryListeners(finishedWork) {\n          var wakeables = finishedWork.updateQueue;\n          if (wakeables !== null) {\n            finishedWork.updateQueue = null;\n            var retryCache = finishedWork.stateNode;\n            if (retryCache === null) {\n              retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n            }\n            wakeables.forEach(function(wakeable) {\n              var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n              if (!retryCache.has(wakeable)) {\n                retryCache.add(wakeable);\n                {\n                  if (isDevToolsPresent) {\n                    if (inProgressLanes !== null && inProgressRoot !== null) {\n                      restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                    } else {\n                      throw Error(\"Expected finished root and lanes to be set. This is a bug in React.\");\n                    }\n                  }\n                }\n                wakeable.then(retry, retry);\n              }\n            });\n          }\n        }\n        function commitMutationEffects(root2, finishedWork, committedLanes) {\n          inProgressLanes = committedLanes;\n          inProgressRoot = root2;\n          setCurrentFiber(finishedWork);\n          commitMutationEffectsOnFiber(finishedWork, root2);\n          setCurrentFiber(finishedWork);\n          inProgressLanes = null;\n          inProgressRoot = null;\n        }\n        function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {\n          var deletions = parentFiber.deletions;\n          if (deletions !== null) {\n            for (var i = 0; i < deletions.length; i++) {\n              var childToDelete = deletions[i];\n              try {\n                commitDeletionEffects(root2, parentFiber, childToDelete);\n              } catch (error2) {\n                captureCommitPhaseError(childToDelete, parentFiber, error2);\n              }\n            }\n          }\n          var prevDebugFiber = getCurrentFiber();\n          if (parentFiber.subtreeFlags & MutationMask) {\n            var child = parentFiber.child;\n            while (child !== null) {\n              setCurrentFiber(child);\n              commitMutationEffectsOnFiber(child, root2);\n              child = child.sibling;\n            }\n          }\n          setCurrentFiber(prevDebugFiber);\n        }\n        function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {\n          var current2 = finishedWork.alternate;\n          var flags = finishedWork.flags;\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case MemoComponent:\n            case SimpleMemoComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                try {\n                  commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                  commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n                if (finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                  recordLayoutEffectDuration(finishedWork);\n                } else {\n                  try {\n                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              }\n              return;\n            }\n            case ClassComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Ref) {\n                if (current2 !== null) {\n                  safelyDetachRef(current2, current2.return);\n                }\n              }\n              return;\n            }\n            case HostComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Ref) {\n                if (current2 !== null) {\n                  safelyDetachRef(current2, current2.return);\n                }\n              }\n              {\n                if (finishedWork.flags & ContentReset) {\n                  var instance = finishedWork.stateNode;\n                  try {\n                    resetTextContent(instance);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n                if (flags & Update) {\n                  var _instance4 = finishedWork.stateNode;\n                  if (_instance4 != null) {\n                    var newProps = finishedWork.memoizedProps;\n                    var oldProps = current2 !== null ? current2.memoizedProps : newProps;\n                    var type = finishedWork.type;\n                    var updatePayload = finishedWork.updateQueue;\n                    finishedWork.updateQueue = null;\n                    if (updatePayload !== null) {\n                      try {\n                        commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);\n                      } catch (error2) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                      }\n                    }\n                  }\n                }\n              }\n              return;\n            }\n            case HostText: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                {\n                  if (finishedWork.stateNode === null) {\n                    throw new Error(\"This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.\");\n                  }\n                  var textInstance = finishedWork.stateNode;\n                  var newText = finishedWork.memoizedProps;\n                  var oldText = current2 !== null ? current2.memoizedProps : newText;\n                  try {\n                    commitTextUpdate(textInstance, oldText, newText);\n                  } catch (error2) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                  }\n                }\n              }\n              return;\n            }\n            case HostRoot: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                {\n                  if (current2 !== null) {\n                    var prevRootState = current2.memoizedState;\n                    if (prevRootState.isDehydrated) {\n                      try {\n                        commitHydratedContainer(root2.containerInfo);\n                      } catch (error2) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                      }\n                    }\n                  }\n                }\n              }\n              return;\n            }\n            case HostPortal: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              return;\n            }\n            case SuspenseComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              var offscreenFiber = finishedWork.child;\n              if (offscreenFiber.flags & Visibility) {\n                var offscreenInstance = offscreenFiber.stateNode;\n                var newState = offscreenFiber.memoizedState;\n                var isHidden = newState !== null;\n                offscreenInstance.isHidden = isHidden;\n                if (isHidden) {\n                  var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;\n                  if (!wasHidden) {\n                    markCommitTimeOfFallback();\n                  }\n                }\n              }\n              if (flags & Update) {\n                try {\n                  commitSuspenseCallback(finishedWork);\n                } catch (error2) {\n                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n                }\n                attachSuspenseRetryListeners(finishedWork);\n              }\n              return;\n            }\n            case OffscreenComponent: {\n              var _wasHidden = current2 !== null && current2.memoizedState !== null;\n              if (\n                // TODO: Remove this dead flag\n                finishedWork.mode & ConcurrentMode\n              ) {\n                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;\n                recursivelyTraverseMutationEffects(root2, finishedWork);\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n              } else {\n                recursivelyTraverseMutationEffects(root2, finishedWork);\n              }\n              commitReconciliationEffects(finishedWork);\n              if (flags & Visibility) {\n                var _offscreenInstance = finishedWork.stateNode;\n                var _newState = finishedWork.memoizedState;\n                var _isHidden = _newState !== null;\n                var offscreenBoundary = finishedWork;\n                _offscreenInstance.isHidden = _isHidden;\n                {\n                  if (_isHidden) {\n                    if (!_wasHidden) {\n                      if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                        nextEffect = offscreenBoundary;\n                        var offscreenChild = offscreenBoundary.child;\n                        while (offscreenChild !== null) {\n                          nextEffect = offscreenChild;\n                          disappearLayoutEffects_begin(offscreenChild);\n                          offscreenChild = offscreenChild.sibling;\n                        }\n                      }\n                    }\n                  }\n                }\n                {\n                  hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n                }\n              }\n              return;\n            }\n            case SuspenseListComponent: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              if (flags & Update) {\n                attachSuspenseRetryListeners(finishedWork);\n              }\n              return;\n            }\n            case ScopeComponent: {\n              return;\n            }\n            default: {\n              recursivelyTraverseMutationEffects(root2, finishedWork);\n              commitReconciliationEffects(finishedWork);\n              return;\n            }\n          }\n        }\n        function commitReconciliationEffects(finishedWork) {\n          var flags = finishedWork.flags;\n          if (flags & Placement) {\n            try {\n              commitPlacement(finishedWork);\n            } catch (error2) {\n              captureCommitPhaseError(finishedWork, finishedWork.return, error2);\n            }\n            finishedWork.flags &= ~Placement;\n          }\n          if (flags & Hydrating) {\n            finishedWork.flags &= ~Hydrating;\n          }\n        }\n        function commitLayoutEffects(finishedWork, root2, committedLanes) {\n          inProgressLanes = committedLanes;\n          inProgressRoot = root2;\n          nextEffect = finishedWork;\n          commitLayoutEffects_begin(finishedWork, root2, committedLanes);\n          inProgressLanes = null;\n          inProgressRoot = null;\n        }\n        function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {\n          var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            if (fiber.tag === OffscreenComponent && isModernRoot) {\n              var isHidden = fiber.memoizedState !== null;\n              var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n              if (newOffscreenSubtreeIsHidden) {\n                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n                continue;\n              } else {\n                var current2 = fiber.alternate;\n                var wasHidden = current2 !== null && current2.memoizedState !== null;\n                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                  nextEffect = fiber;\n                  reappearLayoutEffects_begin(fiber);\n                }\n                var child = firstChild;\n                while (child !== null) {\n                  nextEffect = child;\n                  commitLayoutEffects_begin(\n                    child,\n                    // New root; bubble back up to here and stop.\n                    root2,\n                    committedLanes\n                  );\n                  child = child.sibling;\n                }\n                nextEffect = fiber;\n                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n                continue;\n              }\n            }\n            if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);\n            }\n          }\n        }\n        function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if ((fiber.flags & LayoutMask) !== NoFlags) {\n              var current2 = fiber.alternate;\n              setCurrentFiber(fiber);\n              try {\n                commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              resetCurrentFiber();\n            }\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function disappearLayoutEffects_begin(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case MemoComponent:\n              case SimpleMemoComponent: {\n                if (fiber.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                  } finally {\n                    recordLayoutEffectDuration(fiber);\n                  }\n                } else {\n                  commitHookEffectListUnmount(Layout, fiber, fiber.return);\n                }\n                break;\n              }\n              case ClassComponent: {\n                safelyDetachRef(fiber, fiber.return);\n                var instance = fiber.stateNode;\n                if (typeof instance.componentWillUnmount === \"function\") {\n                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                }\n                break;\n              }\n              case HostComponent: {\n                safelyDetachRef(fiber, fiber.return);\n                break;\n              }\n              case OffscreenComponent: {\n                var isHidden = fiber.memoizedState !== null;\n                if (isHidden) {\n                  disappearLayoutEffects_complete(subtreeRoot);\n                  continue;\n                }\n                break;\n              }\n            }\n            if (firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              disappearLayoutEffects_complete(subtreeRoot);\n            }\n          }\n        }\n        function disappearLayoutEffects_complete(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function reappearLayoutEffects_begin(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            if (fiber.tag === OffscreenComponent) {\n              var isHidden = fiber.memoizedState !== null;\n              if (isHidden) {\n                reappearLayoutEffects_complete(subtreeRoot);\n                continue;\n              }\n            }\n            if (firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              reappearLayoutEffects_complete(subtreeRoot);\n            }\n          }\n        }\n        function reappearLayoutEffects_complete(subtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            setCurrentFiber(fiber);\n            try {\n              reappearLayoutEffectsOnFiber(fiber);\n            } catch (error2) {\n              captureCommitPhaseError(fiber, fiber.return, error2);\n            }\n            resetCurrentFiber();\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {\n          nextEffect = finishedWork;\n          commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);\n        }\n        function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var firstChild = fiber.child;\n            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n              firstChild.return = fiber;\n              nextEffect = firstChild;\n            } else {\n              commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);\n            }\n          }\n        }\n        function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if ((fiber.flags & Passive) !== NoFlags) {\n              setCurrentFiber(fiber);\n              try {\n                commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);\n              } catch (error2) {\n                captureCommitPhaseError(fiber, fiber.return, error2);\n              }\n              resetCurrentFiber();\n            }\n            if (fiber === subtreeRoot) {\n              nextEffect = null;\n              return;\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (finishedWork.mode & ProfileMode) {\n                startPassiveEffectTimer();\n                try {\n                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n                } finally {\n                  recordPassiveEffectDuration(finishedWork);\n                }\n              } else {\n                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n              }\n              break;\n            }\n          }\n        }\n        function commitPassiveUnmountEffects(firstChild) {\n          nextEffect = firstChild;\n          commitPassiveUnmountEffects_begin();\n        }\n        function commitPassiveUnmountEffects_begin() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var child = fiber.child;\n            if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n              var deletions = fiber.deletions;\n              if (deletions !== null) {\n                for (var i = 0; i < deletions.length; i++) {\n                  var fiberToDelete = deletions[i];\n                  nextEffect = fiberToDelete;\n                  commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n                }\n                {\n                  var previousFiber = fiber.alternate;\n                  if (previousFiber !== null) {\n                    var detachedChild = previousFiber.child;\n                    if (detachedChild !== null) {\n                      previousFiber.child = null;\n                      do {\n                        var detachedSibling = detachedChild.sibling;\n                        detachedChild.sibling = null;\n                        detachedChild = detachedSibling;\n                      } while (detachedChild !== null);\n                    }\n                  }\n                }\n                nextEffect = fiber;\n              }\n            }\n            if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n              child.return = fiber;\n              nextEffect = child;\n            } else {\n              commitPassiveUnmountEffects_complete();\n            }\n          }\n        }\n        function commitPassiveUnmountEffects_complete() {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            if ((fiber.flags & Passive) !== NoFlags) {\n              setCurrentFiber(fiber);\n              commitPassiveUnmountOnFiber(fiber);\n              resetCurrentFiber();\n            }\n            var sibling = fiber.sibling;\n            if (sibling !== null) {\n              sibling.return = fiber.return;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = fiber.return;\n          }\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n          switch (finishedWork.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (finishedWork.mode & ProfileMode) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n                recordPassiveEffectDuration(finishedWork);\n              } else {\n                commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n              }\n              break;\n            }\n          }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            setCurrentFiber(fiber);\n            commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n            resetCurrentFiber();\n            var child = fiber.child;\n            if (child !== null) {\n              child.return = fiber;\n              nextEffect = child;\n            } else {\n              commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n            }\n          }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n          while (nextEffect !== null) {\n            var fiber = nextEffect;\n            var sibling = fiber.sibling;\n            var returnFiber = fiber.return;\n            {\n              detachFiberAfterEffects(fiber);\n              if (fiber === deletedSubtreeRoot) {\n                nextEffect = null;\n                return;\n              }\n            }\n            if (sibling !== null) {\n              sibling.return = returnFiber;\n              nextEffect = sibling;\n              return;\n            }\n            nextEffect = returnFiber;\n          }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {\n          switch (current2.tag) {\n            case FunctionComponent:\n            case ForwardRef:\n            case SimpleMemoComponent: {\n              if (current2.mode & ProfileMode) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);\n                recordPassiveEffectDuration(current2);\n              } else {\n                commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);\n              }\n              break;\n            }\n          }\n        }\n        function invokeLayoutEffectMountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListMount(Layout | HasEffect, fiber);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n              case ClassComponent: {\n                var instance = fiber.stateNode;\n                try {\n                  instance.componentDidMount();\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n            }\n          }\n        }\n        function invokePassiveEffectMountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n            }\n          }\n        }\n        function invokeLayoutEffectUnmountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n                break;\n              }\n              case ClassComponent: {\n                var instance = fiber.stateNode;\n                if (typeof instance.componentWillUnmount === \"function\") {\n                  safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n                }\n                break;\n              }\n            }\n          }\n        }\n        function invokePassiveEffectUnmountInDEV(fiber) {\n          {\n            switch (fiber.tag) {\n              case FunctionComponent:\n              case ForwardRef:\n              case SimpleMemoComponent: {\n                try {\n                  commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n                } catch (error2) {\n                  captureCommitPhaseError(fiber, fiber.return, error2);\n                }\n              }\n            }\n          }\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === \"function\" && Symbol.for) {\n          var symbolFor = Symbol.for;\n          COMPONENT_TYPE = symbolFor(\"selector.component\");\n          HAS_PSEUDO_CLASS_TYPE = symbolFor(\"selector.has_pseudo_class\");\n          ROLE_TYPE = symbolFor(\"selector.role\");\n          TEST_NAME_TYPE = symbolFor(\"selector.test_id\");\n          TEXT_TYPE = symbolFor(\"selector.text\");\n        }\n        var commitHooks = [];\n        function onCommitRoot$1() {\n          {\n            commitHooks.forEach(function(commitHook) {\n              return commitHook();\n            });\n          }\n        }\n        var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\n        function isLegacyActEnvironment(fiber) {\n          {\n            var isReactActEnvironmentGlobal = (\n              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n              typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : void 0\n            );\n            var jestIsDefined = typeof jest !== \"undefined\";\n            return jestIsDefined && isReactActEnvironmentGlobal !== false;\n          }\n        }\n        function isConcurrentActEnvironment() {\n          {\n            var isReactActEnvironmentGlobal = (\n              // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n              typeof IS_REACT_ACT_ENVIRONMENT !== \"undefined\" ? IS_REACT_ACT_ENVIRONMENT : void 0\n            );\n            if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n              error(\"The current testing environment is not configured to support act(...)\");\n            }\n            return isReactActEnvironmentGlobal;\n          }\n        }\n        var ceil = Math.ceil;\n        var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\n        var NoContext = (\n          /*             */\n          0\n        );\n        var BatchedContext = (\n          /*               */\n          1\n        );\n        var RenderContext = (\n          /*                */\n          2\n        );\n        var CommitContext = (\n          /*                */\n          4\n        );\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6;\n        var executionContext = NoContext;\n        var workInProgressRoot = null;\n        var workInProgress = null;\n        var workInProgressRootRenderLanes = NoLanes;\n        var subtreeRenderLanes = NoLanes;\n        var subtreeRenderLanesCursor = createCursor(NoLanes);\n        var workInProgressRootExitStatus = RootInProgress;\n        var workInProgressRootFatalError = null;\n        var workInProgressRootIncludedLanes = NoLanes;\n        var workInProgressRootSkippedLanes = NoLanes;\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes;\n        var workInProgressRootPingedLanes = NoLanes;\n        var workInProgressRootConcurrentErrors = null;\n        var workInProgressRootRecoverableErrors = null;\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 500;\n        var workInProgressRootRenderTargetTime = Infinity;\n        var RENDER_TIMEOUT_MS = 500;\n        var workInProgressTransitions = null;\n        function resetRenderTimer() {\n          workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n          return workInProgressRootRenderTargetTime;\n        }\n        var hasUncaughtError = false;\n        var firstUncaughtError = null;\n        var legacyErrorBoundariesThatAlreadyFailed = null;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var pendingPassiveTransitions = null;\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var isFlushingPassiveEffects = false;\n        var didScheduleUpdateDuringPassiveEffects = false;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0;\n        var rootWithPassiveNestedUpdates = null;\n        var currentEventTime = NoTimestamp;\n        var currentEventTransitionLane = NoLanes;\n        var isRunningInsertionEffect = false;\n        function getWorkInProgressRoot() {\n          return workInProgressRoot;\n        }\n        function requestEventTime() {\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            return now();\n          }\n          if (currentEventTime !== NoTimestamp) {\n            return currentEventTime;\n          }\n          currentEventTime = now();\n          return currentEventTime;\n        }\n        function requestUpdateLane(fiber) {\n          var mode = fiber.mode;\n          if ((mode & ConcurrentMode) === NoMode) {\n            return SyncLane;\n          } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n            return pickArbitraryLane(workInProgressRootRenderLanes);\n          }\n          var isTransition = requestCurrentTransition() !== NoTransition;\n          if (isTransition) {\n            if (ReactCurrentBatchConfig$3.transition !== null) {\n              var transition = ReactCurrentBatchConfig$3.transition;\n              if (!transition._updatedFibers) {\n                transition._updatedFibers = /* @__PURE__ */ new Set();\n              }\n              transition._updatedFibers.add(fiber);\n            }\n            if (currentEventTransitionLane === NoLane) {\n              currentEventTransitionLane = claimNextTransitionLane();\n            }\n            return currentEventTransitionLane;\n          }\n          var updateLane = getCurrentUpdatePriority();\n          if (updateLane !== NoLane) {\n            return updateLane;\n          }\n          var eventLane = getCurrentEventPriority();\n          return eventLane;\n        }\n        function requestRetryLane(fiber) {\n          var mode = fiber.mode;\n          if ((mode & ConcurrentMode) === NoMode) {\n            return SyncLane;\n          }\n          return claimNextRetryLane();\n        }\n        function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {\n          checkForNestedUpdates();\n          {\n            if (isRunningInsertionEffect) {\n              error(\"useInsertionEffect must not schedule updates.\");\n            }\n          }\n          {\n            if (isFlushingPassiveEffects) {\n              didScheduleUpdateDuringPassiveEffects = true;\n            }\n          }\n          markRootUpdated(root2, lane, eventTime);\n          if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {\n            warnAboutRenderPhaseUpdatesInDEV(fiber);\n          } else {\n            {\n              if (isDevToolsPresent) {\n                addFiberToLanesMap(root2, fiber, lane);\n              }\n            }\n            warnIfUpdatesNotWrappedWithActDEV(fiber);\n            if (root2 === workInProgressRoot) {\n              if ((executionContext & RenderContext) === NoContext) {\n                workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n              }\n              if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                markRootSuspended$1(root2, workInProgressRootRenderLanes);\n              }\n            }\n            ensureRootIsScheduled(root2, eventTime);\n            if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n            !ReactCurrentActQueue$1.isBatchingLegacy) {\n              resetRenderTimer();\n              flushSyncCallbacksOnlyInLegacyMode();\n            }\n          }\n        }\n        function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {\n          var current2 = root2.current;\n          current2.lanes = lane;\n          markRootUpdated(root2, lane, eventTime);\n          ensureRootIsScheduled(root2, eventTime);\n        }\n        function isUnsafeClassRenderPhaseUpdate(fiber) {\n          return (\n            // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n            // decided not to enable it.\n            (executionContext & RenderContext) !== NoContext\n          );\n        }\n        function ensureRootIsScheduled(root2, currentTime) {\n          var existingCallbackNode = root2.callbackNode;\n          markStarvedLanesAsExpired(root2, currentTime);\n          var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n          if (nextLanes === NoLanes) {\n            if (existingCallbackNode !== null) {\n              cancelCallback$1(existingCallbackNode);\n            }\n            root2.callbackNode = null;\n            root2.callbackPriority = NoLane;\n            return;\n          }\n          var newCallbackPriority = getHighestPriorityLane(nextLanes);\n          var existingCallbackPriority = root2.callbackPriority;\n          if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n          // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n          // on the `act` queue.\n          !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n            {\n              if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n                error(\"Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.\");\n              }\n            }\n            return;\n          }\n          if (existingCallbackNode != null) {\n            cancelCallback$1(existingCallbackNode);\n          }\n          var newCallbackNode;\n          if (newCallbackPriority === SyncLane) {\n            if (root2.tag === LegacyRoot) {\n              if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n                ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n              }\n              scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));\n            } else {\n              scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));\n            }\n            {\n              if (ReactCurrentActQueue$1.current !== null) {\n                ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n              } else {\n                scheduleMicrotask(function() {\n                  if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncCallbacks();\n                  }\n                });\n              }\n            }\n            newCallbackNode = null;\n          } else {\n            var schedulerPriorityLevel;\n            switch (lanesToEventPriority(nextLanes)) {\n              case DiscreteEventPriority:\n                schedulerPriorityLevel = ImmediatePriority;\n                break;\n              case ContinuousEventPriority:\n                schedulerPriorityLevel = UserBlockingPriority;\n                break;\n              case DefaultEventPriority:\n                schedulerPriorityLevel = NormalPriority;\n                break;\n              case IdleEventPriority:\n                schedulerPriorityLevel = IdlePriority;\n                break;\n              default:\n                schedulerPriorityLevel = NormalPriority;\n                break;\n            }\n            newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));\n          }\n          root2.callbackPriority = newCallbackPriority;\n          root2.callbackNode = newCallbackNode;\n        }\n        function performConcurrentWorkOnRoot(root2, didTimeout) {\n          {\n            resetNestedUpdateFlag();\n          }\n          currentEventTime = NoTimestamp;\n          currentEventTransitionLane = NoLanes;\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Should not already be working.\");\n          }\n          var originalCallbackNode = root2.callbackNode;\n          var didFlushPassiveEffects = flushPassiveEffects();\n          if (didFlushPassiveEffects) {\n            if (root2.callbackNode !== originalCallbackNode) {\n              return null;\n            }\n          }\n          var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n          if (lanes === NoLanes) {\n            return null;\n          }\n          var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;\n          var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);\n          if (exitStatus !== RootInProgress) {\n            if (exitStatus === RootErrored) {\n              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n              if (errorRetryLanes !== NoLanes) {\n                lanes = errorRetryLanes;\n                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);\n              }\n            }\n            if (exitStatus === RootFatalErrored) {\n              var fatalError = workInProgressRootFatalError;\n              prepareFreshStack(root2, NoLanes);\n              markRootSuspended$1(root2, lanes);\n              ensureRootIsScheduled(root2, now());\n              throw fatalError;\n            }\n            if (exitStatus === RootDidNotComplete) {\n              markRootSuspended$1(root2, lanes);\n            } else {\n              var renderWasConcurrent = !includesBlockingLane(root2, lanes);\n              var finishedWork = root2.current.alternate;\n              if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                exitStatus = renderRootSync(root2, lanes);\n                if (exitStatus === RootErrored) {\n                  var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n                  if (_errorRetryLanes !== NoLanes) {\n                    lanes = _errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);\n                  }\n                }\n                if (exitStatus === RootFatalErrored) {\n                  var _fatalError = workInProgressRootFatalError;\n                  prepareFreshStack(root2, NoLanes);\n                  markRootSuspended$1(root2, lanes);\n                  ensureRootIsScheduled(root2, now());\n                  throw _fatalError;\n                }\n              }\n              root2.finishedWork = finishedWork;\n              root2.finishedLanes = lanes;\n              finishConcurrentRender(root2, exitStatus, lanes);\n            }\n          }\n          ensureRootIsScheduled(root2, now());\n          if (root2.callbackNode === originalCallbackNode) {\n            return performConcurrentWorkOnRoot.bind(null, root2);\n          }\n          return null;\n        }\n        function recoverFromConcurrentError(root2, errorRetryLanes) {\n          var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n          if (isRootDehydrated(root2)) {\n            var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);\n            rootWorkInProgress.flags |= ForceClientRender;\n            {\n              errorHydratingContainer(root2.containerInfo);\n            }\n          }\n          var exitStatus = renderRootSync(root2, errorRetryLanes);\n          if (exitStatus !== RootErrored) {\n            var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n            workInProgressRootRecoverableErrors = errorsFromFirstAttempt;\n            if (errorsFromSecondAttempt !== null) {\n              queueRecoverableErrors(errorsFromSecondAttempt);\n            }\n          }\n          return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n          if (workInProgressRootRecoverableErrors === null) {\n            workInProgressRootRecoverableErrors = errors;\n          } else {\n            workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n          }\n        }\n        function finishConcurrentRender(root2, exitStatus, lanes) {\n          switch (exitStatus) {\n            case RootInProgress:\n            case RootFatalErrored: {\n              throw new Error(\"Root did not complete. This is a bug in React.\");\n            }\n            case RootErrored: {\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            case RootSuspended: {\n              markRootSuspended$1(root2, lanes);\n              if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n              !shouldForceFlushFallbacksInDEV()) {\n                var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();\n                if (msUntilTimeout > 10) {\n                  var nextLanes = getNextLanes(root2, NoLanes);\n                  if (nextLanes !== NoLanes) {\n                    break;\n                  }\n                  var suspendedLanes = root2.suspendedLanes;\n                  if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n                    var eventTime = requestEventTime();\n                    markRootPinged(root2, suspendedLanes);\n                    break;\n                  }\n                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);\n                  break;\n                }\n              }\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            case RootSuspendedWithDelay: {\n              markRootSuspended$1(root2, lanes);\n              if (includesOnlyTransitions(lanes)) {\n                break;\n              }\n              if (!shouldForceFlushFallbacksInDEV()) {\n                var mostRecentEventTime = getMostRecentEventTime(root2, lanes);\n                var eventTimeMs = mostRecentEventTime;\n                var timeElapsedMs = now() - eventTimeMs;\n                var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;\n                if (_msUntilTimeout > 10) {\n                  root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);\n                  break;\n                }\n              }\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            case RootCompleted: {\n              commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n              break;\n            }\n            default: {\n              throw new Error(\"Unknown root exit status.\");\n            }\n          }\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n          var node = finishedWork;\n          while (true) {\n            if (node.flags & StoreConsistency) {\n              var updateQueue = node.updateQueue;\n              if (updateQueue !== null) {\n                var checks = updateQueue.stores;\n                if (checks !== null) {\n                  for (var i = 0; i < checks.length; i++) {\n                    var check = checks[i];\n                    var getSnapshot = check.getSnapshot;\n                    var renderedValue = check.value;\n                    try {\n                      if (!objectIs(getSnapshot(), renderedValue)) {\n                        return false;\n                      }\n                    } catch (error2) {\n                      return false;\n                    }\n                  }\n                }\n              }\n            }\n            var child = node.child;\n            if (node.subtreeFlags & StoreConsistency && child !== null) {\n              child.return = node;\n              node = child;\n              continue;\n            }\n            if (node === finishedWork) {\n              return true;\n            }\n            while (node.sibling === null) {\n              if (node.return === null || node.return === finishedWork) {\n                return true;\n              }\n              node = node.return;\n            }\n            node.sibling.return = node.return;\n            node = node.sibling;\n          }\n          return true;\n        }\n        function markRootSuspended$1(root2, suspendedLanes) {\n          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n          suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n          markRootSuspended(root2, suspendedLanes);\n        }\n        function performSyncWorkOnRoot(root2) {\n          {\n            syncNestedUpdateFlag();\n          }\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Should not already be working.\");\n          }\n          flushPassiveEffects();\n          var lanes = getNextLanes(root2, NoLanes);\n          if (!includesSomeLane(lanes, SyncLane)) {\n            ensureRootIsScheduled(root2, now());\n            return null;\n          }\n          var exitStatus = renderRootSync(root2, lanes);\n          if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {\n            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);\n            if (errorRetryLanes !== NoLanes) {\n              lanes = errorRetryLanes;\n              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);\n            }\n          }\n          if (exitStatus === RootFatalErrored) {\n            var fatalError = workInProgressRootFatalError;\n            prepareFreshStack(root2, NoLanes);\n            markRootSuspended$1(root2, lanes);\n            ensureRootIsScheduled(root2, now());\n            throw fatalError;\n          }\n          if (exitStatus === RootDidNotComplete) {\n            throw new Error(\"Root did not complete. This is a bug in React.\");\n          }\n          var finishedWork = root2.current.alternate;\n          root2.finishedWork = finishedWork;\n          root2.finishedLanes = lanes;\n          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);\n          ensureRootIsScheduled(root2, now());\n          return null;\n        }\n        function flushRoot(root2, lanes) {\n          if (lanes !== NoLanes) {\n            markRootEntangled(root2, mergeLanes(lanes, SyncLane));\n            ensureRootIsScheduled(root2, now());\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n              resetRenderTimer();\n              flushSyncCallbacks();\n            }\n          }\n        }\n        function batchedUpdates$1(fn, a) {\n          var prevExecutionContext = executionContext;\n          executionContext |= BatchedContext;\n          try {\n            return fn(a);\n          } finally {\n            executionContext = prevExecutionContext;\n            if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n            !ReactCurrentActQueue$1.isBatchingLegacy) {\n              resetRenderTimer();\n              flushSyncCallbacksOnlyInLegacyMode();\n            }\n          }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n          var previousPriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            return fn(a, b, c, d);\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n            if (executionContext === NoContext) {\n              resetRenderTimer();\n            }\n          }\n        }\n        function flushSync(fn) {\n          if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n            flushPassiveEffects();\n          }\n          var prevExecutionContext = executionContext;\n          executionContext |= BatchedContext;\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          var previousPriority = getCurrentUpdatePriority();\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            if (fn) {\n              return fn();\n            } else {\n              return void 0;\n            }\n          } finally {\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n            executionContext = prevExecutionContext;\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n              flushSyncCallbacks();\n            }\n          }\n        }\n        function isAlreadyRendering() {\n          return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        function pushRenderLanes(fiber, lanes) {\n          push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n          subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n          workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n        }\n        function popRenderLanes(fiber) {\n          subtreeRenderLanes = subtreeRenderLanesCursor.current;\n          pop(subtreeRenderLanesCursor, fiber);\n        }\n        function prepareFreshStack(root2, lanes) {\n          root2.finishedWork = null;\n          root2.finishedLanes = NoLanes;\n          var timeoutHandle = root2.timeoutHandle;\n          if (timeoutHandle !== noTimeout) {\n            root2.timeoutHandle = noTimeout;\n            cancelTimeout(timeoutHandle);\n          }\n          if (workInProgress !== null) {\n            var interruptedWork = workInProgress.return;\n            while (interruptedWork !== null) {\n              var current2 = interruptedWork.alternate;\n              unwindInterruptedWork(current2, interruptedWork);\n              interruptedWork = interruptedWork.return;\n            }\n          }\n          workInProgressRoot = root2;\n          var rootWorkInProgress = createWorkInProgress(root2.current, null);\n          workInProgress = rootWorkInProgress;\n          workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n          workInProgressRootExitStatus = RootInProgress;\n          workInProgressRootFatalError = null;\n          workInProgressRootSkippedLanes = NoLanes;\n          workInProgressRootInterleavedUpdatedLanes = NoLanes;\n          workInProgressRootPingedLanes = NoLanes;\n          workInProgressRootConcurrentErrors = null;\n          workInProgressRootRecoverableErrors = null;\n          finishQueueingConcurrentUpdates();\n          {\n            ReactStrictModeWarnings.discardPendingWarnings();\n          }\n          return rootWorkInProgress;\n        }\n        function handleError(root2, thrownValue) {\n          do {\n            var erroredWork = workInProgress;\n            try {\n              resetContextDependencies();\n              resetHooksAfterThrow();\n              resetCurrentFiber();\n              ReactCurrentOwner$2.current = null;\n              if (erroredWork === null || erroredWork.return === null) {\n                workInProgressRootExitStatus = RootFatalErrored;\n                workInProgressRootFatalError = thrownValue;\n                workInProgress = null;\n                return;\n              }\n              if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n              }\n              if (enableSchedulingProfiler) {\n                markComponentRenderStopped();\n                if (thrownValue !== null && typeof thrownValue === \"object\" && typeof thrownValue.then === \"function\") {\n                  var wakeable = thrownValue;\n                  markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                } else {\n                  markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                }\n              }\n              throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n              completeUnitOfWork(erroredWork);\n            } catch (yetAnotherThrownValue) {\n              thrownValue = yetAnotherThrownValue;\n              if (workInProgress === erroredWork && erroredWork !== null) {\n                erroredWork = erroredWork.return;\n                workInProgress = erroredWork;\n              } else {\n                erroredWork = workInProgress;\n              }\n              continue;\n            }\n            return;\n          } while (true);\n        }\n        function pushDispatcher() {\n          var prevDispatcher = ReactCurrentDispatcher$2.current;\n          ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n          if (prevDispatcher === null) {\n            return ContextOnlyDispatcher;\n          } else {\n            return prevDispatcher;\n          }\n        }\n        function popDispatcher(prevDispatcher) {\n          ReactCurrentDispatcher$2.current = prevDispatcher;\n        }\n        function markCommitTimeOfFallback() {\n          globalMostRecentFallbackTime = now();\n        }\n        function markSkippedUpdateLanes(lane) {\n          workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n          if (workInProgressRootExitStatus === RootInProgress) {\n            workInProgressRootExitStatus = RootSuspended;\n          }\n        }\n        function renderDidSuspendDelayIfPossible() {\n          if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n            workInProgressRootExitStatus = RootSuspendedWithDelay;\n          }\n          if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n            markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n          }\n        }\n        function renderDidError(error2) {\n          if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n            workInProgressRootExitStatus = RootErrored;\n          }\n          if (workInProgressRootConcurrentErrors === null) {\n            workInProgressRootConcurrentErrors = [error2];\n          } else {\n            workInProgressRootConcurrentErrors.push(error2);\n          }\n        }\n        function renderHasNotSuspendedYet() {\n          return workInProgressRootExitStatus === RootInProgress;\n        }\n        function renderRootSync(root2, lanes) {\n          var prevExecutionContext = executionContext;\n          executionContext |= RenderContext;\n          var prevDispatcher = pushDispatcher();\n          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {\n            {\n              if (isDevToolsPresent) {\n                var memoizedUpdaters = root2.memoizedUpdaters;\n                if (memoizedUpdaters.size > 0) {\n                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);\n                  memoizedUpdaters.clear();\n                }\n                movePendingFibersToMemoized(root2, lanes);\n              }\n            }\n            workInProgressTransitions = getTransitionsForLanes();\n            prepareFreshStack(root2, lanes);\n          }\n          {\n            markRenderStarted(lanes);\n          }\n          do {\n            try {\n              workLoopSync();\n              break;\n            } catch (thrownValue) {\n              handleError(root2, thrownValue);\n            }\n          } while (true);\n          resetContextDependencies();\n          executionContext = prevExecutionContext;\n          popDispatcher(prevDispatcher);\n          if (workInProgress !== null) {\n            throw new Error(\"Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          {\n            markRenderStopped();\n          }\n          workInProgressRoot = null;\n          workInProgressRootRenderLanes = NoLanes;\n          return workInProgressRootExitStatus;\n        }\n        function workLoopSync() {\n          while (workInProgress !== null) {\n            performUnitOfWork(workInProgress);\n          }\n        }\n        function renderRootConcurrent(root2, lanes) {\n          var prevExecutionContext = executionContext;\n          executionContext |= RenderContext;\n          var prevDispatcher = pushDispatcher();\n          if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {\n            {\n              if (isDevToolsPresent) {\n                var memoizedUpdaters = root2.memoizedUpdaters;\n                if (memoizedUpdaters.size > 0) {\n                  restorePendingUpdaters(root2, workInProgressRootRenderLanes);\n                  memoizedUpdaters.clear();\n                }\n                movePendingFibersToMemoized(root2, lanes);\n              }\n            }\n            workInProgressTransitions = getTransitionsForLanes();\n            resetRenderTimer();\n            prepareFreshStack(root2, lanes);\n          }\n          {\n            markRenderStarted(lanes);\n          }\n          do {\n            try {\n              workLoopConcurrent();\n              break;\n            } catch (thrownValue) {\n              handleError(root2, thrownValue);\n            }\n          } while (true);\n          resetContextDependencies();\n          popDispatcher(prevDispatcher);\n          executionContext = prevExecutionContext;\n          if (workInProgress !== null) {\n            {\n              markRenderYielded();\n            }\n            return RootInProgress;\n          } else {\n            {\n              markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes;\n            return workInProgressRootExitStatus;\n          }\n        }\n        function workLoopConcurrent() {\n          while (workInProgress !== null && !shouldYield()) {\n            performUnitOfWork(workInProgress);\n          }\n        }\n        function performUnitOfWork(unitOfWork) {\n          var current2 = unitOfWork.alternate;\n          setCurrentFiber(unitOfWork);\n          var next;\n          if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n            startProfilerTimer(unitOfWork);\n            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);\n            stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n          } else {\n            next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);\n          }\n          resetCurrentFiber();\n          unitOfWork.memoizedProps = unitOfWork.pendingProps;\n          if (next === null) {\n            completeUnitOfWork(unitOfWork);\n          } else {\n            workInProgress = next;\n          }\n          ReactCurrentOwner$2.current = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n          var completedWork = unitOfWork;\n          do {\n            var current2 = completedWork.alternate;\n            var returnFiber = completedWork.return;\n            if ((completedWork.flags & Incomplete) === NoFlags) {\n              setCurrentFiber(completedWork);\n              var next = void 0;\n              if ((completedWork.mode & ProfileMode) === NoMode) {\n                next = completeWork(current2, completedWork, subtreeRenderLanes);\n              } else {\n                startProfilerTimer(completedWork);\n                next = completeWork(current2, completedWork, subtreeRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n              }\n              resetCurrentFiber();\n              if (next !== null) {\n                workInProgress = next;\n                return;\n              }\n            } else {\n              var _next = unwindWork(current2, completedWork);\n              if (_next !== null) {\n                _next.flags &= HostEffectMask;\n                workInProgress = _next;\n                return;\n              }\n              if ((completedWork.mode & ProfileMode) !== NoMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                var actualDuration = completedWork.actualDuration;\n                var child = completedWork.child;\n                while (child !== null) {\n                  actualDuration += child.actualDuration;\n                  child = child.sibling;\n                }\n                completedWork.actualDuration = actualDuration;\n              }\n              if (returnFiber !== null) {\n                returnFiber.flags |= Incomplete;\n                returnFiber.subtreeFlags = NoFlags;\n                returnFiber.deletions = null;\n              } else {\n                workInProgressRootExitStatus = RootDidNotComplete;\n                workInProgress = null;\n                return;\n              }\n            }\n            var siblingFiber = completedWork.sibling;\n            if (siblingFiber !== null) {\n              workInProgress = siblingFiber;\n              return;\n            }\n            completedWork = returnFiber;\n            workInProgress = completedWork;\n          } while (completedWork !== null);\n          if (workInProgressRootExitStatus === RootInProgress) {\n            workInProgressRootExitStatus = RootCompleted;\n          }\n        }\n        function commitRoot(root2, recoverableErrors, transitions) {\n          var previousUpdateLanePriority = getCurrentUpdatePriority();\n          var prevTransition = ReactCurrentBatchConfig$3.transition;\n          try {\n            ReactCurrentBatchConfig$3.transition = null;\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);\n          } finally {\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n            setCurrentUpdatePriority(previousUpdateLanePriority);\n          }\n          return null;\n        }\n        function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {\n          do {\n            flushPassiveEffects();\n          } while (rootWithPendingPassiveEffects !== null);\n          flushRenderPhaseStrictModeWarningsInDEV();\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Should not already be working.\");\n          }\n          var finishedWork = root2.finishedWork;\n          var lanes = root2.finishedLanes;\n          {\n            markCommitStarted(lanes);\n          }\n          if (finishedWork === null) {\n            {\n              markCommitStopped();\n            }\n            return null;\n          } else {\n            {\n              if (lanes === NoLanes) {\n                error(\"root.finishedLanes should not be empty during a commit. This is a bug in React.\");\n              }\n            }\n          }\n          root2.finishedWork = null;\n          root2.finishedLanes = NoLanes;\n          if (finishedWork === root2.current) {\n            throw new Error(\"Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.\");\n          }\n          root2.callbackNode = null;\n          root2.callbackPriority = NoLane;\n          var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n          markRootFinished(root2, remainingLanes);\n          if (root2 === workInProgressRoot) {\n            workInProgressRoot = null;\n            workInProgress = null;\n            workInProgressRootRenderLanes = NoLanes;\n          }\n          if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n            if (!rootDoesHavePassiveEffects) {\n              rootDoesHavePassiveEffects = true;\n              pendingPassiveTransitions = transitions;\n              scheduleCallback$1(NormalPriority, function() {\n                flushPassiveEffects();\n                return null;\n              });\n            }\n          }\n          var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n          var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n          if (subtreeHasEffects || rootHasEffect) {\n            var prevTransition = ReactCurrentBatchConfig$3.transition;\n            ReactCurrentBatchConfig$3.transition = null;\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(DiscreteEventPriority);\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            ReactCurrentOwner$2.current = null;\n            var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);\n            {\n              recordCommitTime();\n            }\n            commitMutationEffects(root2, finishedWork, lanes);\n            resetAfterCommit(root2.containerInfo);\n            root2.current = finishedWork;\n            {\n              markLayoutEffectsStarted(lanes);\n            }\n            commitLayoutEffects(finishedWork, root2, lanes);\n            {\n              markLayoutEffectsStopped();\n            }\n            requestPaint();\n            executionContext = prevExecutionContext;\n            setCurrentUpdatePriority(previousPriority);\n            ReactCurrentBatchConfig$3.transition = prevTransition;\n          } else {\n            root2.current = finishedWork;\n            {\n              recordCommitTime();\n            }\n          }\n          var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n          if (rootDoesHavePassiveEffects) {\n            rootDoesHavePassiveEffects = false;\n            rootWithPendingPassiveEffects = root2;\n            pendingPassiveEffectsLanes = lanes;\n          } else {\n            {\n              nestedPassiveUpdateCount = 0;\n              rootWithPassiveNestedUpdates = null;\n            }\n          }\n          remainingLanes = root2.pendingLanes;\n          if (remainingLanes === NoLanes) {\n            legacyErrorBoundariesThatAlreadyFailed = null;\n          }\n          {\n            if (!rootDidHavePassiveEffects) {\n              commitDoubleInvokeEffectsInDEV(root2.current, false);\n            }\n          }\n          onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n          {\n            if (isDevToolsPresent) {\n              root2.memoizedUpdaters.clear();\n            }\n          }\n          {\n            onCommitRoot$1();\n          }\n          ensureRootIsScheduled(root2, now());\n          if (recoverableErrors !== null) {\n            var onRecoverableError = root2.onRecoverableError;\n            for (var i = 0; i < recoverableErrors.length; i++) {\n              var recoverableError = recoverableErrors[i];\n              var componentStack = recoverableError.stack;\n              var digest = recoverableError.digest;\n              onRecoverableError(recoverableError.value, {\n                componentStack,\n                digest\n              });\n            }\n          }\n          if (hasUncaughtError) {\n            hasUncaughtError = false;\n            var error$1 = firstUncaughtError;\n            firstUncaughtError = null;\n            throw error$1;\n          }\n          if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {\n            flushPassiveEffects();\n          }\n          remainingLanes = root2.pendingLanes;\n          if (includesSomeLane(remainingLanes, SyncLane)) {\n            {\n              markNestedUpdateScheduled();\n            }\n            if (root2 === rootWithNestedUpdates) {\n              nestedUpdateCount++;\n            } else {\n              nestedUpdateCount = 0;\n              rootWithNestedUpdates = root2;\n            }\n          } else {\n            nestedUpdateCount = 0;\n          }\n          flushSyncCallbacks();\n          {\n            markCommitStopped();\n          }\n          return null;\n        }\n        function flushPassiveEffects() {\n          if (rootWithPendingPassiveEffects !== null) {\n            var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n            var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n            var prevTransition = ReactCurrentBatchConfig$3.transition;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n              ReactCurrentBatchConfig$3.transition = null;\n              setCurrentUpdatePriority(priority);\n              return flushPassiveEffectsImpl();\n            } finally {\n              setCurrentUpdatePriority(previousPriority);\n              ReactCurrentBatchConfig$3.transition = prevTransition;\n            }\n          }\n          return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n          {\n            pendingPassiveProfilerEffects.push(fiber);\n            if (!rootDoesHavePassiveEffects) {\n              rootDoesHavePassiveEffects = true;\n              scheduleCallback$1(NormalPriority, function() {\n                flushPassiveEffects();\n                return null;\n              });\n            }\n          }\n        }\n        function flushPassiveEffectsImpl() {\n          if (rootWithPendingPassiveEffects === null) {\n            return false;\n          }\n          var transitions = pendingPassiveTransitions;\n          pendingPassiveTransitions = null;\n          var root2 = rootWithPendingPassiveEffects;\n          var lanes = pendingPassiveEffectsLanes;\n          rootWithPendingPassiveEffects = null;\n          pendingPassiveEffectsLanes = NoLanes;\n          if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n            throw new Error(\"Cannot flush passive effects while already rendering.\");\n          }\n          {\n            isFlushingPassiveEffects = true;\n            didScheduleUpdateDuringPassiveEffects = false;\n          }\n          {\n            markPassiveEffectsStarted(lanes);\n          }\n          var prevExecutionContext = executionContext;\n          executionContext |= CommitContext;\n          commitPassiveUnmountEffects(root2.current);\n          commitPassiveMountEffects(root2, root2.current, lanes, transitions);\n          {\n            var profilerEffects = pendingPassiveProfilerEffects;\n            pendingPassiveProfilerEffects = [];\n            for (var i = 0; i < profilerEffects.length; i++) {\n              var _fiber = profilerEffects[i];\n              commitPassiveEffectDurations(root2, _fiber);\n            }\n          }\n          {\n            markPassiveEffectsStopped();\n          }\n          {\n            commitDoubleInvokeEffectsInDEV(root2.current, true);\n          }\n          executionContext = prevExecutionContext;\n          flushSyncCallbacks();\n          {\n            if (didScheduleUpdateDuringPassiveEffects) {\n              if (root2 === rootWithPassiveNestedUpdates) {\n                nestedPassiveUpdateCount++;\n              } else {\n                nestedPassiveUpdateCount = 0;\n                rootWithPassiveNestedUpdates = root2;\n              }\n            } else {\n              nestedPassiveUpdateCount = 0;\n            }\n            isFlushingPassiveEffects = false;\n            didScheduleUpdateDuringPassiveEffects = false;\n          }\n          onPostCommitRoot(root2);\n          {\n            var stateNode = root2.current.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n          }\n          return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n          return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n          if (legacyErrorBoundariesThatAlreadyFailed === null) {\n            legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);\n          } else {\n            legacyErrorBoundariesThatAlreadyFailed.add(instance);\n          }\n        }\n        function prepareToThrowUncaughtError(error2) {\n          if (!hasUncaughtError) {\n            hasUncaughtError = true;\n            firstUncaughtError = error2;\n          }\n        }\n        var onUncaughtError = prepareToThrowUncaughtError;\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {\n          var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);\n          var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n          var root2 = enqueueUpdate(rootFiber, update, SyncLane);\n          var eventTime = requestEventTime();\n          if (root2 !== null) {\n            markRootUpdated(root2, SyncLane, eventTime);\n            ensureRootIsScheduled(root2, eventTime);\n          }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n          {\n            reportUncaughtErrorInDEV(error$1);\n            setIsRunningInsertionEffect(false);\n          }\n          if (sourceFiber.tag === HostRoot) {\n            captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n            return;\n          }\n          var fiber = null;\n          {\n            fiber = nearestMountedAncestor;\n          }\n          while (fiber !== null) {\n            if (fiber.tag === HostRoot) {\n              captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n              return;\n            } else if (fiber.tag === ClassComponent) {\n              var ctor = fiber.type;\n              var instance = fiber.stateNode;\n              if (typeof ctor.getDerivedStateFromError === \"function\" || typeof instance.componentDidCatch === \"function\" && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n                var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n                var root2 = enqueueUpdate(fiber, update, SyncLane);\n                var eventTime = requestEventTime();\n                if (root2 !== null) {\n                  markRootUpdated(root2, SyncLane, eventTime);\n                  ensureRootIsScheduled(root2, eventTime);\n                }\n                return;\n              }\n            }\n            fiber = fiber.return;\n          }\n          {\n            error(\"Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\\n\\nError message:\\n\\n%s\", error$1);\n          }\n        }\n        function pingSuspendedRoot(root2, wakeable, pingedLanes) {\n          var pingCache = root2.pingCache;\n          if (pingCache !== null) {\n            pingCache.delete(wakeable);\n          }\n          var eventTime = requestEventTime();\n          markRootPinged(root2, pingedLanes);\n          warnIfSuspenseResolutionNotWrappedWithActDEV(root2);\n          if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n            if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n              prepareFreshStack(root2, NoLanes);\n            } else {\n              workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n            }\n          }\n          ensureRootIsScheduled(root2, eventTime);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n          if (retryLane === NoLane) {\n            retryLane = requestRetryLane(boundaryFiber);\n          }\n          var eventTime = requestEventTime();\n          var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n          if (root2 !== null) {\n            markRootUpdated(root2, retryLane, eventTime);\n            ensureRootIsScheduled(root2, eventTime);\n          }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n          var suspenseState = boundaryFiber.memoizedState;\n          var retryLane = NoLane;\n          if (suspenseState !== null) {\n            retryLane = suspenseState.retryLane;\n          }\n          retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n          var retryLane = NoLane;\n          var retryCache;\n          switch (boundaryFiber.tag) {\n            case SuspenseComponent:\n              retryCache = boundaryFiber.stateNode;\n              var suspenseState = boundaryFiber.memoizedState;\n              if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n              }\n              break;\n            case SuspenseListComponent:\n              retryCache = boundaryFiber.stateNode;\n              break;\n            default:\n              throw new Error(\"Pinged unknown suspense boundary type. This is probably a bug in React.\");\n          }\n          if (retryCache !== null) {\n            retryCache.delete(wakeable);\n          }\n          retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function jnd(timeElapsed) {\n          return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n        }\n        function checkForNestedUpdates() {\n          if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n            nestedUpdateCount = 0;\n            rootWithNestedUpdates = null;\n            throw new Error(\"Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.\");\n          }\n          {\n            if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n              nestedPassiveUpdateCount = 0;\n              rootWithPassiveNestedUpdates = null;\n              error(\"Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.\");\n            }\n          }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n          {\n            ReactStrictModeWarnings.flushLegacyContextWarning();\n            {\n              ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n            }\n          }\n        }\n        function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n          {\n            setCurrentFiber(fiber);\n            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n            if (hasPassiveEffects) {\n              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n            }\n            invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n            if (hasPassiveEffects) {\n              invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n            }\n            resetCurrentFiber();\n          }\n        }\n        function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n          {\n            var current2 = firstChild;\n            var subtreeRoot = null;\n            while (current2 !== null) {\n              var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;\n              if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {\n                current2 = current2.child;\n              } else {\n                if ((current2.flags & fiberFlags) !== NoFlags) {\n                  invokeEffectFn(current2);\n                }\n                if (current2.sibling !== null) {\n                  current2 = current2.sibling;\n                } else {\n                  current2 = subtreeRoot = current2.return;\n                }\n              }\n            }\n          }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n          {\n            if ((executionContext & RenderContext) !== NoContext) {\n              return;\n            }\n            if (!(fiber.mode & ConcurrentMode)) {\n              return;\n            }\n            var tag = fiber.tag;\n            if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n              return;\n            }\n            var componentName = getComponentNameFromFiber(fiber) || \"ReactComponent\";\n            if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n              if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                return;\n              }\n              didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n            } else {\n              didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);\n            }\n            var previousFiber = current;\n            try {\n              setCurrentFiber(fiber);\n              error(\"Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.\");\n            } finally {\n              if (previousFiber) {\n                setCurrentFiber(fiber);\n              } else {\n                resetCurrentFiber();\n              }\n            }\n          }\n        }\n        var beginWork$1;\n        {\n          var dummyFiber = null;\n          beginWork$1 = function(current2, unitOfWork, lanes) {\n            var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n            try {\n              return beginWork(current2, unitOfWork, lanes);\n            } catch (originalError) {\n              if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === \"object\" && typeof originalError.then === \"function\") {\n                throw originalError;\n              }\n              resetContextDependencies();\n              resetHooksAfterThrow();\n              unwindInterruptedWork(current2, unitOfWork);\n              assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n              if (unitOfWork.mode & ProfileMode) {\n                startProfilerTimer(unitOfWork);\n              }\n              invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);\n              if (hasCaughtError()) {\n                var replayError = clearCaughtError();\n                if (typeof replayError === \"object\" && replayError !== null && replayError._suppressLogging && typeof originalError === \"object\" && originalError !== null && !originalError._suppressLogging) {\n                  originalError._suppressLogging = true;\n                }\n              }\n              throw originalError;\n            }\n          };\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n          didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n          {\n            if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n              switch (fiber.tag) {\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent: {\n                  var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || \"Unknown\";\n                  var dedupeKey = renderingComponentName;\n                  if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                    var setStateComponentName = getComponentNameFromFiber(fiber) || \"Unknown\";\n                    error(\"Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render\", setStateComponentName, renderingComponentName, renderingComponentName);\n                  }\n                  break;\n                }\n                case ClassComponent: {\n                  if (!didWarnAboutUpdateInRender) {\n                    error(\"Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.\");\n                    didWarnAboutUpdateInRender = true;\n                  }\n                  break;\n                }\n              }\n            }\n          }\n        }\n        function restorePendingUpdaters(root2, lanes) {\n          {\n            if (isDevToolsPresent) {\n              var memoizedUpdaters = root2.memoizedUpdaters;\n              memoizedUpdaters.forEach(function(schedulingFiber) {\n                addFiberToLanesMap(root2, schedulingFiber, lanes);\n              });\n            }\n          }\n        }\n        var fakeActCallbackNode = {};\n        function scheduleCallback$1(priorityLevel, callback) {\n          {\n            var actQueue = ReactCurrentActQueue$1.current;\n            if (actQueue !== null) {\n              actQueue.push(callback);\n              return fakeActCallbackNode;\n            } else {\n              return scheduleCallback(priorityLevel, callback);\n            }\n          }\n        }\n        function cancelCallback$1(callbackNode) {\n          if (callbackNode === fakeActCallbackNode) {\n            return;\n          }\n          return cancelCallback(callbackNode);\n        }\n        function shouldForceFlushFallbacksInDEV() {\n          return ReactCurrentActQueue$1.current !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n          {\n            if (fiber.mode & ConcurrentMode) {\n              if (!isConcurrentActEnvironment()) {\n                return;\n              }\n            } else {\n              if (!isLegacyActEnvironment()) {\n                return;\n              }\n              if (executionContext !== NoContext) {\n                return;\n              }\n              if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n                return;\n              }\n            }\n            if (ReactCurrentActQueue$1.current === null) {\n              var previousFiber = current;\n              try {\n                setCurrentFiber(fiber);\n                error(\"An update to %s inside a test was not wrapped in act(...).\\n\\nWhen testing, code that causes React state updates should be wrapped into act(...):\\n\\nact(() => {\\n  /* fire events that update state */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act\", getComponentNameFromFiber(fiber));\n              } finally {\n                if (previousFiber) {\n                  setCurrentFiber(fiber);\n                } else {\n                  resetCurrentFiber();\n                }\n              }\n            }\n          }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {\n          {\n            if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n              error(\"A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\\n\\nWhen testing, code that resolves suspended data should be wrapped into act(...):\\n\\nact(() => {\\n  /* finish loading suspended data */\\n});\\n/* assert on the output */\\n\\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act\");\n            }\n          }\n        }\n        function setIsRunningInsertionEffect(isRunning) {\n          {\n            isRunningInsertionEffect = isRunning;\n          }\n        }\n        var resolveFamily = null;\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n          {\n            resolveFamily = handler;\n          }\n        };\n        function resolveFunctionForHotReloading(type) {\n          {\n            if (resolveFamily === null) {\n              return type;\n            }\n            var family = resolveFamily(type);\n            if (family === void 0) {\n              return type;\n            }\n            return family.current;\n          }\n        }\n        function resolveClassForHotReloading(type) {\n          return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n          {\n            if (resolveFamily === null) {\n              return type;\n            }\n            var family = resolveFamily(type);\n            if (family === void 0) {\n              if (type !== null && type !== void 0 && typeof type.render === \"function\") {\n                var currentRender = resolveFunctionForHotReloading(type.render);\n                if (type.render !== currentRender) {\n                  var syntheticType = {\n                    $$typeof: REACT_FORWARD_REF_TYPE,\n                    render: currentRender\n                  };\n                  if (type.displayName !== void 0) {\n                    syntheticType.displayName = type.displayName;\n                  }\n                  return syntheticType;\n                }\n              }\n              return type;\n            }\n            return family.current;\n          }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n          {\n            if (resolveFamily === null) {\n              return false;\n            }\n            var prevType = fiber.elementType;\n            var nextType = element.type;\n            var needsCompareFamilies = false;\n            var $$typeofNextType = typeof nextType === \"object\" && nextType !== null ? nextType.$$typeof : null;\n            switch (fiber.tag) {\n              case ClassComponent: {\n                if (typeof nextType === \"function\") {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              case FunctionComponent: {\n                if (typeof nextType === \"function\") {\n                  needsCompareFamilies = true;\n                } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              case ForwardRef: {\n                if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                  needsCompareFamilies = true;\n                } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              case MemoComponent:\n              case SimpleMemoComponent: {\n                if ($$typeofNextType === REACT_MEMO_TYPE) {\n                  needsCompareFamilies = true;\n                } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                  needsCompareFamilies = true;\n                }\n                break;\n              }\n              default:\n                return false;\n            }\n            if (needsCompareFamilies) {\n              var prevFamily = resolveFamily(prevType);\n              if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {\n                return true;\n              }\n            }\n            return false;\n          }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n          {\n            if (resolveFamily === null) {\n              return;\n            }\n            if (typeof WeakSet !== \"function\") {\n              return;\n            }\n            if (failedBoundaries === null) {\n              failedBoundaries = /* @__PURE__ */ new WeakSet();\n            }\n            failedBoundaries.add(fiber);\n          }\n        }\n        var scheduleRefresh = function(root2, update) {\n          {\n            if (resolveFamily === null) {\n              return;\n            }\n            var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n            flushPassiveEffects();\n            flushSync(function() {\n              scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);\n            });\n          }\n        };\n        var scheduleRoot = function(root2, element) {\n          {\n            if (root2.context !== emptyContextObject) {\n              return;\n            }\n            flushPassiveEffects();\n            flushSync(function() {\n              updateContainer(element, root2, null, null);\n            });\n          }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n          {\n            var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n            var candidateType = null;\n            switch (tag) {\n              case FunctionComponent:\n              case SimpleMemoComponent:\n              case ClassComponent:\n                candidateType = type;\n                break;\n              case ForwardRef:\n                candidateType = type.render;\n                break;\n            }\n            if (resolveFamily === null) {\n              throw new Error(\"Expected resolveFamily to be set during hot reload.\");\n            }\n            var needsRender = false;\n            var needsRemount = false;\n            if (candidateType !== null) {\n              var family = resolveFamily(candidateType);\n              if (family !== void 0) {\n                if (staleFamilies.has(family)) {\n                  needsRemount = true;\n                } else if (updatedFamilies.has(family)) {\n                  if (tag === ClassComponent) {\n                    needsRemount = true;\n                  } else {\n                    needsRender = true;\n                  }\n                }\n              }\n            }\n            if (failedBoundaries !== null) {\n              if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n                needsRemount = true;\n              }\n            }\n            if (needsRemount) {\n              fiber._debugNeedsRemount = true;\n            }\n            if (needsRemount || needsRender) {\n              var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (_root !== null) {\n                scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);\n              }\n            }\n            if (child !== null && !needsRemount) {\n              scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n            }\n            if (sibling !== null) {\n              scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n            }\n          }\n        }\n        var findHostInstancesForRefresh = function(root2, families) {\n          {\n            var hostInstances = /* @__PURE__ */ new Set();\n            var types = new Set(families.map(function(family) {\n              return family.current;\n            }));\n            findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);\n            return hostInstances;\n          }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n          {\n            var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n            var candidateType = null;\n            switch (tag) {\n              case FunctionComponent:\n              case SimpleMemoComponent:\n              case ClassComponent:\n                candidateType = type;\n                break;\n              case ForwardRef:\n                candidateType = type.render;\n                break;\n            }\n            var didMatch = false;\n            if (candidateType !== null) {\n              if (types.has(candidateType)) {\n                didMatch = true;\n              }\n            }\n            if (didMatch) {\n              findHostInstancesForFiberShallowly(fiber, hostInstances);\n            } else {\n              if (child !== null) {\n                findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n              }\n            }\n            if (sibling !== null) {\n              findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n            }\n          }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n          {\n            var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n            if (foundHostInstances) {\n              return;\n            }\n            var node = fiber;\n            while (true) {\n              switch (node.tag) {\n                case HostComponent:\n                  hostInstances.add(node.stateNode);\n                  return;\n                case HostPortal:\n                  hostInstances.add(node.stateNode.containerInfo);\n                  return;\n                case HostRoot:\n                  hostInstances.add(node.stateNode.containerInfo);\n                  return;\n              }\n              if (node.return === null) {\n                throw new Error(\"Expected to reach root first.\");\n              }\n              node = node.return;\n            }\n          }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n          {\n            var node = fiber;\n            var foundHostInstances = false;\n            while (true) {\n              if (node.tag === HostComponent) {\n                foundHostInstances = true;\n                hostInstances.add(node.stateNode);\n              } else if (node.child !== null) {\n                node.child.return = node;\n                node = node.child;\n                continue;\n              }\n              if (node === fiber) {\n                return foundHostInstances;\n              }\n              while (node.sibling === null) {\n                if (node.return === null || node.return === fiber) {\n                  return foundHostInstances;\n                }\n                node = node.return;\n              }\n              node.sibling.return = node.return;\n              node = node.sibling;\n            }\n          }\n          return false;\n        }\n        var hasBadMapPolyfill;\n        {\n          hasBadMapPolyfill = false;\n          try {\n            var nonExtensibleObject = Object.preventExtensions({});\n            /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);\n            /* @__PURE__ */ new Set([nonExtensibleObject]);\n          } catch (e) {\n            hasBadMapPolyfill = true;\n          }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n          this.tag = tag;\n          this.key = key;\n          this.elementType = null;\n          this.type = null;\n          this.stateNode = null;\n          this.return = null;\n          this.child = null;\n          this.sibling = null;\n          this.index = 0;\n          this.ref = null;\n          this.pendingProps = pendingProps;\n          this.memoizedProps = null;\n          this.updateQueue = null;\n          this.memoizedState = null;\n          this.dependencies = null;\n          this.mode = mode;\n          this.flags = NoFlags;\n          this.subtreeFlags = NoFlags;\n          this.deletions = null;\n          this.lanes = NoLanes;\n          this.childLanes = NoLanes;\n          this.alternate = null;\n          {\n            this.actualDuration = Number.NaN;\n            this.actualStartTime = Number.NaN;\n            this.selfBaseDuration = Number.NaN;\n            this.treeBaseDuration = Number.NaN;\n            this.actualDuration = 0;\n            this.actualStartTime = -1;\n            this.selfBaseDuration = 0;\n            this.treeBaseDuration = 0;\n          }\n          {\n            this._debugSource = null;\n            this._debugOwner = null;\n            this._debugNeedsRemount = false;\n            this._debugHookTypes = null;\n            if (!hasBadMapPolyfill && typeof Object.preventExtensions === \"function\") {\n              Object.preventExtensions(this);\n            }\n          }\n        }\n        var createFiber = function(tag, pendingProps, key, mode) {\n          return new FiberNode(tag, pendingProps, key, mode);\n        };\n        function shouldConstruct$1(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n          return typeof type === \"function\" && !shouldConstruct$1(type) && type.defaultProps === void 0;\n        }\n        function resolveLazyComponentTag(Component) {\n          if (typeof Component === \"function\") {\n            return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n          } else if (Component !== void 0 && Component !== null) {\n            var $$typeof = Component.$$typeof;\n            if ($$typeof === REACT_FORWARD_REF_TYPE) {\n              return ForwardRef;\n            }\n            if ($$typeof === REACT_MEMO_TYPE) {\n              return MemoComponent;\n            }\n          }\n          return IndeterminateComponent;\n        }\n        function createWorkInProgress(current2, pendingProps) {\n          var workInProgress2 = current2.alternate;\n          if (workInProgress2 === null) {\n            workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);\n            workInProgress2.elementType = current2.elementType;\n            workInProgress2.type = current2.type;\n            workInProgress2.stateNode = current2.stateNode;\n            {\n              workInProgress2._debugSource = current2._debugSource;\n              workInProgress2._debugOwner = current2._debugOwner;\n              workInProgress2._debugHookTypes = current2._debugHookTypes;\n            }\n            workInProgress2.alternate = current2;\n            current2.alternate = workInProgress2;\n          } else {\n            workInProgress2.pendingProps = pendingProps;\n            workInProgress2.type = current2.type;\n            workInProgress2.flags = NoFlags;\n            workInProgress2.subtreeFlags = NoFlags;\n            workInProgress2.deletions = null;\n            {\n              workInProgress2.actualDuration = 0;\n              workInProgress2.actualStartTime = -1;\n            }\n          }\n          workInProgress2.flags = current2.flags & StaticMask;\n          workInProgress2.childLanes = current2.childLanes;\n          workInProgress2.lanes = current2.lanes;\n          workInProgress2.child = current2.child;\n          workInProgress2.memoizedProps = current2.memoizedProps;\n          workInProgress2.memoizedState = current2.memoizedState;\n          workInProgress2.updateQueue = current2.updateQueue;\n          var currentDependencies = current2.dependencies;\n          workInProgress2.dependencies = currentDependencies === null ? null : {\n            lanes: currentDependencies.lanes,\n            firstContext: currentDependencies.firstContext\n          };\n          workInProgress2.sibling = current2.sibling;\n          workInProgress2.index = current2.index;\n          workInProgress2.ref = current2.ref;\n          {\n            workInProgress2.selfBaseDuration = current2.selfBaseDuration;\n            workInProgress2.treeBaseDuration = current2.treeBaseDuration;\n          }\n          {\n            workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;\n            switch (workInProgress2.tag) {\n              case IndeterminateComponent:\n              case FunctionComponent:\n              case SimpleMemoComponent:\n                workInProgress2.type = resolveFunctionForHotReloading(current2.type);\n                break;\n              case ClassComponent:\n                workInProgress2.type = resolveClassForHotReloading(current2.type);\n                break;\n              case ForwardRef:\n                workInProgress2.type = resolveForwardRefForHotReloading(current2.type);\n                break;\n            }\n          }\n          return workInProgress2;\n        }\n        function resetWorkInProgress(workInProgress2, renderLanes2) {\n          workInProgress2.flags &= StaticMask | Placement;\n          var current2 = workInProgress2.alternate;\n          if (current2 === null) {\n            workInProgress2.childLanes = NoLanes;\n            workInProgress2.lanes = renderLanes2;\n            workInProgress2.child = null;\n            workInProgress2.subtreeFlags = NoFlags;\n            workInProgress2.memoizedProps = null;\n            workInProgress2.memoizedState = null;\n            workInProgress2.updateQueue = null;\n            workInProgress2.dependencies = null;\n            workInProgress2.stateNode = null;\n            {\n              workInProgress2.selfBaseDuration = 0;\n              workInProgress2.treeBaseDuration = 0;\n            }\n          } else {\n            workInProgress2.childLanes = current2.childLanes;\n            workInProgress2.lanes = current2.lanes;\n            workInProgress2.child = current2.child;\n            workInProgress2.subtreeFlags = NoFlags;\n            workInProgress2.deletions = null;\n            workInProgress2.memoizedProps = current2.memoizedProps;\n            workInProgress2.memoizedState = current2.memoizedState;\n            workInProgress2.updateQueue = current2.updateQueue;\n            workInProgress2.type = current2.type;\n            var currentDependencies = current2.dependencies;\n            workInProgress2.dependencies = currentDependencies === null ? null : {\n              lanes: currentDependencies.lanes,\n              firstContext: currentDependencies.firstContext\n            };\n            {\n              workInProgress2.selfBaseDuration = current2.selfBaseDuration;\n              workInProgress2.treeBaseDuration = current2.treeBaseDuration;\n            }\n          }\n          return workInProgress2;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n          var mode;\n          if (tag === ConcurrentRoot) {\n            mode = ConcurrentMode;\n            if (isStrictMode === true) {\n              mode |= StrictLegacyMode;\n              {\n                mode |= StrictEffectsMode;\n              }\n            }\n          } else {\n            mode = NoMode;\n          }\n          if (isDevToolsPresent) {\n            mode |= ProfileMode;\n          }\n          return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n          var fiberTag = IndeterminateComponent;\n          var resolvedType = type;\n          if (typeof type === \"function\") {\n            if (shouldConstruct$1(type)) {\n              fiberTag = ClassComponent;\n              {\n                resolvedType = resolveClassForHotReloading(resolvedType);\n              }\n            } else {\n              {\n                resolvedType = resolveFunctionForHotReloading(resolvedType);\n              }\n            }\n          } else if (typeof type === \"string\") {\n            fiberTag = HostComponent;\n          } else {\n            getTag: switch (type) {\n              case REACT_FRAGMENT_TYPE:\n                return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n              case REACT_STRICT_MODE_TYPE:\n                fiberTag = Mode;\n                mode |= StrictLegacyMode;\n                if ((mode & ConcurrentMode) !== NoMode) {\n                  mode |= StrictEffectsMode;\n                }\n                break;\n              case REACT_PROFILER_TYPE:\n                return createFiberFromProfiler(pendingProps, mode, lanes, key);\n              case REACT_SUSPENSE_TYPE:\n                return createFiberFromSuspense(pendingProps, mode, lanes, key);\n              case REACT_SUSPENSE_LIST_TYPE:\n                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n              case REACT_OFFSCREEN_TYPE:\n                return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n              case REACT_LEGACY_HIDDEN_TYPE:\n              case REACT_SCOPE_TYPE:\n              case REACT_CACHE_TYPE:\n              case REACT_TRACING_MARKER_TYPE:\n              case REACT_DEBUG_TRACING_MODE_TYPE:\n              default: {\n                if (typeof type === \"object\" && type !== null) {\n                  switch (type.$$typeof) {\n                    case REACT_PROVIDER_TYPE:\n                      fiberTag = ContextProvider;\n                      break getTag;\n                    case REACT_CONTEXT_TYPE:\n                      fiberTag = ContextConsumer;\n                      break getTag;\n                    case REACT_FORWARD_REF_TYPE:\n                      fiberTag = ForwardRef;\n                      {\n                        resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                      }\n                      break getTag;\n                    case REACT_MEMO_TYPE:\n                      fiberTag = MemoComponent;\n                      break getTag;\n                    case REACT_LAZY_TYPE:\n                      fiberTag = LazyComponent;\n                      resolvedType = null;\n                      break getTag;\n                  }\n                }\n                var info = \"\";\n                {\n                  if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                    info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n                  }\n                  var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n                  if (ownerName) {\n                    info += \"\\n\\nCheck the render method of `\" + ownerName + \"`.\";\n                  }\n                }\n                throw new Error(\"Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) \" + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n              }\n            }\n          }\n          var fiber = createFiber(fiberTag, pendingProps, key, mode);\n          fiber.elementType = type;\n          fiber.type = resolvedType;\n          fiber.lanes = lanes;\n          {\n            fiber._debugOwner = owner;\n          }\n          return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n          var owner = null;\n          {\n            owner = element._owner;\n          }\n          var type = element.type;\n          var key = element.key;\n          var pendingProps = element.props;\n          var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n          {\n            fiber._debugSource = element._source;\n            fiber._debugOwner = element._owner;\n          }\n          return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n          var fiber = createFiber(Fragment, elements, key, mode);\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n          {\n            if (typeof pendingProps.id !== \"string\") {\n              error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n            }\n          }\n          var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n          fiber.elementType = REACT_PROFILER_TYPE;\n          fiber.lanes = lanes;\n          {\n            fiber.stateNode = {\n              effectDuration: 0,\n              passiveEffectDuration: 0\n            };\n          }\n          return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n          var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n          fiber.elementType = REACT_SUSPENSE_TYPE;\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n          var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n          fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n          var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n          fiber.elementType = REACT_OFFSCREEN_TYPE;\n          fiber.lanes = lanes;\n          var primaryChildInstance = {\n            isHidden: false\n          };\n          fiber.stateNode = primaryChildInstance;\n          return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n          var fiber = createFiber(HostText, content, null, mode);\n          fiber.lanes = lanes;\n          return fiber;\n        }\n        function createFiberFromHostInstanceForDeletion() {\n          var fiber = createFiber(HostComponent, null, null, NoMode);\n          fiber.elementType = \"DELETED\";\n          return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n          var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n          fiber.stateNode = dehydratedNode;\n          return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n          var pendingProps = portal.children !== null ? portal.children : [];\n          var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n          fiber.lanes = lanes;\n          fiber.stateNode = {\n            containerInfo: portal.containerInfo,\n            pendingChildren: null,\n            // Used by persistent updates\n            implementation: portal.implementation\n          };\n          return fiber;\n        }\n        function assignFiberPropertiesInDEV(target, source) {\n          if (target === null) {\n            target = createFiber(IndeterminateComponent, null, null, NoMode);\n          }\n          target.tag = source.tag;\n          target.key = source.key;\n          target.elementType = source.elementType;\n          target.type = source.type;\n          target.stateNode = source.stateNode;\n          target.return = source.return;\n          target.child = source.child;\n          target.sibling = source.sibling;\n          target.index = source.index;\n          target.ref = source.ref;\n          target.pendingProps = source.pendingProps;\n          target.memoizedProps = source.memoizedProps;\n          target.updateQueue = source.updateQueue;\n          target.memoizedState = source.memoizedState;\n          target.dependencies = source.dependencies;\n          target.mode = source.mode;\n          target.flags = source.flags;\n          target.subtreeFlags = source.subtreeFlags;\n          target.deletions = source.deletions;\n          target.lanes = source.lanes;\n          target.childLanes = source.childLanes;\n          target.alternate = source.alternate;\n          {\n            target.actualDuration = source.actualDuration;\n            target.actualStartTime = source.actualStartTime;\n            target.selfBaseDuration = source.selfBaseDuration;\n            target.treeBaseDuration = source.treeBaseDuration;\n          }\n          target._debugSource = source._debugSource;\n          target._debugOwner = source._debugOwner;\n          target._debugNeedsRemount = source._debugNeedsRemount;\n          target._debugHookTypes = source._debugHookTypes;\n          return target;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {\n          this.tag = tag;\n          this.containerInfo = containerInfo;\n          this.pendingChildren = null;\n          this.current = null;\n          this.pingCache = null;\n          this.finishedWork = null;\n          this.timeoutHandle = noTimeout;\n          this.context = null;\n          this.pendingContext = null;\n          this.callbackNode = null;\n          this.callbackPriority = NoLane;\n          this.eventTimes = createLaneMap(NoLanes);\n          this.expirationTimes = createLaneMap(NoTimestamp);\n          this.pendingLanes = NoLanes;\n          this.suspendedLanes = NoLanes;\n          this.pingedLanes = NoLanes;\n          this.expiredLanes = NoLanes;\n          this.mutableReadLanes = NoLanes;\n          this.finishedLanes = NoLanes;\n          this.entangledLanes = NoLanes;\n          this.entanglements = createLaneMap(NoLanes);\n          this.identifierPrefix = identifierPrefix;\n          this.onRecoverableError = onRecoverableError;\n          {\n            this.mutableSourceEagerHydrationData = null;\n          }\n          {\n            this.effectDuration = 0;\n            this.passiveEffectDuration = 0;\n          }\n          {\n            this.memoizedUpdaters = /* @__PURE__ */ new Set();\n            var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n            for (var _i = 0; _i < TotalLanes; _i++) {\n              pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());\n            }\n          }\n          {\n            switch (tag) {\n              case ConcurrentRoot:\n                this._debugRootType = hydrate2 ? \"hydrateRoot()\" : \"createRoot()\";\n                break;\n              case LegacyRoot:\n                this._debugRootType = hydrate2 ? \"hydrate()\" : \"render()\";\n                break;\n            }\n          }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n          var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);\n          var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n          root2.current = uninitializedFiber;\n          uninitializedFiber.stateNode = root2;\n          {\n            var _initialState = {\n              element: initialChildren,\n              isDehydrated: hydrate2,\n              cache: null,\n              // not enabled yet\n              transitions: null,\n              pendingSuspenseBoundaries: null\n            };\n            uninitializedFiber.memoizedState = _initialState;\n          }\n          initializeUpdateQueue(uninitializedFiber);\n          return root2;\n        }\n        var ReactVersion = \"18.3.1\";\n        function createPortal(children, containerInfo, implementation) {\n          var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n          {\n            checkKeyStringCoercion(key);\n          }\n          return {\n            // This tag allow us to uniquely identify this as a React Portal\n            $$typeof: REACT_PORTAL_TYPE,\n            key: key == null ? null : \"\" + key,\n            children,\n            containerInfo,\n            implementation\n          };\n        }\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n          didWarnAboutNestedUpdates = false;\n          didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n          if (!parentComponent) {\n            return emptyContextObject;\n          }\n          var fiber = get(parentComponent);\n          var parentContext = findCurrentUnmaskedContext(fiber);\n          if (fiber.tag === ClassComponent) {\n            var Component = fiber.type;\n            if (isContextProvider(Component)) {\n              return processChildContext(fiber, Component, parentContext);\n            }\n          }\n          return parentContext;\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n          {\n            var fiber = get(component);\n            if (fiber === void 0) {\n              if (typeof component.render === \"function\") {\n                throw new Error(\"Unable to find node on an unmounted component.\");\n              } else {\n                var keys = Object.keys(component).join(\",\");\n                throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n              }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n              return null;\n            }\n            if (hostFiber.mode & StrictLegacyMode) {\n              var componentName = getComponentNameFromFiber(fiber) || \"Component\";\n              if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                didWarnAboutFindNodeInStrictMode[componentName] = true;\n                var previousFiber = current;\n                try {\n                  setCurrentFiber(hostFiber);\n                  if (fiber.mode & StrictLegacyMode) {\n                    error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                  } else {\n                    error(\"%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node\", methodName, methodName, componentName);\n                  }\n                } finally {\n                  if (previousFiber) {\n                    setCurrentFiber(previousFiber);\n                  } else {\n                    resetCurrentFiber();\n                  }\n                }\n              }\n            }\n            return hostFiber.stateNode;\n          }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n          var hydrate2 = false;\n          var initialChildren = null;\n          return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n          var hydrate2 = true;\n          var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n          root2.context = getContextForSubtree(null);\n          var current2 = root2.current;\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(current2);\n          var update = createUpdate(eventTime, lane);\n          update.callback = callback !== void 0 && callback !== null ? callback : null;\n          enqueueUpdate(current2, update, lane);\n          scheduleInitialHydrationOnRoot(root2, lane, eventTime);\n          return root2;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n          {\n            onScheduleRoot(container, element);\n          }\n          var current$1 = container.current;\n          var eventTime = requestEventTime();\n          var lane = requestUpdateLane(current$1);\n          {\n            markRenderScheduled(lane);\n          }\n          var context = getContextForSubtree(parentComponent);\n          if (container.context === null) {\n            container.context = context;\n          } else {\n            container.pendingContext = context;\n          }\n          {\n            if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n              didWarnAboutNestedUpdates = true;\n              error(\"Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\\n\\nCheck the render method of %s.\", getComponentNameFromFiber(current) || \"Unknown\");\n            }\n          }\n          var update = createUpdate(eventTime, lane);\n          update.payload = {\n            element\n          };\n          callback = callback === void 0 ? null : callback;\n          if (callback !== null) {\n            {\n              if (typeof callback !== \"function\") {\n                error(\"render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\", callback);\n              }\n            }\n            update.callback = callback;\n          }\n          var root2 = enqueueUpdate(current$1, update, lane);\n          if (root2 !== null) {\n            scheduleUpdateOnFiber(root2, current$1, lane, eventTime);\n            entangleTransitions(root2, current$1, lane);\n          }\n          return lane;\n        }\n        function getPublicRootInstance(container) {\n          var containerFiber = container.current;\n          if (!containerFiber.child) {\n            return null;\n          }\n          switch (containerFiber.child.tag) {\n            case HostComponent:\n              return getPublicInstance(containerFiber.child.stateNode);\n            default:\n              return containerFiber.child.stateNode;\n          }\n        }\n        function attemptSynchronousHydration$1(fiber) {\n          switch (fiber.tag) {\n            case HostRoot: {\n              var root2 = fiber.stateNode;\n              if (isRootDehydrated(root2)) {\n                var lanes = getHighestPriorityPendingLanes(root2);\n                flushRoot(root2, lanes);\n              }\n              break;\n            }\n            case SuspenseComponent: {\n              flushSync(function() {\n                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root3 !== null) {\n                  var eventTime = requestEventTime();\n                  scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);\n                }\n              });\n              var retryLane = SyncLane;\n              markRetryLaneIfNotHydrated(fiber, retryLane);\n              break;\n            }\n          }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n          var suspenseState = fiber.memoizedState;\n          if (suspenseState !== null && suspenseState.dehydrated !== null) {\n            suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n          }\n        }\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n          markRetryLaneImpl(fiber, retryLane);\n          var alternate = fiber.alternate;\n          if (alternate) {\n            markRetryLaneImpl(alternate, retryLane);\n          }\n        }\n        function attemptContinuousHydration$1(fiber) {\n          if (fiber.tag !== SuspenseComponent) {\n            return;\n          }\n          var lane = SelectiveHydrationLane;\n          var root2 = enqueueConcurrentRenderForLane(fiber, lane);\n          if (root2 !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n          }\n          markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority$1(fiber) {\n          if (fiber.tag !== SuspenseComponent) {\n            return;\n          }\n          var lane = requestUpdateLane(fiber);\n          var root2 = enqueueConcurrentRenderForLane(fiber, lane);\n          if (root2 !== null) {\n            var eventTime = requestEventTime();\n            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);\n          }\n          markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n          var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        }\n        var shouldErrorImpl = function(fiber) {\n          return null;\n        };\n        function shouldError(fiber) {\n          return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n          return false;\n        };\n        function shouldSuspend(fiber) {\n          return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n          var copyWithDeleteImpl = function(obj, path, index2) {\n            var key = path[index2];\n            var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n            if (index2 + 1 === path.length) {\n              if (isArray(updated)) {\n                updated.splice(key, 1);\n              } else {\n                delete updated[key];\n              }\n              return updated;\n            }\n            updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);\n            return updated;\n          };\n          var copyWithDelete = function(obj, path) {\n            return copyWithDeleteImpl(obj, path, 0);\n          };\n          var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {\n            var oldKey = oldPath[index2];\n            var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n            if (index2 + 1 === oldPath.length) {\n              var newKey = newPath[index2];\n              updated[newKey] = updated[oldKey];\n              if (isArray(updated)) {\n                updated.splice(oldKey, 1);\n              } else {\n                delete updated[oldKey];\n              }\n            } else {\n              updated[oldKey] = copyWithRenameImpl(\n                // $FlowFixMe number or string is fine here\n                obj[oldKey],\n                oldPath,\n                newPath,\n                index2 + 1\n              );\n            }\n            return updated;\n          };\n          var copyWithRename = function(obj, oldPath, newPath) {\n            if (oldPath.length !== newPath.length) {\n              warn(\"copyWithRename() expects paths of the same length\");\n              return;\n            } else {\n              for (var i = 0; i < newPath.length - 1; i++) {\n                if (oldPath[i] !== newPath[i]) {\n                  warn(\"copyWithRename() expects paths to be the same except for the deepest key\");\n                  return;\n                }\n              }\n            }\n            return copyWithRenameImpl(obj, oldPath, newPath, 0);\n          };\n          var copyWithSetImpl = function(obj, path, index2, value) {\n            if (index2 >= path.length) {\n              return value;\n            }\n            var key = path[index2];\n            var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n            updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);\n            return updated;\n          };\n          var copyWithSet = function(obj, path, value) {\n            return copyWithSetImpl(obj, path, 0, value);\n          };\n          var findHook = function(fiber, id) {\n            var currentHook2 = fiber.memoizedState;\n            while (currentHook2 !== null && id > 0) {\n              currentHook2 = currentHook2.next;\n              id--;\n            }\n            return currentHook2;\n          };\n          overrideHookState = function(fiber, id, path, value) {\n            var hook = findHook(fiber, id);\n            if (hook !== null) {\n              var newState = copyWithSet(hook.memoizedState, path, value);\n              hook.memoizedState = newState;\n              hook.baseState = newState;\n              fiber.memoizedProps = assign({}, fiber.memoizedProps);\n              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root2 !== null) {\n                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n              }\n            }\n          };\n          overrideHookStateDeletePath = function(fiber, id, path) {\n            var hook = findHook(fiber, id);\n            if (hook !== null) {\n              var newState = copyWithDelete(hook.memoizedState, path);\n              hook.memoizedState = newState;\n              hook.baseState = newState;\n              fiber.memoizedProps = assign({}, fiber.memoizedProps);\n              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root2 !== null) {\n                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n              }\n            }\n          };\n          overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n            var hook = findHook(fiber, id);\n            if (hook !== null) {\n              var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n              hook.memoizedState = newState;\n              hook.baseState = newState;\n              fiber.memoizedProps = assign({}, fiber.memoizedProps);\n              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n              if (root2 !== null) {\n                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n              }\n            }\n          };\n          overrideProps = function(fiber, path, value) {\n            fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n            if (fiber.alternate) {\n              fiber.alternate.pendingProps = fiber.pendingProps;\n            }\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          overridePropsDeletePath = function(fiber, path) {\n            fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n            if (fiber.alternate) {\n              fiber.alternate.pendingProps = fiber.pendingProps;\n            }\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          overridePropsRenamePath = function(fiber, oldPath, newPath) {\n            fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n            if (fiber.alternate) {\n              fiber.alternate.pendingProps = fiber.pendingProps;\n            }\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          scheduleUpdate = function(fiber) {\n            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root2 !== null) {\n              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);\n            }\n          };\n          setErrorHandler = function(newShouldErrorImpl) {\n            shouldErrorImpl = newShouldErrorImpl;\n          };\n          setSuspenseHandler = function(newShouldSuspendImpl) {\n            shouldSuspendImpl = newShouldSuspendImpl;\n          };\n        }\n        function findHostInstanceByFiber(fiber) {\n          var hostFiber = findCurrentHostFiber(fiber);\n          if (hostFiber === null) {\n            return null;\n          }\n          return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n          return null;\n        }\n        function getCurrentFiberForDevTools() {\n          return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n          var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n          var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;\n          return injectInternals({\n            bundleType: devToolsConfig.bundleType,\n            version: devToolsConfig.version,\n            rendererPackageName: devToolsConfig.rendererPackageName,\n            rendererConfig: devToolsConfig.rendererConfig,\n            overrideHookState,\n            overrideHookStateDeletePath,\n            overrideHookStateRenamePath,\n            overrideProps,\n            overridePropsDeletePath,\n            overridePropsRenamePath,\n            setErrorHandler,\n            setSuspenseHandler,\n            scheduleUpdate,\n            currentDispatcherRef: ReactCurrentDispatcher2,\n            findHostInstanceByFiber,\n            findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n            // React Refresh\n            findHostInstancesForRefresh,\n            scheduleRefresh,\n            scheduleRoot,\n            setRefreshHandler,\n            // Enables DevTools to append owner stacks to error messages in DEV mode.\n            getCurrentFiber: getCurrentFiberForDevTools,\n            // Enables DevTools to detect reconciler version rather than renderer version\n            // which may not match for third party renderers.\n            reconcilerVersion: ReactVersion\n          });\n        }\n        var defaultOnRecoverableError = typeof reportError === \"function\" ? (\n          // In modern browsers, reportError will dispatch an error event,\n          // emulating an uncaught JavaScript error.\n          reportError\n        ) : function(error2) {\n          console[\"error\"](error2);\n        };\n        function ReactDOMRoot(internalRoot) {\n          this._internalRoot = internalRoot;\n        }\n        ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {\n          var root2 = this._internalRoot;\n          if (root2 === null) {\n            throw new Error(\"Cannot update an unmounted root.\");\n          }\n          {\n            if (typeof arguments[1] === \"function\") {\n              error(\"render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().\");\n            } else if (isValidContainer(arguments[1])) {\n              error(\"You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.\");\n            } else if (typeof arguments[1] !== \"undefined\") {\n              error(\"You passed a second argument to root.render(...) but it only accepts one argument.\");\n            }\n            var container = root2.containerInfo;\n            if (container.nodeType !== COMMENT_NODE) {\n              var hostInstance = findHostInstanceWithNoPortals(root2.current);\n              if (hostInstance) {\n                if (hostInstance.parentNode !== container) {\n                  error(\"render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.\");\n                }\n              }\n            }\n          }\n          updateContainer(children, root2, null, null);\n        };\n        ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {\n          {\n            if (typeof arguments[0] === \"function\") {\n              error(\"unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().\");\n            }\n          }\n          var root2 = this._internalRoot;\n          if (root2 !== null) {\n            this._internalRoot = null;\n            var container = root2.containerInfo;\n            {\n              if (isAlreadyRendering()) {\n                error(\"Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.\");\n              }\n            }\n            flushSync(function() {\n              updateContainer(null, root2, null, null);\n            });\n            unmarkContainerAsRoot(container);\n          }\n        };\n        function createRoot(container, options2) {\n          if (!isValidContainer(container)) {\n            throw new Error(\"createRoot(...): Target container is not a DOM element.\");\n          }\n          warnIfReactDOMContainerInDEV(container);\n          var isStrictMode = false;\n          var concurrentUpdatesByDefaultOverride = false;\n          var identifierPrefix = \"\";\n          var onRecoverableError = defaultOnRecoverableError;\n          var transitionCallbacks = null;\n          if (options2 !== null && options2 !== void 0) {\n            {\n              if (options2.hydrate) {\n                warn(\"hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.\");\n              } else {\n                if (typeof options2 === \"object\" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {\n                  error(\"You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\\n\\n  let root = createRoot(domContainer);\\n  root.render(<App />);\");\n                }\n              }\n            }\n            if (options2.unstable_strictMode === true) {\n              isStrictMode = true;\n            }\n            if (options2.identifierPrefix !== void 0) {\n              identifierPrefix = options2.identifierPrefix;\n            }\n            if (options2.onRecoverableError !== void 0) {\n              onRecoverableError = options2.onRecoverableError;\n            }\n            if (options2.transitionCallbacks !== void 0) {\n              transitionCallbacks = options2.transitionCallbacks;\n            }\n          }\n          var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n          markContainerAsRoot(root2.current, container);\n          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n          listenToAllSupportedEvents(rootContainerElement);\n          return new ReactDOMRoot(root2);\n        }\n        function ReactDOMHydrationRoot(internalRoot) {\n          this._internalRoot = internalRoot;\n        }\n        function scheduleHydration(target) {\n          if (target) {\n            queueExplicitHydrationTarget(target);\n          }\n        }\n        ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;\n        function hydrateRoot(container, initialChildren, options2) {\n          if (!isValidContainer(container)) {\n            throw new Error(\"hydrateRoot(...): Target container is not a DOM element.\");\n          }\n          warnIfReactDOMContainerInDEV(container);\n          {\n            if (initialChildren === void 0) {\n              error(\"Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)\");\n            }\n          }\n          var hydrationCallbacks = options2 != null ? options2 : null;\n          var mutableSources = options2 != null && options2.hydratedSources || null;\n          var isStrictMode = false;\n          var concurrentUpdatesByDefaultOverride = false;\n          var identifierPrefix = \"\";\n          var onRecoverableError = defaultOnRecoverableError;\n          if (options2 !== null && options2 !== void 0) {\n            if (options2.unstable_strictMode === true) {\n              isStrictMode = true;\n            }\n            if (options2.identifierPrefix !== void 0) {\n              identifierPrefix = options2.identifierPrefix;\n            }\n            if (options2.onRecoverableError !== void 0) {\n              onRecoverableError = options2.onRecoverableError;\n            }\n          }\n          var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n          markContainerAsRoot(root2.current, container);\n          listenToAllSupportedEvents(container);\n          if (mutableSources) {\n            for (var i = 0; i < mutableSources.length; i++) {\n              var mutableSource = mutableSources[i];\n              registerMutableSourceForHydration(root2, mutableSource);\n            }\n          }\n          return new ReactDOMHydrationRoot(root2);\n        }\n        function isValidContainer(node) {\n          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));\n        }\n        function isValidContainerLegacy(node) {\n          return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === \" react-mount-point-unstable \"));\n        }\n        function warnIfReactDOMContainerInDEV(container) {\n          {\n            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === \"BODY\") {\n              error(\"createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.\");\n            }\n            if (isContainerMarkedAsRoot(container)) {\n              if (container._reactRootContainer) {\n                error(\"You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.\");\n              } else {\n                error(\"You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.\");\n              }\n            }\n          }\n        }\n        var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;\n        var topLevelUpdateWarnings;\n        {\n          topLevelUpdateWarnings = function(container) {\n            if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {\n              var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);\n              if (hostInstance) {\n                if (hostInstance.parentNode !== container) {\n                  error(\"render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.\");\n                }\n              }\n            }\n            var isRootRenderedBySomeReact = !!container._reactRootContainer;\n            var rootEl = getReactRootElementInContainer(container);\n            var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));\n            if (hasNonRootReactChild && !isRootRenderedBySomeReact) {\n              error(\"render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.\");\n            }\n            if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === \"BODY\") {\n              error(\"render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.\");\n            }\n          };\n        }\n        function getReactRootElementInContainer(container) {\n          if (!container) {\n            return null;\n          }\n          if (container.nodeType === DOCUMENT_NODE) {\n            return container.documentElement;\n          } else {\n            return container.firstChild;\n          }\n        }\n        function noopOnRecoverableError() {\n        }\n        function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {\n          if (isHydrationContainer) {\n            if (typeof callback === \"function\") {\n              var originalCallback = callback;\n              callback = function() {\n                var instance = getPublicRootInstance(root2);\n                originalCallback.call(instance);\n              };\n            }\n            var root2 = createHydrationContainer(\n              initialChildren,\n              callback,\n              container,\n              LegacyRoot,\n              null,\n              // hydrationCallbacks\n              false,\n              // isStrictMode\n              false,\n              // concurrentUpdatesByDefaultOverride,\n              \"\",\n              // identifierPrefix\n              noopOnRecoverableError\n            );\n            container._reactRootContainer = root2;\n            markContainerAsRoot(root2.current, container);\n            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n            listenToAllSupportedEvents(rootContainerElement);\n            flushSync();\n            return root2;\n          } else {\n            var rootSibling;\n            while (rootSibling = container.lastChild) {\n              container.removeChild(rootSibling);\n            }\n            if (typeof callback === \"function\") {\n              var _originalCallback = callback;\n              callback = function() {\n                var instance = getPublicRootInstance(_root);\n                _originalCallback.call(instance);\n              };\n            }\n            var _root = createContainer(\n              container,\n              LegacyRoot,\n              null,\n              // hydrationCallbacks\n              false,\n              // isStrictMode\n              false,\n              // concurrentUpdatesByDefaultOverride,\n              \"\",\n              // identifierPrefix\n              noopOnRecoverableError\n            );\n            container._reactRootContainer = _root;\n            markContainerAsRoot(_root.current, container);\n            var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;\n            listenToAllSupportedEvents(_rootContainerElement);\n            flushSync(function() {\n              updateContainer(initialChildren, _root, parentComponent, callback);\n            });\n            return _root;\n          }\n        }\n        function warnOnInvalidCallback$1(callback, callerName) {\n          {\n            if (callback !== null && typeof callback !== \"function\") {\n              error(\"%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.\", callerName, callback);\n            }\n          }\n        }\n        function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {\n          {\n            topLevelUpdateWarnings(container);\n            warnOnInvalidCallback$1(callback === void 0 ? null : callback, \"render\");\n          }\n          var maybeRoot = container._reactRootContainer;\n          var root2;\n          if (!maybeRoot) {\n            root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);\n          } else {\n            root2 = maybeRoot;\n            if (typeof callback === \"function\") {\n              var originalCallback = callback;\n              callback = function() {\n                var instance = getPublicRootInstance(root2);\n                originalCallback.call(instance);\n              };\n            }\n            updateContainer(children, root2, parentComponent, callback);\n          }\n          return getPublicRootInstance(root2);\n        }\n        var didWarnAboutFindDOMNode = false;\n        function findDOMNode(componentOrElement) {\n          {\n            if (!didWarnAboutFindDOMNode) {\n              didWarnAboutFindDOMNode = true;\n              error(\"findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node\");\n            }\n            var owner = ReactCurrentOwner$3.current;\n            if (owner !== null && owner.stateNode !== null) {\n              var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;\n              if (!warnedAboutRefsInRender) {\n                error(\"%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.\", getComponentNameFromType(owner.type) || \"A component\");\n              }\n              owner.stateNode._warnedAboutRefsInRender = true;\n            }\n          }\n          if (componentOrElement == null) {\n            return null;\n          }\n          if (componentOrElement.nodeType === ELEMENT_NODE) {\n            return componentOrElement;\n          }\n          {\n            return findHostInstanceWithWarning(componentOrElement, \"findDOMNode\");\n          }\n        }\n        function hydrate(element, container, callback) {\n          {\n            error(\"ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n          }\n          if (!isValidContainerLegacy(container)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          {\n            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;\n            if (isModernRoot) {\n              error(\"You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?\");\n            }\n          }\n          return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);\n        }\n        function render(element, container, callback) {\n          {\n            error(\"ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n          }\n          if (!isValidContainerLegacy(container)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          {\n            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;\n            if (isModernRoot) {\n              error(\"You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?\");\n            }\n          }\n          return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);\n        }\n        function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n          {\n            error(\"ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot\");\n          }\n          if (!isValidContainerLegacy(containerNode)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          if (parentComponent == null || !has(parentComponent)) {\n            throw new Error(\"parentComponent must be a valid React Component\");\n          }\n          return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);\n        }\n        var didWarnAboutUnmountComponentAtNode = false;\n        function unmountComponentAtNode(container) {\n          {\n            if (!didWarnAboutUnmountComponentAtNode) {\n              didWarnAboutUnmountComponentAtNode = true;\n              error(\"unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot\");\n            }\n          }\n          if (!isValidContainerLegacy(container)) {\n            throw new Error(\"unmountComponentAtNode(...): Target container is not a DOM element.\");\n          }\n          {\n            var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;\n            if (isModernRoot) {\n              error(\"You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?\");\n            }\n          }\n          if (container._reactRootContainer) {\n            {\n              var rootEl = getReactRootElementInContainer(container);\n              var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);\n              if (renderedByDifferentReact) {\n                error(\"unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.\");\n              }\n            }\n            flushSync(function() {\n              legacyRenderSubtreeIntoContainer(null, null, container, false, function() {\n                container._reactRootContainer = null;\n                unmarkContainerAsRoot(container);\n              });\n            });\n            return true;\n          } else {\n            {\n              var _rootEl = getReactRootElementInContainer(container);\n              var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));\n              var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;\n              if (hasNonRootReactChild) {\n                error(\"unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s\", isContainerReactRoot ? \"You may have accidentally passed in a React root node instead of its container.\" : \"Instead, have the parent component update its state and rerender in order to remove this component.\");\n              }\n            }\n            return false;\n          }\n        }\n        setAttemptSynchronousHydration(attemptSynchronousHydration$1);\n        setAttemptContinuousHydration(attemptContinuousHydration$1);\n        setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);\n        setGetCurrentUpdatePriority(getCurrentUpdatePriority);\n        setAttemptHydrationAtPriority(runWithPriority);\n        {\n          if (typeof Map !== \"function\" || // $FlowIssue Flow incorrectly thinks Map has no prototype\n          Map.prototype == null || typeof Map.prototype.forEach !== \"function\" || typeof Set !== \"function\" || // $FlowIssue Flow incorrectly thinks Set has no prototype\n          Set.prototype == null || typeof Set.prototype.clear !== \"function\" || typeof Set.prototype.forEach !== \"function\") {\n            error(\"React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills\");\n          }\n        }\n        setRestoreImplementation(restoreControlledState$3);\n        setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);\n        function createPortal$1(children, container) {\n          var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n          if (!isValidContainer(container)) {\n            throw new Error(\"Target container is not a DOM element.\");\n          }\n          return createPortal(children, container, null, key);\n        }\n        function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {\n          return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);\n        }\n        var Internals = {\n          usingClientEntryPoint: false,\n          // Keep in sync with ReactTestUtils.js.\n          // This is an array for better minification.\n          Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]\n        };\n        function createRoot$1(container, options2) {\n          {\n            if (!Internals.usingClientEntryPoint && true) {\n              error('You are importing createRoot from \"react-dom\" which is not supported. You should instead import it from \"react-dom/client\".');\n            }\n          }\n          return createRoot(container, options2);\n        }\n        function hydrateRoot$1(container, initialChildren, options2) {\n          {\n            if (!Internals.usingClientEntryPoint && true) {\n              error('You are importing hydrateRoot from \"react-dom\" which is not supported. You should instead import it from \"react-dom/client\".');\n            }\n          }\n          return hydrateRoot(container, initialChildren, options2);\n        }\n        function flushSync$1(fn) {\n          {\n            if (isAlreadyRendering()) {\n              error(\"flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.\");\n            }\n          }\n          return flushSync(fn);\n        }\n        var foundDevTools = injectIntoDevTools({\n          findFiberByHostInstance: getClosestInstanceFromNode,\n          bundleType: 1,\n          version: ReactVersion,\n          rendererPackageName: \"react-dom\"\n        });\n        {\n          if (!foundDevTools && canUseDOM && window.top === window.self) {\n            if (navigator.userAgent.indexOf(\"Chrome\") > -1 && navigator.userAgent.indexOf(\"Edge\") === -1 || navigator.userAgent.indexOf(\"Firefox\") > -1) {\n              var protocol = window.location.protocol;\n              if (/^(https?|file):$/.test(protocol)) {\n                console.info(\"%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools\" + (protocol === \"file:\" ? \"\\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq\" : \"\"), \"font-weight:bold\");\n              }\n            }\n          }\n        }\n        exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;\n        exports.createPortal = createPortal$1;\n        exports.createRoot = createRoot$1;\n        exports.findDOMNode = findDOMNode;\n        exports.flushSync = flushSync$1;\n        exports.hydrate = hydrate;\n        exports.hydrateRoot = hydrateRoot$1;\n        exports.render = render;\n        exports.unmountComponentAtNode = unmountComponentAtNode;\n        exports.unstable_batchedUpdates = batchedUpdates$1;\n        exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;\n        exports.version = ReactVersion;\n        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n          __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n      })();\n    }\n  }\n});\n\n// node_modules/react-dom/index.js\nvar require_react_dom = __commonJS({\n  \"node_modules/react-dom/index.js\"(exports, module) {\n    if (false) {\n      checkDCE();\n      module.exports = null;\n    } else {\n      module.exports = require_react_dom_development();\n    }\n  }\n});\n\nexport {\n  require_react_dom\n};\n/*! Bundled license information:\n\nscheduler/cjs/scheduler.development.js:\n  (**\n   * @license React\n   * scheduler.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n\nreact-dom/cjs/react-dom.development.js:\n  (**\n   * @license React\n   * react-dom.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n  (**\n   * Checks if an event is supported in the current execution environment.\n   *\n   * NOTE: This will not work correctly for non-generic events such as `change`,\n   * `reset`, `load`, `error`, and `select`.\n   *\n   * Borrows from Modernizr.\n   *\n   * @param {string} eventNameSuffix Event name, e.g. \"click\".\n   * @return {boolean} True if the event is supported.\n   * @internal\n   * @license Modernizr 3.0.0pre (Custom Build) | MIT\n   *)\n*/\n//# sourceMappingURL=chunk-NUMECXU6.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.686Z",
        "time": 19.070999998803018,
        "timings": {
          "blocked": 16.320000000582077,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.1890000003692694,
          "receive": 2.5619999978516717,
          "_blocked_queueing": 16.250000000582077,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184658",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 18
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/components/Header.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"15b1-weeqtjSf+7foUm1z5Knjf/YTYJQ\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 531,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 9712,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/components/Header.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport * as RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.$RefreshReg$) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong.\"\n    );\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(\"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\");\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nconst Header = ({ statistics, onShowAboutModal }) => {\n  return /* @__PURE__ */ jsxDEV(\"header\", { className: \"header\", children: /* @__PURE__ */ jsxDEV(\"div\", { className: \"header-content\", children: [\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"header-left\", children: [\n      /* @__PURE__ */ jsxDEV(\"img\", { src: \"/logo-compacto.png\", alt: \"Logo\", className: \"header-logo\" }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n        lineNumber: 33,\n        columnNumber: 11\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"h1\", { className: \"header-title\", children: \"Grandes Modelos de Lenguaje (LLM)\" }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n        lineNumber: 34,\n        columnNumber: 11\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n      lineNumber: 32,\n      columnNumber: 9\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"header-center\", children: /* @__PURE__ */ jsxDEV(\"div\", { className: \"statistics-counter\", children: [\n      /* @__PURE__ */ jsxDEV(\"span\", { className: \"statistics-label\", children: \"Prompts generados:\" }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n        lineNumber: 39,\n        columnNumber: 13\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"span\", { className: \"statistics-value\", children: statistics.promptCount.toLocaleString(\"es-ES\") }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n        lineNumber: 40,\n        columnNumber: 13\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n      lineNumber: 38,\n      columnNumber: 11\n    }, this) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n      lineNumber: 37,\n      columnNumber: 9\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"header-right\", children: /* @__PURE__ */ jsxDEV(\n      \"button\",\n      {\n        type: \"button\",\n        onClick: onShowAboutModal,\n        className: \"about-button\",\n        title: \"Informacin sobre la aplicacin\",\n        children: [\n          /* @__PURE__ */ jsxDEV(\"svg\", { className: \"w-5 h-5\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\n            \"path\",\n            {\n              strokeLinecap: \"round\",\n              strokeLinejoin: \"round\",\n              strokeWidth: \"2\",\n              d: \"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\"\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n              lineNumber: 54,\n              columnNumber: 15\n            },\n            this\n          ) }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n            lineNumber: 53,\n            columnNumber: 13\n          }, this),\n          \"Acerca de\"\n        ]\n      },\n      void 0,\n      true,\n      {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n        lineNumber: 47,\n        columnNumber: 11\n      },\n      this\n    ) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n      lineNumber: 46,\n      columnNumber: 9\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n    lineNumber: 31,\n    columnNumber: 7\n  }, this) }, void 0, false, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\",\n    lineNumber: 30,\n    columnNumber: 5\n  }, this);\n};\n_c = Header;\nexport default Header;\nvar _c;\n$RefreshReg$(_c, \"Header\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n}\nif (import.meta.hot && !inWebWorker) {\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(\"/home/jano/DEV_WSL/LLM/src/frontend/components/Header.tsx\", currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBYVU7Ozs7Ozs7Ozs7Ozs7Ozs7QUFMVixNQUFNQSxTQUFnQ0EsQ0FBQyxFQUFFQyxZQUFZQyxpQkFBaUIsTUFBTTtBQUMxRSxTQUNFLHVCQUFDLFlBQU8sV0FBVSxVQUNoQixpQ0FBQyxTQUFJLFdBQVUsa0JBQ2I7QUFBQSwyQkFBQyxTQUFJLFdBQVUsZUFDYjtBQUFBLDZCQUFDLFNBQUksS0FBSSxzQkFBcUIsS0FBSSxRQUFPLFdBQVUsaUJBQW5EO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBZ0U7QUFBQSxNQUNoRSx1QkFBQyxRQUFHLFdBQVUsZ0JBQWUsaURBQTdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBOEQ7QUFBQSxTQUZoRTtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBR0E7QUFBQSxJQUVBLHVCQUFDLFNBQUksV0FBVSxpQkFDYixpQ0FBQyxTQUFJLFdBQVUsc0JBQ2I7QUFBQSw2QkFBQyxVQUFLLFdBQVUsb0JBQW1CLGtDQUFuQztBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQXFEO0FBQUEsTUFDckQsdUJBQUMsVUFBSyxXQUFVLG9CQUNiRCxxQkFBV0UsWUFBWUMsZUFBZSxPQUFPLEtBRGhEO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFFQTtBQUFBLFNBSkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUtBLEtBTkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQU9BO0FBQUEsSUFFQSx1QkFBQyxTQUFJLFdBQVUsZ0JBQ2I7QUFBQSxNQUFDO0FBQUE7QUFBQSxRQUNDLE1BQUs7QUFBQSxRQUNMLFNBQVNGO0FBQUFBLFFBQ1QsV0FBVTtBQUFBLFFBQ1YsT0FBTTtBQUFBLFFBRU47QUFBQSxpQ0FBQyxTQUFJLFdBQVUsV0FBVSxNQUFLLFFBQU8sUUFBTyxnQkFBZSxTQUFRLGFBQ2pFO0FBQUEsWUFBQztBQUFBO0FBQUEsY0FBSyxlQUFjO0FBQUEsY0FBUSxnQkFBZTtBQUFBLGNBQVEsYUFBWTtBQUFBLGNBQzdELEdBQUU7QUFBQTtBQUFBLFlBREo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBQytELEtBRmpFO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBR0E7QUFBQSxVQUFNO0FBQUE7QUFBQTtBQUFBLE1BVFI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBV0EsS0FaRjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBYUE7QUFBQSxPQTVCRjtBQUFBO0FBQUE7QUFBQTtBQUFBLFNBNkJBLEtBOUJGO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0ErQkE7QUFFSjtBQUFFRyxLQW5DSUw7QUFxQ04sZUFBZUE7QUFBTyxJQUFBSztBQUFBQyxhQUFBRCxJQUFBIiwibmFtZXMiOlsiSGVhZGVyIiwic3RhdGlzdGljcyIsIm9uU2hvd0Fib3V0TW9kYWwiLCJwcm9tcHRDb3VudCIsInRvTG9jYWxlU3RyaW5nIiwiX2MiLCIkUmVmcmVzaFJlZyQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiSGVhZGVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBTdGF0aXN0aWNzIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuaW50ZXJmYWNlIEhlYWRlclByb3BzIHtcclxuICBzdGF0aXN0aWNzOiBTdGF0aXN0aWNzO1xyXG4gIG9uU2hvd0Fib3V0TW9kYWw6ICgpID0+IHZvaWQ7XHJcbn1cclxuXHJcbmNvbnN0IEhlYWRlcjogUmVhY3QuRkM8SGVhZGVyUHJvcHM+ID0gKHsgc3RhdGlzdGljcywgb25TaG93QWJvdXRNb2RhbCB9KSA9PiB7XHJcbiAgcmV0dXJuIChcclxuICAgIDxoZWFkZXIgY2xhc3NOYW1lPVwiaGVhZGVyXCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLWNvbnRlbnRcIj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlci1sZWZ0XCI+XHJcbiAgICAgICAgICA8aW1nIHNyYz1cIi9sb2dvLWNvbXBhY3RvLnBuZ1wiIGFsdD1cIkxvZ29cIiBjbGFzc05hbWU9XCJoZWFkZXItbG9nb1wiIC8+XHJcbiAgICAgICAgICA8aDEgY2xhc3NOYW1lPVwiaGVhZGVyLXRpdGxlXCI+R3JhbmRlcyBNb2RlbG9zIGRlIExlbmd1YWplIChMTE0pPC9oMT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICBcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImhlYWRlci1jZW50ZXJcIj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3RhdGlzdGljcy1jb3VudGVyXCI+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInN0YXRpc3RpY3MtbGFiZWxcIj5Qcm9tcHRzIGdlbmVyYWRvczo8L3NwYW4+XHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInN0YXRpc3RpY3MtdmFsdWVcIj5cclxuICAgICAgICAgICAgICB7c3RhdGlzdGljcy5wcm9tcHRDb3VudC50b0xvY2FsZVN0cmluZygnZXMtRVMnKX1cclxuICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLXJpZ2h0XCI+XHJcbiAgICAgICAgICA8YnV0dG9uIFxyXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcclxuICAgICAgICAgICAgb25DbGljaz17b25TaG93QWJvdXRNb2RhbH1cclxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYWJvdXQtYnV0dG9uXCJcclxuICAgICAgICAgICAgdGl0bGU9XCJJbmZvcm1hY2nDs24gc29icmUgbGEgYXBsaWNhY2nDs25cIlxyXG4gICAgICAgICAgPlxyXG4gICAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cInctNSBoLTVcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cclxuICAgICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9XCIyXCIgXHJcbiAgICAgICAgICAgICAgICBkPVwiTTEzIDE2aC0xdi00aC0xbTEtNGguMDFNMjEgMTJhOSA5IDAgMTEtMTggMCA5IDkgMCAwMTE4IDB6XCIgLz5cclxuICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgIEFjZXJjYSBkZVxyXG4gICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9oZWFkZXI+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjsiXSwiZmlsZSI6Ii9ob21lL2phbm8vREVWX1dTTC9MTE0vc3JjL2Zyb250ZW5kL2NvbXBvbmVudHMvSGVhZGVyLnRzeCJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.695Z",
        "time": 12.768999997206265,
        "timings": {
          "blocked": 10.452999997771112,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.10999999999999988,
          "wait": 1.8570000013394747,
          "receive": 0.34899999809567817,
          "_blocked_queueing": 8.987999997771112,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184654",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 19
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/components/Modal.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"f2a-AzpI0i+fM858KWWf3stKsglFu/o\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 529,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 6669,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/components/Modal.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport * as RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.$RefreshReg$) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong.\"\n    );\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(\"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\");\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nconst Modal = ({ isOpen, onClose, title, children }) => {\n  if (!isOpen) return null;\n  return /* @__PURE__ */ jsxDEV(\"div\", { className: \"modal-overlay\", onClick: onClose, children: /* @__PURE__ */ jsxDEV(\"div\", { className: \"modal-content\", onClick: (e) => e.stopPropagation(), children: [\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"modal-header\", children: [\n      /* @__PURE__ */ jsxDEV(\"h2\", { className: \"modal-title\", children: title }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n        lineNumber: 36,\n        columnNumber: 11\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"button\", { className: \"modal-close\", onClick: onClose, children: /* @__PURE__ */ jsxDEV(\"svg\", { className: \"w-6 h-6\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"2\", d: \"M6 18L18 6M6 6l12 12\" }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n        lineNumber: 39,\n        columnNumber: 15\n      }, this) }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n        lineNumber: 38,\n        columnNumber: 13\n      }, this) }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n        lineNumber: 37,\n        columnNumber: 11\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n      lineNumber: 35,\n      columnNumber: 9\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"modal-body\", children }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n      lineNumber: 43,\n      columnNumber: 9\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n    lineNumber: 34,\n    columnNumber: 7\n  }, this) }, void 0, false, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\",\n    lineNumber: 33,\n    columnNumber: 5\n  }, this);\n};\n_c = Modal;\nexport default Modal;\nvar _c;\n$RefreshReg$(_c, \"Modal\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n}\nif (import.meta.hot && !inWebWorker) {\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(\"/home/jano/DEV_WSL/LLM/src/frontend/components/Modal.tsx\", currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBZ0JVOzs7Ozs7Ozs7Ozs7Ozs7O0FBUFYsTUFBTUEsUUFBOEJBLENBQUMsRUFBRUMsUUFBUUMsU0FBU0MsT0FBT0MsU0FBUyxNQUFNO0FBQzVFLE1BQUksQ0FBQ0gsT0FBUSxRQUFPO0FBRXBCLFNBQ0UsdUJBQUMsU0FBSSxXQUFVLGlCQUFnQixTQUFTQyxTQUN0QyxpQ0FBQyxTQUFJLFdBQVUsaUJBQWdCLFNBQVMsQ0FBQUcsTUFBS0EsRUFBRUMsZ0JBQWdCLEdBQzdEO0FBQUEsMkJBQUMsU0FBSSxXQUFVLGdCQUNiO0FBQUEsNkJBQUMsUUFBRyxXQUFVLGVBQWVILG1CQUE3QjtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQW1DO0FBQUEsTUFDbkMsdUJBQUMsWUFBTyxXQUFVLGVBQWMsU0FBU0QsU0FDdkMsaUNBQUMsU0FBSSxXQUFVLFdBQVUsTUFBSyxRQUFPLFFBQU8sZ0JBQWUsU0FBUSxhQUNqRSxpQ0FBQyxVQUFLLGVBQWMsU0FBUSxnQkFBZSxTQUFRLGFBQVksS0FBSSxHQUFFLDBCQUFyRTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQTJGLEtBRDdGO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFFQSxLQUhGO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFJQTtBQUFBLFNBTkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQU9BO0FBQUEsSUFDQSx1QkFBQyxTQUFJLFdBQVUsY0FDWkUsWUFESDtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBRUE7QUFBQSxPQVhGO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FZQSxLQWJGO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FjQTtBQUVKO0FBQUVHLEtBcEJJUDtBQXNCTixlQUFlQTtBQUFNLElBQUFPO0FBQUFDLGFBQUFELElBQUEiLCJuYW1lcyI6WyJNb2RhbCIsImlzT3BlbiIsIm9uQ2xvc2UiLCJ0aXRsZSIsImNoaWxkcmVuIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsIl9jIiwiJFJlZnJlc2hSZWckIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbIk1vZGFsLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIE1vZGFsUHJvcHMge1xyXG4gIGlzT3BlbjogYm9vbGVhbjtcclxuICBvbkNsb3NlOiAoKSA9PiB2b2lkO1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZTtcclxufVxyXG5cclxuY29uc3QgTW9kYWw6IFJlYWN0LkZDPE1vZGFsUHJvcHM+ID0gKHsgaXNPcGVuLCBvbkNsb3NlLCB0aXRsZSwgY2hpbGRyZW4gfSkgPT4ge1xyXG4gIGlmICghaXNPcGVuKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtb3ZlcmxheVwiIG9uQ2xpY2s9e29uQ2xvc2V9PlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1vZGFsLWNvbnRlbnRcIiBvbkNsaWNrPXtlID0+IGUuc3RvcFByb3BhZ2F0aW9uKCl9PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibW9kYWwtaGVhZGVyXCI+XHJcbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwibW9kYWwtdGl0bGVcIj57dGl0bGV9PC9oMj5cclxuICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwibW9kYWwtY2xvc2VcIiBvbkNsaWNrPXtvbkNsb3NlfT5cclxuICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJ3LTYgaC02XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlTGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlTGluZWpvaW49XCJyb3VuZFwiIHN0cm9rZVdpZHRoPVwiMlwiIGQ9XCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIC8+XHJcbiAgICAgICAgICAgIDwvc3ZnPlxyXG4gICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtb2RhbC1ib2R5XCI+XHJcbiAgICAgICAgICB7Y2hpbGRyZW59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IE1vZGFsOyJdLCJmaWxlIjoiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvY29tcG9uZW50cy9Nb2RhbC50c3gifQ=="
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.695Z",
        "time": 14.327999997476583,
        "timings": {
          "blocked": 10.455000000914094,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.07899999999999996,
          "wait": 3.392999999052845,
          "receive": 0.40099999750964344,
          "_blocked_queueing": 9.094000000914093,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 20
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/components/PromptInput.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"2373-05vvT3wl72PFm/WjPeW4F9VRoS4\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 536,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 18766,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/components/PromptInput.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport * as RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.$RefreshReg$) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong.\"\n    );\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(\"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\");\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const useState = __vite__cjsImport3_react[\"useState\"];\nimport FileUpload from \"/components/FileUpload.tsx\";\nconst PromptInput = ({ onSubmit, loading }) => {\n  _s();\n  const [prompt, setPrompt] = useState(\"\");\n  const [showFileUpload, setShowFileUpload] = useState(false);\n  const [selectedFiles, setSelectedFiles] = useState([]);\n  const handleSubmit = (e) => {\n    e.preventDefault();\n    if (prompt.trim() && !loading) {\n      onSubmit(prompt, selectedFiles.length > 0 ? selectedFiles : void 0);\n      setSelectedFiles([]);\n      setShowFileUpload(false);\n    }\n  };\n  const handleKeyDown = (e) => {\n    if (e.key === \"Enter\" && e.ctrlKey) {\n      handleSubmit(e);\n    }\n  };\n  const handleFilesSelected = (files) => {\n    setSelectedFiles(files);\n  };\n  return /* @__PURE__ */ jsxDEV(\"form\", { onSubmit: handleSubmit, className: \"prompt-input-container\", children: [\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"prompt-input-row\", children: [\n      /* @__PURE__ */ jsxDEV(\"label\", { className: \"prompt-label\", children: \"Prompt:\" }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n        lineNumber: 56,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"div\", { className: \"prompt-input-with-files\", children: [\n        /* @__PURE__ */ jsxDEV(\n          \"textarea\",\n          {\n            value: prompt,\n            onChange: (e) => setPrompt(e.target.value),\n            onKeyDown: handleKeyDown,\n            placeholder: \"Escribe aqu tu prompt para los modelos de lenguaje...\",\n            className: `prompt-textarea ${selectedFiles.length > 0 ? \"prompt-with-files\" : \"\"}`,\n            rows: 3,\n            disabled: loading\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n            lineNumber: 58,\n            columnNumber: 11\n          },\n          this\n        ),\n        selectedFiles.length > 0 && /* @__PURE__ */ jsxDEV(\"span\", { className: \"files-attached-indicator\", children: [\n          /* @__PURE__ */ jsxDEV(\"svg\", { fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\n            \"path\",\n            {\n              strokeLinecap: \"round\",\n              strokeLinejoin: \"round\",\n              strokeWidth: \"2\",\n              d: \"M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13\"\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n              lineNumber: 70,\n              columnNumber: 17\n            },\n            this\n          ) }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n            lineNumber: 69,\n            columnNumber: 15\n          }, this),\n          selectedFiles.length,\n          \" archivo\",\n          selectedFiles.length > 1 ? \"s\" : \"\"\n        ] }, void 0, true, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n          lineNumber: 68,\n          columnNumber: 11\n        }, this)\n      ] }, void 0, true, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n        lineNumber: 57,\n        columnNumber: 9\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n      lineNumber: 55,\n      columnNumber: 7\n    }, this),\n    showFileUpload && /* @__PURE__ */ jsxDEV(\n      FileUpload,\n      {\n        onFilesSelected: handleFilesSelected,\n        maxFiles: 5,\n        maxSizeMB: 20\n      },\n      void 0,\n      false,\n      {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n        lineNumber: 80,\n        columnNumber: 7\n      },\n      this\n    ),\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"prompt-actions\", children: [\n      /* @__PURE__ */ jsxDEV(\n        \"button\",\n        {\n          type: \"submit\",\n          disabled: !prompt.trim() || loading,\n          className: \"submit-button\",\n          children: loading ? \"Generando...\" : \"Generar\"\n        },\n        void 0,\n        false,\n        {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n          lineNumber: 88,\n          columnNumber: 9\n        },\n        this\n      ),\n      /* @__PURE__ */ jsxDEV(\n        \"button\",\n        {\n          type: \"button\",\n          onClick: () => {\n            setPrompt(\"\");\n            setSelectedFiles([]);\n            setShowFileUpload(false);\n          },\n          disabled: loading,\n          className: \"clear-button\",\n          children: \"Limpiar\"\n        },\n        void 0,\n        false,\n        {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n          lineNumber: 95,\n          columnNumber: 9\n        },\n        this\n      ),\n      /* @__PURE__ */ jsxDEV(\n        \"button\",\n        {\n          type: \"button\",\n          onClick: () => setShowFileUpload(!showFileUpload),\n          disabled: loading,\n          className: \"file-button\",\n          title: \"Subir imgenes o PDFs\",\n          children: [\n            /* @__PURE__ */ jsxDEV(\"svg\", { className: \"w-4 h-4 mr-2\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\n              \"path\",\n              {\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeWidth: \"2\",\n                d: \"M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13\"\n              },\n              void 0,\n              false,\n              {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n                lineNumber: 115,\n                columnNumber: 13\n              },\n              this\n            ) }, void 0, false, {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n              lineNumber: 114,\n              columnNumber: 11\n            }, this),\n            showFileUpload ? \"Ocultar\" : \"Adjuntar\"\n          ]\n        },\n        void 0,\n        true,\n        {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n          lineNumber: 107,\n          columnNumber: 9\n        },\n        this\n      ),\n      /* @__PURE__ */ jsxDEV(\"span\", { className: \"prompt-hint\", children: \"Tip: Ctrl+Enter para enviar\" }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n        lineNumber: 120,\n        columnNumber: 9\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n      lineNumber: 87,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\",\n    lineNumber: 54,\n    columnNumber: 5\n  }, this);\n};\n_s(PromptInput, \"nAAcbMrnZay9w0FxkIeQ9OfursI=\");\n_c = PromptInput;\nexport default PromptInput;\nvar _c;\n$RefreshReg$(_c, \"PromptInput\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n}\nif (import.meta.hot && !inWebWorker) {\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(\"/home/jano/DEV_WSL/LLM/src/frontend/components/PromptInput.tsx\", currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBb0NROzs7Ozs7Ozs7Ozs7Ozs7OztBQXBDUixTQUFnQkEsZ0JBQWdCO0FBQ2hDLE9BQU9DLGdCQUFnQjtBQU92QixNQUFNQyxjQUEwQ0EsQ0FBQyxFQUFFQyxVQUFVQyxRQUFRLE1BQU07QUFBQUMsS0FBQTtBQUN6RSxRQUFNLENBQUNDLFFBQVFDLFNBQVMsSUFBSVAsU0FBUyxFQUFFO0FBQ3ZDLFFBQU0sQ0FBQ1EsZ0JBQWdCQyxpQkFBaUIsSUFBSVQsU0FBUyxLQUFLO0FBQzFELFFBQU0sQ0FBQ1UsZUFBZUMsZ0JBQWdCLElBQUlYLFNBQWlCLEVBQUU7QUFFN0QsUUFBTVksZUFBZUEsQ0FBQ0MsTUFBdUI7QUFDM0NBLE1BQUVDLGVBQWU7QUFDakIsUUFBSVIsT0FBT1MsS0FBSyxLQUFLLENBQUNYLFNBQVM7QUFDN0JELGVBQVNHLFFBQVFJLGNBQWNNLFNBQVMsSUFBSU4sZ0JBQWdCTyxNQUFTO0FBRXJFTix1QkFBaUIsRUFBRTtBQUNuQkYsd0JBQWtCLEtBQUs7QUFBQSxJQUN6QjtBQUFBLEVBQ0Y7QUFFQSxRQUFNUyxnQkFBZ0JBLENBQUNMLE1BQWdEO0FBQ3JFLFFBQUlBLEVBQUVNLFFBQVEsV0FBV04sRUFBRU8sU0FBUztBQUNsQ1IsbUJBQWFDLENBQVE7QUFBQSxJQUN2QjtBQUFBLEVBQ0Y7QUFFQSxRQUFNUSxzQkFBc0JBLENBQUNDLFVBQWtCO0FBQzdDWCxxQkFBaUJXLEtBQUs7QUFBQSxFQUN4QjtBQUVBLFNBQ0UsdUJBQUMsVUFBSyxVQUFVVixjQUFjLFdBQVUsMEJBQ3RDO0FBQUEsMkJBQUMsU0FBSSxXQUFVLG9CQUNiO0FBQUEsNkJBQUMsV0FBTSxXQUFVLGdCQUFlLHVCQUFoQztBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQXVDO0FBQUEsTUFDdkMsdUJBQUMsU0FBSSxXQUFVLDJCQUNiO0FBQUE7QUFBQSxVQUFDO0FBQUE7QUFBQSxZQUNDLE9BQU9OO0FBQUFBLFlBQ1AsVUFBVSxDQUFDTyxNQUFNTixVQUFVTSxFQUFFVSxPQUFPQyxLQUFLO0FBQUEsWUFDekMsV0FBV047QUFBQUEsWUFDWCxhQUFZO0FBQUEsWUFDWixXQUFXLG1CQUFtQlIsY0FBY00sU0FBUyxJQUFJLHNCQUFzQixFQUFFO0FBQUEsWUFDakYsTUFBTTtBQUFBLFlBQ04sVUFBVVo7QUFBQUE7QUFBQUEsVUFQWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFPb0I7QUFBQSxRQUVuQk0sY0FBY00sU0FBUyxLQUN0Qix1QkFBQyxVQUFLLFdBQVUsNEJBQ2Q7QUFBQSxpQ0FBQyxTQUFJLE1BQUssUUFBTyxRQUFPLGdCQUFlLFNBQVEsYUFDN0M7QUFBQSxZQUFDO0FBQUE7QUFBQSxjQUFLLGVBQWM7QUFBQSxjQUFRLGdCQUFlO0FBQUEsY0FBUSxhQUFZO0FBQUEsY0FDN0QsR0FBRTtBQUFBO0FBQUEsWUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFDMEgsS0FGNUg7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFHQTtBQUFBLFVBQ0NOLGNBQWNNO0FBQUFBLFVBQU87QUFBQSxVQUFTTixjQUFjTSxTQUFTLElBQUksTUFBTTtBQUFBLGFBTGxFO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFNQTtBQUFBLFdBakJKO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFtQkE7QUFBQSxTQXJCRjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBc0JBO0FBQUEsSUFFQ1Isa0JBQ0M7QUFBQSxNQUFDO0FBQUE7QUFBQSxRQUNDLGlCQUFpQmE7QUFBQUEsUUFDakIsVUFBVTtBQUFBLFFBQ1YsV0FBVztBQUFBO0FBQUEsTUFIYjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFHZ0I7QUFBQSxJQUlsQix1QkFBQyxTQUFJLFdBQVUsa0JBQ2I7QUFBQTtBQUFBLFFBQUM7QUFBQTtBQUFBLFVBQ0MsTUFBSztBQUFBLFVBQ0wsVUFBVSxDQUFDZixPQUFPUyxLQUFLLEtBQUtYO0FBQUFBLFVBQzVCLFdBQVU7QUFBQSxVQUVUQSxvQkFBVSxpQkFBaUI7QUFBQTtBQUFBLFFBTDlCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BO0FBQUEsTUFDQTtBQUFBLFFBQUM7QUFBQTtBQUFBLFVBQ0MsTUFBSztBQUFBLFVBQ0wsU0FBUyxNQUFNO0FBQ2JHLHNCQUFVLEVBQUU7QUFDWkksNkJBQWlCLEVBQUU7QUFDbkJGLDhCQUFrQixLQUFLO0FBQUEsVUFDekI7QUFBQSxVQUNBLFVBQVVMO0FBQUFBLFVBQ1YsV0FBVTtBQUFBLFVBQWM7QUFBQTtBQUFBLFFBUjFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVdBO0FBQUEsTUFDQTtBQUFBLFFBQUM7QUFBQTtBQUFBLFVBQ0MsTUFBSztBQUFBLFVBQ0wsU0FBUyxNQUFNSyxrQkFBa0IsQ0FBQ0QsY0FBYztBQUFBLFVBQ2hELFVBQVVKO0FBQUFBLFVBQ1YsV0FBVTtBQUFBLFVBQ1YsT0FBTTtBQUFBLFVBRU47QUFBQSxtQ0FBQyxTQUFJLFdBQVUsZ0JBQWUsTUFBSyxRQUFPLFFBQU8sZ0JBQWUsU0FBUSxhQUN0RTtBQUFBLGNBQUM7QUFBQTtBQUFBLGdCQUFLLGVBQWM7QUFBQSxnQkFBUSxnQkFBZTtBQUFBLGdCQUFRLGFBQVk7QUFBQSxnQkFDN0QsR0FBRTtBQUFBO0FBQUEsY0FESjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsWUFDMEgsS0FGNUg7QUFBQTtBQUFBO0FBQUE7QUFBQSxtQkFHQTtBQUFBLFlBQ0NJLGlCQUFpQixZQUFZO0FBQUE7QUFBQTtBQUFBLFFBWGhDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVlBO0FBQUEsTUFDQSx1QkFBQyxVQUFLLFdBQVUsZUFBYywyQ0FBOUI7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUF5RDtBQUFBLFNBakMzRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBa0NBO0FBQUEsT0FuRUY7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQW9FQTtBQUVKO0FBQUVILEdBaEdJSCxhQUF1QztBQUFBdUIsS0FBdkN2QjtBQWtHTixlQUFlQTtBQUFZLElBQUF1QjtBQUFBQyxhQUFBRCxJQUFBIiwibmFtZXMiOlsidXNlU3RhdGUiLCJGaWxlVXBsb2FkIiwiUHJvbXB0SW5wdXQiLCJvblN1Ym1pdCIsImxvYWRpbmciLCJfcyIsInByb21wdCIsInNldFByb21wdCIsInNob3dGaWxlVXBsb2FkIiwic2V0U2hvd0ZpbGVVcGxvYWQiLCJzZWxlY3RlZEZpbGVzIiwic2V0U2VsZWN0ZWRGaWxlcyIsImhhbmRsZVN1Ym1pdCIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInRyaW0iLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiY3RybEtleSIsImhhbmRsZUZpbGVzU2VsZWN0ZWQiLCJmaWxlcyIsInRhcmdldCIsInZhbHVlIiwiX2MiLCIkUmVmcmVzaFJlZyQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiUHJvbXB0SW5wdXQudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IEZpbGVVcGxvYWQgZnJvbSAnLi9GaWxlVXBsb2FkJztcclxuXHJcbmludGVyZmFjZSBQcm9tcHRJbnB1dFByb3BzIHtcclxuICBvblN1Ym1pdDogKHByb21wdDogc3RyaW5nLCBmaWxlcz86IEZpbGVbXSkgPT4gdm9pZDtcclxuICBsb2FkaW5nOiBib29sZWFuO1xyXG59XHJcblxyXG5jb25zdCBQcm9tcHRJbnB1dDogUmVhY3QuRkM8UHJvbXB0SW5wdXRQcm9wcz4gPSAoeyBvblN1Ym1pdCwgbG9hZGluZyB9KSA9PiB7XHJcbiAgY29uc3QgW3Byb21wdCwgc2V0UHJvbXB0XSA9IHVzZVN0YXRlKCcnKTtcclxuICBjb25zdCBbc2hvd0ZpbGVVcGxvYWQsIHNldFNob3dGaWxlVXBsb2FkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICBjb25zdCBbc2VsZWN0ZWRGaWxlcywgc2V0U2VsZWN0ZWRGaWxlc10gPSB1c2VTdGF0ZTxGaWxlW10+KFtdKTtcclxuXHJcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gKGU6IFJlYWN0LkZvcm1FdmVudCkgPT4ge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgaWYgKHByb21wdC50cmltKCkgJiYgIWxvYWRpbmcpIHtcclxuICAgICAgb25TdWJtaXQocHJvbXB0LCBzZWxlY3RlZEZpbGVzLmxlbmd0aCA+IDAgPyBzZWxlY3RlZEZpbGVzIDogdW5kZWZpbmVkKTtcclxuICAgICAgLy8gQ2xlYXIgZmlsZXMgYWZ0ZXIgc3VibWl0XHJcbiAgICAgIHNldFNlbGVjdGVkRmlsZXMoW10pO1xyXG4gICAgICBzZXRTaG93RmlsZVVwbG9hZChmYWxzZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlOiBSZWFjdC5LZXlib2FyZEV2ZW50PEhUTUxUZXh0QXJlYUVsZW1lbnQ+KSA9PiB7XHJcbiAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgZS5jdHJsS2V5KSB7XHJcbiAgICAgIGhhbmRsZVN1Ym1pdChlIGFzIGFueSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgaGFuZGxlRmlsZXNTZWxlY3RlZCA9IChmaWxlczogRmlsZVtdKSA9PiB7XHJcbiAgICBzZXRTZWxlY3RlZEZpbGVzKGZpbGVzKTtcclxuICB9O1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH0gY2xhc3NOYW1lPVwicHJvbXB0LWlucHV0LWNvbnRhaW5lclwiPlxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInByb21wdC1pbnB1dC1yb3dcIj5cclxuICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwicHJvbXB0LWxhYmVsXCI+UHJvbXB0OjwvbGFiZWw+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9tcHQtaW5wdXQtd2l0aC1maWxlc1wiPlxyXG4gICAgICAgICAgPHRleHRhcmVhXHJcbiAgICAgICAgICAgIHZhbHVlPXtwcm9tcHR9XHJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0UHJvbXB0KGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgICAgb25LZXlEb3duPXtoYW5kbGVLZXlEb3dufVxyXG4gICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVzY3JpYmUgYXF1w60gdHUgcHJvbXB0IHBhcmEgbG9zIG1vZGVsb3MgZGUgbGVuZ3VhamUuLi5cIlxyXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Bwcm9tcHQtdGV4dGFyZWEgJHtzZWxlY3RlZEZpbGVzLmxlbmd0aCA+IDAgPyAncHJvbXB0LXdpdGgtZmlsZXMnIDogJyd9YH1cclxuICAgICAgICAgICAgcm93cz17M31cclxuICAgICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XHJcbiAgICAgICAgICAvPlxyXG4gICAgICAgICAge3NlbGVjdGVkRmlsZXMubGVuZ3RoID4gMCAmJiAoXHJcbiAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZpbGVzLWF0dGFjaGVkLWluZGljYXRvclwiPlxyXG4gICAgICAgICAgICAgIDxzdmcgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9XCIyXCIgXHJcbiAgICAgICAgICAgICAgICAgIGQ9XCJNMTUuMTcyIDdsLTYuNTg2IDYuNTg2YTIgMiAwIDEwMi44MjggMi44MjhsNi40MTQtNi41ODZhNCA0IDAgMDAtNS42NTYtNS42NTZsLTYuNDE1IDYuNTg1YTYgNiAwIDEwOC40ODYgOC40ODZMMjAuNSAxM1wiIC8+XHJcbiAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAge3NlbGVjdGVkRmlsZXMubGVuZ3RofSBhcmNoaXZve3NlbGVjdGVkRmlsZXMubGVuZ3RoID4gMSA/ICdzJyA6ICcnfVxyXG4gICAgICAgICAgICA8L3NwYW4+XHJcbiAgICAgICAgICApfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgXHJcbiAgICAgIHtzaG93RmlsZVVwbG9hZCAmJiAoXHJcbiAgICAgICAgPEZpbGVVcGxvYWRcclxuICAgICAgICAgIG9uRmlsZXNTZWxlY3RlZD17aGFuZGxlRmlsZXNTZWxlY3RlZH1cclxuICAgICAgICAgIG1heEZpbGVzPXs1fVxyXG4gICAgICAgICAgbWF4U2l6ZU1CPXsyMH1cclxuICAgICAgICAvPlxyXG4gICAgICApfVxyXG4gICAgICBcclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9tcHQtYWN0aW9uc1wiPlxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxyXG4gICAgICAgICAgZGlzYWJsZWQ9eyFwcm9tcHQudHJpbSgpIHx8IGxvYWRpbmd9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJzdWJtaXQtYnV0dG9uXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICB7bG9hZGluZyA/ICdHZW5lcmFuZG8uLi4nIDogJ0dlbmVyYXInfVxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4ge1xyXG4gICAgICAgICAgICBzZXRQcm9tcHQoJycpO1xyXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEZpbGVzKFtdKTtcclxuICAgICAgICAgICAgc2V0U2hvd0ZpbGVVcGxvYWQoZmFsc2UpO1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICAgIGRpc2FibGVkPXtsb2FkaW5nfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPVwiY2xlYXItYnV0dG9uXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICBMaW1waWFyXHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93RmlsZVVwbG9hZCghc2hvd0ZpbGVVcGxvYWQpfVxyXG4gICAgICAgICAgZGlzYWJsZWQ9e2xvYWRpbmd9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJmaWxlLWJ1dHRvblwiXHJcbiAgICAgICAgICB0aXRsZT1cIlN1YmlyIGltw6FnZW5lcyBvIFBERnNcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwidy00IGgtNCBtci0yXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD1cIjJcIiBcclxuICAgICAgICAgICAgICBkPVwiTTE1LjE3MiA3bC02LjU4NiA2LjU4NmEyIDIgMCAxMDIuODI4IDIuODI4bDYuNDE0LTYuNTg2YTQgNCAwIDAwLTUuNjU2LTUuNjU2bC02LjQxNSA2LjU4NWE2IDYgMCAxMDguNDg2IDguNDg2TDIwLjUgMTNcIiAvPlxyXG4gICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICB7c2hvd0ZpbGVVcGxvYWQgPyAnT2N1bHRhcicgOiAnQWRqdW50YXInfVxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInByb21wdC1oaW50XCI+VGlwOiBDdHJsK0VudGVyIHBhcmEgZW52aWFyPC9zcGFuPlxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZm9ybT5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgUHJvbXB0SW5wdXQ7Il0sImZpbGUiOiIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9jb21wb25lbnRzL1Byb21wdElucHV0LnRzeCJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.695Z",
        "time": 13.472999999066815,
        "timings": {
          "blocked": 10.492000000328058,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.04899999999999993,
          "wait": 2.3030000004405156,
          "receive": 0.6289999982982408,
          "_blocked_queueing": 9.146000000328058,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184573",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 21
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/components/LLMResponseBox.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"2c96-HPYhfWf4xcjWKhoLSZdHR7+fouw\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 539,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 22657,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/components/LLMResponseBox.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const Fragment = __vite__cjsImport0_react_jsxDevRuntime[\"Fragment\"]; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport * as RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.$RefreshReg$) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong.\"\n    );\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(\"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\");\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const useState = __vite__cjsImport3_react[\"useState\"];\nimport MarkdownRenderer from \"/components/SimpleMarkdownRenderer.tsx\";\nconst LLMResponseBox = ({\n  title,\n  provider,\n  response,\n  model,\n  temperature,\n  models,\n  loading,\n  onModelChange,\n  onTemperatureChange\n}) => {\n  _s();\n  const [copySuccess, setCopySuccess] = useState(false);\n  const providerColors = {\n    openai: \"border-green-500\",\n    anthropic: \"border-orange-500\"\n  };\n  const providerBg = {\n    openai: \"bg-green-50\",\n    anthropic: \"bg-orange-50\"\n  };\n  const copyToClipboard = async () => {\n    if (!response) return;\n    try {\n      await navigator.clipboard.writeText(response);\n      setCopySuccess(true);\n      setTimeout(() => setCopySuccess(false), 2e3);\n    } catch (err) {\n      console.error(\"Error copying to clipboard:\", err);\n    }\n  };\n  const characterCount = response.length;\n  return /* @__PURE__ */ jsxDEV(\"div\", { className: `llm-response-box ${providerColors[provider]}`, children: [\n    /* @__PURE__ */ jsxDEV(\"div\", { className: `llm-response-header ${providerBg[provider]}`, children: [\n      /* @__PURE__ */ jsxDEV(\"div\", { className: \"header-top-row\", children: [\n        /* @__PURE__ */ jsxDEV(\"h3\", { className: \"llm-response-title\", children: title }, void 0, false, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n          lineNumber: 76,\n          columnNumber: 11\n        }, this),\n        /* @__PURE__ */ jsxDEV(\"div\", { className: \"header-actions\", children: (response || loading) && /* @__PURE__ */ jsxDEV(Fragment, { children: [\n          /* @__PURE__ */ jsxDEV(\"span\", { className: \"char-count-compact\", children: characterCount.toLocaleString() }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n            lineNumber: 80,\n            columnNumber: 17\n          }, this),\n          response && /* @__PURE__ */ jsxDEV(\n            \"button\",\n            {\n              onClick: copyToClipboard,\n              className: \"copy-button-compact\",\n              disabled: !response,\n              title: \"Copiar respuesta\",\n              children: copySuccess ? /* @__PURE__ */ jsxDEV(\"svg\", { className: \"w-3 h-3\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"2\", d: \"M5 13l4 4L19 7\" }, void 0, false, {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n                lineNumber: 92,\n                columnNumber: 25\n              }, this) }, void 0, false, {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n                lineNumber: 91,\n                columnNumber: 17\n              }, this) : /* @__PURE__ */ jsxDEV(\"svg\", { className: \"w-3 h-3\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\n                \"path\",\n                {\n                  strokeLinecap: \"round\",\n                  strokeLinejoin: \"round\",\n                  strokeWidth: \"2\",\n                  d: \"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\"\n                },\n                void 0,\n                false,\n                {\n                  fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n                  lineNumber: 96,\n                  columnNumber: 25\n                },\n                this\n              ) }, void 0, false, {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n                lineNumber: 95,\n                columnNumber: 17\n              }, this)\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n              lineNumber: 84,\n              columnNumber: 15\n            },\n            this\n          )\n        ] }, void 0, true, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n          lineNumber: 79,\n          columnNumber: 13\n        }, this) }, void 0, false, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n          lineNumber: 77,\n          columnNumber: 11\n        }, this)\n      ] }, void 0, true, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n        lineNumber: 75,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\"div\", { className: \"llm-controls\", children: [\n        /* @__PURE__ */ jsxDEV(\"div\", { className: \"control-group\", children: [\n          /* @__PURE__ */ jsxDEV(\"label\", { className: \"control-label\", children: \"Modelo:\" }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n            lineNumber: 108,\n            columnNumber: 13\n          }, this),\n          /* @__PURE__ */ jsxDEV(\n            \"select\",\n            {\n              value: model,\n              onChange: (e) => onModelChange(e.target.value),\n              className: \"model-select\",\n              children: models.map(\n                (m) => /* @__PURE__ */ jsxDEV(\"option\", { value: m, children: m }, m, false, {\n                  fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n                  lineNumber: 115,\n                  columnNumber: 15\n                }, this)\n              )\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n              lineNumber: 109,\n              columnNumber: 13\n            },\n            this\n          )\n        ] }, void 0, true, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n          lineNumber: 107,\n          columnNumber: 11\n        }, this),\n        /* @__PURE__ */ jsxDEV(\"div\", { className: \"control-group\", children: [\n          /* @__PURE__ */ jsxDEV(\"label\", { className: \"control-label\", children: [\n            \"Temperatura: \",\n            temperature\n          ] }, void 0, true, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n            lineNumber: 120,\n            columnNumber: 13\n          }, this),\n          /* @__PURE__ */ jsxDEV(\n            \"input\",\n            {\n              type: \"range\",\n              min: \"0\",\n              max: \"1\",\n              step: \"0.1\",\n              value: temperature,\n              onChange: (e) => onTemperatureChange(parseFloat(e.target.value)),\n              className: \"temperature-slider\"\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n              lineNumber: 121,\n              columnNumber: 13\n            },\n            this\n          )\n        ] }, void 0, true, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n          lineNumber: 119,\n          columnNumber: 11\n        }, this)\n      ] }, void 0, true, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n        lineNumber: 106,\n        columnNumber: 9\n      }, this)\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n      lineNumber: 74,\n      columnNumber: 7\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"llm-response-content\", children: response ? /* @__PURE__ */ jsxDEV(\n      MarkdownRenderer,\n      {\n        content: response,\n        isStreaming: loading,\n        className: \"response-markdown\"\n      },\n      void 0,\n      false,\n      {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n        lineNumber: 136,\n        columnNumber: 9\n      },\n      this\n    ) : loading ? /* @__PURE__ */ jsxDEV(\"div\", { className: \"response-text\", children: /* @__PURE__ */ jsxDEV(\"span\", { className: \"typing-cursor\", children: \"\" }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n      lineNumber: 143,\n      columnNumber: 13\n    }, this) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n      lineNumber: 142,\n      columnNumber: 9\n    }, this) : /* @__PURE__ */ jsxDEV(\"div\", { className: \"empty-response\", children: /* @__PURE__ */ jsxDEV(\"p\", { children: \"Ingresa un prompt para ver la respuesta aqu\" }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n      lineNumber: 147,\n      columnNumber: 13\n    }, this) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n      lineNumber: 146,\n      columnNumber: 9\n    }, this) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n      lineNumber: 134,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\",\n    lineNumber: 73,\n    columnNumber: 5\n  }, this);\n};\n_s(LLMResponseBox, \"d3T/Mxp070EAvZV/qoM5C1aXF60=\");\n_c = LLMResponseBox;\nexport default LLMResponseBox;\nvar _c;\n$RefreshReg$(_c, \"LLMResponseBox\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n}\nif (import.meta.hot && !inWebWorker) {\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(\"/home/jano/DEV_WSL/LLM/src/frontend/components/LLMResponseBox.tsx\", currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBd0RVLFNBR0ksVUFISjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF4RFYsU0FBZ0JBLGdCQUFnQjtBQUNoQyxPQUFPQyxzQkFBc0I7QUFjN0IsTUFBTUMsaUJBQWdEQSxDQUFDO0FBQUEsRUFDckRDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQUFBLEVBQ0FDO0FBQ0YsTUFBTTtBQUFBQyxLQUFBO0FBQ0osUUFBTSxDQUFDQyxhQUFhQyxjQUFjLElBQUlkLFNBQVMsS0FBSztBQUVwRCxRQUFNZSxpQkFBaUI7QUFBQSxJQUNyQkMsUUFBUTtBQUFBLElBQ1JDLFdBQVc7QUFBQSxFQUNiO0FBRUEsUUFBTUMsYUFBYTtBQUFBLElBQ2pCRixRQUFRO0FBQUEsSUFDUkMsV0FBVztBQUFBLEVBQ2I7QUFFQSxRQUFNRSxrQkFBa0IsWUFBWTtBQUNsQyxRQUFJLENBQUNkLFNBQVU7QUFFZixRQUFJO0FBQ0YsWUFBTWUsVUFBVUMsVUFBVUMsVUFBVWpCLFFBQVE7QUFDNUNTLHFCQUFlLElBQUk7QUFDbkJTLGlCQUFXLE1BQU1ULGVBQWUsS0FBSyxHQUFHLEdBQUk7QUFBQSxJQUM5QyxTQUFTVSxLQUFLO0FBQ1pDLGNBQVFDLE1BQU0sK0JBQStCRixHQUFHO0FBQUEsSUFDbEQ7QUFBQSxFQUNGO0FBRUEsUUFBTUcsaUJBQWlCdEIsU0FBU3VCO0FBRWhDLFNBQ0UsdUJBQUMsU0FBSSxXQUFXLG9CQUFvQmIsZUFBZVgsUUFBUSxDQUFDLElBQzFEO0FBQUEsMkJBQUMsU0FBSSxXQUFXLHVCQUF1QmMsV0FBV2QsUUFBUSxDQUFDLElBQ3pEO0FBQUEsNkJBQUMsU0FBSSxXQUFVLGtCQUNiO0FBQUEsK0JBQUMsUUFBRyxXQUFVLHNCQUFzQkQsbUJBQXBDO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFBMEM7QUFBQSxRQUMxQyx1QkFBQyxTQUFJLFdBQVUsa0JBQ1hFLHVCQUFZSSxZQUNaLG1DQUNFO0FBQUEsaUNBQUMsVUFBSyxXQUFVLHNCQUNia0IseUJBQWVFLGVBQWUsS0FEakM7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFFQTtBQUFBLFVBQ0N4QixZQUNDO0FBQUEsWUFBQztBQUFBO0FBQUEsY0FDQyxTQUFTYztBQUFBQSxjQUNULFdBQVU7QUFBQSxjQUNWLFVBQVUsQ0FBQ2Q7QUFBQUEsY0FDWCxPQUFNO0FBQUEsY0FFTFEsd0JBQ0MsdUJBQUMsU0FBSSxXQUFVLFdBQVUsTUFBSyxRQUFPLFFBQU8sZ0JBQWUsU0FBUSxhQUNqRSxpQ0FBQyxVQUFLLGVBQWMsU0FBUSxnQkFBZSxTQUFRLGFBQVksS0FBSSxHQUFFLG9CQUFyRTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUFxRixLQUR2RjtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUVBLElBRUEsdUJBQUMsU0FBSSxXQUFVLFdBQVUsTUFBSyxRQUFPLFFBQU8sZ0JBQWUsU0FBUSxhQUNqRTtBQUFBLGdCQUFDO0FBQUE7QUFBQSxrQkFBSyxlQUFjO0FBQUEsa0JBQVEsZ0JBQWU7QUFBQSxrQkFBUSxhQUFZO0FBQUEsa0JBQzdELEdBQUU7QUFBQTtBQUFBLGdCQURKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUMySCxLQUY3SDtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUdBO0FBQUE7QUFBQSxZQWRKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQWdCQTtBQUFBLGFBckJKO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUF1QkEsS0F6Qko7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQTJCQTtBQUFBLFdBN0JGO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUE4QkE7QUFBQSxNQUNBLHVCQUFDLFNBQUksV0FBVSxnQkFDYjtBQUFBLCtCQUFDLFNBQUksV0FBVSxpQkFDYjtBQUFBLGlDQUFDLFdBQU0sV0FBVSxpQkFBZ0IsdUJBQWpDO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQXdDO0FBQUEsVUFDeEM7QUFBQSxZQUFDO0FBQUE7QUFBQSxjQUNDLE9BQU9QO0FBQUFBLGNBQ1AsVUFBVSxDQUFDd0IsTUFBTXBCLGNBQWNvQixFQUFFQyxPQUFPQyxLQUFLO0FBQUEsY0FDN0MsV0FBVTtBQUFBLGNBRVR4QixpQkFBT3lCO0FBQUFBLGdCQUFJLENBQUFDLE1BQ1YsdUJBQUMsWUFBZSxPQUFPQSxHQUFJQSxlQUFkQSxHQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBQTZCO0FBQUEsY0FDOUI7QUFBQTtBQUFBLFlBUEg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBUUE7QUFBQSxhQVZGO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFXQTtBQUFBLFFBQ0EsdUJBQUMsU0FBSSxXQUFVLGlCQUNiO0FBQUEsaUNBQUMsV0FBTSxXQUFVLGlCQUFnQjtBQUFBO0FBQUEsWUFBYzNCO0FBQUFBLGVBQS9DO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQTJEO0FBQUEsVUFDM0Q7QUFBQSxZQUFDO0FBQUE7QUFBQSxjQUNDLE1BQUs7QUFBQSxjQUNMLEtBQUk7QUFBQSxjQUNKLEtBQUk7QUFBQSxjQUNKLE1BQUs7QUFBQSxjQUNMLE9BQU9BO0FBQUFBLGNBQ1AsVUFBVSxDQUFDdUIsTUFBTW5CLG9CQUFvQndCLFdBQVdMLEVBQUVDLE9BQU9DLEtBQUssQ0FBQztBQUFBLGNBQy9ELFdBQVU7QUFBQTtBQUFBLFlBUFo7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFVBT2dDO0FBQUEsYUFUbEM7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQVdBO0FBQUEsV0F4QkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQXlCQTtBQUFBLFNBekRGO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0EwREE7QUFBQSxJQUVBLHVCQUFDLFNBQUksV0FBVSx3QkFDWjNCLHFCQUNDO0FBQUEsTUFBQztBQUFBO0FBQUEsUUFDQyxTQUFTQTtBQUFBQSxRQUNULGFBQWFJO0FBQUFBLFFBQ2IsV0FBVTtBQUFBO0FBQUEsTUFIWjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFHK0IsSUFFN0JBLFVBQ0YsdUJBQUMsU0FBSSxXQUFVLGlCQUNiLGlDQUFDLFVBQUssV0FBVSxpQkFBZ0IsaUJBQWhDO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBaUMsS0FEbkM7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUVBLElBRUEsdUJBQUMsU0FBSSxXQUFVLGtCQUNiLGlDQUFDLE9BQUUsNERBQUg7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUErQyxLQURqRDtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBRUEsS0FkSjtBQUFBO0FBQUE7QUFBQTtBQUFBLFdBZ0JBO0FBQUEsT0E3RUY7QUFBQTtBQUFBO0FBQUE7QUFBQSxTQThFQTtBQUVKO0FBQUVHLEdBdEhJVixnQkFBNkM7QUFBQWtDLEtBQTdDbEM7QUF3SE4sZUFBZUE7QUFBZSxJQUFBa0M7QUFBQUMsYUFBQUQsSUFBQSIsIm5hbWVzIjpbInVzZVN0YXRlIiwiTWFya2Rvd25SZW5kZXJlciIsIkxMTVJlc3BvbnNlQm94IiwidGl0bGUiLCJwcm92aWRlciIsInJlc3BvbnNlIiwibW9kZWwiLCJ0ZW1wZXJhdHVyZSIsIm1vZGVscyIsImxvYWRpbmciLCJvbk1vZGVsQ2hhbmdlIiwib25UZW1wZXJhdHVyZUNoYW5nZSIsIl9zIiwiY29weVN1Y2Nlc3MiLCJzZXRDb3B5U3VjY2VzcyIsInByb3ZpZGVyQ29sb3JzIiwib3BlbmFpIiwiYW50aHJvcGljIiwicHJvdmlkZXJCZyIsImNvcHlUb0NsaXBib2FyZCIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsInNldFRpbWVvdXQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJjaGFyYWN0ZXJDb3VudCIsImxlbmd0aCIsInRvTG9jYWxlU3RyaW5nIiwiZSIsInRhcmdldCIsInZhbHVlIiwibWFwIiwibSIsInBhcnNlRmxvYXQiLCJfYyIsIiRSZWZyZXNoUmVnJCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJMTE1SZXNwb25zZUJveC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgTWFya2Rvd25SZW5kZXJlciBmcm9tICcuL1NpbXBsZU1hcmtkb3duUmVuZGVyZXInO1xyXG5cclxuaW50ZXJmYWNlIExMTVJlc3BvbnNlQm94UHJvcHMge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgcHJvdmlkZXI6ICdvcGVuYWknIHwgJ2FudGhyb3BpYyc7XHJcbiAgcmVzcG9uc2U6IHN0cmluZztcclxuICBtb2RlbDogc3RyaW5nO1xyXG4gIHRlbXBlcmF0dXJlOiBudW1iZXI7XHJcbiAgbW9kZWxzOiBzdHJpbmdbXTtcclxuICBsb2FkaW5nOiBib29sZWFuO1xyXG4gIG9uTW9kZWxDaGFuZ2U6IChtb2RlbDogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIG9uVGVtcGVyYXR1cmVDaGFuZ2U6ICh0ZW1wZXJhdHVyZTogbnVtYmVyKSA9PiB2b2lkO1xyXG59XHJcblxyXG5jb25zdCBMTE1SZXNwb25zZUJveDogUmVhY3QuRkM8TExNUmVzcG9uc2VCb3hQcm9wcz4gPSAoe1xyXG4gIHRpdGxlLFxyXG4gIHByb3ZpZGVyLFxyXG4gIHJlc3BvbnNlLFxyXG4gIG1vZGVsLFxyXG4gIHRlbXBlcmF0dXJlLFxyXG4gIG1vZGVscyxcclxuICBsb2FkaW5nLFxyXG4gIG9uTW9kZWxDaGFuZ2UsXHJcbiAgb25UZW1wZXJhdHVyZUNoYW5nZVxyXG59KSA9PiB7XHJcbiAgY29uc3QgW2NvcHlTdWNjZXNzLCBzZXRDb3B5U3VjY2Vzc10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIGNvbnN0IHByb3ZpZGVyQ29sb3JzID0ge1xyXG4gICAgb3BlbmFpOiAnYm9yZGVyLWdyZWVuLTUwMCcsXHJcbiAgICBhbnRocm9waWM6ICdib3JkZXItb3JhbmdlLTUwMCdcclxuICB9O1xyXG5cclxuICBjb25zdCBwcm92aWRlckJnID0ge1xyXG4gICAgb3BlbmFpOiAnYmctZ3JlZW4tNTAnLFxyXG4gICAgYW50aHJvcGljOiAnYmctb3JhbmdlLTUwJ1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGNvcHlUb0NsaXBib2FyZCA9IGFzeW5jICgpID0+IHtcclxuICAgIGlmICghcmVzcG9uc2UpIHJldHVybjtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocmVzcG9uc2UpO1xyXG4gICAgICBzZXRDb3B5U3VjY2Vzcyh0cnVlKTtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRDb3B5U3VjY2VzcyhmYWxzZSksIDIwMDApO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvcHlpbmcgdG8gY2xpcGJvYXJkOicsIGVycik7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgY2hhcmFjdGVyQ291bnQgPSByZXNwb25zZS5sZW5ndGg7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT17YGxsbS1yZXNwb25zZS1ib3ggJHtwcm92aWRlckNvbG9yc1twcm92aWRlcl19YH0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtgbGxtLXJlc3BvbnNlLWhlYWRlciAke3Byb3ZpZGVyQmdbcHJvdmlkZXJdfWB9PlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLXRvcC1yb3dcIj5cclxuICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJsbG0tcmVzcG9uc2UtdGl0bGVcIj57dGl0bGV9PC9oMz5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaGVhZGVyLWFjdGlvbnNcIj5cclxuICAgICAgICAgICAgeyhyZXNwb25zZSB8fCBsb2FkaW5nKSAmJiAoXHJcbiAgICAgICAgICAgICAgPD5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImNoYXItY291bnQtY29tcGFjdFwiPlxyXG4gICAgICAgICAgICAgICAgICB7Y2hhcmFjdGVyQ291bnQudG9Mb2NhbGVTdHJpbmcoKX1cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIHtyZXNwb25zZSAmJiAoXHJcbiAgICAgICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtjb3B5VG9DbGlwYm9hcmR9XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29weS1idXR0b24tY29tcGFjdFwiXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQ9eyFyZXNwb25zZX1cclxuICAgICAgICAgICAgICAgICAgICB0aXRsZT1cIkNvcGlhciByZXNwdWVzdGFcIlxyXG4gICAgICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICAgICAge2NvcHlTdWNjZXNzID8gKFxyXG4gICAgICAgICAgICAgICAgICAgICAgPHN2ZyBjbGFzc05hbWU9XCJ3LTMgaC0zXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD1cIjJcIiBkPVwiTTUgMTNsNCA0TDE5IDdcIiAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9zdmc+XHJcbiAgICAgICAgICAgICAgICAgICAgKSA6IChcclxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwidy0zIGgtM1wiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9XCIyXCIgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZD1cIk04IDE2SDZhMiAyIDAgMDEtMi0yVjZhMiAyIDAgMDEyLTJoOGEyIDIgMCAwMTIgMnYybS02IDEyaDhhMiAyIDAgMDAyLTJ2LThhMiAyIDAgMDAtMi0yaC04YTIgMiAwIDAwLTIgMnY4YTIgMiAwIDAwMiAyelwiIC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cclxuICAgICAgICAgICAgICAgICAgICApfVxyXG4gICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICAgICAgICAgICl9XHJcbiAgICAgICAgICAgICAgPC8+XHJcbiAgICAgICAgICAgICl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImxsbS1jb250cm9sc1wiPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb250cm9sLWdyb3VwXCI+XHJcbiAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJjb250cm9sLWxhYmVsXCI+TW9kZWxvOjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxzZWxlY3QgXHJcbiAgICAgICAgICAgICAgdmFsdWU9e21vZGVsfVxyXG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gb25Nb2RlbENoYW5nZShlLnRhcmdldC52YWx1ZSl9XHJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibW9kZWwtc2VsZWN0XCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIHttb2RlbHMubWFwKG0gPT4gKFxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiBrZXk9e219IHZhbHVlPXttfT57bX08L29wdGlvbj5cclxuICAgICAgICAgICAgICApKX1cclxuICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udHJvbC1ncm91cFwiPlxyXG4gICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiY29udHJvbC1sYWJlbFwiPlRlbXBlcmF0dXJhOiB7dGVtcGVyYXR1cmV9PC9sYWJlbD5cclxuICAgICAgICAgICAgPGlucHV0XHJcbiAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcclxuICAgICAgICAgICAgICBtaW49XCIwXCJcclxuICAgICAgICAgICAgICBtYXg9XCIxXCJcclxuICAgICAgICAgICAgICBzdGVwPVwiMC4xXCJcclxuICAgICAgICAgICAgICB2YWx1ZT17dGVtcGVyYXR1cmV9XHJcbiAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBvblRlbXBlcmF0dXJlQ2hhbmdlKHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpKX1cclxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZW1wZXJhdHVyZS1zbGlkZXJcIlxyXG4gICAgICAgICAgICAvPlxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICBcclxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJsbG0tcmVzcG9uc2UtY29udGVudFwiPlxyXG4gICAgICAgIHtyZXNwb25zZSA/IChcclxuICAgICAgICAgIDxNYXJrZG93blJlbmRlcmVyIFxyXG4gICAgICAgICAgICBjb250ZW50PXtyZXNwb25zZX1cclxuICAgICAgICAgICAgaXNTdHJlYW1pbmc9e2xvYWRpbmd9XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT1cInJlc3BvbnNlLW1hcmtkb3duXCJcclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgKSA6IGxvYWRpbmcgPyAoXHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInJlc3BvbnNlLXRleHRcIj5cclxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwidHlwaW5nLWN1cnNvclwiPuKWijwvc3Bhbj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICkgOiAoXHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImVtcHR5LXJlc3BvbnNlXCI+XHJcbiAgICAgICAgICAgIDxwPkluZ3Jlc2EgdW4gcHJvbXB0IHBhcmEgdmVyIGxhIHJlc3B1ZXN0YSBhcXXDrTwvcD5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IExMTVJlc3BvbnNlQm94OyJdLCJmaWxlIjoiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvY29tcG9uZW50cy9MTE1SZXNwb25zZUJveC50c3gifQ=="
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.696Z",
        "time": 13.647999996464932,
        "timings": {
          "blocked": 10.53399999711453,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.040000000000000036,
          "wait": 2.5710000000519213,
          "receive": 0.5029999992984813,
          "_blocked_queueing": 9.15799999711453,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184618",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 22
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/hooks/useStatistics.ts",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"3df-Aq0Rsg5icTYI/Ve4Adrs1M0X2gs\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 531,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 3242,
            "mimeType": "text/javascript",
            "text": "import __vite__cjsImport0_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const useState = __vite__cjsImport0_react[\"useState\"]; const useEffect = __vite__cjsImport0_react[\"useEffect\"];\nimport { api } from \"/services/api.ts\";\nexport const useStatistics = () => {\n  const [statistics, setStatistics] = useState({\n    promptCount: 0,\n    lastUpdated: (/* @__PURE__ */ new Date()).toISOString()\n  });\n  const [loading, setLoading] = useState(false);\n  const fetchStatistics = async () => {\n    setLoading(true);\n    try {\n      const stats = await api.getStatistics();\n      setStatistics(stats);\n    } catch (error) {\n      console.error(\"Error fetching statistics:\", error);\n    } finally {\n      setLoading(false);\n    }\n  };\n  useEffect(() => {\n    fetchStatistics();\n    const interval = setInterval(fetchStatistics, 3e4);\n    return () => clearInterval(interval);\n  }, []);\n  return {\n    statistics,\n    loading,\n    refetch: fetchStatistics\n  };\n};\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVzZVN0YXRpc3RpY3MudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgYXBpIH0gZnJvbSAnLi4vc2VydmljZXMvYXBpJztcclxuaW1wb3J0IHsgU3RhdGlzdGljcyB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmV4cG9ydCBjb25zdCB1c2VTdGF0aXN0aWNzID0gKCkgPT4ge1xyXG4gIGNvbnN0IFtzdGF0aXN0aWNzLCBzZXRTdGF0aXN0aWNzXSA9IHVzZVN0YXRlPFN0YXRpc3RpY3M+KHtcclxuICAgIHByb21wdENvdW50OiAwLFxyXG4gICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKVxyXG4gIH0pO1xyXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgY29uc3QgZmV0Y2hTdGF0aXN0aWNzID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgYXBpLmdldFN0YXRpc3RpY3MoKTtcclxuICAgICAgc2V0U3RhdGlzdGljcyhzdGF0cyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBzdGF0aXN0aWNzOicsIGVycm9yKTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBmZXRjaFN0YXRpc3RpY3MoKTtcclxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoZmV0Y2hTdGF0aXN0aWNzLCAzMDAwMCk7IC8vIEFjdHVhbGl6YXIgY2FkYSAzMCBzZWd1bmRvc1xyXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIHN0YXRpc3RpY3MsXHJcbiAgICBsb2FkaW5nLFxyXG4gICAgcmVmZXRjaDogZmV0Y2hTdGF0aXN0aWNzXHJcbiAgfTtcclxufTsiXSwibWFwcGluZ3MiOiJBQUFBLFNBQVMsVUFBVSxpQkFBaUI7QUFDcEMsU0FBUyxXQUFXO0FBR2IsYUFBTSxnQkFBZ0IsTUFBTTtBQUNqQyxRQUFNLENBQUMsWUFBWSxhQUFhLElBQUksU0FBcUI7QUFBQSxJQUN2RCxhQUFhO0FBQUEsSUFDYixjQUFhLG9CQUFJLEtBQUssR0FBRSxZQUFZO0FBQUEsRUFDdEMsQ0FBQztBQUNELFFBQU0sQ0FBQyxTQUFTLFVBQVUsSUFBSSxTQUFTLEtBQUs7QUFFNUMsUUFBTSxrQkFBa0IsWUFBWTtBQUNsQyxlQUFXLElBQUk7QUFDZixRQUFJO0FBQ0YsWUFBTSxRQUFRLE1BQU0sSUFBSSxjQUFjO0FBQ3RDLG9CQUFjLEtBQUs7QUFBQSxJQUNyQixTQUFTLE9BQU87QUFDZCxjQUFRLE1BQU0sOEJBQThCLEtBQUs7QUFBQSxJQUNuRCxVQUFFO0FBQ0EsaUJBQVcsS0FBSztBQUFBLElBQ2xCO0FBQUEsRUFDRjtBQUVBLFlBQVUsTUFBTTtBQUNkLG9CQUFnQjtBQUNoQixVQUFNLFdBQVcsWUFBWSxpQkFBaUIsR0FBSztBQUNuRCxXQUFPLE1BQU0sY0FBYyxRQUFRO0FBQUEsRUFDckMsR0FBRyxDQUFDLENBQUM7QUFFTCxTQUFPO0FBQUEsSUFDTDtBQUFBLElBQ0E7QUFBQSxJQUNBLFNBQVM7QUFBQSxFQUNYO0FBQ0Y7IiwibmFtZXMiOltdfQ=="
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.696Z",
        "time": 14.266999998653773,
        "timings": {
          "blocked": 10.529000001182082,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.04200000000000004,
          "wait": 3.368999999547843,
          "receive": 0.32699999792384915,
          "_blocked_queueing": 9.213000001182081,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184622",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 23
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/hooks/useModels.ts",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"3ef-fIjLGFYQGJ9M7tMxImVKza9fZSY\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 527,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 3210,
            "mimeType": "text/javascript",
            "text": "import __vite__cjsImport0_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const useState = __vite__cjsImport0_react[\"useState\"]; const useEffect = __vite__cjsImport0_react[\"useEffect\"];\nimport { api } from \"/services/api.ts\";\nexport const useModels = () => {\n  const [openaiModels, setOpenaiModels] = useState([]);\n  const [anthropicModels, setAnthropicModels] = useState([]);\n  const [loading, setLoading] = useState(false);\n  useEffect(() => {\n    const fetchModels = async () => {\n      setLoading(true);\n      try {\n        const response = await api.getModels();\n        if (response.success && response.data) {\n          setOpenaiModels(response.data.openai);\n          setAnthropicModels(response.data.anthropic);\n        }\n      } catch (error) {\n        console.error(\"Error fetching models:\", error);\n      } finally {\n        setLoading(false);\n      }\n    };\n    fetchModels();\n  }, []);\n  return {\n    openaiModels,\n    anthropicModels,\n    loading\n  };\n};\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInVzZU1vZGVscy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgeyBhcGkgfSBmcm9tICcuLi9zZXJ2aWNlcy9hcGknO1xyXG5cclxuZXhwb3J0IGNvbnN0IHVzZU1vZGVscyA9ICgpID0+IHtcclxuICBjb25zdCBbb3BlbmFpTW9kZWxzLCBzZXRPcGVuYWlNb2RlbHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuICBjb25zdCBbYW50aHJvcGljTW9kZWxzLCBzZXRBbnRocm9waWNNb2RlbHNdID0gdXNlU3RhdGU8c3RyaW5nW10+KFtdKTtcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBmZXRjaE1vZGVscyA9IGFzeW5jICgpID0+IHtcclxuICAgICAgc2V0TG9hZGluZyh0cnVlKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFwaS5nZXRNb2RlbHMoKTtcclxuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5kYXRhKSB7XHJcbiAgICAgICAgICBzZXRPcGVuYWlNb2RlbHMocmVzcG9uc2UuZGF0YS5vcGVuYWkpO1xyXG4gICAgICAgICAgc2V0QW50aHJvcGljTW9kZWxzKHJlc3BvbnNlLmRhdGEuYW50aHJvcGljKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbW9kZWxzOicsIGVycm9yKTtcclxuICAgICAgfSBmaW5hbGx5IHtcclxuICAgICAgICBzZXRMb2FkaW5nKGZhbHNlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBmZXRjaE1vZGVscygpO1xyXG4gIH0sIFtdKTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIG9wZW5haU1vZGVscyxcclxuICAgIGFudGhyb3BpY01vZGVscyxcclxuICAgIGxvYWRpbmdcclxuICB9O1xyXG59OyJdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxVQUFVLGlCQUFpQjtBQUNwQyxTQUFTLFdBQVc7QUFFYixhQUFNLFlBQVksTUFBTTtBQUM3QixRQUFNLENBQUMsY0FBYyxlQUFlLElBQUksU0FBbUIsQ0FBQyxDQUFDO0FBQzdELFFBQU0sQ0FBQyxpQkFBaUIsa0JBQWtCLElBQUksU0FBbUIsQ0FBQyxDQUFDO0FBQ25FLFFBQU0sQ0FBQyxTQUFTLFVBQVUsSUFBSSxTQUFTLEtBQUs7QUFFNUMsWUFBVSxNQUFNO0FBQ2QsVUFBTSxjQUFjLFlBQVk7QUFDOUIsaUJBQVcsSUFBSTtBQUNmLFVBQUk7QUFDRixjQUFNLFdBQVcsTUFBTSxJQUFJLFVBQVU7QUFDckMsWUFBSSxTQUFTLFdBQVcsU0FBUyxNQUFNO0FBQ3JDLDBCQUFnQixTQUFTLEtBQUssTUFBTTtBQUNwQyw2QkFBbUIsU0FBUyxLQUFLLFNBQVM7QUFBQSxRQUM1QztBQUFBLE1BQ0YsU0FBUyxPQUFPO0FBQ2QsZ0JBQVEsTUFBTSwwQkFBMEIsS0FBSztBQUFBLE1BQy9DLFVBQUU7QUFDQSxtQkFBVyxLQUFLO0FBQUEsTUFDbEI7QUFBQSxJQUNGO0FBRUEsZ0JBQVk7QUFBQSxFQUNkLEdBQUcsQ0FBQyxDQUFDO0FBRUwsU0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLEVBQ0Y7QUFDRjsiLCJuYW1lcyI6W119"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.696Z",
        "time": 14.40799999909359,
        "timings": {
          "blocked": 10.49599999838788,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.04499999999999993,
          "wait": 3.4959999988002237,
          "receive": 0.371000001905486,
          "_blocked_queueing": 9.19399999838788,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184658",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 24
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/services/api.ts",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"ab5-e7LolcZ+UJXbxm/vD3IGmbwIKBw\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 524,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 10160,
            "mimeType": "text/javascript",
            "text": "import.meta.env = {\"BASE_URL\": \"/\", \"DEV\": true, \"MODE\": \"development\", \"PROD\": false, \"SSR\": false};const API_BASE_URL = import.meta.env.VITE_API_URL || \"\";\nexport const api = {\n  async generateDualResponse(request) {\n    const response = await fetch(`${API_BASE_URL}/api/llm/generate`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(request)\n    });\n    return response.json();\n  },\n  async streamResponse(request, callbacks) {\n    const response = await fetch(`${API_BASE_URL}/api/llm/stream`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(request)\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder();\n    if (!reader) {\n      throw new Error(\"No reader available\");\n    }\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        const chunk = decoder.decode(value);\n        const lines = chunk.split(\"\\n\");\n        for (const line of lines) {\n          if (line.startsWith(\"data: \")) {\n            const data = line.slice(6);\n            if (data.trim()) {\n              try {\n                const parsed = JSON.parse(data);\n                if (parsed.error) {\n                  callbacks.onError?.(parsed.error);\n                } else if (parsed.done) {\n                  callbacks.onComplete?.();\n                } else {\n                  if (request.provider === \"dual\") {\n                    if (parsed.openai) {\n                      callbacks.onOpenAIChunk?.(parsed.openai);\n                    }\n                    if (parsed.anthropic) {\n                      callbacks.onAnthropicChunk?.(parsed.anthropic);\n                    }\n                  } else if (parsed.content) {\n                    if (parsed.provider === \"openai\") {\n                      callbacks.onOpenAIChunk?.(parsed.content);\n                    } else if (parsed.provider === \"anthropic\") {\n                      callbacks.onAnthropicChunk?.(parsed.content);\n                    }\n                  }\n                }\n              } catch (e) {\n                console.error(\"Error parsing SSE data:\", e);\n              }\n            }\n          }\n        }\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  },\n  async getModels() {\n    const response = await fetch(`${API_BASE_URL}/api/llm/models`);\n    return response.json();\n  },\n  async getStatistics() {\n    const response = await fetch(`${API_BASE_URL}/api/statistics`);\n    const data = await response.json();\n    return data.data;\n  }\n};\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEdWFsTExNUmVxdWVzdCwgRHVhbExMTVJlc3BvbnNlLCBTdGF0aXN0aWNzLCBNb2RlbHNSZXNwb25zZSB9IGZyb20gJy4uL3R5cGVzJztcclxuXHJcbmNvbnN0IEFQSV9CQVNFX1VSTCA9IGltcG9ydC5tZXRhLmVudi5WSVRFX0FQSV9VUkwgfHwgJyc7XHJcblxyXG5pbnRlcmZhY2UgU3RyZWFtQ2FsbGJhY2tzIHtcclxuICBvbk9wZW5BSUNodW5rPzogKGNodW5rOiBzdHJpbmcpID0+IHZvaWQ7XHJcbiAgb25BbnRocm9waWNDaHVuaz86IChjaHVuazogc3RyaW5nKSA9PiB2b2lkO1xyXG4gIG9uRXJyb3I/OiAoZXJyb3I6IHN0cmluZykgPT4gdm9pZDtcclxuICBvbkNvbXBsZXRlPzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGFwaSA9IHtcclxuICBhc3luYyBnZW5lcmF0ZUR1YWxSZXNwb25zZShyZXF1ZXN0OiBEdWFsTExNUmVxdWVzdCk6IFByb21pc2U8RHVhbExMTVJlc3BvbnNlPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2xsbS9nZW5lcmF0ZWAsIHtcclxuICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gICAgICB9LFxyXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcclxuICB9LFxyXG5cclxuICBhc3luYyBzdHJlYW1SZXNwb25zZShcclxuICAgIHJlcXVlc3Q6IHsgXHJcbiAgICAgIHByb21wdDogc3RyaW5nOyBcclxuICAgICAgcHJvdmlkZXI6ICdvcGVuYWknIHwgJ2FudGhyb3BpYycgfCAnZHVhbCc7IFxyXG4gICAgICBtb2RlbD86IHN0cmluZzsgXHJcbiAgICAgIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xyXG4gICAgICBvcGVuYWlNb2RlbD86IHN0cmluZztcclxuICAgICAgYW50aHJvcGljTW9kZWw/OiBzdHJpbmc7XHJcbiAgICAgIG9wZW5haVRlbXBlcmF0dXJlPzogbnVtYmVyO1xyXG4gICAgICBhbnRocm9waWNUZW1wZXJhdHVyZT86IG51bWJlcjtcclxuICAgICAgZmlsZUlkcz86IHN0cmluZ1tdO1xyXG4gICAgfSxcclxuICAgIGNhbGxiYWNrczogU3RyZWFtQ2FsbGJhY2tzXHJcbiAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL2xsbS9zdHJlYW1gLCB7XHJcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgfSxcclxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksXHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5Py5nZXRSZWFkZXIoKTtcclxuICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcclxuXHJcbiAgICBpZiAoIXJlYWRlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHJlYWRlciBhdmFpbGFibGUnKTtcclxuICAgIH1cclxuXHJcbiAgICB0cnkge1xyXG4gICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XHJcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xyXG5cclxuICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlKTtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IGNodW5rLnNwbGl0KCdcXG4nKTtcclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XHJcbiAgICAgICAgICBpZiAobGluZS5zdGFydHNXaXRoKCdkYXRhOiAnKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbGluZS5zbGljZSg2KTtcclxuICAgICAgICAgICAgaWYgKGRhdGEudHJpbSgpKSB7XHJcbiAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IEpTT04ucGFyc2UoZGF0YSk7XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLm9uRXJyb3I/LihwYXJzZWQuZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQuZG9uZSkge1xyXG4gICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25Db21wbGV0ZT8uKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5wcm92aWRlciA9PT0gJ2R1YWwnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5vcGVuYWkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbk9wZW5BSUNodW5rPy4ocGFyc2VkLm9wZW5haSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQuYW50aHJvcGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25BbnRocm9waWNDaHVuaz8uKHBhcnNlZC5hbnRocm9waWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJzZWQuY29udGVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWQucHJvdmlkZXIgPT09ICdvcGVuYWknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3Mub25PcGVuQUlDaHVuaz8uKHBhcnNlZC5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnNlZC5wcm92aWRlciA9PT0gJ2FudGhyb3BpYycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5vbkFudGhyb3BpY0NodW5rPy4ocGFyc2VkLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgU1NFIGRhdGE6JywgZSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGZpbmFsbHkge1xyXG4gICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBhc3luYyBnZXRNb2RlbHMoKTogUHJvbWlzZTxNb2RlbHNSZXNwb25zZT4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfQkFTRV9VUkx9L2FwaS9sbG0vbW9kZWxzYCk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpO1xyXG4gIH0sXHJcblxyXG4gIGFzeW5jIGdldFN0YXRpc3RpY3MoKTogUHJvbWlzZTxTdGF0aXN0aWNzPiB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFX1VSTH0vYXBpL3N0YXRpc3RpY3NgKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICByZXR1cm4gZGF0YS5kYXRhO1xyXG4gIH0sXHJcbn07Il0sIm1hcHBpbmdzIjoiQUFFQSxNQUFNLGVBQWUsWUFBWSxJQUFJLGdCQUFnQjtBQVM5QyxhQUFNLE1BQU07QUFBQSxFQUNqQixNQUFNLHFCQUFxQixTQUFtRDtBQUM1RSxVQUFNLFdBQVcsTUFBTSxNQUFNLEdBQUcsWUFBWSxxQkFBcUI7QUFBQSxNQUMvRCxRQUFRO0FBQUEsTUFDUixTQUFTO0FBQUEsUUFDUCxnQkFBZ0I7QUFBQSxNQUNsQjtBQUFBLE1BQ0EsTUFBTSxLQUFLLFVBQVUsT0FBTztBQUFBLElBQzlCLENBQUM7QUFDRCxXQUFPLFNBQVMsS0FBSztBQUFBLEVBQ3ZCO0FBQUEsRUFFQSxNQUFNLGVBQ0osU0FXQSxXQUNlO0FBQ2YsVUFBTSxXQUFXLE1BQU0sTUFBTSxHQUFHLFlBQVksbUJBQW1CO0FBQUEsTUFDN0QsUUFBUTtBQUFBLE1BQ1IsU0FBUztBQUFBLFFBQ1AsZ0JBQWdCO0FBQUEsTUFDbEI7QUFBQSxNQUNBLE1BQU0sS0FBSyxVQUFVLE9BQU87QUFBQSxJQUM5QixDQUFDO0FBRUQsUUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNoQixZQUFNLElBQUksTUFBTSx1QkFBdUIsU0FBUyxNQUFNLEVBQUU7QUFBQSxJQUMxRDtBQUVBLFVBQU0sU0FBUyxTQUFTLE1BQU0sVUFBVTtBQUN4QyxVQUFNLFVBQVUsSUFBSSxZQUFZO0FBRWhDLFFBQUksQ0FBQyxRQUFRO0FBQ1gsWUFBTSxJQUFJLE1BQU0scUJBQXFCO0FBQUEsSUFDdkM7QUFFQSxRQUFJO0FBQ0YsYUFBTyxNQUFNO0FBQ1gsY0FBTSxFQUFFLE1BQU0sTUFBTSxJQUFJLE1BQU0sT0FBTyxLQUFLO0FBQzFDLFlBQUksS0FBTTtBQUVWLGNBQU0sUUFBUSxRQUFRLE9BQU8sS0FBSztBQUNsQyxjQUFNLFFBQVEsTUFBTSxNQUFNLElBQUk7QUFFOUIsbUJBQVcsUUFBUSxPQUFPO0FBQ3hCLGNBQUksS0FBSyxXQUFXLFFBQVEsR0FBRztBQUM3QixrQkFBTSxPQUFPLEtBQUssTUFBTSxDQUFDO0FBQ3pCLGdCQUFJLEtBQUssS0FBSyxHQUFHO0FBQ2Ysa0JBQUk7QUFDRixzQkFBTSxTQUFTLEtBQUssTUFBTSxJQUFJO0FBRTlCLG9CQUFJLE9BQU8sT0FBTztBQUNoQiw0QkFBVSxVQUFVLE9BQU8sS0FBSztBQUFBLGdCQUNsQyxXQUFXLE9BQU8sTUFBTTtBQUN0Qiw0QkFBVSxhQUFhO0FBQUEsZ0JBQ3pCLE9BQU87QUFDTCxzQkFBSSxRQUFRLGFBQWEsUUFBUTtBQUMvQix3QkFBSSxPQUFPLFFBQVE7QUFDakIsZ0NBQVUsZ0JBQWdCLE9BQU8sTUFBTTtBQUFBLG9CQUN6QztBQUNBLHdCQUFJLE9BQU8sV0FBVztBQUNwQixnQ0FBVSxtQkFBbUIsT0FBTyxTQUFTO0FBQUEsb0JBQy9DO0FBQUEsa0JBQ0YsV0FBVyxPQUFPLFNBQVM7QUFDekIsd0JBQUksT0FBTyxhQUFhLFVBQVU7QUFDaEMsZ0NBQVUsZ0JBQWdCLE9BQU8sT0FBTztBQUFBLG9CQUMxQyxXQUFXLE9BQU8sYUFBYSxhQUFhO0FBQzFDLGdDQUFVLG1CQUFtQixPQUFPLE9BQU87QUFBQSxvQkFDN0M7QUFBQSxrQkFDRjtBQUFBLGdCQUNGO0FBQUEsY0FDRixTQUFTLEdBQUc7QUFDVix3QkFBUSxNQUFNLDJCQUEyQixDQUFDO0FBQUEsY0FDNUM7QUFBQSxZQUNGO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRixVQUFFO0FBQ0EsYUFBTyxZQUFZO0FBQUEsSUFDckI7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLFlBQXFDO0FBQ3pDLFVBQU0sV0FBVyxNQUFNLE1BQU0sR0FBRyxZQUFZLGlCQUFpQjtBQUM3RCxXQUFPLFNBQVMsS0FBSztBQUFBLEVBQ3ZCO0FBQUEsRUFFQSxNQUFNLGdCQUFxQztBQUN6QyxVQUFNLFdBQVcsTUFBTSxNQUFNLEdBQUcsWUFBWSxpQkFBaUI7QUFDN0QsVUFBTSxPQUFPLE1BQU0sU0FBUyxLQUFLO0FBQ2pDLFdBQU8sS0FBSztBQUFBLEVBQ2Q7QUFDRjsiLCJuYW1lcyI6W119"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.696Z",
        "time": 14.408999999432126,
        "timings": {
          "blocked": 12.02100000185403,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.05999999999999961,
          "wait": 2.079000000594184,
          "receive": 0.24899999698391184,
          "_blocked_queueing": 9.17200000185403,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/App.tsx",
          "lineNumber": 25
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/services/file.api.ts",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"b4d-/OxhKxTO0jnwV34ZQdnA5enxDr0\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/App.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 529,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 11404,
            "mimeType": "text/javascript",
            "text": "class FileAPI {\n  constructor() {\n    this.baseURL = true ? \"http://localhost:3000\" : \"\";\n  }\n  async uploadFiles(files) {\n    try {\n      const formData = new FormData();\n      files.forEach((file) => {\n        formData.append(\"files\", file);\n      });\n      const response = await fetch(`${this.baseURL}/api/upload/upload`, {\n        method: \"POST\",\n        body: formData\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(\"File upload error:\", error);\n      return {\n        success: false,\n        error: error.message || \"Error al subir los archivos\"\n      };\n    }\n  }\n  async getFileData(fileId) {\n    try {\n      const response = await fetch(`${this.baseURL}/api/upload/file/${fileId}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(\"Get file data error:\", error);\n      return {\n        success: false,\n        error: error.message || \"Error al obtener los datos del archivo\"\n      };\n    }\n  }\n  async deleteFile(fileId) {\n    try {\n      const response = await fetch(`${this.baseURL}/api/upload/file/${fileId}`, {\n        method: \"DELETE\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(\"Delete file error:\", error);\n      return {\n        success: false,\n        error: error.message || \"Error al eliminar el archivo\"\n      };\n    }\n  }\n  async checkModelCapabilities(models, fileTypes) {\n    try {\n      const response = await fetch(`${this.baseURL}/api/upload/check-capabilities`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({ models, fileTypes })\n      });\n      if (!response.ok) {\n        const errorData = await response.json().catch(() => ({}));\n        throw new Error(errorData.error || `HTTP error! status: ${response.status}`);\n      }\n      return await response.json();\n    } catch (error) {\n      console.error(\"Check capabilities error:\", error);\n      return {\n        success: false,\n        error: error.message || \"Error al verificar las capacidades del modelo\"\n      };\n    }\n  }\n}\nexport const fileAPI = new FileAPI();\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBc0NBLE1BQU0sUUFBUTtBQUFBLEVBR1osY0FBYztBQUNaLFNBQUssVUFBVSxPQUNYLDBCQUNBO0FBQUEsRUFDTjtBQUFBLEVBRUEsTUFBTSxZQUFZLE9BQTRDO0FBQzVELFFBQUk7QUFDRixZQUFNLFdBQVcsSUFBSSxTQUFTO0FBQzlCLFlBQU0sUUFBUSxVQUFRO0FBQ3BCLGlCQUFTLE9BQU8sU0FBUyxJQUFJO0FBQUEsTUFDL0IsQ0FBQztBQUVELFlBQU0sV0FBVyxNQUFNLE1BQU0sR0FBRyxLQUFLLE9BQU8sc0JBQXNCO0FBQUEsUUFDaEUsUUFBUTtBQUFBLFFBQ1IsTUFBTTtBQUFBLE1BQ1IsQ0FBQztBQUVELFVBQUksQ0FBQyxTQUFTLElBQUk7QUFDaEIsY0FBTSxZQUFZLE1BQU0sU0FBUyxLQUFLLEVBQUUsTUFBTSxPQUFPLENBQUMsRUFBRTtBQUN4RCxjQUFNLElBQUksTUFBTSxVQUFVLFNBQVMsdUJBQXVCLFNBQVMsTUFBTSxFQUFFO0FBQUEsTUFDN0U7QUFFQSxhQUFPLE1BQU0sU0FBUyxLQUFLO0FBQUEsSUFDN0IsU0FBUyxPQUFZO0FBQ25CLGNBQVEsTUFBTSxzQkFBc0IsS0FBSztBQUN6QyxhQUFPO0FBQUEsUUFDTCxTQUFTO0FBQUEsUUFDVCxPQUFPLE1BQU0sV0FBVztBQUFBLE1BQzFCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFBQSxFQUVBLE1BQU0sWUFBWSxRQUEyQztBQUMzRCxRQUFJO0FBQ0YsWUFBTSxXQUFXLE1BQU0sTUFBTSxHQUFHLEtBQUssT0FBTyxvQkFBb0IsTUFBTSxJQUFJO0FBQUEsUUFDeEUsUUFBUTtBQUFBLFFBQ1IsU0FBUztBQUFBLFVBQ1AsZ0JBQWdCO0FBQUEsUUFDbEI7QUFBQSxNQUNGLENBQUM7QUFFRCxVQUFJLENBQUMsU0FBUyxJQUFJO0FBQ2hCLGNBQU0sWUFBWSxNQUFNLFNBQVMsS0FBSyxFQUFFLE1BQU0sT0FBTyxDQUFDLEVBQUU7QUFDeEQsY0FBTSxJQUFJLE1BQU0sVUFBVSxTQUFTLHVCQUF1QixTQUFTLE1BQU0sRUFBRTtBQUFBLE1BQzdFO0FBRUEsYUFBTyxNQUFNLFNBQVMsS0FBSztBQUFBLElBQzdCLFNBQVMsT0FBWTtBQUNuQixjQUFRLE1BQU0sd0JBQXdCLEtBQUs7QUFDM0MsYUFBTztBQUFBLFFBQ0wsU0FBUztBQUFBLFFBQ1QsT0FBTyxNQUFNLFdBQVc7QUFBQSxNQUMxQjtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFNLFdBQVcsUUFBK0Q7QUFDOUUsUUFBSTtBQUNGLFlBQU0sV0FBVyxNQUFNLE1BQU0sR0FBRyxLQUFLLE9BQU8sb0JBQW9CLE1BQU0sSUFBSTtBQUFBLFFBQ3hFLFFBQVE7QUFBQSxRQUNSLFNBQVM7QUFBQSxVQUNQLGdCQUFnQjtBQUFBLFFBQ2xCO0FBQUEsTUFDRixDQUFDO0FBRUQsVUFBSSxDQUFDLFNBQVMsSUFBSTtBQUNoQixjQUFNLFlBQVksTUFBTSxTQUFTLEtBQUssRUFBRSxNQUFNLE9BQU8sQ0FBQyxFQUFFO0FBQ3hELGNBQU0sSUFBSSxNQUFNLFVBQVUsU0FBUyx1QkFBdUIsU0FBUyxNQUFNLEVBQUU7QUFBQSxNQUM3RTtBQUVBLGFBQU8sTUFBTSxTQUFTLEtBQUs7QUFBQSxJQUM3QixTQUFTLE9BQVk7QUFDbkIsY0FBUSxNQUFNLHNCQUFzQixLQUFLO0FBQ3pDLGFBQU87QUFBQSxRQUNMLFNBQVM7QUFBQSxRQUNULE9BQU8sTUFBTSxXQUFXO0FBQUEsTUFDMUI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSx1QkFDSixRQUNBLFdBQ29DO0FBQ3BDLFFBQUk7QUFDRixZQUFNLFdBQVcsTUFBTSxNQUFNLEdBQUcsS0FBSyxPQUFPLGtDQUFrQztBQUFBLFFBQzVFLFFBQVE7QUFBQSxRQUNSLFNBQVM7QUFBQSxVQUNQLGdCQUFnQjtBQUFBLFFBQ2xCO0FBQUEsUUFDQSxNQUFNLEtBQUssVUFBVSxFQUFFLFFBQVEsVUFBVSxDQUFDO0FBQUEsTUFDNUMsQ0FBQztBQUVELFVBQUksQ0FBQyxTQUFTLElBQUk7QUFDaEIsY0FBTSxZQUFZLE1BQU0sU0FBUyxLQUFLLEVBQUUsTUFBTSxPQUFPLENBQUMsRUFBRTtBQUN4RCxjQUFNLElBQUksTUFBTSxVQUFVLFNBQVMsdUJBQXVCLFNBQVMsTUFBTSxFQUFFO0FBQUEsTUFDN0U7QUFFQSxhQUFPLE1BQU0sU0FBUyxLQUFLO0FBQUEsSUFDN0IsU0FBUyxPQUFZO0FBQ25CLGNBQVEsTUFBTSw2QkFBNkIsS0FBSztBQUNoRCxhQUFPO0FBQUEsUUFDTCxTQUFTO0FBQUEsUUFDVCxPQUFPLE1BQU0sV0FBVztBQUFBLE1BQzFCO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFDRjtBQUVPLGFBQU0sVUFBVSxJQUFJLFFBQVEiLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VzIjpbImZpbGUuYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImludGVyZmFjZSBVcGxvYWRlZEZpbGUge1xuICBpZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6ICdpbWFnZScgfCAncGRmJztcbiAgc2l6ZTogbnVtYmVyO1xuICBtaW1lVHlwZTogc3RyaW5nO1xuICBwcmV2aWV3Pzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmlsZVVwbG9hZFJlc3BvbnNlIHtcbiAgc3VjY2VzczogYm9vbGVhbjtcbiAgZGF0YT86IHtcbiAgICBmaWxlczogVXBsb2FkZWRGaWxlW107XG4gICAgZXJyb3JzPzogQXJyYXk8eyBmaWxlOiBzdHJpbmc7IGVycm9yOiBzdHJpbmcgfT47XG4gIH07XG4gIGVycm9yPzogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgRmlsZURhdGFSZXNwb25zZSB7XG4gIHN1Y2Nlc3M6IGJvb2xlYW47XG4gIGRhdGE/OiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgdHlwZTogJ2ltYWdlJyB8ICdwZGYnO1xuICAgIHNpemU6IG51bWJlcjtcbiAgICBtaW1lVHlwZTogc3RyaW5nO1xuICAgIGJhc2U2ND86IHN0cmluZztcbiAgICB0ZXh0Pzogc3RyaW5nO1xuICB9O1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIE1vZGVsQ2FwYWJpbGl0aWVzUmVzcG9uc2Uge1xuICBzdWNjZXNzOiBib29sZWFuO1xuICBkYXRhPzogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgeyBjYW5Qcm9jZXNzOiBib29sZWFuOyByZWFzb24/OiBzdHJpbmcgfT4+O1xuICBlcnJvcj86IHN0cmluZztcbn1cblxuY2xhc3MgRmlsZUFQSSB7XG4gIHByaXZhdGUgYmFzZVVSTDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYmFzZVVSTCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnIFxuICAgICAgPyAnaHR0cDovL2xvY2FsaG9zdDozMDAwJyBcbiAgICAgIDogJyc7XG4gIH1cblxuICBhc3luYyB1cGxvYWRGaWxlcyhmaWxlczogRmlsZVtdKTogUHJvbWlzZTxGaWxlVXBsb2FkUmVzcG9uc2U+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZXMnLCBmaWxlKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3VwbG9hZC91cGxvYWRgLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBmb3JtRGF0YVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbGUgdXBsb2FkIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgYWwgc3ViaXIgbG9zIGFyY2hpdm9zJ1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBnZXRGaWxlRGF0YShmaWxlSWQ6IHN0cmluZyk6IFByb21pc2U8RmlsZURhdGFSZXNwb25zZT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVSTH0vYXBpL3VwbG9hZC9maWxlLyR7ZmlsZUlkfWAsIHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgZXJyb3JEYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpLmNhdGNoKCgpID0+ICh7fSkpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JEYXRhLmVycm9yIHx8IGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0dldCBmaWxlIGRhdGEgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBvYnRlbmVyIGxvcyBkYXRvcyBkZWwgYXJjaGl2bydcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZGVsZXRlRmlsZShmaWxlSWQ6IHN0cmluZyk6IFByb21pc2U8eyBzdWNjZXNzOiBib29sZWFuOyBlcnJvcj86IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdXBsb2FkL2ZpbGUvJHtmaWxlSWR9YCwge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRGVsZXRlIGZpbGUgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBlbGltaW5hciBlbCBhcmNoaXZvJ1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBjaGVja01vZGVsQ2FwYWJpbGl0aWVzKFxuICAgIG1vZGVsczogc3RyaW5nW10sIFxuICAgIGZpbGVUeXBlczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxNb2RlbENhcGFiaWxpdGllc1Jlc3BvbnNlPiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVVJMfS9hcGkvdXBsb2FkL2NoZWNrLWNhcGFiaWxpdGllc2AsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgbW9kZWxzLCBmaWxlVHlwZXMgfSlcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiAoe30pKTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCBgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdDaGVjayBjYXBhYmlsaXRpZXMgZXJyb3I6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCB2ZXJpZmljYXIgbGFzIGNhcGFjaWRhZGVzIGRlbCBtb2RlbG8nXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZmlsZUFQSSA9IG5ldyBGaWxlQVBJKCk7XG5leHBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSwgRmlsZVVwbG9hZFJlc3BvbnNlLCBGaWxlRGF0YVJlc3BvbnNlIH07Il0sImZpbGUiOiIvaG9tZS9qYW5vL0RFVl9XU0wvTExNL3NyYy9mcm9udGVuZC9zZXJ2aWNlcy9maWxlLmFwaS50cyJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.696Z",
        "time": 15.543999998044455,
        "timings": {
          "blocked": 12.563999998554587,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.06300000000000017,
          "wait": 2.36000000010035,
          "receive": 0.556999999389518,
          "_blocked_queueing": 9.172999998554587,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "setupWebSocket",
                "scriptId": "124",
                "url": "http://localhost:5174/@vite/client",
                "lineNumber": 535,
                "columnNumber": 18
              },
              {
                "functionName": "",
                "scriptId": "124",
                "url": "http://localhost:5174/@vite/client",
                "lineNumber": 530,
                "columnNumber": 11
              }
            ]
          }
        },
        "_priority": null,
        "_resourceType": "websocket",
        "_webSocketMessages": [
          {
            "type": "receive",
            "time": 1754515986.73754,
            "opcode": 1,
            "data": "{\"type\":\"connected\"}"
          }
        ],
        "cache": {},
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "ws://localhost:5174/?token=B0ljPQ3LU_Ss",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Upgrade",
              "value": "websocket"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "no-cache"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Pragma",
              "value": "no-cache"
            },
            {
              "name": "Connection",
              "value": "Upgrade"
            },
            {
              "name": "Sec-WebSocket-Key",
              "value": "kpwmGJb61XEqRlLT/5IBlw=="
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Sec-WebSocket-Version",
              "value": "13"
            },
            {
              "name": "Sec-WebSocket-Protocol",
              "value": "vite-hmr"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "Sec-WebSocket-Extensions",
              "value": "permessage-deflate; client_max_window_bits"
            }
          ],
          "queryString": [
            {
              "name": "token",
              "value": "B0ljPQ3LU_Ss"
            }
          ],
          "cookies": [],
          "headersSize": 593,
          "bodySize": 0
        },
        "response": {
          "status": 101,
          "statusText": "Switching Protocols",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Upgrade",
              "value": "websocket"
            },
            {
              "name": "Sec-WebSocket-Protocol",
              "value": "vite-hmr"
            },
            {
              "name": "Sec-WebSocket-Accept",
              "value": "vh8d2YfBiLPa1HrKlH5yogOHF5A="
            },
            {
              "name": "Connection",
              "value": "Upgrade"
            }
          ],
          "cookies": [],
          "content": {
            "size": 0,
            "mimeType": "x-unknown",
            "compression": 163
          },
          "redirectURL": "",
          "headersSize": 163,
          "bodySize": -163,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "",
        "startedDateTime": "2025-08-06T21:33:06.714Z",
        "time": 22.777999998652376,
        "timings": {
          "blocked": -1,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 22.777999998652376,
          "receive": 0,
          "_blocked_queueing": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/PromptInput.tsx",
          "lineNumber": 18
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/components/FileUpload.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"2e80-vgpZshwz+MM2XR6RIra/Re+OgOc\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/PromptInput.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 554,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 27463,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/components/FileUpload.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport * as RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.$RefreshReg$) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong.\"\n    );\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(\"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\");\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const useState = __vite__cjsImport3_react[\"useState\"]; const useRef = __vite__cjsImport3_react[\"useRef\"];\nconst FileUpload = ({\n  onFilesSelected,\n  maxFiles = 5,\n  maxSizeMB = 20,\n  acceptedTypes = [\"image/jpeg\", \"image/jpg\", \"image/png\", \"image/gif\", \"image/webp\", \"application/pdf\"]\n}) => {\n  _s();\n  const [uploadedFiles, setUploadedFiles] = useState([]);\n  const [dragActive, setDragActive] = useState(false);\n  const fileInputRef = useRef(null);\n  const handleDrag = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    if (e.type === \"dragenter\" || e.type === \"dragover\") {\n      setDragActive(true);\n    } else if (e.type === \"dragleave\") {\n      setDragActive(false);\n    }\n  };\n  const handleDrop = (e) => {\n    e.preventDefault();\n    e.stopPropagation();\n    setDragActive(false);\n    if (e.dataTransfer.files && e.dataTransfer.files[0]) {\n      handleFiles(Array.from(e.dataTransfer.files));\n    }\n  };\n  const handleChange = (e) => {\n    e.preventDefault();\n    if (e.target.files && e.target.files[0]) {\n      handleFiles(Array.from(e.target.files));\n    }\n  };\n  const handleFiles = (files) => {\n    const validFiles = [];\n    const errors = [];\n    files.forEach((file) => {\n      if (uploadedFiles.length + validFiles.length >= maxFiles) {\n        errors.push(`Mximo ${maxFiles} archivos permitidos`);\n        return;\n      }\n      if (!acceptedTypes.includes(file.type)) {\n        errors.push(`${file.name}: Tipo de archivo no permitido`);\n        return;\n      }\n      if (file.size > maxSizeMB * 1024 * 1024) {\n        errors.push(`${file.name}: Excede el tamao mximo de ${maxSizeMB}MB`);\n        return;\n      }\n      let preview;\n      if (file.type.startsWith(\"image/\")) {\n        preview = URL.createObjectURL(file);\n      }\n      validFiles.push({\n        file,\n        preview,\n        id: Math.random().toString(36).substr(2, 9)\n      });\n    });\n    if (errors.length > 0) {\n      alert(errors.join(\"\\n\"));\n    }\n    if (validFiles.length > 0) {\n      const newFiles = [...uploadedFiles, ...validFiles];\n      setUploadedFiles(newFiles);\n      onFilesSelected(newFiles.map((f) => f.file));\n    }\n  };\n  const removeFile = (id) => {\n    const newFiles = uploadedFiles.filter((f) => f.id !== id);\n    setUploadedFiles(newFiles);\n    onFilesSelected(newFiles.map((f) => f.file));\n    const file = uploadedFiles.find((f) => f.id === id);\n    if (file?.preview) {\n      URL.revokeObjectURL(file.preview);\n    }\n  };\n  const formatFileSize = (bytes) => {\n    if (bytes === 0) return \"0 Bytes\";\n    const k = 1024;\n    const sizes = [\"Bytes\", \"KB\", \"MB\"];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + \" \" + sizes[i];\n  };\n  return /* @__PURE__ */ jsxDEV(\"div\", { className: \"file-upload-container\", children: [\n    /* @__PURE__ */ jsxDEV(\n      \"div\",\n      {\n        className: `file-upload-dropzone ${dragActive ? \"drag-active\" : \"\"}`,\n        onDragEnter: handleDrag,\n        onDragLeave: handleDrag,\n        onDragOver: handleDrag,\n        onDrop: handleDrop,\n        onClick: () => fileInputRef.current?.click(),\n        children: [\n          /* @__PURE__ */ jsxDEV(\n            \"input\",\n            {\n              ref: fileInputRef,\n              type: \"file\",\n              multiple: true,\n              accept: acceptedTypes.join(\",\"),\n              onChange: handleChange,\n              style: { display: \"none\" }\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n              lineNumber: 149,\n              columnNumber: 9\n            },\n            this\n          ),\n          /* @__PURE__ */ jsxDEV(\"div\", { className: \"dropzone-content\", children: [\n            /* @__PURE__ */ jsxDEV(\"svg\", { className: \"upload-icon\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\n              \"path\",\n              {\n                strokeLinecap: \"round\",\n                strokeLinejoin: \"round\",\n                strokeWidth: \"2\",\n                d: \"M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12\"\n              },\n              void 0,\n              false,\n              {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n                lineNumber: 160,\n                columnNumber: 13\n              },\n              this\n            ) }, void 0, false, {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n              lineNumber: 159,\n              columnNumber: 11\n            }, this),\n            /* @__PURE__ */ jsxDEV(\"p\", { className: \"dropzone-text\", children: [\n              /* @__PURE__ */ jsxDEV(\"span\", { className: \"dropzone-text-primary\", children: \"Haz clic o arrastra archivos aqu\" }, void 0, false, {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n                lineNumber: 164,\n                columnNumber: 13\n              }, this),\n              /* @__PURE__ */ jsxDEV(\"span\", { className: \"dropzone-text-secondary\", children: [\n                \"Imgenes (JPG, PNG, GIF, WebP) o PDFs - Mx. \",\n                maxSizeMB,\n                \"MB\"\n              ] }, void 0, true, {\n                fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n                lineNumber: 165,\n                columnNumber: 13\n              }, this)\n            ] }, void 0, true, {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n              lineNumber: 163,\n              columnNumber: 11\n            }, this)\n          ] }, void 0, true, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n            lineNumber: 158,\n            columnNumber: 9\n          }, this)\n        ]\n      },\n      void 0,\n      true,\n      {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n        lineNumber: 141,\n        columnNumber: 7\n      },\n      this\n    ),\n    uploadedFiles.length > 0 && /* @__PURE__ */ jsxDEV(\"div\", { className: \"uploaded-files-list\", children: uploadedFiles.map(\n      ({ file, preview, id }) => /* @__PURE__ */ jsxDEV(\"div\", { className: \"uploaded-file-item\", children: [\n        preview ? /* @__PURE__ */ jsxDEV(\"img\", { src: preview, alt: file.name, className: \"file-preview-image\" }, void 0, false, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n          lineNumber: 177,\n          columnNumber: 11\n        }, this) : /* @__PURE__ */ jsxDEV(\"div\", { className: \"file-preview-pdf\", children: /* @__PURE__ */ jsxDEV(\"svg\", { className: \"pdf-icon\", fill: \"currentColor\", viewBox: \"0 0 20 20\", children: /* @__PURE__ */ jsxDEV(\"path\", { d: \"M4 18h12V6h-4V2H4v16zm8-12h3.586L12 2.414V6z\" }, void 0, false, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n          lineNumber: 181,\n          columnNumber: 21\n        }, this) }, void 0, false, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n          lineNumber: 180,\n          columnNumber: 19\n        }, this) }, void 0, false, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n          lineNumber: 179,\n          columnNumber: 11\n        }, this),\n        /* @__PURE__ */ jsxDEV(\"div\", { className: \"file-info\", children: [\n          /* @__PURE__ */ jsxDEV(\"p\", { className: \"file-name\", children: file.name }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n            lineNumber: 186,\n            columnNumber: 17\n          }, this),\n          /* @__PURE__ */ jsxDEV(\"p\", { className: \"file-size\", children: formatFileSize(file.size) }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n            lineNumber: 187,\n            columnNumber: 17\n          }, this)\n        ] }, void 0, true, {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n          lineNumber: 185,\n          columnNumber: 15\n        }, this),\n        /* @__PURE__ */ jsxDEV(\n          \"button\",\n          {\n            onClick: (e) => {\n              e.stopPropagation();\n              removeFile(id);\n            },\n            className: \"file-remove-button\",\n            title: \"Eliminar archivo\",\n            children: /* @__PURE__ */ jsxDEV(\"svg\", { className: \"remove-icon\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"2\", d: \"M6 18L18 6M6 6l12 12\" }, void 0, false, {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n              lineNumber: 198,\n              columnNumber: 19\n            }, this) }, void 0, false, {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n              lineNumber: 197,\n              columnNumber: 17\n            }, this)\n          },\n          void 0,\n          false,\n          {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n            lineNumber: 189,\n            columnNumber: 15\n          },\n          this\n        )\n      ] }, id, true, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n        lineNumber: 175,\n        columnNumber: 9\n      }, this)\n    ) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n      lineNumber: 173,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\",\n    lineNumber: 140,\n    columnNumber: 5\n  }, this);\n};\n_s(FileUpload, \"gkE4PywNA7CMvhxQjm/mnxv2usc=\");\n_c = FileUpload;\nexport default FileUpload;\nvar _c;\n$RefreshReg$(_c, \"FileUpload\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n}\nif (import.meta.hot && !inWebWorker) {\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(\"/home/jano/DEV_WSL/LLM/src/frontend/components/FileUpload.tsx\", currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBaUlROzs7Ozs7Ozs7Ozs7Ozs7OztBQWpJUixTQUFnQkEsVUFBVUMsY0FBYztBQWV4QyxNQUFNQyxhQUF3Q0EsQ0FBQztBQUFBLEVBQzdDQztBQUFBQSxFQUNBQyxXQUFXO0FBQUEsRUFDWEMsWUFBWTtBQUFBLEVBQ1pDLGdCQUFnQixDQUFDLGNBQWMsYUFBYSxhQUFhLGFBQWEsY0FBYyxpQkFBaUI7QUFDdkcsTUFBTTtBQUFBQyxLQUFBO0FBQ0osUUFBTSxDQUFDQyxlQUFlQyxnQkFBZ0IsSUFBSVQsU0FBeUIsRUFBRTtBQUNyRSxRQUFNLENBQUNVLFlBQVlDLGFBQWEsSUFBSVgsU0FBUyxLQUFLO0FBQ2xELFFBQU1ZLGVBQWVYLE9BQXlCLElBQUk7QUFFbEQsUUFBTVksYUFBYUEsQ0FBQ0MsTUFBdUI7QUFDekNBLE1BQUVDLGVBQWU7QUFDakJELE1BQUVFLGdCQUFnQjtBQUNsQixRQUFJRixFQUFFRyxTQUFTLGVBQWVILEVBQUVHLFNBQVMsWUFBWTtBQUNuRE4sb0JBQWMsSUFBSTtBQUFBLElBQ3BCLFdBQVdHLEVBQUVHLFNBQVMsYUFBYTtBQUNqQ04sb0JBQWMsS0FBSztBQUFBLElBQ3JCO0FBQUEsRUFDRjtBQUVBLFFBQU1PLGFBQWFBLENBQUNKLE1BQXVCO0FBQ3pDQSxNQUFFQyxlQUFlO0FBQ2pCRCxNQUFFRSxnQkFBZ0I7QUFDbEJMLGtCQUFjLEtBQUs7QUFFbkIsUUFBSUcsRUFBRUssYUFBYUMsU0FBU04sRUFBRUssYUFBYUMsTUFBTSxDQUFDLEdBQUc7QUFDbkRDLGtCQUFZQyxNQUFNQyxLQUFLVCxFQUFFSyxhQUFhQyxLQUFLLENBQUM7QUFBQSxJQUM5QztBQUFBLEVBQ0Y7QUFFQSxRQUFNSSxlQUFlQSxDQUFDVixNQUEyQztBQUMvREEsTUFBRUMsZUFBZTtBQUNqQixRQUFJRCxFQUFFVyxPQUFPTCxTQUFTTixFQUFFVyxPQUFPTCxNQUFNLENBQUMsR0FBRztBQUN2Q0Msa0JBQVlDLE1BQU1DLEtBQUtULEVBQUVXLE9BQU9MLEtBQUssQ0FBQztBQUFBLElBQ3hDO0FBQUEsRUFDRjtBQUVBLFFBQU1DLGNBQWNBLENBQUNELFVBQWtCO0FBQ3JDLFVBQU1NLGFBQTZCO0FBQ25DLFVBQU1DLFNBQW1CO0FBRXpCUCxVQUFNUSxRQUFRLENBQUFDLFNBQVE7QUFFcEIsVUFBSXJCLGNBQWNzQixTQUFTSixXQUFXSSxVQUFVMUIsVUFBVTtBQUN4RHVCLGVBQU9JLEtBQUssVUFBVTNCLFFBQVEsc0JBQXNCO0FBQ3BEO0FBQUEsTUFDRjtBQUdBLFVBQUksQ0FBQ0UsY0FBYzBCLFNBQVNILEtBQUtaLElBQUksR0FBRztBQUN0Q1UsZUFBT0ksS0FBSyxHQUFHRixLQUFLSSxJQUFJLGdDQUFnQztBQUN4RDtBQUFBLE1BQ0Y7QUFHQSxVQUFJSixLQUFLSyxPQUFPN0IsWUFBWSxPQUFPLE1BQU07QUFDdkNzQixlQUFPSSxLQUFLLEdBQUdGLEtBQUtJLElBQUksZ0NBQWdDNUIsU0FBUyxJQUFJO0FBQ3JFO0FBQUEsTUFDRjtBQUdBLFVBQUk4QjtBQUNKLFVBQUlOLEtBQUtaLEtBQUttQixXQUFXLFFBQVEsR0FBRztBQUNsQ0Qsa0JBQVVFLElBQUlDLGdCQUFnQlQsSUFBSTtBQUFBLE1BQ3BDO0FBRUFILGlCQUFXSyxLQUFLO0FBQUEsUUFDZEY7QUFBQUEsUUFDQU07QUFBQUEsUUFDQUksSUFBSUMsS0FBS0MsT0FBTyxFQUFFQyxTQUFTLEVBQUUsRUFBRUMsT0FBTyxHQUFHLENBQUM7QUFBQSxNQUM1QyxDQUFDO0FBQUEsSUFDSCxDQUFDO0FBRUQsUUFBSWhCLE9BQU9HLFNBQVMsR0FBRztBQUNyQmMsWUFBTWpCLE9BQU9rQixLQUFLLElBQUksQ0FBQztBQUFBLElBQ3pCO0FBRUEsUUFBSW5CLFdBQVdJLFNBQVMsR0FBRztBQUN6QixZQUFNZ0IsV0FBVyxDQUFDLEdBQUd0QyxlQUFlLEdBQUdrQixVQUFVO0FBQ2pEakIsdUJBQWlCcUMsUUFBUTtBQUN6QjNDLHNCQUFnQjJDLFNBQVNDLElBQUksQ0FBQUMsTUFBS0EsRUFBRW5CLElBQUksQ0FBQztBQUFBLElBQzNDO0FBQUEsRUFDRjtBQUVBLFFBQU1vQixhQUFhQSxDQUFDVixPQUFlO0FBQ2pDLFVBQU1PLFdBQVd0QyxjQUFjMEMsT0FBTyxDQUFBRixNQUFLQSxFQUFFVCxPQUFPQSxFQUFFO0FBQ3REOUIscUJBQWlCcUMsUUFBUTtBQUN6QjNDLG9CQUFnQjJDLFNBQVNDLElBQUksQ0FBQUMsTUFBS0EsRUFBRW5CLElBQUksQ0FBQztBQUd6QyxVQUFNQSxPQUFPckIsY0FBYzJDLEtBQUssQ0FBQUgsTUFBS0EsRUFBRVQsT0FBT0EsRUFBRTtBQUNoRCxRQUFJVixNQUFNTSxTQUFTO0FBQ2pCRSxVQUFJZSxnQkFBZ0J2QixLQUFLTSxPQUFPO0FBQUEsSUFDbEM7QUFBQSxFQUNGO0FBRUEsUUFBTWtCLGlCQUFpQkEsQ0FBQ0MsVUFBMEI7QUFDaEQsUUFBSUEsVUFBVSxFQUFHLFFBQU87QUFDeEIsVUFBTUMsSUFBSTtBQUNWLFVBQU1DLFFBQVEsQ0FBQyxTQUFTLE1BQU0sSUFBSTtBQUNsQyxVQUFNQyxJQUFJakIsS0FBS2tCLE1BQU1sQixLQUFLbUIsSUFBSUwsS0FBSyxJQUFJZCxLQUFLbUIsSUFBSUosQ0FBQyxDQUFDO0FBQ2xELFdBQU9mLEtBQUtvQixNQUFNTixRQUFRZCxLQUFLcUIsSUFBSU4sR0FBR0UsQ0FBQyxJQUFJLEdBQUcsSUFBSSxNQUFNLE1BQU1ELE1BQU1DLENBQUM7QUFBQSxFQUN2RTtBQUVBLFNBQ0UsdUJBQUMsU0FBSSxXQUFVLHlCQUNiO0FBQUE7QUFBQSxNQUFDO0FBQUE7QUFBQSxRQUNDLFdBQVcsd0JBQXdCL0MsYUFBYSxnQkFBZ0IsRUFBRTtBQUFBLFFBQ2xFLGFBQWFHO0FBQUFBLFFBQ2IsYUFBYUE7QUFBQUEsUUFDYixZQUFZQTtBQUFBQSxRQUNaLFFBQVFLO0FBQUFBLFFBQ1IsU0FBUyxNQUFNTixhQUFha0QsU0FBU0MsTUFBTTtBQUFBLFFBRTNDO0FBQUE7QUFBQSxZQUFDO0FBQUE7QUFBQSxjQUNDLEtBQUtuRDtBQUFBQSxjQUNMLE1BQUs7QUFBQSxjQUNMO0FBQUEsY0FDQSxRQUFRTixjQUFjdUMsS0FBSyxHQUFHO0FBQUEsY0FDOUIsVUFBVXJCO0FBQUFBLGNBQ1YsT0FBTyxFQUFFd0MsU0FBUyxPQUFPO0FBQUE7QUFBQSxZQU4zQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFNNkI7QUFBQSxVQUc3Qix1QkFBQyxTQUFJLFdBQVUsb0JBQ2I7QUFBQSxtQ0FBQyxTQUFJLFdBQVUsZUFBYyxNQUFLLFFBQU8sUUFBTyxnQkFBZSxTQUFRLGFBQ3JFO0FBQUEsY0FBQztBQUFBO0FBQUEsZ0JBQUssZUFBYztBQUFBLGdCQUFRLGdCQUFlO0FBQUEsZ0JBQVEsYUFBWTtBQUFBLGdCQUM3RCxHQUFFO0FBQUE7QUFBQSxjQURKO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxZQUMyRixLQUY3RjtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUdBO0FBQUEsWUFDQSx1QkFBQyxPQUFFLFdBQVUsaUJBQ1g7QUFBQSxxQ0FBQyxVQUFLLFdBQVUseUJBQXdCLGlEQUF4QztBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQUF5RTtBQUFBLGNBQ3pFLHVCQUFDLFVBQUssV0FBVSwyQkFBeUI7QUFBQTtBQUFBLGdCQUNPM0Q7QUFBQUEsZ0JBQVU7QUFBQSxtQkFEMUQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFFQTtBQUFBLGlCQUpGO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBS0E7QUFBQSxlQVZGO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBV0E7QUFBQTtBQUFBO0FBQUEsTUE1QkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBNkJBO0FBQUEsSUFFQ0csY0FBY3NCLFNBQVMsS0FDdEIsdUJBQUMsU0FBSSxXQUFVLHVCQUNadEIsd0JBQWN1QztBQUFBQSxNQUFJLENBQUMsRUFBRWxCLE1BQU1NLFNBQVNJLEdBQUcsTUFDdEMsdUJBQUMsU0FBYSxXQUFVLHNCQUNyQko7QUFBQUEsa0JBQ0MsdUJBQUMsU0FBSSxLQUFLQSxTQUFTLEtBQUtOLEtBQUtJLE1BQU0sV0FBVSx3QkFBN0M7QUFBQTtBQUFBO0FBQUE7QUFBQSxlQUFpRSxJQUVqRSx1QkFBQyxTQUFJLFdBQVUsb0JBQ2IsaUNBQUMsU0FBSSxXQUFVLFlBQVcsTUFBSyxnQkFBZSxTQUFRLGFBQ3BELGlDQUFDLFVBQUssR0FBRSxrREFBUjtBQUFBO0FBQUE7QUFBQTtBQUFBLGVBQXNELEtBRHhEO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFFQSxLQUhGO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFJQTtBQUFBLFFBRUYsdUJBQUMsU0FBSSxXQUFVLGFBQ2I7QUFBQSxpQ0FBQyxPQUFFLFdBQVUsYUFBYUosZUFBS0ksUUFBL0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFBb0M7QUFBQSxVQUNwQyx1QkFBQyxPQUFFLFdBQVUsYUFBYW9CLHlCQUFleEIsS0FBS0ssSUFBSSxLQUFsRDtBQUFBO0FBQUE7QUFBQTtBQUFBLGlCQUFvRDtBQUFBLGFBRnREO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFHQTtBQUFBLFFBQ0E7QUFBQSxVQUFDO0FBQUE7QUFBQSxZQUNDLFNBQVMsQ0FBQ3BCLE1BQU07QUFDZEEsZ0JBQUVFLGdCQUFnQjtBQUNsQmlDLHlCQUFXVixFQUFFO0FBQUEsWUFDZjtBQUFBLFlBQ0EsV0FBVTtBQUFBLFlBQ1YsT0FBTTtBQUFBLFlBRU4saUNBQUMsU0FBSSxXQUFVLGVBQWMsTUFBSyxRQUFPLFFBQU8sZ0JBQWUsU0FBUSxhQUNyRSxpQ0FBQyxVQUFLLGVBQWMsU0FBUSxnQkFBZSxTQUFRLGFBQVksS0FBSSxHQUFFLDBCQUFyRTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUEyRixLQUQ3RjtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUVBO0FBQUE7QUFBQSxVQVZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQVdBO0FBQUEsV0F6QlFBLElBQVY7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQTBCQTtBQUFBLElBQ0QsS0E3Qkg7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQThCQTtBQUFBLE9BL0RKO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FpRUE7QUFFSjtBQUFFaEMsR0E1S0lMLFlBQXFDO0FBQUErRCxLQUFyQy9EO0FBOEtOLGVBQWVBO0FBQVcsSUFBQStEO0FBQUFDLGFBQUFELElBQUEiLCJuYW1lcyI6WyJ1c2VTdGF0ZSIsInVzZVJlZiIsIkZpbGVVcGxvYWQiLCJvbkZpbGVzU2VsZWN0ZWQiLCJtYXhGaWxlcyIsIm1heFNpemVNQiIsImFjY2VwdGVkVHlwZXMiLCJfcyIsInVwbG9hZGVkRmlsZXMiLCJzZXRVcGxvYWRlZEZpbGVzIiwiZHJhZ0FjdGl2ZSIsInNldERyYWdBY3RpdmUiLCJmaWxlSW5wdXRSZWYiLCJoYW5kbGVEcmFnIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidHlwZSIsImhhbmRsZURyb3AiLCJkYXRhVHJhbnNmZXIiLCJmaWxlcyIsImhhbmRsZUZpbGVzIiwiQXJyYXkiLCJmcm9tIiwiaGFuZGxlQ2hhbmdlIiwidGFyZ2V0IiwidmFsaWRGaWxlcyIsImVycm9ycyIsImZvckVhY2giLCJmaWxlIiwibGVuZ3RoIiwicHVzaCIsImluY2x1ZGVzIiwibmFtZSIsInNpemUiLCJwcmV2aWV3Iiwic3RhcnRzV2l0aCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImlkIiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyIiwiYWxlcnQiLCJqb2luIiwibmV3RmlsZXMiLCJtYXAiLCJmIiwicmVtb3ZlRmlsZSIsImZpbHRlciIsImZpbmQiLCJyZXZva2VPYmplY3RVUkwiLCJmb3JtYXRGaWxlU2l6ZSIsImJ5dGVzIiwiayIsInNpemVzIiwiaSIsImZsb29yIiwibG9nIiwicm91bmQiLCJwb3ciLCJjdXJyZW50IiwiY2xpY2siLCJkaXNwbGF5IiwiX2MiLCIkUmVmcmVzaFJlZyQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZXMiOlsiRmlsZVVwbG9hZC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5cbmludGVyZmFjZSBGaWxlVXBsb2FkUHJvcHMge1xuICBvbkZpbGVzU2VsZWN0ZWQ6IChmaWxlczogRmlsZVtdKSA9PiB2b2lkO1xuICBtYXhGaWxlcz86IG51bWJlcjtcbiAgbWF4U2l6ZU1CPzogbnVtYmVyO1xuICBhY2NlcHRlZFR5cGVzPzogc3RyaW5nW107XG59XG5cbmludGVyZmFjZSBVcGxvYWRlZEZpbGUge1xuICBmaWxlOiBGaWxlO1xuICBwcmV2aWV3Pzogc3RyaW5nO1xuICBpZDogc3RyaW5nO1xufVxuXG5jb25zdCBGaWxlVXBsb2FkOiBSZWFjdC5GQzxGaWxlVXBsb2FkUHJvcHM+ID0gKHtcbiAgb25GaWxlc1NlbGVjdGVkLFxuICBtYXhGaWxlcyA9IDUsXG4gIG1heFNpemVNQiA9IDIwLFxuICBhY2NlcHRlZFR5cGVzID0gWydpbWFnZS9qcGVnJywgJ2ltYWdlL2pwZycsICdpbWFnZS9wbmcnLCAnaW1hZ2UvZ2lmJywgJ2ltYWdlL3dlYnAnLCAnYXBwbGljYXRpb24vcGRmJ11cbn0pID0+IHtcbiAgY29uc3QgW3VwbG9hZGVkRmlsZXMsIHNldFVwbG9hZGVkRmlsZXNdID0gdXNlU3RhdGU8VXBsb2FkZWRGaWxlW10+KFtdKTtcbiAgY29uc3QgW2RyYWdBY3RpdmUsIHNldERyYWdBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XG5cbiAgY29uc3QgaGFuZGxlRHJhZyA9IChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBpZiAoZS50eXBlID09PSBcImRyYWdlbnRlclwiIHx8IGUudHlwZSA9PT0gXCJkcmFnb3ZlclwiKSB7XG4gICAgICBzZXREcmFnQWN0aXZlKHRydWUpO1xuICAgIH0gZWxzZSBpZiAoZS50eXBlID09PSBcImRyYWdsZWF2ZVwiKSB7XG4gICAgICBzZXREcmFnQWN0aXZlKGZhbHNlKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlRHJvcCA9IChlOiBSZWFjdC5EcmFnRXZlbnQpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzZXREcmFnQWN0aXZlKGZhbHNlKTtcbiAgICBcbiAgICBpZiAoZS5kYXRhVHJhbnNmZXIuZmlsZXMgJiYgZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF0pIHtcbiAgICAgIGhhbmRsZUZpbGVzKEFycmF5LmZyb20oZS5kYXRhVHJhbnNmZXIuZmlsZXMpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKGU6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGlmIChlLnRhcmdldC5maWxlcyAmJiBlLnRhcmdldC5maWxlc1swXSkge1xuICAgICAgaGFuZGxlRmlsZXMoQXJyYXkuZnJvbShlLnRhcmdldC5maWxlcykpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVGaWxlcyA9IChmaWxlczogRmlsZVtdKSA9PiB7XG4gICAgY29uc3QgdmFsaWRGaWxlczogVXBsb2FkZWRGaWxlW10gPSBbXTtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICBmaWxlcy5mb3JFYWNoKGZpbGUgPT4ge1xuICAgICAgLy8gQ2hlY2sgZmlsZSBjb3VudFxuICAgICAgaWYgKHVwbG9hZGVkRmlsZXMubGVuZ3RoICsgdmFsaWRGaWxlcy5sZW5ndGggPj0gbWF4RmlsZXMpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYE3DoXhpbW8gJHttYXhGaWxlc30gYXJjaGl2b3MgcGVybWl0aWRvc2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZpbGUgdHlwZVxuICAgICAgaWYgKCFhY2NlcHRlZFR5cGVzLmluY2x1ZGVzKGZpbGUudHlwZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goYCR7ZmlsZS5uYW1lfTogVGlwbyBkZSBhcmNoaXZvIG5vIHBlcm1pdGlkb2ApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZpbGUgc2l6ZVxuICAgICAgaWYgKGZpbGUuc2l6ZSA+IG1heFNpemVNQiAqIDEwMjQgKiAxMDI0KSB7XG4gICAgICAgIGVycm9ycy5wdXNoKGAke2ZpbGUubmFtZX06IEV4Y2VkZSBlbCB0YW1hw7FvIG3DoXhpbW8gZGUgJHttYXhTaXplTUJ9TUJgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgcHJldmlldyBmb3IgaW1hZ2VzXG4gICAgICBsZXQgcHJldmlldzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAgICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICBwcmV2aWV3ID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcbiAgICAgIH1cblxuICAgICAgdmFsaWRGaWxlcy5wdXNoKHtcbiAgICAgICAgZmlsZSxcbiAgICAgICAgcHJldmlldyxcbiAgICAgICAgaWQ6IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIGFsZXJ0KGVycm9ycy5qb2luKCdcXG4nKSk7XG4gICAgfVxuXG4gICAgaWYgKHZhbGlkRmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbmV3RmlsZXMgPSBbLi4udXBsb2FkZWRGaWxlcywgLi4udmFsaWRGaWxlc107XG4gICAgICBzZXRVcGxvYWRlZEZpbGVzKG5ld0ZpbGVzKTtcbiAgICAgIG9uRmlsZXNTZWxlY3RlZChuZXdGaWxlcy5tYXAoZiA9PiBmLmZpbGUpKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmVtb3ZlRmlsZSA9IChpZDogc3RyaW5nKSA9PiB7XG4gICAgY29uc3QgbmV3RmlsZXMgPSB1cGxvYWRlZEZpbGVzLmZpbHRlcihmID0+IGYuaWQgIT09IGlkKTtcbiAgICBzZXRVcGxvYWRlZEZpbGVzKG5ld0ZpbGVzKTtcbiAgICBvbkZpbGVzU2VsZWN0ZWQobmV3RmlsZXMubWFwKGYgPT4gZi5maWxlKSk7XG4gICAgXG4gICAgLy8gUmV2b2tlIG9iamVjdCBVUkwgdG8gZnJlZSBtZW1vcnlcbiAgICBjb25zdCBmaWxlID0gdXBsb2FkZWRGaWxlcy5maW5kKGYgPT4gZi5pZCA9PT0gaWQpO1xuICAgIGlmIChmaWxlPy5wcmV2aWV3KSB7XG4gICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKGZpbGUucHJldmlldyk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGZvcm1hdEZpbGVTaXplID0gKGJ5dGVzOiBudW1iZXIpOiBzdHJpbmcgPT4ge1xuICAgIGlmIChieXRlcyA9PT0gMCkgcmV0dXJuICcwIEJ5dGVzJztcbiAgICBjb25zdCBrID0gMTAyNDtcbiAgICBjb25zdCBzaXplcyA9IFsnQnl0ZXMnLCAnS0InLCAnTUInXTtcbiAgICBjb25zdCBpID0gTWF0aC5mbG9vcihNYXRoLmxvZyhieXRlcykgLyBNYXRoLmxvZyhrKSk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQoYnl0ZXMgLyBNYXRoLnBvdyhrLCBpKSAqIDEwMCkgLyAxMDAgKyAnICcgKyBzaXplc1tpXTtcbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmlsZS11cGxvYWQtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IFxuICAgICAgICBjbGFzc05hbWU9e2BmaWxlLXVwbG9hZC1kcm9wem9uZSAke2RyYWdBY3RpdmUgPyAnZHJhZy1hY3RpdmUnIDogJyd9YH1cbiAgICAgICAgb25EcmFnRW50ZXI9e2hhbmRsZURyYWd9XG4gICAgICAgIG9uRHJhZ0xlYXZlPXtoYW5kbGVEcmFnfVxuICAgICAgICBvbkRyYWdPdmVyPXtoYW5kbGVEcmFnfVxuICAgICAgICBvbkRyb3A9e2hhbmRsZURyb3B9XG4gICAgICAgIG9uQ2xpY2s9eygpID0+IGZpbGVJbnB1dFJlZi5jdXJyZW50Py5jbGljaygpfVxuICAgICAgPlxuICAgICAgICA8aW5wdXRcbiAgICAgICAgICByZWY9e2ZpbGVJbnB1dFJlZn1cbiAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgbXVsdGlwbGVcbiAgICAgICAgICBhY2NlcHQ9e2FjY2VwdGVkVHlwZXMuam9pbignLCcpfVxuICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XG4gICAgICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ25vbmUnIH19XG4gICAgICAgIC8+XG4gICAgICAgIFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRyb3B6b25lLWNvbnRlbnRcIj5cbiAgICAgICAgICA8c3ZnIGNsYXNzTmFtZT1cInVwbG9hZC1pY29uXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgICA8cGF0aCBzdHJva2VMaW5lY2FwPVwicm91bmRcIiBzdHJva2VMaW5lam9pbj1cInJvdW5kXCIgc3Ryb2tlV2lkdGg9XCIyXCIgXG4gICAgICAgICAgICAgIGQ9XCJNNyAxNmE0IDQgMCAwMS0uODgtNy45MDNBNSA1IDAgMTExNS45IDZMMTYgNmE1IDUgMCAwMTEgOS45TTE1IDEzbC0zLTNtMCAwbC0zIDNtMy0zdjEyXCIgLz5cbiAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJkcm9wem9uZS10ZXh0XCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJkcm9wem9uZS10ZXh0LXByaW1hcnlcIj5IYXogY2xpYyBvIGFycmFzdHJhIGFyY2hpdm9zIGFxdcOtPC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZHJvcHpvbmUtdGV4dC1zZWNvbmRhcnlcIj5cbiAgICAgICAgICAgICAgSW3DoWdlbmVzIChKUEcsIFBORywgR0lGLCBXZWJQKSBvIFBERnMgLSBNw6F4LiB7bWF4U2l6ZU1CfU1CXG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuXG4gICAgICB7dXBsb2FkZWRGaWxlcy5sZW5ndGggPiAwICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ1cGxvYWRlZC1maWxlcy1saXN0XCI+XG4gICAgICAgICAge3VwbG9hZGVkRmlsZXMubWFwKCh7IGZpbGUsIHByZXZpZXcsIGlkIH0pID0+IChcbiAgICAgICAgICAgIDxkaXYga2V5PXtpZH0gY2xhc3NOYW1lPVwidXBsb2FkZWQtZmlsZS1pdGVtXCI+XG4gICAgICAgICAgICAgIHtwcmV2aWV3ID8gKFxuICAgICAgICAgICAgICAgIDxpbWcgc3JjPXtwcmV2aWV3fSBhbHQ9e2ZpbGUubmFtZX0gY2xhc3NOYW1lPVwiZmlsZS1wcmV2aWV3LWltYWdlXCIgLz5cbiAgICAgICAgICAgICAgKSA6IChcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZpbGUtcHJldmlldy1wZGZcIj5cbiAgICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwicGRmLWljb25cIiBmaWxsPVwiY3VycmVudENvbG9yXCIgdmlld0JveD1cIjAgMCAyMCAyMFwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTQgMThoMTJWNmgtNFYySDR2MTZ6bTgtMTJoMy41ODZMMTIgMi40MTRWNnpcIi8+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmaWxlLWluZm9cIj5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmaWxlLW5hbWVcIj57ZmlsZS5uYW1lfTwvcD5cbiAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJmaWxlLXNpemVcIj57Zm9ybWF0RmlsZVNpemUoZmlsZS5zaXplKX08L3A+XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgb25DbGljaz17KGUpID0+IHtcbiAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICByZW1vdmVGaWxlKGlkKTtcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImZpbGUtcmVtb3ZlLWJ1dHRvblwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJFbGltaW5hciBhcmNoaXZvXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwicmVtb3ZlLWljb25cIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD1cIjJcIiBkPVwiTTYgMThMMTggNk02IDZsMTIgMTJcIiAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICkpfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGaWxlVXBsb2FkOyJdLCJmaWxlIjoiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvY29tcG9uZW50cy9GaWxlVXBsb2FkLnRzeCJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.715Z",
        "time": 4.005999999208143,
        "timings": {
          "blocked": 1.6209999988649506,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.08999999999999997,
          "wait": 1.784999998674961,
          "receive": 0.5100000016682316,
          "_blocked_queueing": 1.1249999988649506,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/LLMResponseBox.tsx",
          "lineNumber": 18
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"2734-Npy7T7Xx/xAMhNMZ1tCZHHWr4X4\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/LLMResponseBox.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 569,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 21107,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/components/SimpleMarkdownRenderer.tsx\");import __vite__cjsImport0_react_jsxDevRuntime from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react_jsx-dev-runtime.js?v=2a7591ed\"; const jsxDEV = __vite__cjsImport0_react_jsxDevRuntime[\"jsxDEV\"];\nimport * as RefreshRuntime from \"/@react-refresh\";\nconst inWebWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\nlet prevRefreshReg;\nlet prevRefreshSig;\nif (import.meta.hot && !inWebWorker) {\n  if (!window.$RefreshReg$) {\n    throw new Error(\n      \"@vitejs/plugin-react can't detect preamble. Something is wrong.\"\n    );\n  }\n  prevRefreshReg = window.$RefreshReg$;\n  prevRefreshSig = window.$RefreshSig$;\n  window.$RefreshReg$ = RefreshRuntime.getRefreshReg(\"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\");\n  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;\n}\nvar _s = $RefreshSig$();\nimport __vite__cjsImport3_react from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react.js?v=2a7591ed\"; const useState = __vite__cjsImport3_react[\"useState\"]; const useCallback = __vite__cjsImport3_react[\"useCallback\"];\nimport ReactMarkdown from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-markdown.js?v=2a7591ed\";\nimport remarkGfm from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-gfm.js?v=2a7591ed\";\nimport remarkMath from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed\";\nimport rehypeKatex from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-katex.js?v=2a7591ed\";\nimport rehypeSanitize, { defaultSchema } from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-sanitize.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/katex.min.css\";\nconst CodeBlock = ({ children, className, inline }) => {\n  _s();\n  const [copied, setCopied] = useState(false);\n  const handleCopy = useCallback(async () => {\n    try {\n      await navigator.clipboard.writeText(children);\n      setCopied(true);\n      setTimeout(() => setCopied(false), 2e3);\n    } catch (err) {\n      console.error(\"Error copying code:\", err);\n    }\n  }, [children]);\n  const language = className ? className.replace(\"language-\", \"\") : \"\";\n  if (inline) {\n    return /* @__PURE__ */ jsxDEV(\"code\", { className: \"inline-code\", children }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 57,\n      columnNumber: 12\n    }, this);\n  }\n  return /* @__PURE__ */ jsxDEV(\"div\", { className: \"code-block-wrapper\", children: [\n    /* @__PURE__ */ jsxDEV(\"div\", { className: \"code-block-header\", children: [\n      language && /* @__PURE__ */ jsxDEV(\"span\", { className: \"code-language\", children: language }, void 0, false, {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n        lineNumber: 64,\n        columnNumber: 9\n      }, this),\n      /* @__PURE__ */ jsxDEV(\n        \"button\",\n        {\n          onClick: handleCopy,\n          className: \"copy-code-button\",\n          title: \"Copiar cdigo\",\n          children: copied ? /* @__PURE__ */ jsxDEV(\"svg\", { className: \"copy-icon\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\"path\", { strokeLinecap: \"round\", strokeLinejoin: \"round\", strokeWidth: \"2\", d: \"M5 13l4 4L19 7\" }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n            lineNumber: 73,\n            columnNumber: 15\n          }, this) }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n            lineNumber: 72,\n            columnNumber: 11\n          }, this) : /* @__PURE__ */ jsxDEV(\"svg\", { className: \"copy-icon\", fill: \"none\", stroke: \"currentColor\", viewBox: \"0 0 24 24\", children: /* @__PURE__ */ jsxDEV(\n            \"path\",\n            {\n              strokeLinecap: \"round\",\n              strokeLinejoin: \"round\",\n              strokeWidth: \"2\",\n              d: \"M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z\"\n            },\n            void 0,\n            false,\n            {\n              fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n              lineNumber: 77,\n              columnNumber: 15\n            },\n            this\n          ) }, void 0, false, {\n            fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n            lineNumber: 76,\n            columnNumber: 11\n          }, this)\n        },\n        void 0,\n        false,\n        {\n          fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n          lineNumber: 66,\n          columnNumber: 9\n        },\n        this\n      )\n    ] }, void 0, true, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 62,\n      columnNumber: 7\n    }, this),\n    /* @__PURE__ */ jsxDEV(\"pre\", { className: `code-block ${className || \"\"}`, children: /* @__PURE__ */ jsxDEV(\"code\", { className, children }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 84,\n      columnNumber: 9\n    }, this) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 83,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n    lineNumber: 61,\n    columnNumber: 5\n  }, this);\n};\n_s(CodeBlock, \"p/6Yo8FQEJZXv4gOdZmefYkNrGA=\");\n_c = CodeBlock;\nconst SimpleMarkdownRenderer = ({\n  content,\n  isStreaming = false,\n  className = \"\"\n}) => {\n  const sanitizeSchema = {\n    ...defaultSchema,\n    tagNames: [\n      ...defaultSchema.tagNames,\n      \"math\",\n      \"semantics\",\n      \"mrow\",\n      \"mo\",\n      \"mi\",\n      \"mn\",\n      \"mtext\",\n      \"mspace\",\n      \"mover\",\n      \"munder\",\n      \"munderover\",\n      \"msub\",\n      \"msup\",\n      \"msubsup\",\n      \"mfrac\",\n      \"msqrt\",\n      \"mroot\",\n      \"mtable\",\n      \"mtr\",\n      \"mtd\",\n      \"annotation\"\n    ],\n    attributes: {\n      ...defaultSchema.attributes,\n      \"*\": [...defaultSchema.attributes[\"*\"] || [], \"className\", \"style\"],\n      \"math\": [\"xmlns\"],\n      \"semantics\": [\"*\"],\n      \"annotation\": [\"encoding\"]\n    }\n  };\n  const components = {\n    code: CodeBlock,\n    // Custom table styling\n    table: ({ children, ...props }) => /* @__PURE__ */ jsxDEV(\"div\", { className: \"table-wrapper\", children: /* @__PURE__ */ jsxDEV(\"table\", { className: \"markdown-table\", ...props, children }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 120,\n      columnNumber: 9\n    }, this) }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 119,\n      columnNumber: 5\n    }, this),\n    // Custom blockquote styling\n    blockquote: ({ children, ...props }) => /* @__PURE__ */ jsxDEV(\"blockquote\", { className: \"markdown-blockquote\", ...props, children }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 127,\n      columnNumber: 5\n    }, this),\n    // Custom link styling with security\n    a: ({ children, href, ...props }) => /* @__PURE__ */ jsxDEV(\n      \"a\",\n      {\n        href,\n        target: \"_blank\",\n        rel: \"noopener noreferrer\",\n        className: \"markdown-link\",\n        ...props,\n        children\n      },\n      void 0,\n      false,\n      {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n        lineNumber: 133,\n        columnNumber: 5\n      },\n      this\n    )\n  };\n  return /* @__PURE__ */ jsxDEV(\"div\", { className: `markdown-renderer ${className} ${isStreaming ? \"streaming\" : \"\"}`, children: [\n    /* @__PURE__ */ jsxDEV(\n      ReactMarkdown,\n      {\n        remarkPlugins: [remarkGfm, remarkMath],\n        rehypePlugins: [\n          [rehypeSanitize, sanitizeSchema],\n          rehypeKatex\n        ],\n        components,\n        children: content\n      },\n      void 0,\n      false,\n      {\n        fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n        lineNumber: 147,\n        columnNumber: 7\n      },\n      this\n    ),\n    isStreaming && /* @__PURE__ */ jsxDEV(\"span\", { className: \"streaming-cursor\", children: \"\" }, void 0, false, {\n      fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n      lineNumber: 158,\n      columnNumber: 7\n    }, this)\n  ] }, void 0, true, {\n    fileName: \"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\",\n    lineNumber: 146,\n    columnNumber: 5\n  }, this);\n};\n_c2 = SimpleMarkdownRenderer;\nexport default SimpleMarkdownRenderer;\nvar _c, _c2;\n$RefreshReg$(_c, \"CodeBlock\");\n$RefreshReg$(_c2, \"SimpleMarkdownRenderer\");\nif (import.meta.hot && !inWebWorker) {\n  window.$RefreshReg$ = prevRefreshReg;\n  window.$RefreshSig$ = prevRefreshSig;\n}\nif (import.meta.hot && !inWebWorker) {\n  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {\n    RefreshRuntime.registerExportsForReactRefresh(\"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\", currentExports);\n    import.meta.hot.accept((nextExports) => {\n      if (!nextExports) return;\n      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(\"/home/jano/DEV_WSL/LLM/src/frontend/components/SimpleMarkdownRenderer.tsx\", currentExports, nextExports);\n      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);\n    });\n  });\n}\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJtYXBwaW5ncyI6IkFBcUNXOzs7Ozs7Ozs7Ozs7Ozs7OztBQXJDWCxTQUFnQkEsVUFBVUMsbUJBQW1CO0FBQzdDLE9BQU9DLG1CQUFtQjtBQUMxQixPQUFPQyxlQUFlO0FBQ3RCLE9BQU9DLGdCQUFnQjtBQUN2QixPQUFPQyxpQkFBaUI7QUFDeEIsT0FBT0Msa0JBQWtCQyxxQkFBcUI7QUFDOUMsT0FBTztBQWNQLE1BQU1DLFlBQXNDQSxDQUFDLEVBQUVDLFVBQVVDLFdBQVdDLE9BQU8sTUFBTTtBQUFBQyxLQUFBO0FBQy9FLFFBQU0sQ0FBQ0MsUUFBUUMsU0FBUyxJQUFJZCxTQUFTLEtBQUs7QUFFMUMsUUFBTWUsYUFBYWQsWUFBWSxZQUFZO0FBQ3pDLFFBQUk7QUFDRixZQUFNZSxVQUFVQyxVQUFVQyxVQUFVVCxRQUFRO0FBQzVDSyxnQkFBVSxJQUFJO0FBQ2RLLGlCQUFXLE1BQU1MLFVBQVUsS0FBSyxHQUFHLEdBQUk7QUFBQSxJQUN6QyxTQUFTTSxLQUFLO0FBQ1pDLGNBQVFDLE1BQU0sdUJBQXVCRixHQUFHO0FBQUEsSUFDMUM7QUFBQSxFQUNGLEdBQUcsQ0FBQ1gsUUFBUSxDQUFDO0FBR2IsUUFBTWMsV0FBV2IsWUFBWUEsVUFBVWMsUUFBUSxhQUFhLEVBQUUsSUFBSTtBQUVsRSxNQUFJYixRQUFRO0FBQ1YsV0FBTyx1QkFBQyxVQUFLLFdBQVUsZUFBZUYsWUFBL0I7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUF3QztBQUFBLEVBQ2pEO0FBRUEsU0FDRSx1QkFBQyxTQUFJLFdBQVUsc0JBQ2I7QUFBQSwyQkFBQyxTQUFJLFdBQVUscUJBQ1pjO0FBQUFBLGtCQUNDLHVCQUFDLFVBQUssV0FBVSxpQkFBaUJBLHNCQUFqQztBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQTBDO0FBQUEsTUFFNUM7QUFBQSxRQUFDO0FBQUE7QUFBQSxVQUNDLFNBQVNSO0FBQUFBLFVBQ1QsV0FBVTtBQUFBLFVBQ1YsT0FBTTtBQUFBLFVBRUxGLG1CQUNDLHVCQUFDLFNBQUksV0FBVSxhQUFZLE1BQUssUUFBTyxRQUFPLGdCQUFlLFNBQVEsYUFDbkUsaUNBQUMsVUFBSyxlQUFjLFNBQVEsZ0JBQWUsU0FBUSxhQUFZLEtBQUksR0FBRSxvQkFBckU7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFBcUYsS0FEdkY7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFFQSxJQUVBLHVCQUFDLFNBQUksV0FBVSxhQUFZLE1BQUssUUFBTyxRQUFPLGdCQUFlLFNBQVEsYUFDbkU7QUFBQSxZQUFDO0FBQUE7QUFBQSxjQUFLLGVBQWM7QUFBQSxjQUFRLGdCQUFlO0FBQUEsY0FBUSxhQUFZO0FBQUEsY0FDN0QsR0FBRTtBQUFBO0FBQUEsWUFESjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsVUFDMkgsS0FGN0g7QUFBQTtBQUFBO0FBQUE7QUFBQSxpQkFHQTtBQUFBO0FBQUEsUUFiSjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFlQTtBQUFBLFNBbkJGO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FvQkE7QUFBQSxJQUNBLHVCQUFDLFNBQUksV0FBVyxjQUFjSCxhQUFhLEVBQUUsSUFDM0MsaUNBQUMsVUFBSyxXQUNIRCxZQURIO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FFQSxLQUhGO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FJQTtBQUFBLE9BMUJGO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0EyQkE7QUFFSjtBQUFFRyxHQWxESUosV0FBbUM7QUFBQWlCLEtBQW5DakI7QUFvRE4sTUFBTWtCLHlCQUFnRUEsQ0FBQztBQUFBLEVBQ3JFQztBQUFBQSxFQUNBQyxjQUFjO0FBQUEsRUFDZGxCLFlBQVk7QUFDZCxNQUFNO0FBRUosUUFBTW1CLGlCQUFpQjtBQUFBLElBQ3JCLEdBQUd0QjtBQUFBQSxJQUNIdUIsVUFBVTtBQUFBLE1BQ1IsR0FBR3ZCLGNBQWN1QjtBQUFBQSxNQUNqQjtBQUFBLE1BQVE7QUFBQSxNQUFhO0FBQUEsTUFBUTtBQUFBLE1BQU07QUFBQSxNQUFNO0FBQUEsTUFBTTtBQUFBLE1BQy9DO0FBQUEsTUFBVTtBQUFBLE1BQVM7QUFBQSxNQUFVO0FBQUEsTUFBYztBQUFBLE1BQVE7QUFBQSxNQUFRO0FBQUEsTUFDM0Q7QUFBQSxNQUFTO0FBQUEsTUFBUztBQUFBLE1BQVM7QUFBQSxNQUFVO0FBQUEsTUFBTztBQUFBLE1BQU87QUFBQSxJQUFZO0FBQUEsSUFFakVDLFlBQVk7QUFBQSxNQUNWLEdBQUd4QixjQUFjd0I7QUFBQUEsTUFDakIsS0FBSyxDQUFDLEdBQUl4QixjQUFjd0IsV0FBWSxHQUFHLEtBQUssSUFBSyxhQUFhLE9BQU87QUFBQSxNQUNyRSxRQUFRLENBQUMsT0FBTztBQUFBLE1BQ2hCLGFBQWEsQ0FBQyxHQUFHO0FBQUEsTUFDakIsY0FBYyxDQUFDLFVBQVU7QUFBQSxJQUMzQjtBQUFBLEVBQ0Y7QUFFQSxRQUFNQyxhQUFhO0FBQUEsSUFDakJDLE1BQU16QjtBQUFBQTtBQUFBQSxJQUVOMEIsT0FBT0EsQ0FBQyxFQUFFekIsVUFBVSxHQUFHMEIsTUFBVyxNQUNoQyx1QkFBQyxTQUFJLFdBQVUsaUJBQ2IsaUNBQUMsV0FBTSxXQUFVLGtCQUFpQixHQUFJQSxPQUNuQzFCLFlBREg7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUVBLEtBSEY7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUlBO0FBQUE7QUFBQSxJQUdGMkIsWUFBWUEsQ0FBQyxFQUFFM0IsVUFBVSxHQUFHMEIsTUFBVyxNQUNyQyx1QkFBQyxnQkFBVyxXQUFVLHVCQUFzQixHQUFJQSxPQUM3QzFCLFlBREg7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQUVBO0FBQUE7QUFBQSxJQUdGNEIsR0FBR0EsQ0FBQyxFQUFFNUIsVUFBVTZCLE1BQU0sR0FBR0gsTUFBVyxNQUNsQztBQUFBLE1BQUM7QUFBQTtBQUFBLFFBQ0M7QUFBQSxRQUNBLFFBQU87QUFBQSxRQUNQLEtBQUk7QUFBQSxRQUNKLFdBQVU7QUFBQSxRQUNWLEdBQUlBO0FBQUFBLFFBRUgxQjtBQUFBQTtBQUFBQSxNQVBIO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQVFBO0FBQUEsRUFFSjtBQUVBLFNBQ0UsdUJBQUMsU0FBSSxXQUFXLHFCQUFxQkMsU0FBUyxJQUFJa0IsY0FBYyxjQUFjLEVBQUUsSUFDOUU7QUFBQTtBQUFBLE1BQUM7QUFBQTtBQUFBLFFBQ0MsZUFBZSxDQUFDekIsV0FBV0MsVUFBVTtBQUFBLFFBQ3JDLGVBQWU7QUFBQSxVQUNiLENBQUNFLGdCQUFnQnVCLGNBQWM7QUFBQSxVQUMvQnhCO0FBQUFBLFFBQVc7QUFBQSxRQUViO0FBQUEsUUFFQ3NCO0FBQUFBO0FBQUFBLE1BUkg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBU0E7QUFBQSxJQUNDQyxlQUNDLHVCQUFDLFVBQUssV0FBVSxvQkFBbUIsaUJBQW5DO0FBQUE7QUFBQTtBQUFBO0FBQUEsV0FBb0M7QUFBQSxPQVp4QztBQUFBO0FBQUE7QUFBQTtBQUFBLFNBY0E7QUFFSjtBQUFFVyxNQXRFSWI7QUF3RU4sZUFBZUE7QUFBdUIsSUFBQUQsSUFBQWM7QUFBQUMsYUFBQWYsSUFBQTtBQUFBZSxhQUFBRCxLQUFBIiwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VDYWxsYmFjayIsIlJlYWN0TWFya2Rvd24iLCJyZW1hcmtHZm0iLCJyZW1hcmtNYXRoIiwicmVoeXBlS2F0ZXgiLCJyZWh5cGVTYW5pdGl6ZSIsImRlZmF1bHRTY2hlbWEiLCJDb2RlQmxvY2siLCJjaGlsZHJlbiIsImNsYXNzTmFtZSIsImlubGluZSIsIl9zIiwiY29waWVkIiwic2V0Q29waWVkIiwiaGFuZGxlQ29weSIsIm5hdmlnYXRvciIsImNsaXBib2FyZCIsIndyaXRlVGV4dCIsInNldFRpbWVvdXQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJsYW5ndWFnZSIsInJlcGxhY2UiLCJfYyIsIlNpbXBsZU1hcmtkb3duUmVuZGVyZXIiLCJjb250ZW50IiwiaXNTdHJlYW1pbmciLCJzYW5pdGl6ZVNjaGVtYSIsInRhZ05hbWVzIiwiYXR0cmlidXRlcyIsImNvbXBvbmVudHMiLCJjb2RlIiwidGFibGUiLCJwcm9wcyIsImJsb2NrcXVvdGUiLCJhIiwiaHJlZiIsIl9jMiIsIiRSZWZyZXNoUmVnJCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlcyI6WyJTaW1wbGVNYXJrZG93blJlbmRlcmVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0TWFya2Rvd24gZnJvbSAncmVhY3QtbWFya2Rvd24nO1xuaW1wb3J0IHJlbWFya0dmbSBmcm9tICdyZW1hcmstZ2ZtJztcbmltcG9ydCByZW1hcmtNYXRoIGZyb20gJ3JlbWFyay1tYXRoJztcbmltcG9ydCByZWh5cGVLYXRleCBmcm9tICdyZWh5cGUta2F0ZXgnO1xuaW1wb3J0IHJlaHlwZVNhbml0aXplLCB7IGRlZmF1bHRTY2hlbWEgfSBmcm9tICdyZWh5cGUtc2FuaXRpemUnO1xuaW1wb3J0ICdrYXRleC9kaXN0L2thdGV4Lm1pbi5jc3MnO1xuXG5pbnRlcmZhY2UgU2ltcGxlTWFya2Rvd25SZW5kZXJlclByb3BzIHtcbiAgY29udGVudDogc3RyaW5nO1xuICBpc1N0cmVhbWluZz86IGJvb2xlYW47XG4gIGNsYXNzTmFtZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIENvZGVCbG9ja1Byb3BzIHtcbiAgY2hpbGRyZW46IHN0cmluZztcbiAgY2xhc3NOYW1lPzogc3RyaW5nO1xuICBpbmxpbmU/OiBib29sZWFuO1xufVxuXG5jb25zdCBDb2RlQmxvY2s6IFJlYWN0LkZDPENvZGVCbG9ja1Byb3BzPiA9ICh7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGlubGluZSB9KSA9PiB7XG4gIGNvbnN0IFtjb3BpZWQsIHNldENvcGllZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICBjb25zdCBoYW5kbGVDb3B5ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChjaGlsZHJlbik7XG4gICAgICBzZXRDb3BpZWQodHJ1ZSk7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHNldENvcGllZChmYWxzZSksIDIwMDApO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29weWluZyBjb2RlOicsIGVycik7XG4gICAgfVxuICB9LCBbY2hpbGRyZW5dKTtcblxuICAvLyBFeHRyYWN0IGxhbmd1YWdlIGZyb20gY2xhc3NOYW1lIChmb3JtYXQ6IGxhbmd1YWdlLXh4eClcbiAgY29uc3QgbGFuZ3VhZ2UgPSBjbGFzc05hbWUgPyBjbGFzc05hbWUucmVwbGFjZSgnbGFuZ3VhZ2UtJywgJycpIDogJyc7XG4gIFxuICBpZiAoaW5saW5lKSB7XG4gICAgcmV0dXJuIDxjb2RlIGNsYXNzTmFtZT1cImlubGluZS1jb2RlXCI+e2NoaWxkcmVufTwvY29kZT47XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29kZS1ibG9jay13cmFwcGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvZGUtYmxvY2staGVhZGVyXCI+XG4gICAgICAgIHtsYW5ndWFnZSAmJiAoXG4gICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY29kZS1sYW5ndWFnZVwiPntsYW5ndWFnZX08L3NwYW4+XG4gICAgICAgICl9XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDb3B5fVxuICAgICAgICAgIGNsYXNzTmFtZT1cImNvcHktY29kZS1idXR0b25cIlxuICAgICAgICAgIHRpdGxlPVwiQ29waWFyIGPDs2RpZ29cIlxuICAgICAgICA+XG4gICAgICAgICAge2NvcGllZCA/IChcbiAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiY29weS1pY29uXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD1cIjJcIiBkPVwiTTUgMTNsNCA0TDE5IDdcIiAvPlxuICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgKSA6IChcbiAgICAgICAgICAgIDxzdmcgY2xhc3NOYW1lPVwiY29weS1pY29uXCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgICAgIDxwYXRoIHN0cm9rZUxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZUxpbmVqb2luPVwicm91bmRcIiBzdHJva2VXaWR0aD1cIjJcIiBcbiAgICAgICAgICAgICAgICBkPVwiTTggMTZINmEyIDIgMCAwMS0yLTJWNmEyIDIgMCAwMTItMmg4YTIgMiAwIDAxMiAydjJtLTYgMTJoOGEyIDIgMCAwMDItMnYtOGEyIDIgMCAwMC0yLTJoLThhMiAyIDAgMDAtMiAydjhhMiAyIDAgMDAyIDJ6XCIgLz5cbiAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgICA8cHJlIGNsYXNzTmFtZT17YGNvZGUtYmxvY2sgJHtjbGFzc05hbWUgfHwgJyd9YH0+XG4gICAgICAgIDxjb2RlIGNsYXNzTmFtZT17Y2xhc3NOYW1lfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvY29kZT5cbiAgICAgIDwvcHJlPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuY29uc3QgU2ltcGxlTWFya2Rvd25SZW5kZXJlcjogUmVhY3QuRkM8U2ltcGxlTWFya2Rvd25SZW5kZXJlclByb3BzPiA9ICh7IFxuICBjb250ZW50LCBcbiAgaXNTdHJlYW1pbmcgPSBmYWxzZSwgXG4gIGNsYXNzTmFtZSA9ICcnIFxufSkgPT4ge1xuICAvLyBDdXN0b20gc2FuaXRpemF0aW9uIHNjaGVtYSB0aGF0IGFsbG93cyBLYVRlWCBlbGVtZW50c1xuICBjb25zdCBzYW5pdGl6ZVNjaGVtYSA9IHtcbiAgICAuLi5kZWZhdWx0U2NoZW1hLFxuICAgIHRhZ05hbWVzOiBbXG4gICAgICAuLi5kZWZhdWx0U2NoZW1hLnRhZ05hbWVzISxcbiAgICAgICdtYXRoJywgJ3NlbWFudGljcycsICdtcm93JywgJ21vJywgJ21pJywgJ21uJywgJ210ZXh0JyxcbiAgICAgICdtc3BhY2UnLCAnbW92ZXInLCAnbXVuZGVyJywgJ211bmRlcm92ZXInLCAnbXN1YicsICdtc3VwJywgJ21zdWJzdXAnLFxuICAgICAgJ21mcmFjJywgJ21zcXJ0JywgJ21yb290JywgJ210YWJsZScsICdtdHInLCAnbXRkJywgJ2Fubm90YXRpb24nXG4gICAgXSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAuLi5kZWZhdWx0U2NoZW1hLmF0dHJpYnV0ZXMsXG4gICAgICAnKic6IFsuLi4oZGVmYXVsdFNjaGVtYS5hdHRyaWJ1dGVzIVsnKiddIHx8IFtdKSwgJ2NsYXNzTmFtZScsICdzdHlsZSddLFxuICAgICAgJ21hdGgnOiBbJ3htbG5zJ10sXG4gICAgICAnc2VtYW50aWNzJzogWycqJ10sXG4gICAgICAnYW5ub3RhdGlvbic6IFsnZW5jb2RpbmcnXVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBjb21wb25lbnRzID0ge1xuICAgIGNvZGU6IENvZGVCbG9jayxcbiAgICAvLyBDdXN0b20gdGFibGUgc3R5bGluZ1xuICAgIHRhYmxlOiAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogYW55KSA9PiAoXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInRhYmxlLXdyYXBwZXJcIj5cbiAgICAgICAgPHRhYmxlIGNsYXNzTmFtZT1cIm1hcmtkb3duLXRhYmxlXCIgey4uLnByb3BzfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvdGFibGU+XG4gICAgICA8L2Rpdj5cbiAgICApLFxuICAgIC8vIEN1c3RvbSBibG9ja3F1b3RlIHN0eWxpbmdcbiAgICBibG9ja3F1b3RlOiAoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogYW55KSA9PiAoXG4gICAgICA8YmxvY2txdW90ZSBjbGFzc05hbWU9XCJtYXJrZG93bi1ibG9ja3F1b3RlXCIgey4uLnByb3BzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9ibG9ja3F1b3RlPlxuICAgICksXG4gICAgLy8gQ3VzdG9tIGxpbmsgc3R5bGluZyB3aXRoIHNlY3VyaXR5XG4gICAgYTogKHsgY2hpbGRyZW4sIGhyZWYsIC4uLnByb3BzIH06IGFueSkgPT4gKFxuICAgICAgPGEgXG4gICAgICAgIGhyZWY9e2hyZWZ9IFxuICAgICAgICB0YXJnZXQ9XCJfYmxhbmtcIiBcbiAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9yZWZlcnJlclwiIFxuICAgICAgICBjbGFzc05hbWU9XCJtYXJrZG93bi1saW5rXCJcbiAgICAgICAgey4uLnByb3BzfVxuICAgICAgPlxuICAgICAgICB7Y2hpbGRyZW59XG4gICAgICA8L2E+XG4gICAgKVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2BtYXJrZG93bi1yZW5kZXJlciAke2NsYXNzTmFtZX0gJHtpc1N0cmVhbWluZyA/ICdzdHJlYW1pbmcnIDogJyd9YH0+XG4gICAgICA8UmVhY3RNYXJrZG93blxuICAgICAgICByZW1hcmtQbHVnaW5zPXtbcmVtYXJrR2ZtLCByZW1hcmtNYXRoXX1cbiAgICAgICAgcmVoeXBlUGx1Z2lucz17W1xuICAgICAgICAgIFtyZWh5cGVTYW5pdGl6ZSwgc2FuaXRpemVTY2hlbWFdLFxuICAgICAgICAgIHJlaHlwZUthdGV4XG4gICAgICAgIF19XG4gICAgICAgIGNvbXBvbmVudHM9e2NvbXBvbmVudHN9XG4gICAgICA+XG4gICAgICAgIHtjb250ZW50fVxuICAgICAgPC9SZWFjdE1hcmtkb3duPlxuICAgICAge2lzU3RyZWFtaW5nICYmIChcbiAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwic3RyZWFtaW5nLWN1cnNvclwiPuKWijwvc3Bhbj5cbiAgICAgICl9XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTaW1wbGVNYXJrZG93blJlbmRlcmVyOyJdLCJmaWxlIjoiL2hvbWUvamFuby9ERVZfV1NML0xMTS9zcmMvZnJvbnRlbmQvY29tcG9uZW50cy9TaW1wbGVNYXJrZG93blJlbmRlcmVyLnRzeCJ9"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.736Z",
        "time": 3.4069999965140596,
        "timings": {
          "blocked": 1.1109999964439776,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.09900000000000003,
          "wait": 1.7879999998521525,
          "receive": 0.4090000002179295,
          "_blocked_queueing": 0.6879999964439776,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "lineNumber": 18
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-markdown.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "178305"
            },
            {
              "name": "Etag",
              "value": "W/\"2b881-nrBPS2lnTCnlxkBwfGu4joT26f0\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 178305,
            "mimeType": "text/javascript",
            "text": "aW1wb3J0IHsKICBmaW5kLAogIGhhc3RUb1JlYWN0LAogIGh0bWwsCiAgc3RyaW5naWZ5LAogIHN0cmluZ2lmeTIsCiAgc3ZnCn0gZnJvbSAiL0Bmcy9ob21lL2phbm8vREVWX1dTTC9MTE0vbm9kZV9tb2R1bGVzLy52aXRlL2RlcHMvY2h1bmstSkpXVkNEV0YuanM/dj0yYTc1OTFlZCI7CmltcG9ydCB7CiAgcmVxdWlyZV9qc3hfcnVudGltZQp9IGZyb20gIi9AZnMvaG9tZS9qYW5vL0RFVl9XU0wvTExNL25vZGVfbW9kdWxlcy8udml0ZS9kZXBzL2NodW5rLVM3MjVEQUNRLmpzP3Y9MmE3NTkxZWQiOwppbXBvcnQgewogIHJlcXVpcmVfcmVhY3QKfSBmcm9tICIvQGZzL2hvbWUvamFuby9ERVZfV1NML0xMTS9ub2RlX21vZHVsZXMvLnZpdGUvZGVwcy9jaHVuay1STEoyUkNKUS5qcz92PTJhNzU5MWVkIjsKaW1wb3J0IHsKICBhdHRlbnRpb24sCiAgYXV0b2xpbmssCiAgYmxhbmtMaW5lLAogIGJsb2NrUXVvdGUsCiAgY2hhcmFjdGVyRXNjYXBlLAogIGNoYXJhY3RlclJlZmVyZW5jZSwKICBjb2RlRmVuY2VkLAogIGNvZGVJbmRlbnRlZCwKICBjb2RlVGV4dCwKICBjb21iaW5lRXh0ZW5zaW9ucywKICBjb250ZW50LAogIGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlLAogIGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UsCiAgZGVjb2RlU3RyaW5nLAogIGRlZmluaXRpb24sCiAgaGFyZEJyZWFrRXNjYXBlLAogIGhlYWRpbmdBdHgsCiAgaHRtbEZsb3csCiAgaHRtbFRleHQsCiAgbGFiZWxFbmQsCiAgbGFiZWxTdGFydEltYWdlLAogIGxhYmVsU3RhcnRMaW5rLAogIGxpbmVFbmRpbmcsCiAgbGlzdCwKICBub3JtYWxpemVJZGVudGlmaWVyLAogIG5vcm1hbGl6ZVVyaSwKICBwdXNoLAogIHJlc29sdmVBbGwsCiAgc2V0ZXh0VW5kZXJsaW5lLAogIHNwbGljZSwKICBzdWJ0b2tlbml6ZSwKICB0aGVtYXRpY0JyZWFrLAogIHRvU3RyaW5nLAogIHZpc2l0Cn0gZnJvbSAiL0Bmcy9ob21lL2phbm8vREVWX1dTTC9MTE0vbm9kZV9tb2R1bGVzLy52aXRlL2RlcHMvY2h1bmstV0taSDczM0ouanM/dj0yYTc1OTFlZCI7CmltcG9ydCAiL0Bmcy9ob21lL2phbm8vREVWX1dTTC9MTE0vbm9kZV9tb2R1bGVzLy52aXRlL2RlcHMvY2h1bmstWEhTU0tQQ0guanM/dj0yYTc1OTFlZCI7CmltcG9ydCB7CiAgZXNtX2RlZmF1bHQsCiAgcG9pbnRFbmQsCiAgcG9pbnRTdGFydCwKICBwb3NpdGlvbgp9IGZyb20gIi9AZnMvaG9tZS9qYW5vL0RFVl9XU0wvTExNL25vZGVfbW9kdWxlcy8udml0ZS9kZXBzL2NodW5rLVdBN0JJWklOLmpzP3Y9MmE3NTkxZWQiOwppbXBvcnQgewogIGNvZGVzLAogIGNvbnN0YW50cywKICBmYWN0b3J5U3BhY2UsCiAgbWFya2Rvd25MaW5lRW5kaW5nLAogIG9rLAogIHR5cGVzLAogIHVucmVhY2hhYmxlLAogIHZhbHVlcwp9IGZyb20gIi9AZnMvaG9tZS9qYW5vL0RFVl9XU0wvTExNL25vZGVfbW9kdWxlcy8udml0ZS9kZXBzL2NodW5rLUVJQkdFREVKLmpzP3Y9MmE3NTkxZWQiOwppbXBvcnQgewogIF9fY29tbW9uSlMsCiAgX19leHBvcnQsCiAgX190b0VTTQp9IGZyb20gIi9AZnMvaG9tZS9qYW5vL0RFVl9XU0wvTExNL25vZGVfbW9kdWxlcy8udml0ZS9kZXBzL2NodW5rLURDNUFNWUJTLmpzP3Y9MmE3NTkxZWQiOwoKLy8gbm9kZV9tb2R1bGVzL2lubGluZS1zdHlsZS1wYXJzZXIvaW5kZXguanMKdmFyIHJlcXVpcmVfaW5saW5lX3N0eWxlX3BhcnNlciA9IF9fY29tbW9uSlMoewogICJub2RlX21vZHVsZXMvaW5saW5lLXN0eWxlLXBhcnNlci9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICB2YXIgQ09NTUVOVF9SRUdFWCA9IC9cL1wqW14qXSpcKisoW14vKl1bXipdKlwqKykqXC8vZzsKICAgIHZhciBORVdMSU5FX1JFR0VYID0gL1xuL2c7CiAgICB2YXIgV0hJVEVTUEFDRV9SRUdFWCA9IC9eXHMqLzsKICAgIHZhciBQUk9QRVJUWV9SRUdFWCA9IC9eKFwqP1stIy8qXFxcd10rKFxbWzAtOWEtel8tXStcXSk/KVxzKi87CiAgICB2YXIgQ09MT05fUkVHRVggPSAvXjpccyovOwogICAgdmFyIFZBTFVFX1JFR0VYID0gL14oKD86Jyg/OlxcJ3wuKSo/J3wiKD86XFwifC4pKj8ifFwoW14pXSo/XCl8W159O10pKykvOwogICAgdmFyIFNFTUlDT0xPTl9SRUdFWCA9IC9eWztcc10qLzsKICAgIHZhciBUUklNX1JFR0VYID0gL15ccyt8XHMrJC9nOwogICAgdmFyIE5FV0xJTkUgPSAiXG4iOwogICAgdmFyIEZPUldBUkRfU0xBU0ggPSAiLyI7CiAgICB2YXIgQVNURVJJU0sgPSAiKiI7CiAgICB2YXIgRU1QVFlfU1RSSU5HID0gIiI7CiAgICB2YXIgVFlQRV9DT01NRU5UID0gImNvbW1lbnQiOwogICAgdmFyIFRZUEVfREVDTEFSQVRJT04gPSAiZGVjbGFyYXRpb24iOwogICAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHlsZSwgb3B0aW9ucykgewogICAgICBpZiAodHlwZW9mIHN0eWxlICE9PSAic3RyaW5nIikgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmciKTsKICAgICAgfQogICAgICBpZiAoIXN0eWxlKSByZXR1cm4gW107CiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICB2YXIgbGluZW5vID0gMTsKICAgICAgdmFyIGNvbHVtbiA9IDE7CiAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKHN0cikgewogICAgICAgIHZhciBsaW5lcyA9IHN0ci5tYXRjaChORVdMSU5FX1JFR0VYKTsKICAgICAgICBpZiAobGluZXMpIGxpbmVubyArPSBsaW5lcy5sZW5ndGg7CiAgICAgICAgdmFyIGkgPSBzdHIubGFzdEluZGV4T2YoTkVXTElORSk7CiAgICAgICAgY29sdW1uID0gfmkgPyBzdHIubGVuZ3RoIC0gaSA6IGNvbHVtbiArIHN0ci5sZW5ndGg7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gcG9zaXRpb24zKCkgewogICAgICAgIHZhciBzdGFydDIgPSB7IGxpbmU6IGxpbmVubywgY29sdW1uIH07CiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHsKICAgICAgICAgIG5vZGUucG9zaXRpb24gPSBuZXcgUG9zaXRpb24oc3RhcnQyKTsKICAgICAgICAgIHdoaXRlc3BhY2UyKCk7CiAgICAgICAgICByZXR1cm4gbm9kZTsKICAgICAgICB9OwogICAgICB9CiAgICAgIGZ1bmN0aW9uIFBvc2l0aW9uKHN0YXJ0MikgewogICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDI7CiAgICAgICAgdGhpcy5lbmQgPSB7IGxpbmU6IGxpbmVubywgY29sdW1uIH07CiAgICAgICAgdGhpcy5zb3VyY2UgPSBvcHRpb25zLnNvdXJjZTsKICAgICAgfQogICAgICBQb3NpdGlvbi5wcm90b3R5cGUuY29udGVudCA9IHN0eWxlOwogICAgICB2YXIgZXJyb3JzTGlzdCA9IFtdOwogICAgICBmdW5jdGlvbiBlcnJvcihtc2cpIHsKICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKAogICAgICAgICAgb3B0aW9ucy5zb3VyY2UgKyAiOiIgKyBsaW5lbm8gKyAiOiIgKyBjb2x1bW4gKyAiOiAiICsgbXNnCiAgICAgICAgKTsKICAgICAgICBlcnIucmVhc29uID0gbXNnOwogICAgICAgIGVyci5maWxlbmFtZSA9IG9wdGlvbnMuc291cmNlOwogICAgICAgIGVyci5saW5lID0gbGluZW5vOwogICAgICAgIGVyci5jb2x1bW4gPSBjb2x1bW47CiAgICAgICAgZXJyLnNvdXJjZSA9IHN0eWxlOwogICAgICAgIGlmIChvcHRpb25zLnNpbGVudCkgewogICAgICAgICAgZXJyb3JzTGlzdC5wdXNoKGVycik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93IGVycjsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gbWF0Y2gocmUyKSB7CiAgICAgICAgdmFyIG0gPSByZTIuZXhlYyhzdHlsZSk7CiAgICAgICAgaWYgKCFtKSByZXR1cm47CiAgICAgICAgdmFyIHN0ciA9IG1bMF07CiAgICAgICAgdXBkYXRlUG9zaXRpb24oc3RyKTsKICAgICAgICBzdHlsZSA9IHN0eWxlLnNsaWNlKHN0ci5sZW5ndGgpOwogICAgICAgIHJldHVybiBtOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIHdoaXRlc3BhY2UyKCkgewogICAgICAgIG1hdGNoKFdISVRFU1BBQ0VfUkVHRVgpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGNvbW1lbnRzKHJ1bGVzKSB7CiAgICAgICAgdmFyIGM7CiAgICAgICAgcnVsZXMgPSBydWxlcyB8fCBbXTsKICAgICAgICB3aGlsZSAoYyA9IGNvbW1lbnQoKSkgewogICAgICAgICAgaWYgKGMgIT09IGZhbHNlKSB7CiAgICAgICAgICAgIHJ1bGVzLnB1c2goYyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBydWxlczsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb21tZW50KCkgewogICAgICAgIHZhciBwb3MgPSBwb3NpdGlvbjMoKTsKICAgICAgICBpZiAoRk9SV0FSRF9TTEFTSCAhPSBzdHlsZS5jaGFyQXQoMCkgfHwgQVNURVJJU0sgIT0gc3R5bGUuY2hhckF0KDEpKSByZXR1cm47CiAgICAgICAgdmFyIGkgPSAyOwogICAgICAgIHdoaWxlIChFTVBUWV9TVFJJTkcgIT0gc3R5bGUuY2hhckF0KGkpICYmIChBU1RFUklTSyAhPSBzdHlsZS5jaGFyQXQoaSkgfHwgRk9SV0FSRF9TTEFTSCAhPSBzdHlsZS5jaGFyQXQoaSArIDEpKSkgewogICAgICAgICAgKytpOwogICAgICAgIH0KICAgICAgICBpICs9IDI7CiAgICAgICAgaWYgKEVNUFRZX1NUUklORyA9PT0gc3R5bGUuY2hhckF0KGkgLSAxKSkgewogICAgICAgICAgcmV0dXJuIGVycm9yKCJFbmQgb2YgY29tbWVudCBtaXNzaW5nIik7CiAgICAgICAgfQogICAgICAgIHZhciBzdHIgPSBzdHlsZS5zbGljZSgyLCBpIC0gMik7CiAgICAgICAgY29sdW1uICs9IDI7CiAgICAgICAgdXBkYXRlUG9zaXRpb24oc3RyKTsKICAgICAgICBzdHlsZSA9IHN0eWxlLnNsaWNlKGkpOwogICAgICAgIGNvbHVtbiArPSAyOwogICAgICAgIHJldHVybiBwb3MoewogICAgICAgICAgdHlwZTogVFlQRV9DT01NRU5ULAogICAgICAgICAgY29tbWVudDogc3RyCiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjbGFyYXRpb24oKSB7CiAgICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uMygpOwogICAgICAgIHZhciBwcm9wID0gbWF0Y2goUFJPUEVSVFlfUkVHRVgpOwogICAgICAgIGlmICghcHJvcCkgcmV0dXJuOwogICAgICAgIGNvbW1lbnQoKTsKICAgICAgICBpZiAoIW1hdGNoKENPTE9OX1JFR0VYKSkgcmV0dXJuIGVycm9yKCJwcm9wZXJ0eSBtaXNzaW5nICc6JyIpOwogICAgICAgIHZhciB2YWwgPSBtYXRjaChWQUxVRV9SRUdFWCk7CiAgICAgICAgdmFyIHJldCA9IHBvcyh7CiAgICAgICAgICB0eXBlOiBUWVBFX0RFQ0xBUkFUSU9OLAogICAgICAgICAgcHJvcGVydHk6IHRyaW0ocHJvcFswXS5yZXBsYWNlKENPTU1FTlRfUkVHRVgsIEVNUFRZX1NUUklORykpLAogICAgICAgICAgdmFsdWU6IHZhbCA/IHRyaW0odmFsWzBdLnJlcGxhY2UoQ09NTUVOVF9SRUdFWCwgRU1QVFlfU1RSSU5HKSkgOiBFTVBUWV9TVFJJTkcKICAgICAgICB9KTsKICAgICAgICBtYXRjaChTRU1JQ09MT05fUkVHRVgpOwogICAgICAgIHJldHVybiByZXQ7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGVjbGFyYXRpb25zKCkgewogICAgICAgIHZhciBkZWNscyA9IFtdOwogICAgICAgIGNvbW1lbnRzKGRlY2xzKTsKICAgICAgICB2YXIgZGVjbDsKICAgICAgICB3aGlsZSAoZGVjbCA9IGRlY2xhcmF0aW9uKCkpIHsKICAgICAgICAgIGlmIChkZWNsICE9PSBmYWxzZSkgewogICAgICAgICAgICBkZWNscy5wdXNoKGRlY2wpOwogICAgICAgICAgICBjb21tZW50cyhkZWNscyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBkZWNsczsKICAgICAgfQogICAgICB3aGl0ZXNwYWNlMigpOwogICAgICByZXR1cm4gZGVjbGFyYXRpb25zKCk7CiAgICB9OwogICAgZnVuY3Rpb24gdHJpbShzdHIpIHsKICAgICAgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKFRSSU1fUkVHRVgsIEVNUFRZX1NUUklORykgOiBFTVBUWV9TVFJJTkc7CiAgICB9CiAgfQp9KTsKCi8vIG5vZGVfbW9kdWxlcy9zdHlsZS10by1vYmplY3QvY2pzL2luZGV4LmpzCnZhciByZXF1aXJlX2NqcyA9IF9fY29tbW9uSlMoewogICJub2RlX21vZHVsZXMvc3R5bGUtdG8tb2JqZWN0L2Nqcy9pbmRleC5qcyIoZXhwb3J0cykgewogICAgInVzZSBzdHJpY3QiOwogICAgdmFyIF9faW1wb3J0RGVmYXVsdCA9IGV4cG9ydHMgJiYgZXhwb3J0cy5fX2ltcG9ydERlZmF1bHQgfHwgZnVuY3Rpb24obW9kKSB7CiAgICAgIHJldHVybiBtb2QgJiYgbW9kLl9fZXNNb2R1bGUgPyBtb2QgOiB7ICJkZWZhdWx0IjogbW9kIH07CiAgICB9OwogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgIGV4cG9ydHMuZGVmYXVsdCA9IFN0eWxlVG9PYmplY3Q7CiAgICB2YXIgaW5saW5lX3N0eWxlX3BhcnNlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmVfaW5saW5lX3N0eWxlX3BhcnNlcigpKTsKICAgIGZ1bmN0aW9uIFN0eWxlVG9PYmplY3Qoc3R5bGUsIGl0ZXJhdG9yKSB7CiAgICAgIHZhciBzdHlsZU9iamVjdCA9IG51bGw7CiAgICAgIGlmICghc3R5bGUgfHwgdHlwZW9mIHN0eWxlICE9PSAic3RyaW5nIikgewogICAgICAgIHJldHVybiBzdHlsZU9iamVjdDsKICAgICAgfQogICAgICB2YXIgZGVjbGFyYXRpb25zID0gKDAsIGlubGluZV9zdHlsZV9wYXJzZXJfMS5kZWZhdWx0KShzdHlsZSk7CiAgICAgIHZhciBoYXNJdGVyYXRvciA9IHR5cGVvZiBpdGVyYXRvciA9PT0gImZ1bmN0aW9uIjsKICAgICAgZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24oZGVjbGFyYXRpb24pIHsKICAgICAgICBpZiAoZGVjbGFyYXRpb24udHlwZSAhPT0gImRlY2xhcmF0aW9uIikgewogICAgICAgICAgcmV0dXJuOwogICAgICAgIH0KICAgICAgICB2YXIgcHJvcGVydHkgPSBkZWNsYXJhdGlvbi5wcm9wZXJ0eSwgdmFsdWUgPSBkZWNsYXJhdGlvbi52YWx1ZTsKICAgICAgICBpZiAoaGFzSXRlcmF0b3IpIHsKICAgICAgICAgIGl0ZXJhdG9yKHByb3BlcnR5LCB2YWx1ZSwgZGVjbGFyYXRpb24pOwogICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHsKICAgICAgICAgIHN0eWxlT2JqZWN0ID0gc3R5bGVPYmplY3QgfHwge307CiAgICAgICAgICBzdHlsZU9iamVjdFtwcm9wZXJ0eV0gPSB2YWx1ZTsKICAgICAgICB9CiAgICAgIH0pOwogICAgICByZXR1cm4gc3R5bGVPYmplY3Q7CiAgICB9CiAgfQp9KTsKCi8vIG5vZGVfbW9kdWxlcy9zdHlsZS10by1qcy9janMvdXRpbGl0aWVzLmpzCnZhciByZXF1aXJlX3V0aWxpdGllcyA9IF9fY29tbW9uSlMoewogICJub2RlX21vZHVsZXMvc3R5bGUtdG8tanMvY2pzL3V0aWxpdGllcy5qcyIoZXhwb3J0cykgewogICAgInVzZSBzdHJpY3QiOwogICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICJfX2VzTW9kdWxlIiwgeyB2YWx1ZTogdHJ1ZSB9KTsKICAgIGV4cG9ydHMuY2FtZWxDYXNlID0gdm9pZCAwOwogICAgdmFyIENVU1RPTV9QUk9QRVJUWV9SRUdFWCA9IC9eLS1bYS16QS1aMC05Xy1dKyQvOwogICAgdmFyIEhZUEhFTl9SRUdFWCA9IC8tKFthLXpdKS9nOwogICAgdmFyIE5PX0hZUEhFTl9SRUdFWCA9IC9eW14tXSskLzsKICAgIHZhciBWRU5ET1JfUFJFRklYX1JFR0VYID0gL14tKHdlYmtpdHxtb3p8bXN8b3xraHRtbCktLzsKICAgIHZhciBNU19WRU5ET1JfUFJFRklYX1JFR0VYID0gL14tKG1zKS0vOwogICAgdmFyIHNraXBDYW1lbENhc2UgPSBmdW5jdGlvbihwcm9wZXJ0eSkgewogICAgICByZXR1cm4gIXByb3BlcnR5IHx8IE5PX0hZUEhFTl9SRUdFWC50ZXN0KHByb3BlcnR5KSB8fCBDVVNUT01fUFJPUEVSVFlfUkVHRVgudGVzdChwcm9wZXJ0eSk7CiAgICB9OwogICAgdmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbihtYXRjaCwgY2hhcmFjdGVyKSB7CiAgICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTsKICAgIH07CiAgICB2YXIgdHJpbUh5cGhlbiA9IGZ1bmN0aW9uKG1hdGNoLCBwcmVmaXgpIHsKICAgICAgcmV0dXJuICIiLmNvbmNhdChwcmVmaXgsICItIik7CiAgICB9OwogICAgdmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uKHByb3BlcnR5LCBvcHRpb25zKSB7CiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsKICAgICAgICBvcHRpb25zID0ge307CiAgICAgIH0KICAgICAgaWYgKHNraXBDYW1lbENhc2UocHJvcGVydHkpKSB7CiAgICAgICAgcmV0dXJuIHByb3BlcnR5OwogICAgICB9CiAgICAgIHByb3BlcnR5ID0gcHJvcGVydHkudG9Mb3dlckNhc2UoKTsKICAgICAgaWYgKG9wdGlvbnMucmVhY3RDb21wYXQpIHsKICAgICAgICBwcm9wZXJ0eSA9IHByb3BlcnR5LnJlcGxhY2UoTVNfVkVORE9SX1BSRUZJWF9SRUdFWCwgdHJpbUh5cGhlbik7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcHJvcGVydHkgPSBwcm9wZXJ0eS5yZXBsYWNlKFZFTkRPUl9QUkVGSVhfUkVHRVgsIHRyaW1IeXBoZW4pOwogICAgICB9CiAgICAgIHJldHVybiBwcm9wZXJ0eS5yZXBsYWNlKEhZUEhFTl9SRUdFWCwgY2FwaXRhbGl6ZSk7CiAgICB9OwogICAgZXhwb3J0cy5jYW1lbENhc2UgPSBjYW1lbENhc2U7CiAgfQp9KTsKCi8vIG5vZGVfbW9kdWxlcy9zdHlsZS10by1qcy9janMvaW5kZXguanMKdmFyIHJlcXVpcmVfY2pzMiA9IF9fY29tbW9uSlMoewogICJub2RlX21vZHVsZXMvc3R5bGUtdG8tanMvY2pzL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgICJ1c2Ugc3RyaWN0IjsKICAgIHZhciBfX2ltcG9ydERlZmF1bHQgPSBleHBvcnRzICYmIGV4cG9ydHMuX19pbXBvcnREZWZhdWx0IHx8IGZ1bmN0aW9uKG1vZCkgewogICAgICByZXR1cm4gbW9kICYmIG1vZC5fX2VzTW9kdWxlID8gbW9kIDogeyAiZGVmYXVsdCI6IG1vZCB9OwogICAgfTsKICAgIHZhciBzdHlsZV90b19vYmplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlX2NqcygpKTsKICAgIHZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmVfdXRpbGl0aWVzKCk7CiAgICBmdW5jdGlvbiBTdHlsZVRvSlMoc3R5bGUsIG9wdGlvbnMpIHsKICAgICAgdmFyIG91dHB1dCA9IHt9OwogICAgICBpZiAoIXN0eWxlIHx8IHR5cGVvZiBzdHlsZSAhPT0gInN0cmluZyIpIHsKICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICB9CiAgICAgICgwLCBzdHlsZV90b19vYmplY3RfMS5kZWZhdWx0KShzdHlsZSwgZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKSB7CiAgICAgICAgaWYgKHByb3BlcnR5ICYmIHZhbHVlKSB7CiAgICAgICAgICBvdXRwdXRbKDAsIHV0aWxpdGllc18xLmNhbWVsQ2FzZSkocHJvcGVydHksIG9wdGlvbnMpXSA9IHZhbHVlOwogICAgICAgIH0KICAgICAgfSk7CiAgICAgIHJldHVybiBvdXRwdXQ7CiAgICB9CiAgICBTdHlsZVRvSlMuZGVmYXVsdCA9IFN0eWxlVG9KUzsKICAgIG1vZHVsZS5leHBvcnRzID0gU3R5bGVUb0pTOwogIH0KfSk7CgovLyBub2RlX21vZHVsZXMvbXMvaW5kZXguanMKdmFyIHJlcXVpcmVfbXMgPSBfX2NvbW1vbkpTKHsKICAibm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgIHZhciBzID0gMWUzOwogICAgdmFyIG0gPSBzICogNjA7CiAgICB2YXIgaCA9IG0gKiA2MDsKICAgIHZhciBkID0gaCAqIDI0OwogICAgdmFyIHcgPSBkICogNzsKICAgIHZhciB5ID0gZCAqIDM2NS4yNTsKICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7CiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OwogICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7CiAgICAgIGlmICh0eXBlID09PSAic3RyaW5nIiAmJiB2YWwubGVuZ3RoID4gMCkgewogICAgICAgIHJldHVybiBwYXJzZTIodmFsKTsKICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAibnVtYmVyIiAmJiBpc0Zpbml0ZSh2YWwpKSB7CiAgICAgICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAgICJ2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPSIgKyBKU09OLnN0cmluZ2lmeSh2YWwpCiAgICAgICk7CiAgICB9OwogICAgZnVuY3Rpb24gcGFyc2UyKHN0cikgewogICAgICBzdHIgPSBTdHJpbmcoc3RyKTsKICAgICAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgdmFyIG1hdGNoID0gL14oLT8oPzpcZCspP1wuP1xkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKAogICAgICAgIHN0cgogICAgICApOwogICAgICBpZiAoIW1hdGNoKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7CiAgICAgIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICJtcyIpLnRvTG93ZXJDYXNlKCk7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgInllYXJzIjoKICAgICAgICBjYXNlICJ5ZWFyIjoKICAgICAgICBjYXNlICJ5cnMiOgogICAgICAgIGNhc2UgInlyIjoKICAgICAgICBjYXNlICJ5IjoKICAgICAgICAgIHJldHVybiBuICogeTsKICAgICAgICBjYXNlICJ3ZWVrcyI6CiAgICAgICAgY2FzZSAid2VlayI6CiAgICAgICAgY2FzZSAidyI6CiAgICAgICAgICByZXR1cm4gbiAqIHc7CiAgICAgICAgY2FzZSAiZGF5cyI6CiAgICAgICAgY2FzZSAiZGF5IjoKICAgICAgICBjYXNlICJkIjoKICAgICAgICAgIHJldHVybiBuICogZDsKICAgICAgICBjYXNlICJob3VycyI6CiAgICAgICAgY2FzZSAiaG91ciI6CiAgICAgICAgY2FzZSAiaHJzIjoKICAgICAgICBjYXNlICJociI6CiAgICAgICAgY2FzZSAiaCI6CiAgICAgICAgICByZXR1cm4gbiAqIGg7CiAgICAgICAgY2FzZSAibWludXRlcyI6CiAgICAgICAgY2FzZSAibWludXRlIjoKICAgICAgICBjYXNlICJtaW5zIjoKICAgICAgICBjYXNlICJtaW4iOgogICAgICAgIGNhc2UgIm0iOgogICAgICAgICAgcmV0dXJuIG4gKiBtOwogICAgICAgIGNhc2UgInNlY29uZHMiOgogICAgICAgIGNhc2UgInNlY29uZCI6CiAgICAgICAgY2FzZSAic2VjcyI6CiAgICAgICAgY2FzZSAic2VjIjoKICAgICAgICBjYXNlICJzIjoKICAgICAgICAgIHJldHVybiBuICogczsKICAgICAgICBjYXNlICJtaWxsaXNlY29uZHMiOgogICAgICAgIGNhc2UgIm1pbGxpc2Vjb25kIjoKICAgICAgICBjYXNlICJtc2VjcyI6CiAgICAgICAgY2FzZSAibXNlYyI6CiAgICAgICAgY2FzZSAibXMiOgogICAgICAgICAgcmV0dXJuIG47CiAgICAgICAgZGVmYXVsdDoKICAgICAgICAgIHJldHVybiB2b2lkIDA7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7CiAgICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTsKICAgICAgaWYgKG1zQWJzID49IGQpIHsKICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgImQiOwogICAgICB9CiAgICAgIGlmIChtc0FicyA+PSBoKSB7CiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICJoIjsKICAgICAgfQogICAgICBpZiAobXNBYnMgPj0gbSkgewogICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAibSI7CiAgICAgIH0KICAgICAgaWYgKG1zQWJzID49IHMpIHsKICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgInMiOwogICAgICB9CiAgICAgIHJldHVybiBtcyArICJtcyI7CiAgICB9CiAgICBmdW5jdGlvbiBmbXRMb25nKG1zKSB7CiAgICAgIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTsKICAgICAgaWYgKG1zQWJzID49IGQpIHsKICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgImRheSIpOwogICAgICB9CiAgICAgIGlmIChtc0FicyA+PSBoKSB7CiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICJob3VyIik7CiAgICAgIH0KICAgICAgaWYgKG1zQWJzID49IG0pIHsKICAgICAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgIm1pbnV0ZSIpOwogICAgICB9CiAgICAgIGlmIChtc0FicyA+PSBzKSB7CiAgICAgICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICJzZWNvbmQiKTsKICAgICAgfQogICAgICByZXR1cm4gbXMgKyAiIG1zIjsKICAgIH0KICAgIGZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUyKSB7CiAgICAgIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7CiAgICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAiICIgKyBuYW1lMiArIChpc1BsdXJhbCA/ICJzIiA6ICIiKTsKICAgIH0KICB9Cn0pOwoKLy8gbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMKdmFyIHJlcXVpcmVfY29tbW9uID0gX19jb21tb25KUyh7CiAgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIihleHBvcnRzLCBtb2R1bGUpIHsKICAgIGZ1bmN0aW9uIHNldHVwKGVudikgewogICAgICBjcmVhdGVEZWJ1ZzIuZGVidWcgPSBjcmVhdGVEZWJ1ZzI7CiAgICAgIGNyZWF0ZURlYnVnMi5kZWZhdWx0ID0gY3JlYXRlRGVidWcyOwogICAgICBjcmVhdGVEZWJ1ZzIuY29lcmNlID0gY29lcmNlOwogICAgICBjcmVhdGVEZWJ1ZzIuZGlzYWJsZSA9IGRpc2FibGUyOwogICAgICBjcmVhdGVEZWJ1ZzIuZW5hYmxlID0gZW5hYmxlOwogICAgICBjcmVhdGVEZWJ1ZzIuZW5hYmxlZCA9IGVuYWJsZWQ7CiAgICAgIGNyZWF0ZURlYnVnMi5odW1hbml6ZSA9IHJlcXVpcmVfbXMoKTsKICAgICAgY3JlYXRlRGVidWcyLmRlc3Ryb3kgPSBkZXN0cm95OwogICAgICBPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goKGtleSkgPT4gewogICAgICAgIGNyZWF0ZURlYnVnMltrZXldID0gZW52W2tleV07CiAgICAgIH0pOwogICAgICBjcmVhdGVEZWJ1ZzIubmFtZXMgPSBbXTsKICAgICAgY3JlYXRlRGVidWcyLnNraXBzID0gW107CiAgICAgIGNyZWF0ZURlYnVnMi5mb3JtYXR0ZXJzID0ge307CiAgICAgIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkgewogICAgICAgIGxldCBoYXNoID0gMDsKICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykgewogICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgaGFzaCB8PSAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3JlYXRlRGVidWcyLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnMi5jb2xvcnMubGVuZ3RoXTsKICAgICAgfQogICAgICBjcmVhdGVEZWJ1ZzIuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjsKICAgICAgZnVuY3Rpb24gY3JlYXRlRGVidWcyKG5hbWVzcGFjZSkgewogICAgICAgIGxldCBwcmV2VGltZTsKICAgICAgICBsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsOwogICAgICAgIGxldCBuYW1lc3BhY2VzQ2FjaGU7CiAgICAgICAgbGV0IGVuYWJsZWRDYWNoZTsKICAgICAgICBmdW5jdGlvbiBkZWJ1ZzIoLi4uYXJncykgewogICAgICAgICAgaWYgKCFkZWJ1ZzIuZW5hYmxlZCkgewogICAgICAgICAgICByZXR1cm47CiAgICAgICAgICB9CiAgICAgICAgICBjb25zdCBzZWxmID0gZGVidWcyOwogICAgICAgICAgY29uc3QgY3VyciA9IE51bWJlcigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSk7CiAgICAgICAgICBjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7CiAgICAgICAgICBzZWxmLmRpZmYgPSBtczsKICAgICAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lOwogICAgICAgICAgc2VsZi5jdXJyID0gY3VycjsKICAgICAgICAgIHByZXZUaW1lID0gY3VycjsKICAgICAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1ZzIuY29lcmNlKGFyZ3NbMF0pOwogICAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzBdICE9PSAic3RyaW5nIikgewogICAgICAgICAgICBhcmdzLnVuc2hpZnQoIiVPIik7CiAgICAgICAgICB9CiAgICAgICAgICBsZXQgaW5kZXgyID0gMDsKICAgICAgICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4gewogICAgICAgICAgICBpZiAobWF0Y2ggPT09ICIlJSIpIHsKICAgICAgICAgICAgICByZXR1cm4gIiUiOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGluZGV4MisrOwogICAgICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1ZzIuZm9ybWF0dGVyc1tmb3JtYXRdOwogICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXgyXTsKICAgICAgICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7CiAgICAgICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgyLCAxKTsKICAgICAgICAgICAgICBpbmRleDItLTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbWF0Y2g7CiAgICAgICAgICB9KTsKICAgICAgICAgIGNyZWF0ZURlYnVnMi5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7CiAgICAgICAgICBjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnMi5sb2c7CiAgICAgICAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTsKICAgICAgICB9CiAgICAgICAgZGVidWcyLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTsKICAgICAgICBkZWJ1ZzIudXNlQ29sb3JzID0gY3JlYXRlRGVidWcyLnVzZUNvbG9ycygpOwogICAgICAgIGRlYnVnMi5jb2xvciA9IGNyZWF0ZURlYnVnMi5zZWxlY3RDb2xvcihuYW1lc3BhY2UpOwogICAgICAgIGRlYnVnMi5leHRlbmQgPSBleHRlbmQyOwogICAgICAgIGRlYnVnMi5kZXN0cm95ID0gY3JlYXRlRGVidWcyLmRlc3Ryb3k7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnMiwgImVuYWJsZWQiLCB7CiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSwKICAgICAgICAgIGdldDogKCkgPT4gewogICAgICAgICAgICBpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHsKICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlT3ZlcnJpZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcyLm5hbWVzcGFjZXMpIHsKICAgICAgICAgICAgICBuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1ZzIubmFtZXNwYWNlczsKICAgICAgICAgICAgICBlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1ZzIuZW5hYmxlZChuYW1lc3BhY2UpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBlbmFibGVkQ2FjaGU7CiAgICAgICAgICB9LAogICAgICAgICAgc2V0OiAodikgPT4gewogICAgICAgICAgICBlbmFibGVPdmVycmlkZSA9IHY7CiAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICAgICAgaWYgKHR5cGVvZiBjcmVhdGVEZWJ1ZzIuaW5pdCA9PT0gImZ1bmN0aW9uIikgewogICAgICAgICAgY3JlYXRlRGVidWcyLmluaXQoZGVidWcyKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGRlYnVnMjsKICAgICAgfQogICAgICBmdW5jdGlvbiBleHRlbmQyKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7CiAgICAgICAgY29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1ZzIodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gInVuZGVmaW5lZCIgPyAiOiIgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTsKICAgICAgICBuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZzsKICAgICAgICByZXR1cm4gbmV3RGVidWc7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHsKICAgICAgICBjcmVhdGVEZWJ1ZzIuc2F2ZShuYW1lc3BhY2VzKTsKICAgICAgICBjcmVhdGVEZWJ1ZzIubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7CiAgICAgICAgY3JlYXRlRGVidWcyLm5hbWVzID0gW107CiAgICAgICAgY3JlYXRlRGVidWcyLnNraXBzID0gW107CiAgICAgICAgY29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICJzdHJpbmciID8gbmFtZXNwYWNlcyA6ICIiKS50cmltKCkucmVwbGFjZSgvXHMrL2csICIsIikuc3BsaXQoIiwiKS5maWx0ZXIoQm9vbGVhbik7CiAgICAgICAgZm9yIChjb25zdCBucyBvZiBzcGxpdCkgewogICAgICAgICAgaWYgKG5zWzBdID09PSAiLSIpIHsKICAgICAgICAgICAgY3JlYXRlRGVidWcyLnNraXBzLnB1c2gobnMuc2xpY2UoMSkpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY3JlYXRlRGVidWcyLm5hbWVzLnB1c2gobnMpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBtYXRjaGVzVGVtcGxhdGUoc2VhcmNoMiwgdGVtcGxhdGUpIHsKICAgICAgICBsZXQgc2VhcmNoSW5kZXggPSAwOwogICAgICAgIGxldCB0ZW1wbGF0ZUluZGV4ID0gMDsKICAgICAgICBsZXQgc3RhckluZGV4ID0gLTE7CiAgICAgICAgbGV0IG1hdGNoSW5kZXggPSAwOwogICAgICAgIHdoaWxlIChzZWFyY2hJbmRleCA8IHNlYXJjaDIubGVuZ3RoKSB7CiAgICAgICAgICBpZiAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiAodGVtcGxhdGVbdGVtcGxhdGVJbmRleF0gPT09IHNlYXJjaDJbc2VhcmNoSW5kZXhdIHx8IHRlbXBsYXRlW3RlbXBsYXRlSW5kZXhdID09PSAiKiIpKSB7CiAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gIioiKSB7CiAgICAgICAgICAgICAgc3RhckluZGV4ID0gdGVtcGxhdGVJbmRleDsKICAgICAgICAgICAgICBtYXRjaEluZGV4ID0gc2VhcmNoSW5kZXg7CiAgICAgICAgICAgICAgdGVtcGxhdGVJbmRleCsrOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHNlYXJjaEluZGV4Kys7CiAgICAgICAgICAgICAgdGVtcGxhdGVJbmRleCsrOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJJbmRleCAhPT0gLTEpIHsKICAgICAgICAgICAgdGVtcGxhdGVJbmRleCA9IHN0YXJJbmRleCArIDE7CiAgICAgICAgICAgIG1hdGNoSW5kZXgrKzsKICAgICAgICAgICAgc2VhcmNoSW5kZXggPSBtYXRjaEluZGV4OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB3aGlsZSAodGVtcGxhdGVJbmRleCA8IHRlbXBsYXRlLmxlbmd0aCAmJiB0ZW1wbGF0ZVt0ZW1wbGF0ZUluZGV4XSA9PT0gIioiKSB7CiAgICAgICAgICB0ZW1wbGF0ZUluZGV4Kys7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0ZW1wbGF0ZUluZGV4ID09PSB0ZW1wbGF0ZS5sZW5ndGg7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gZGlzYWJsZTIoKSB7CiAgICAgICAgY29uc3QgbmFtZXNwYWNlcyA9IFsKICAgICAgICAgIC4uLmNyZWF0ZURlYnVnMi5uYW1lcywKICAgICAgICAgIC4uLmNyZWF0ZURlYnVnMi5za2lwcy5tYXAoKG5hbWVzcGFjZSkgPT4gIi0iICsgbmFtZXNwYWNlKQogICAgICAgIF0uam9pbigiLCIpOwogICAgICAgIGNyZWF0ZURlYnVnMi5lbmFibGUoIiIpOwogICAgICAgIHJldHVybiBuYW1lc3BhY2VzOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGVuYWJsZWQobmFtZTIpIHsKICAgICAgICBmb3IgKGNvbnN0IHNraXAgb2YgY3JlYXRlRGVidWcyLnNraXBzKSB7CiAgICAgICAgICBpZiAobWF0Y2hlc1RlbXBsYXRlKG5hbWUyLCBza2lwKSkgewogICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGZvciAoY29uc3QgbnMgb2YgY3JlYXRlRGVidWcyLm5hbWVzKSB7CiAgICAgICAgICBpZiAobWF0Y2hlc1RlbXBsYXRlKG5hbWUyLCBucykpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICBmdW5jdGlvbiBjb2VyY2UodmFsKSB7CiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgICByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gdmFsOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7CiAgICAgICAgY29uc29sZS53YXJuKCJJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuIik7CiAgICAgIH0KICAgICAgY3JlYXRlRGVidWcyLmVuYWJsZShjcmVhdGVEZWJ1ZzIubG9hZCgpKTsKICAgICAgcmV0dXJuIGNyZWF0ZURlYnVnMjsKICAgIH0KICAgIG1vZHVsZS5leHBvcnRzID0gc2V0dXA7CiAgfQp9KTsKCi8vIG5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcwp2YXIgcmVxdWlyZV9icm93c2VyID0gX19jb21tb25KUyh7CiAgIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICBleHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzOwogICAgZXhwb3J0cy5zYXZlID0gc2F2ZTsKICAgIGV4cG9ydHMubG9hZCA9IGxvYWQ7CiAgICBleHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9yczsKICAgIGV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpOwogICAgZXhwb3J0cy5kZXN0cm95ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7CiAgICAgIGxldCB3YXJuZWQgPSBmYWxzZTsKICAgICAgcmV0dXJuICgpID0+IHsKICAgICAgICBpZiAoIXdhcm5lZCkgewogICAgICAgICAgd2FybmVkID0gdHJ1ZTsKICAgICAgICAgIGNvbnNvbGUud2FybigiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLiIpOwogICAgICAgIH0KICAgICAgfTsKICAgIH0pKCk7CiAgICBleHBvcnRzLmNvbG9ycyA9IFsKICAgICAgIiMwMDAwQ0MiLAogICAgICAiIzAwMDBGRiIsCiAgICAgICIjMDAzM0NDIiwKICAgICAgIiMwMDMzRkYiLAogICAgICAiIzAwNjZDQyIsCiAgICAgICIjMDA2NkZGIiwKICAgICAgIiMwMDk5Q0MiLAogICAgICAiIzAwOTlGRiIsCiAgICAgICIjMDBDQzAwIiwKICAgICAgIiMwMENDMzMiLAogICAgICAiIzAwQ0M2NiIsCiAgICAgICIjMDBDQzk5IiwKICAgICAgIiMwMENDQ0MiLAogICAgICAiIzAwQ0NGRiIsCiAgICAgICIjMzMwMENDIiwKICAgICAgIiMzMzAwRkYiLAogICAgICAiIzMzMzNDQyIsCiAgICAgICIjMzMzM0ZGIiwKICAgICAgIiMzMzY2Q0MiLAogICAgICAiIzMzNjZGRiIsCiAgICAgICIjMzM5OUNDIiwKICAgICAgIiMzMzk5RkYiLAogICAgICAiIzMzQ0MwMCIsCiAgICAgICIjMzNDQzMzIiwKICAgICAgIiMzM0NDNjYiLAogICAgICAiIzMzQ0M5OSIsCiAgICAgICIjMzNDQ0NDIiwKICAgICAgIiMzM0NDRkYiLAogICAgICAiIzY2MDBDQyIsCiAgICAgICIjNjYwMEZGIiwKICAgICAgIiM2NjMzQ0MiLAogICAgICAiIzY2MzNGRiIsCiAgICAgICIjNjZDQzAwIiwKICAgICAgIiM2NkNDMzMiLAogICAgICAiIzk5MDBDQyIsCiAgICAgICIjOTkwMEZGIiwKICAgICAgIiM5OTMzQ0MiLAogICAgICAiIzk5MzNGRiIsCiAgICAgICIjOTlDQzAwIiwKICAgICAgIiM5OUNDMzMiLAogICAgICAiI0NDMDAwMCIsCiAgICAgICIjQ0MwMDMzIiwKICAgICAgIiNDQzAwNjYiLAogICAgICAiI0NDMDA5OSIsCiAgICAgICIjQ0MwMENDIiwKICAgICAgIiNDQzAwRkYiLAogICAgICAiI0NDMzMwMCIsCiAgICAgICIjQ0MzMzMzIiwKICAgICAgIiNDQzMzNjYiLAogICAgICAiI0NDMzM5OSIsCiAgICAgICIjQ0MzM0NDIiwKICAgICAgIiNDQzMzRkYiLAogICAgICAiI0NDNjYwMCIsCiAgICAgICIjQ0M2NjMzIiwKICAgICAgIiNDQzk5MDAiLAogICAgICAiI0NDOTkzMyIsCiAgICAgICIjQ0NDQzAwIiwKICAgICAgIiNDQ0NDMzMiLAogICAgICAiI0ZGMDAwMCIsCiAgICAgICIjRkYwMDMzIiwKICAgICAgIiNGRjAwNjYiLAogICAgICAiI0ZGMDA5OSIsCiAgICAgICIjRkYwMENDIiwKICAgICAgIiNGRjAwRkYiLAogICAgICAiI0ZGMzMwMCIsCiAgICAgICIjRkYzMzMzIiwKICAgICAgIiNGRjMzNjYiLAogICAgICAiI0ZGMzM5OSIsCiAgICAgICIjRkYzM0NDIiwKICAgICAgIiNGRjMzRkYiLAogICAgICAiI0ZGNjYwMCIsCiAgICAgICIjRkY2NjMzIiwKICAgICAgIiNGRjk5MDAiLAogICAgICAiI0ZGOTkzMyIsCiAgICAgICIjRkZDQzAwIiwKICAgICAgIiNGRkNDMzMiCiAgICBdOwogICAgZnVuY3Rpb24gdXNlQ29sb3JzKCkgewogICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gInVuZGVmaW5lZCIgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICJyZW5kZXJlciIgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkgewogICAgICAgIHJldHVybiB0cnVlOwogICAgICB9CiAgICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAidW5kZWZpbmVkIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcLyhcZCspLykpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgbGV0IG07CiAgICAgIHJldHVybiB0eXBlb2YgZG9jdW1lbnQgIT09ICJ1bmRlZmluZWQiICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UgfHwgLy8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3MwogICAgICB0eXBlb2Ygd2luZG93ICE9PSAidW5kZWZpbmVkIiAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCB3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpIHx8IC8vIElzIGZpcmVmb3ggPj0gdjMxPwogICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXMKICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gInVuZGVmaW5lZCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiAobSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFwvKFxkKykvKSkgJiYgcGFyc2VJbnQobVsxXSwgMTApID49IDMxIHx8IC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXIKICAgICAgdHlwZW9mIG5hdmlnYXRvciAhPT0gInVuZGVmaW5lZCIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XC8oXGQrKS8pOwogICAgfQogICAgZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7CiAgICAgIGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAiJWMiIDogIiIpICsgdGhpcy5uYW1lc3BhY2UgKyAodGhpcy51c2VDb2xvcnMgPyAiICVjIiA6ICIgIikgKyBhcmdzWzBdICsgKHRoaXMudXNlQ29sb3JzID8gIiVjICIgOiAiICIpICsgIisiICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTsKICAgICAgaWYgKCF0aGlzLnVzZUNvbG9ycykgewogICAgICAgIHJldHVybjsKICAgICAgfQogICAgICBjb25zdCBjID0gImNvbG9yOiAiICsgdGhpcy5jb2xvcjsKICAgICAgYXJncy5zcGxpY2UoMSwgMCwgYywgImNvbG9yOiBpbmhlcml0Iik7CiAgICAgIGxldCBpbmRleDIgPSAwOwogICAgICBsZXQgbGFzdEMgPSAwOwogICAgICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgKG1hdGNoKSA9PiB7CiAgICAgICAgaWYgKG1hdGNoID09PSAiJSUiKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICAgIGluZGV4MisrOwogICAgICAgIGlmIChtYXRjaCA9PT0gIiVjIikgewogICAgICAgICAgbGFzdEMgPSBpbmRleDI7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpOwogICAgfQogICAgZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7CiAgICB9KTsKICAgIGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykgewogICAgICB0cnkgewogICAgICAgIGlmIChuYW1lc3BhY2VzKSB7CiAgICAgICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgiZGVidWciLCBuYW1lc3BhY2VzKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oImRlYnVnIik7CiAgICAgICAgfQogICAgICB9IGNhdGNoIChlcnJvcikgewogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBsb2FkKCkgewogICAgICBsZXQgcjsKICAgICAgdHJ5IHsKICAgICAgICByID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oImRlYnVnIikgfHwgZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oIkRFQlVHIik7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgIH0KICAgICAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAidW5kZWZpbmVkIiAmJiAiZW52IiBpbiBwcm9jZXNzKSB7CiAgICAgICAgciA9IHByb2Nlc3MuZW52LkRFQlVHOwogICAgICB9CiAgICAgIHJldHVybiByOwogICAgfQogICAgZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgIH0KICAgIH0KICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZV9jb21tb24oKShleHBvcnRzKTsKICAgIHZhciB7IGZvcm1hdHRlcnMgfSA9IG1vZHVsZS5leHBvcnRzOwogICAgZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTsKICAgICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgICByZXR1cm4gIltVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAiICsgZXJyb3IubWVzc2FnZTsKICAgICAgfQogICAgfTsKICB9Cn0pOwoKLy8gbm9kZV9tb2R1bGVzL2V4dGVuZC9pbmRleC5qcwp2YXIgcmVxdWlyZV9leHRlbmQgPSBfX2NvbW1vbkpTKHsKICAibm9kZV9tb2R1bGVzL2V4dGVuZC9pbmRleC5qcyIoZXhwb3J0cywgbW9kdWxlKSB7CiAgICAidXNlIHN0cmljdCI7CiAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTsKICAgIHZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7CiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7CiAgICB2YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7CiAgICB2YXIgaXNBcnJheSA9IGZ1bmN0aW9uIGlzQXJyYXkyKGFycikgewogICAgICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpOwogICAgICB9CiAgICAgIHJldHVybiB0b1N0ci5jYWxsKGFycikgPT09ICJbb2JqZWN0IEFycmF5XSI7CiAgICB9OwogICAgdmFyIGlzUGxhaW5PYmplY3QyID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdDMob2JqKSB7CiAgICAgIGlmICghb2JqIHx8IHRvU3RyLmNhbGwob2JqKSAhPT0gIltvYmplY3QgT2JqZWN0XSIpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgdmFyIGhhc093bkNvbnN0cnVjdG9yID0gaGFzT3duLmNhbGwob2JqLCAiY29uc3RydWN0b3IiKTsKICAgICAgdmFyIGhhc0lzUHJvdG90eXBlT2YgPSBvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSAmJiBoYXNPd24uY2FsbChvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCAiaXNQcm90b3R5cGVPZiIpOwogICAgICBpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNPd25Db25zdHJ1Y3RvciAmJiAhaGFzSXNQcm90b3R5cGVPZikgewogICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgfQogICAgICB2YXIga2V5OwogICAgICBmb3IgKGtleSBpbiBvYmopIHsKICAgICAgfQogICAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gInVuZGVmaW5lZCIgfHwgaGFzT3duLmNhbGwob2JqLCBrZXkpOwogICAgfTsKICAgIHZhciBzZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIHNldFByb3BlcnR5Mih0YXJnZXQsIG9wdGlvbnMpIHsKICAgICAgaWYgKGRlZmluZVByb3BlcnR5ICYmIG9wdGlvbnMubmFtZSA9PT0gIl9fcHJvdG9fXyIpIHsKICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG9wdGlvbnMubmFtZSwgewogICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSwKICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSwKICAgICAgICAgIHZhbHVlOiBvcHRpb25zLm5ld1ZhbHVlLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0YXJnZXRbb3B0aW9ucy5uYW1lXSA9IG9wdGlvbnMubmV3VmFsdWU7CiAgICAgIH0KICAgIH07CiAgICB2YXIgZ2V0UHJvcGVydHkgPSBmdW5jdGlvbiBnZXRQcm9wZXJ0eTIob2JqLCBuYW1lMikgewogICAgICBpZiAobmFtZTIgPT09ICJfX3Byb3RvX18iKSB7CiAgICAgICAgaWYgKCFoYXNPd24uY2FsbChvYmosIG5hbWUyKSkgewogICAgICAgICAgcmV0dXJuIHZvaWQgMDsKICAgICAgICB9IGVsc2UgaWYgKGdPUEQpIHsKICAgICAgICAgIHJldHVybiBnT1BEKG9iaiwgbmFtZTIpLnZhbHVlOwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb2JqW25hbWUyXTsKICAgIH07CiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGV4dGVuZDIoKSB7CiAgICAgIHZhciBvcHRpb25zLCBuYW1lMiwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmU7CiAgICAgIHZhciB0YXJnZXQgPSBhcmd1bWVudHNbMF07CiAgICAgIHZhciBpID0gMTsKICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7CiAgICAgIHZhciBkZWVwID0gZmFsc2U7CiAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAiYm9vbGVhbiIpIHsKICAgICAgICBkZWVwID0gdGFyZ2V0OwogICAgICAgIHRhcmdldCA9IGFyZ3VtZW50c1sxXSB8fCB7fTsKICAgICAgICBpID0gMjsKICAgICAgfQogICAgICBpZiAodGFyZ2V0ID09IG51bGwgfHwgdHlwZW9mIHRhcmdldCAhPT0gIm9iamVjdCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gImZ1bmN0aW9uIikgewogICAgICAgIHRhcmdldCA9IHt9OwogICAgICB9CiAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyArK2kpIHsKICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzW2ldOwogICAgICAgIGlmIChvcHRpb25zICE9IG51bGwpIHsKICAgICAgICAgIGZvciAobmFtZTIgaW4gb3B0aW9ucykgewogICAgICAgICAgICBzcmMgPSBnZXRQcm9wZXJ0eSh0YXJnZXQsIG5hbWUyKTsKICAgICAgICAgICAgY29weSA9IGdldFByb3BlcnR5KG9wdGlvbnMsIG5hbWUyKTsKICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gY29weSkgewogICAgICAgICAgICAgIGlmIChkZWVwICYmIGNvcHkgJiYgKGlzUGxhaW5PYmplY3QyKGNvcHkpIHx8IChjb3B5SXNBcnJheSA9IGlzQXJyYXkoY29weSkpKSkgewogICAgICAgICAgICAgICAgaWYgKGNvcHlJc0FycmF5KSB7CiAgICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgIGNsb25lID0gc3JjICYmIGlzQXJyYXkoc3JjKSA/IHNyYyA6IFtdOwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdDIoc3JjKSA/IHNyYyA6IHt9OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc2V0UHJvcGVydHkodGFyZ2V0LCB7IG5hbWU6IG5hbWUyLCBuZXdWYWx1ZTogZXh0ZW5kMihkZWVwLCBjbG9uZSwgY29weSkgfSk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY29weSAhPT0gInVuZGVmaW5lZCIpIHsKICAgICAgICAgICAgICAgIHNldFByb3BlcnR5KHRhcmdldCwgeyBuYW1lOiBuYW1lMiwgbmV3VmFsdWU6IGNvcHkgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB0YXJnZXQ7CiAgICB9OwogIH0KfSk7CgovLyBub2RlX21vZHVsZXMvZXN0cmVlLXV0aWwtaXMtaWRlbnRpZmllci1uYW1lL2xpYi9pbmRleC5qcwp2YXIgbmFtZVJlID0gL15bJF9ccHtJRF9TdGFydH1dWyRfXHV7MjAwQ31cdXsyMDBEfVxwe0lEX0NvbnRpbnVlfV0qJC91Owp2YXIgbmFtZVJlSnN4ID0gL15bJF9ccHtJRF9TdGFydH1dWy0kX1x1ezIwMEN9XHV7MjAwRH1ccHtJRF9Db250aW51ZX1dKiQvdTsKdmFyIGVtcHR5T3B0aW9ucyA9IHt9OwpmdW5jdGlvbiBuYW1lKG5hbWUyLCBvcHRpb25zKSB7CiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IGVtcHR5T3B0aW9uczsKICBjb25zdCByZTIgPSBzZXR0aW5ncy5qc3ggPyBuYW1lUmVKc3ggOiBuYW1lUmU7CiAgcmV0dXJuIHJlMi50ZXN0KG5hbWUyKTsKfQoKLy8gbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC13aGl0ZXNwYWNlL2xpYi9pbmRleC5qcwp2YXIgcmUgPSAvWyBcdFxuXGZccl0vZzsKZnVuY3Rpb24gd2hpdGVzcGFjZSh0aGluZykgewogIHJldHVybiB0eXBlb2YgdGhpbmcgPT09ICJvYmplY3QiID8gdGhpbmcudHlwZSA9PT0gInRleHQiID8gZW1wdHkodGhpbmcudmFsdWUpIDogZmFsc2UgOiBlbXB0eSh0aGluZyk7Cn0KZnVuY3Rpb24gZW1wdHkodmFsdWUpIHsKICByZXR1cm4gdmFsdWUucmVwbGFjZShyZSwgIiIpID09PSAiIjsKfQoKLy8gbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanMKdmFyIGltcG9ydF9zdHlsZV90b19qcyA9IF9fdG9FU00ocmVxdWlyZV9janMyKCksIDEpOwoKLy8gbm9kZV9tb2R1bGVzL3VuaXN0LXV0aWwtc3RyaW5naWZ5LXBvc2l0aW9uL2xpYi9pbmRleC5qcwpmdW5jdGlvbiBzdHJpbmdpZnlQb3NpdGlvbih2YWx1ZSkgewogIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAib2JqZWN0IikgewogICAgcmV0dXJuICIiOwogIH0KICBpZiAoInBvc2l0aW9uIiBpbiB2YWx1ZSB8fCAidHlwZSIgaW4gdmFsdWUpIHsKICAgIHJldHVybiBwb3NpdGlvbjIodmFsdWUucG9zaXRpb24pOwogIH0KICBpZiAoInN0YXJ0IiBpbiB2YWx1ZSB8fCAiZW5kIiBpbiB2YWx1ZSkgewogICAgcmV0dXJuIHBvc2l0aW9uMih2YWx1ZSk7CiAgfQogIGlmICgibGluZSIgaW4gdmFsdWUgfHwgImNvbHVtbiIgaW4gdmFsdWUpIHsKICAgIHJldHVybiBwb2ludCh2YWx1ZSk7CiAgfQogIHJldHVybiAiIjsKfQpmdW5jdGlvbiBwb2ludChwb2ludDMpIHsKICByZXR1cm4gaW5kZXgocG9pbnQzICYmIHBvaW50My5saW5lKSArICI6IiArIGluZGV4KHBvaW50MyAmJiBwb2ludDMuY29sdW1uKTsKfQpmdW5jdGlvbiBwb3NpdGlvbjIocG9zKSB7CiAgcmV0dXJuIHBvaW50KHBvcyAmJiBwb3Muc3RhcnQpICsgIi0iICsgcG9pbnQocG9zICYmIHBvcy5lbmQpOwp9CmZ1bmN0aW9uIGluZGV4KHZhbHVlKSB7CiAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gIm51bWJlciIgPyB2YWx1ZSA6IDE7Cn0KCi8vIG5vZGVfbW9kdWxlcy92ZmlsZS1tZXNzYWdlL2xpYi9pbmRleC5qcwp2YXIgVkZpbGVNZXNzYWdlID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7CiAgLyoqCiAgICogQ3JlYXRlIGEgbWVzc2FnZSBmb3IgYHJlYXNvbmAuCiAgICoKICAgKiA+IPCfqqYgKipOb3RlKio6IGFsc28gaGFzIG9ic29sZXRlIHNpZ25hdHVyZXMuCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uCiAgICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdCiAgICogQHJldHVybnMKICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24KICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudAogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucwogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbgogICAqIEBwYXJhbSB7UG9pbnQgfCBQb3NpdGlvbiB8IG51bGwgfCB1bmRlZmluZWR9IHBsYWNlCiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uCiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZQogICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGFyZW50CiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZQogICAqIEBwYXJhbSB7UG9pbnQgfCBQb3NpdGlvbiB8IG51bGwgfCB1bmRlZmluZWR9IHBsYWNlCiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZQogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucwogICAqCiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZSB8IHN0cmluZ30gY2F1c2VPclJlYXNvbgogICAqICAgUmVhc29uIGZvciBtZXNzYWdlLCBzaG91bGQgdXNlIG1hcmtkb3duLgogICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgT3B0aW9ucyB8IFBvaW50IHwgUG9zaXRpb24gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc09yUGFyZW50T3JQbGFjZV0KICAgKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS4KICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6CiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS4KICAgKiBAcmV0dXJucwogICAqICAgSW5zdGFuY2Ugb2YgYFZGaWxlTWVzc2FnZWAuCiAgICovCiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHkKICBjb25zdHJ1Y3RvcihjYXVzZU9yUmVhc29uLCBvcHRpb25zT3JQYXJlbnRPclBsYWNlLCBvcmlnaW4pIHsKICAgIHN1cGVyKCk7CiAgICBpZiAodHlwZW9mIG9wdGlvbnNPclBhcmVudE9yUGxhY2UgPT09ICJzdHJpbmciKSB7CiAgICAgIG9yaWdpbiA9IG9wdGlvbnNPclBhcmVudE9yUGxhY2U7CiAgICAgIG9wdGlvbnNPclBhcmVudE9yUGxhY2UgPSB2b2lkIDA7CiAgICB9CiAgICBsZXQgcmVhc29uID0gIiI7CiAgICBsZXQgb3B0aW9ucyA9IHt9OwogICAgbGV0IGxlZ2FjeUNhdXNlID0gZmFsc2U7CiAgICBpZiAob3B0aW9uc09yUGFyZW50T3JQbGFjZSkgewogICAgICBpZiAoImxpbmUiIGluIG9wdGlvbnNPclBhcmVudE9yUGxhY2UgJiYgImNvbHVtbiIgaW4gb3B0aW9uc09yUGFyZW50T3JQbGFjZSkgewogICAgICAgIG9wdGlvbnMgPSB7IHBsYWNlOiBvcHRpb25zT3JQYXJlbnRPclBsYWNlIH07CiAgICAgIH0gZWxzZSBpZiAoInN0YXJ0IiBpbiBvcHRpb25zT3JQYXJlbnRPclBsYWNlICYmICJlbmQiIGluIG9wdGlvbnNPclBhcmVudE9yUGxhY2UpIHsKICAgICAgICBvcHRpb25zID0geyBwbGFjZTogb3B0aW9uc09yUGFyZW50T3JQbGFjZSB9OwogICAgICB9IGVsc2UgaWYgKCJ0eXBlIiBpbiBvcHRpb25zT3JQYXJlbnRPclBsYWNlKSB7CiAgICAgICAgb3B0aW9ucyA9IHsKICAgICAgICAgIGFuY2VzdG9yczogW29wdGlvbnNPclBhcmVudE9yUGxhY2VdLAogICAgICAgICAgcGxhY2U6IG9wdGlvbnNPclBhcmVudE9yUGxhY2UucG9zaXRpb24KICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnNPclBhcmVudE9yUGxhY2UgfTsKICAgICAgfQogICAgfQogICAgaWYgKHR5cGVvZiBjYXVzZU9yUmVhc29uID09PSAic3RyaW5nIikgewogICAgICByZWFzb24gPSBjYXVzZU9yUmVhc29uOwogICAgfSBlbHNlIGlmICghb3B0aW9ucy5jYXVzZSAmJiBjYXVzZU9yUmVhc29uKSB7CiAgICAgIGxlZ2FjeUNhdXNlID0gdHJ1ZTsKICAgICAgcmVhc29uID0gY2F1c2VPclJlYXNvbi5tZXNzYWdlOwogICAgICBvcHRpb25zLmNhdXNlID0gY2F1c2VPclJlYXNvbjsKICAgIH0KICAgIGlmICghb3B0aW9ucy5ydWxlSWQgJiYgIW9wdGlvbnMuc291cmNlICYmIHR5cGVvZiBvcmlnaW4gPT09ICJzdHJpbmciKSB7CiAgICAgIGNvbnN0IGluZGV4MiA9IG9yaWdpbi5pbmRleE9mKCI6Iik7CiAgICAgIGlmIChpbmRleDIgPT09IC0xKSB7CiAgICAgICAgb3B0aW9ucy5ydWxlSWQgPSBvcmlnaW47CiAgICAgIH0gZWxzZSB7CiAgICAgICAgb3B0aW9ucy5zb3VyY2UgPSBvcmlnaW4uc2xpY2UoMCwgaW5kZXgyKTsKICAgICAgICBvcHRpb25zLnJ1bGVJZCA9IG9yaWdpbi5zbGljZShpbmRleDIgKyAxKTsKICAgICAgfQogICAgfQogICAgaWYgKCFvcHRpb25zLnBsYWNlICYmIG9wdGlvbnMuYW5jZXN0b3JzICYmIG9wdGlvbnMuYW5jZXN0b3JzKSB7CiAgICAgIGNvbnN0IHBhcmVudCA9IG9wdGlvbnMuYW5jZXN0b3JzW29wdGlvbnMuYW5jZXN0b3JzLmxlbmd0aCAtIDFdOwogICAgICBpZiAocGFyZW50KSB7CiAgICAgICAgb3B0aW9ucy5wbGFjZSA9IHBhcmVudC5wb3NpdGlvbjsKICAgICAgfQogICAgfQogICAgY29uc3Qgc3RhcnQyID0gb3B0aW9ucy5wbGFjZSAmJiAic3RhcnQiIGluIG9wdGlvbnMucGxhY2UgPyBvcHRpb25zLnBsYWNlLnN0YXJ0IDogb3B0aW9ucy5wbGFjZTsKICAgIHRoaXMuYW5jZXN0b3JzID0gb3B0aW9ucy5hbmNlc3RvcnMgfHwgdm9pZCAwOwogICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMuY2F1c2UgfHwgdm9pZCAwOwogICAgdGhpcy5jb2x1bW4gPSBzdGFydDIgPyBzdGFydDIuY29sdW1uIDogdm9pZCAwOwogICAgdGhpcy5mYXRhbCA9IHZvaWQgMDsKICAgIHRoaXMuZmlsZSA9ICIiOwogICAgdGhpcy5tZXNzYWdlID0gcmVhc29uOwogICAgdGhpcy5saW5lID0gc3RhcnQyID8gc3RhcnQyLmxpbmUgOiB2b2lkIDA7CiAgICB0aGlzLm5hbWUgPSBzdHJpbmdpZnlQb3NpdGlvbihvcHRpb25zLnBsYWNlKSB8fCAiMToxIjsKICAgIHRoaXMucGxhY2UgPSBvcHRpb25zLnBsYWNlIHx8IHZvaWQgMDsKICAgIHRoaXMucmVhc29uID0gdGhpcy5tZXNzYWdlOwogICAgdGhpcy5ydWxlSWQgPSBvcHRpb25zLnJ1bGVJZCB8fCB2b2lkIDA7CiAgICB0aGlzLnNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8IHZvaWQgMDsKICAgIHRoaXMuc3RhY2sgPSBsZWdhY3lDYXVzZSAmJiBvcHRpb25zLmNhdXNlICYmIHR5cGVvZiBvcHRpb25zLmNhdXNlLnN0YWNrID09PSAic3RyaW5nIiA/IG9wdGlvbnMuY2F1c2Uuc3RhY2sgOiAiIjsKICAgIHRoaXMuYWN0dWFsID0gdm9pZCAwOwogICAgdGhpcy5leHBlY3RlZCA9IHZvaWQgMDsKICAgIHRoaXMubm90ZSA9IHZvaWQgMDsKICAgIHRoaXMudXJsID0gdm9pZCAwOwogIH0KfTsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5maWxlID0gIiI7ClZGaWxlTWVzc2FnZS5wcm90b3R5cGUubmFtZSA9ICIiOwpWRmlsZU1lc3NhZ2UucHJvdG90eXBlLnJlYXNvbiA9ICIiOwpWRmlsZU1lc3NhZ2UucHJvdG90eXBlLm1lc3NhZ2UgPSAiIjsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5zdGFjayA9ICIiOwpWRmlsZU1lc3NhZ2UucHJvdG90eXBlLmNvbHVtbiA9IHZvaWQgMDsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5saW5lID0gdm9pZCAwOwpWRmlsZU1lc3NhZ2UucHJvdG90eXBlLmFuY2VzdG9ycyA9IHZvaWQgMDsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5jYXVzZSA9IHZvaWQgMDsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5mYXRhbCA9IHZvaWQgMDsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5wbGFjZSA9IHZvaWQgMDsKVkZpbGVNZXNzYWdlLnByb3RvdHlwZS5ydWxlSWQgPSB2b2lkIDA7ClZGaWxlTWVzc2FnZS5wcm90b3R5cGUuc291cmNlID0gdm9pZCAwOwoKLy8gbm9kZV9tb2R1bGVzL2hhc3QtdXRpbC10by1qc3gtcnVudGltZS9saWIvaW5kZXguanMKdmFyIG93biA9IHt9Lmhhc093blByb3BlcnR5Owp2YXIgZW1wdHlNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwp2YXIgY2FwID0gL1tBLVpdL2c7CnZhciB0YWJsZUVsZW1lbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWyJ0YWJsZSIsICJ0Ym9keSIsICJ0aGVhZCIsICJ0Zm9vdCIsICJ0ciJdKTsKdmFyIHRhYmxlQ2VsbEVsZW1lbnQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbInRkIiwgInRoIl0pOwp2YXIgZG9jcyA9ICJodHRwczovL2dpdGh1Yi5jb20vc3ludGF4LXRyZWUvaGFzdC11dGlsLXRvLWpzeC1ydW50aW1lIjsKZnVuY3Rpb24gdG9Kc3hSdW50aW1lKHRyZWUsIG9wdGlvbnMpIHsKICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5GcmFnbWVudCA9PT0gdm9pZCAwKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RlZCBgRnJhZ21lbnRgIGluIG9wdGlvbnMiKTsKICB9CiAgY29uc3QgZmlsZVBhdGggPSBvcHRpb25zLmZpbGVQYXRoIHx8IHZvaWQgMDsKICBsZXQgY3JlYXRlOwogIGlmIChvcHRpb25zLmRldmVsb3BtZW50KSB7CiAgICBpZiAodHlwZW9mIG9wdGlvbnMuanN4REVWICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgIkV4cGVjdGVkIGBqc3hERVZgIGluIG9wdGlvbnMgd2hlbiBgZGV2ZWxvcG1lbnQ6IHRydWVgIgogICAgICApOwogICAgfQogICAgY3JlYXRlID0gZGV2ZWxvcG1lbnRDcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4REVWKTsKICB9IGVsc2UgewogICAgaWYgKHR5cGVvZiBvcHRpb25zLmpzeCAhPT0gImZ1bmN0aW9uIikgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RlZCBganN4YCBpbiBwcm9kdWN0aW9uIG9wdGlvbnMiKTsKICAgIH0KICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5qc3hzICE9PSAiZnVuY3Rpb24iKSB7CiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkV4cGVjdGVkIGBqc3hzYCBpbiBwcm9kdWN0aW9uIG9wdGlvbnMiKTsKICAgIH0KICAgIGNyZWF0ZSA9IHByb2R1Y3Rpb25DcmVhdGUoZmlsZVBhdGgsIG9wdGlvbnMuanN4LCBvcHRpb25zLmpzeHMpOwogIH0KICBjb25zdCBzdGF0ZSA9IHsKICAgIEZyYWdtZW50OiBvcHRpb25zLkZyYWdtZW50LAogICAgYW5jZXN0b3JzOiBbXSwKICAgIGNvbXBvbmVudHM6IG9wdGlvbnMuY29tcG9uZW50cyB8fCB7fSwKICAgIGNyZWF0ZSwKICAgIGVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZTogb3B0aW9ucy5lbGVtZW50QXR0cmlidXRlTmFtZUNhc2UgfHwgInJlYWN0IiwKICAgIGV2YWx1YXRlcjogb3B0aW9ucy5jcmVhdGVFdmFsdWF0ZXIgPyBvcHRpb25zLmNyZWF0ZUV2YWx1YXRlcigpIDogdm9pZCAwLAogICAgZmlsZVBhdGgsCiAgICBpZ25vcmVJbnZhbGlkU3R5bGU6IG9wdGlvbnMuaWdub3JlSW52YWxpZFN0eWxlIHx8IGZhbHNlLAogICAgcGFzc0tleXM6IG9wdGlvbnMucGFzc0tleXMgIT09IGZhbHNlLAogICAgcGFzc05vZGU6IG9wdGlvbnMucGFzc05vZGUgfHwgZmFsc2UsCiAgICBzY2hlbWE6IG9wdGlvbnMuc3BhY2UgPT09ICJzdmciID8gc3ZnIDogaHRtbCwKICAgIHN0eWxlUHJvcGVydHlOYW1lQ2FzZTogb3B0aW9ucy5zdHlsZVByb3BlcnR5TmFtZUNhc2UgfHwgImRvbSIsCiAgICB0YWJsZUNlbGxBbGlnblRvU3R5bGU6IG9wdGlvbnMudGFibGVDZWxsQWxpZ25Ub1N0eWxlICE9PSBmYWxzZQogIH07CiAgY29uc3QgcmVzdWx0ID0gb25lKHN0YXRlLCB0cmVlLCB2b2lkIDApOwogIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdCAhPT0gInN0cmluZyIpIHsKICAgIHJldHVybiByZXN1bHQ7CiAgfQogIHJldHVybiBzdGF0ZS5jcmVhdGUoCiAgICB0cmVlLAogICAgc3RhdGUuRnJhZ21lbnQsCiAgICB7IGNoaWxkcmVuOiByZXN1bHQgfHwgdm9pZCAwIH0sCiAgICB2b2lkIDAKICApOwp9CmZ1bmN0aW9uIG9uZShzdGF0ZSwgbm9kZSwga2V5KSB7CiAgaWYgKG5vZGUudHlwZSA9PT0gImVsZW1lbnQiKSB7CiAgICByZXR1cm4gZWxlbWVudChzdGF0ZSwgbm9kZSwga2V5KTsKICB9CiAgaWYgKG5vZGUudHlwZSA9PT0gIm1keEZsb3dFeHByZXNzaW9uIiB8fCBub2RlLnR5cGUgPT09ICJtZHhUZXh0RXhwcmVzc2lvbiIpIHsKICAgIHJldHVybiBtZHhFeHByZXNzaW9uKHN0YXRlLCBub2RlKTsKICB9CiAgaWYgKG5vZGUudHlwZSA9PT0gIm1keEpzeEZsb3dFbGVtZW50IiB8fCBub2RlLnR5cGUgPT09ICJtZHhKc3hUZXh0RWxlbWVudCIpIHsKICAgIHJldHVybiBtZHhKc3hFbGVtZW50KHN0YXRlLCBub2RlLCBrZXkpOwogIH0KICBpZiAobm9kZS50eXBlID09PSAibWR4anNFc20iKSB7CiAgICByZXR1cm4gbWR4RXNtKHN0YXRlLCBub2RlKTsKICB9CiAgaWYgKG5vZGUudHlwZSA9PT0gInJvb3QiKSB7CiAgICByZXR1cm4gcm9vdChzdGF0ZSwgbm9kZSwga2V5KTsKICB9CiAgaWYgKG5vZGUudHlwZSA9PT0gInRleHQiKSB7CiAgICByZXR1cm4gdGV4dChzdGF0ZSwgbm9kZSk7CiAgfQp9CmZ1bmN0aW9uIGVsZW1lbnQoc3RhdGUsIG5vZGUsIGtleSkgewogIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYTsKICBsZXQgc2NoZW1hID0gcGFyZW50U2NoZW1hOwogIGlmIChub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gInN2ZyIgJiYgcGFyZW50U2NoZW1hLnNwYWNlID09PSAiaHRtbCIpIHsKICAgIHNjaGVtYSA9IHN2ZzsKICAgIHN0YXRlLnNjaGVtYSA9IHNjaGVtYTsKICB9CiAgc3RhdGUuYW5jZXN0b3JzLnB1c2gobm9kZSk7CiAgY29uc3QgdHlwZSA9IGZpbmRDb21wb25lbnRGcm9tTmFtZShzdGF0ZSwgbm9kZS50YWdOYW1lLCBmYWxzZSk7CiAgY29uc3QgcHJvcHMgPSBjcmVhdGVFbGVtZW50UHJvcHMoc3RhdGUsIG5vZGUpOwogIGxldCBjaGlsZHJlbiA9IGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKTsKICBpZiAodGFibGVFbGVtZW50cy5oYXMobm9kZS50YWdOYW1lKSkgewogICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24oY2hpbGQpIHsKICAgICAgcmV0dXJuIHR5cGVvZiBjaGlsZCA9PT0gInN0cmluZyIgPyAhd2hpdGVzcGFjZShjaGlsZCkgOiB0cnVlOwogICAgfSk7CiAgfQogIGFkZE5vZGUoc3RhdGUsIHByb3BzLCB0eXBlLCBub2RlKTsKICBhZGRDaGlsZHJlbihwcm9wcywgY2hpbGRyZW4pOwogIHN0YXRlLmFuY2VzdG9ycy5wb3AoKTsKICBzdGF0ZS5zY2hlbWEgPSBwYXJlbnRTY2hlbWE7CiAgcmV0dXJuIHN0YXRlLmNyZWF0ZShub2RlLCB0eXBlLCBwcm9wcywga2V5KTsKfQpmdW5jdGlvbiBtZHhFeHByZXNzaW9uKHN0YXRlLCBub2RlKSB7CiAgaWYgKG5vZGUuZGF0YSAmJiBub2RlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikgewogICAgY29uc3QgcHJvZ3JhbSA9IG5vZGUuZGF0YS5lc3RyZWU7CiAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdOwogICAgb2soZXhwcmVzc2lvbi50eXBlID09PSAiRXhwcmVzc2lvblN0YXRlbWVudCIpOwogICAgcmV0dXJuICgKICAgICAgLyoqIEB0eXBlIHtDaGlsZCB8IHVuZGVmaW5lZH0gKi8KICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihleHByZXNzaW9uLmV4cHJlc3Npb24pCiAgICApOwogIH0KICBjcmFzaEVzdHJlZShzdGF0ZSwgbm9kZS5wb3NpdGlvbik7Cn0KZnVuY3Rpb24gbWR4RXNtKHN0YXRlLCBub2RlKSB7CiAgaWYgKG5vZGUuZGF0YSAmJiBub2RlLmRhdGEuZXN0cmVlICYmIHN0YXRlLmV2YWx1YXRlcikgewogICAgcmV0dXJuICgKICAgICAgLyoqIEB0eXBlIHtDaGlsZCB8IHVuZGVmaW5lZH0gKi8KICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlUHJvZ3JhbShub2RlLmRhdGEuZXN0cmVlKQogICAgKTsKICB9CiAgY3Jhc2hFc3RyZWUoc3RhdGUsIG5vZGUucG9zaXRpb24pOwp9CmZ1bmN0aW9uIG1keEpzeEVsZW1lbnQoc3RhdGUsIG5vZGUsIGtleSkgewogIGNvbnN0IHBhcmVudFNjaGVtYSA9IHN0YXRlLnNjaGVtYTsKICBsZXQgc2NoZW1hID0gcGFyZW50U2NoZW1hOwogIGlmIChub2RlLm5hbWUgPT09ICJzdmciICYmIHBhcmVudFNjaGVtYS5zcGFjZSA9PT0gImh0bWwiKSB7CiAgICBzY2hlbWEgPSBzdmc7CiAgICBzdGF0ZS5zY2hlbWEgPSBzY2hlbWE7CiAgfQogIHN0YXRlLmFuY2VzdG9ycy5wdXNoKG5vZGUpOwogIGNvbnN0IHR5cGUgPSBub2RlLm5hbWUgPT09IG51bGwgPyBzdGF0ZS5GcmFnbWVudCA6IGZpbmRDb21wb25lbnRGcm9tTmFtZShzdGF0ZSwgbm9kZS5uYW1lLCB0cnVlKTsKICBjb25zdCBwcm9wcyA9IGNyZWF0ZUpzeEVsZW1lbnRQcm9wcyhzdGF0ZSwgbm9kZSk7CiAgY29uc3QgY2hpbGRyZW4gPSBjcmVhdGVDaGlsZHJlbihzdGF0ZSwgbm9kZSk7CiAgYWRkTm9kZShzdGF0ZSwgcHJvcHMsIHR5cGUsIG5vZGUpOwogIGFkZENoaWxkcmVuKHByb3BzLCBjaGlsZHJlbik7CiAgc3RhdGUuYW5jZXN0b3JzLnBvcCgpOwogIHN0YXRlLnNjaGVtYSA9IHBhcmVudFNjaGVtYTsKICByZXR1cm4gc3RhdGUuY3JlYXRlKG5vZGUsIHR5cGUsIHByb3BzLCBrZXkpOwp9CmZ1bmN0aW9uIHJvb3Qoc3RhdGUsIG5vZGUsIGtleSkgewogIGNvbnN0IHByb3BzID0ge307CiAgYWRkQ2hpbGRyZW4ocHJvcHMsIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSk7CiAgcmV0dXJuIHN0YXRlLmNyZWF0ZShub2RlLCBzdGF0ZS5GcmFnbWVudCwgcHJvcHMsIGtleSk7Cn0KZnVuY3Rpb24gdGV4dChfLCBub2RlKSB7CiAgcmV0dXJuIG5vZGUudmFsdWU7Cn0KZnVuY3Rpb24gYWRkTm9kZShzdGF0ZSwgcHJvcHMsIHR5cGUsIG5vZGUpIHsKICBpZiAodHlwZW9mIHR5cGUgIT09ICJzdHJpbmciICYmIHR5cGUgIT09IHN0YXRlLkZyYWdtZW50ICYmIHN0YXRlLnBhc3NOb2RlKSB7CiAgICBwcm9wcy5ub2RlID0gbm9kZTsKICB9Cn0KZnVuY3Rpb24gYWRkQ2hpbGRyZW4ocHJvcHMsIGNoaWxkcmVuKSB7CiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDApIHsKICAgIGNvbnN0IHZhbHVlID0gY2hpbGRyZW4ubGVuZ3RoID4gMSA/IGNoaWxkcmVuIDogY2hpbGRyZW5bMF07CiAgICBpZiAodmFsdWUpIHsKICAgICAgcHJvcHMuY2hpbGRyZW4gPSB2YWx1ZTsKICAgIH0KICB9Cn0KZnVuY3Rpb24gcHJvZHVjdGlvbkNyZWF0ZShfLCBqc3gyLCBqc3hzMikgewogIHJldHVybiBjcmVhdGU7CiAgZnVuY3Rpb24gY3JlYXRlKF8yLCB0eXBlLCBwcm9wcywga2V5KSB7CiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7CiAgICBjb25zdCBmbiA9IGlzU3RhdGljQ2hpbGRyZW4gPyBqc3hzMiA6IGpzeDI7CiAgICByZXR1cm4ga2V5ID8gZm4odHlwZSwgcHJvcHMsIGtleSkgOiBmbih0eXBlLCBwcm9wcyk7CiAgfQp9CmZ1bmN0aW9uIGRldmVsb3BtZW50Q3JlYXRlKGZpbGVQYXRoLCBqc3hERVYpIHsKICByZXR1cm4gY3JlYXRlOwogIGZ1bmN0aW9uIGNyZWF0ZShub2RlLCB0eXBlLCBwcm9wcywga2V5KSB7CiAgICBjb25zdCBpc1N0YXRpY0NoaWxkcmVuID0gQXJyYXkuaXNBcnJheShwcm9wcy5jaGlsZHJlbik7CiAgICBjb25zdCBwb2ludDMgPSBwb2ludFN0YXJ0KG5vZGUpOwogICAgcmV0dXJuIGpzeERFVigKICAgICAgdHlwZSwKICAgICAgcHJvcHMsCiAgICAgIGtleSwKICAgICAgaXNTdGF0aWNDaGlsZHJlbiwKICAgICAgewogICAgICAgIGNvbHVtbk51bWJlcjogcG9pbnQzID8gcG9pbnQzLmNvbHVtbiAtIDEgOiB2b2lkIDAsCiAgICAgICAgZmlsZU5hbWU6IGZpbGVQYXRoLAogICAgICAgIGxpbmVOdW1iZXI6IHBvaW50MyA/IHBvaW50My5saW5lIDogdm9pZCAwCiAgICAgIH0sCiAgICAgIHZvaWQgMAogICAgKTsKICB9Cn0KZnVuY3Rpb24gY3JlYXRlRWxlbWVudFByb3BzKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcHJvcHMgPSB7fTsKICBsZXQgYWxpZ25WYWx1ZTsKICBsZXQgcHJvcDsKICBmb3IgKHByb3AgaW4gbm9kZS5wcm9wZXJ0aWVzKSB7CiAgICBpZiAocHJvcCAhPT0gImNoaWxkcmVuIiAmJiBvd24uY2FsbChub2RlLnByb3BlcnRpZXMsIHByb3ApKSB7CiAgICAgIGNvbnN0IHJlc3VsdCA9IGNyZWF0ZVByb3BlcnR5KHN0YXRlLCBwcm9wLCBub2RlLnByb3BlcnRpZXNbcHJvcF0pOwogICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gcmVzdWx0OwogICAgICAgIGlmIChzdGF0ZS50YWJsZUNlbGxBbGlnblRvU3R5bGUgJiYga2V5ID09PSAiYWxpZ24iICYmIHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIgJiYgdGFibGVDZWxsRWxlbWVudC5oYXMobm9kZS50YWdOYW1lKSkgewogICAgICAgICAgYWxpZ25WYWx1ZSA9IHZhbHVlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwcm9wc1trZXldID0gdmFsdWU7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIGlmIChhbGlnblZhbHVlKSB7CiAgICBjb25zdCBzdHlsZSA9ICgKICAgICAgLyoqIEB0eXBlIHtTdHlsZX0gKi8KICAgICAgcHJvcHMuc3R5bGUgfHwgKHByb3BzLnN0eWxlID0ge30pCiAgICApOwogICAgc3R5bGVbc3RhdGUuc3R5bGVQcm9wZXJ0eU5hbWVDYXNlID09PSAiY3NzIiA/ICJ0ZXh0LWFsaWduIiA6ICJ0ZXh0QWxpZ24iXSA9IGFsaWduVmFsdWU7CiAgfQogIHJldHVybiBwcm9wczsKfQpmdW5jdGlvbiBjcmVhdGVKc3hFbGVtZW50UHJvcHMoc3RhdGUsIG5vZGUpIHsKICBjb25zdCBwcm9wcyA9IHt9OwogIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIG5vZGUuYXR0cmlidXRlcykgewogICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAibWR4SnN4RXhwcmVzc2lvbkF0dHJpYnV0ZSIpIHsKICAgICAgaWYgKGF0dHJpYnV0ZS5kYXRhICYmIGF0dHJpYnV0ZS5kYXRhLmVzdHJlZSAmJiBzdGF0ZS5ldmFsdWF0ZXIpIHsKICAgICAgICBjb25zdCBwcm9ncmFtID0gYXR0cmlidXRlLmRhdGEuZXN0cmVlOwogICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBwcm9ncmFtLmJvZHlbMF07CiAgICAgICAgb2soZXhwcmVzc2lvbi50eXBlID09PSAiRXhwcmVzc2lvblN0YXRlbWVudCIpOwogICAgICAgIGNvbnN0IG9iamVjdEV4cHJlc3Npb24gPSBleHByZXNzaW9uLmV4cHJlc3Npb247CiAgICAgICAgb2sob2JqZWN0RXhwcmVzc2lvbi50eXBlID09PSAiT2JqZWN0RXhwcmVzc2lvbiIpOwogICAgICAgIGNvbnN0IHByb3BlcnR5ID0gb2JqZWN0RXhwcmVzc2lvbi5wcm9wZXJ0aWVzWzBdOwogICAgICAgIG9rKHByb3BlcnR5LnR5cGUgPT09ICJTcHJlYWRFbGVtZW50Iik7CiAgICAgICAgT2JqZWN0LmFzc2lnbigKICAgICAgICAgIHByb3BzLAogICAgICAgICAgc3RhdGUuZXZhbHVhdGVyLmV2YWx1YXRlRXhwcmVzc2lvbihwcm9wZXJ0eS5hcmd1bWVudCkKICAgICAgICApOwogICAgICB9IGVsc2UgewogICAgICAgIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgY29uc3QgbmFtZTIgPSBhdHRyaWJ1dGUubmFtZTsKICAgICAgbGV0IHZhbHVlOwogICAgICBpZiAoYXR0cmlidXRlLnZhbHVlICYmIHR5cGVvZiBhdHRyaWJ1dGUudmFsdWUgPT09ICJvYmplY3QiKSB7CiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZS5kYXRhICYmIGF0dHJpYnV0ZS52YWx1ZS5kYXRhLmVzdHJlZSAmJiBzdGF0ZS5ldmFsdWF0ZXIpIHsKICAgICAgICAgIGNvbnN0IHByb2dyYW0gPSBhdHRyaWJ1dGUudmFsdWUuZGF0YS5lc3RyZWU7CiAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gcHJvZ3JhbS5ib2R5WzBdOwogICAgICAgICAgb2soZXhwcmVzc2lvbi50eXBlID09PSAiRXhwcmVzc2lvblN0YXRlbWVudCIpOwogICAgICAgICAgdmFsdWUgPSBzdGF0ZS5ldmFsdWF0ZXIuZXZhbHVhdGVFeHByZXNzaW9uKGV4cHJlc3Npb24uZXhwcmVzc2lvbik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGNyYXNoRXN0cmVlKHN0YXRlLCBub2RlLnBvc2l0aW9uKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUgPT09IG51bGwgPyB0cnVlIDogYXR0cmlidXRlLnZhbHVlOwogICAgICB9CiAgICAgIHByb3BzW25hbWUyXSA9IC8qKiBAdHlwZSB7UHJvcHNba2V5b2YgUHJvcHNdfSAqLwogICAgICB2YWx1ZTsKICAgIH0KICB9CiAgcmV0dXJuIHByb3BzOwp9CmZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgY2hpbGRyZW4gPSBbXTsKICBsZXQgaW5kZXgyID0gLTE7CiAgY29uc3QgY291bnRzQnlOYW1lID0gc3RhdGUucGFzc0tleXMgPyAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIDogZW1wdHlNYXA7CiAgd2hpbGUgKCsraW5kZXgyIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHsKICAgIGNvbnN0IGNoaWxkID0gbm9kZS5jaGlsZHJlbltpbmRleDJdOwogICAgbGV0IGtleTsKICAgIGlmIChzdGF0ZS5wYXNzS2V5cykgewogICAgICBjb25zdCBuYW1lMiA9IGNoaWxkLnR5cGUgPT09ICJlbGVtZW50IiA/IGNoaWxkLnRhZ05hbWUgOiBjaGlsZC50eXBlID09PSAibWR4SnN4Rmxvd0VsZW1lbnQiIHx8IGNoaWxkLnR5cGUgPT09ICJtZHhKc3hUZXh0RWxlbWVudCIgPyBjaGlsZC5uYW1lIDogdm9pZCAwOwogICAgICBpZiAobmFtZTIpIHsKICAgICAgICBjb25zdCBjb3VudCA9IGNvdW50c0J5TmFtZS5nZXQobmFtZTIpIHx8IDA7CiAgICAgICAga2V5ID0gbmFtZTIgKyAiLSIgKyBjb3VudDsKICAgICAgICBjb3VudHNCeU5hbWUuc2V0KG5hbWUyLCBjb3VudCArIDEpOwogICAgICB9CiAgICB9CiAgICBjb25zdCByZXN1bHQgPSBvbmUoc3RhdGUsIGNoaWxkLCBrZXkpOwogICAgaWYgKHJlc3VsdCAhPT0gdm9pZCAwKSBjaGlsZHJlbi5wdXNoKHJlc3VsdCk7CiAgfQogIHJldHVybiBjaGlsZHJlbjsKfQpmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eShzdGF0ZSwgcHJvcCwgdmFsdWUpIHsKICBjb25zdCBpbmZvID0gZmluZChzdGF0ZS5zY2hlbWEsIHByb3ApOwogIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiB2YWx1ZSA9PT0gIm51bWJlciIgJiYgTnVtYmVyLmlzTmFOKHZhbHVlKSkgewogICAgcmV0dXJuOwogIH0KICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHsKICAgIHZhbHVlID0gaW5mby5jb21tYVNlcGFyYXRlZCA/IHN0cmluZ2lmeSh2YWx1ZSkgOiBzdHJpbmdpZnkyKHZhbHVlKTsKICB9CiAgaWYgKGluZm8ucHJvcGVydHkgPT09ICJzdHlsZSIpIHsKICAgIGxldCBzdHlsZU9iamVjdCA9IHR5cGVvZiB2YWx1ZSA9PT0gIm9iamVjdCIgPyB2YWx1ZSA6IHBhcnNlU3R5bGUoc3RhdGUsIFN0cmluZyh2YWx1ZSkpOwogICAgaWYgKHN0YXRlLnN0eWxlUHJvcGVydHlOYW1lQ2FzZSA9PT0gImNzcyIpIHsKICAgICAgc3R5bGVPYmplY3QgPSB0cmFuc2Zvcm1TdHlsZXNUb0Nzc0Nhc2luZyhzdHlsZU9iamVjdCk7CiAgICB9CiAgICByZXR1cm4gWyJzdHlsZSIsIHN0eWxlT2JqZWN0XTsKICB9CiAgcmV0dXJuIFsKICAgIHN0YXRlLmVsZW1lbnRBdHRyaWJ1dGVOYW1lQ2FzZSA9PT0gInJlYWN0IiAmJiBpbmZvLnNwYWNlID8gaGFzdFRvUmVhY3RbaW5mby5wcm9wZXJ0eV0gfHwgaW5mby5wcm9wZXJ0eSA6IGluZm8uYXR0cmlidXRlLAogICAgdmFsdWUKICBdOwp9CmZ1bmN0aW9uIHBhcnNlU3R5bGUoc3RhdGUsIHZhbHVlKSB7CiAgdHJ5IHsKICAgIHJldHVybiAoMCwgaW1wb3J0X3N0eWxlX3RvX2pzLmRlZmF1bHQpKHZhbHVlLCB7IHJlYWN0Q29tcGF0OiB0cnVlIH0pOwogIH0gY2F0Y2ggKGVycm9yKSB7CiAgICBpZiAoc3RhdGUuaWdub3JlSW52YWxpZFN0eWxlKSB7CiAgICAgIHJldHVybiB7fTsKICAgIH0KICAgIGNvbnN0IGNhdXNlID0gKAogICAgICAvKiogQHR5cGUge0Vycm9yfSAqLwogICAgICBlcnJvcgogICAgKTsKICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVkZpbGVNZXNzYWdlKCJDYW5ub3QgcGFyc2UgYHN0eWxlYCBhdHRyaWJ1dGUiLCB7CiAgICAgIGFuY2VzdG9yczogc3RhdGUuYW5jZXN0b3JzLAogICAgICBjYXVzZSwKICAgICAgcnVsZUlkOiAic3R5bGUiLAogICAgICBzb3VyY2U6ICJoYXN0LXV0aWwtdG8tanN4LXJ1bnRpbWUiCiAgICB9KTsKICAgIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHZvaWQgMDsKICAgIG1lc3NhZ2UudXJsID0gZG9jcyArICIjY2Fubm90LXBhcnNlLXN0eWxlLWF0dHJpYnV0ZSI7CiAgICB0aHJvdyBtZXNzYWdlOwogIH0KfQpmdW5jdGlvbiBmaW5kQ29tcG9uZW50RnJvbU5hbWUoc3RhdGUsIG5hbWUyLCBhbGxvd0V4cHJlc3Npb24pIHsKICBsZXQgcmVzdWx0OwogIGlmICghYWxsb3dFeHByZXNzaW9uKSB7CiAgICByZXN1bHQgPSB7IHR5cGU6ICJMaXRlcmFsIiwgdmFsdWU6IG5hbWUyIH07CiAgfSBlbHNlIGlmIChuYW1lMi5pbmNsdWRlcygiLiIpKSB7CiAgICBjb25zdCBpZGVudGlmaWVycyA9IG5hbWUyLnNwbGl0KCIuIik7CiAgICBsZXQgaW5kZXgyID0gLTE7CiAgICBsZXQgbm9kZTsKICAgIHdoaWxlICgrK2luZGV4MiA8IGlkZW50aWZpZXJzLmxlbmd0aCkgewogICAgICBjb25zdCBwcm9wID0gbmFtZShpZGVudGlmaWVyc1tpbmRleDJdKSA/IHsgdHlwZTogIklkZW50aWZpZXIiLCBuYW1lOiBpZGVudGlmaWVyc1tpbmRleDJdIH0gOiB7IHR5cGU6ICJMaXRlcmFsIiwgdmFsdWU6IGlkZW50aWZpZXJzW2luZGV4Ml0gfTsKICAgICAgbm9kZSA9IG5vZGUgPyB7CiAgICAgICAgdHlwZTogIk1lbWJlckV4cHJlc3Npb24iLAogICAgICAgIG9iamVjdDogbm9kZSwKICAgICAgICBwcm9wZXJ0eTogcHJvcCwKICAgICAgICBjb21wdXRlZDogQm9vbGVhbihpbmRleDIgJiYgcHJvcC50eXBlID09PSAiTGl0ZXJhbCIpLAogICAgICAgIG9wdGlvbmFsOiBmYWxzZQogICAgICB9IDogcHJvcDsKICAgIH0KICAgIG9rKG5vZGUsICJhbHdheXMgYSByZXN1bHQiKTsKICAgIHJlc3VsdCA9IG5vZGU7CiAgfSBlbHNlIHsKICAgIHJlc3VsdCA9IG5hbWUobmFtZTIpICYmICEvXlthLXpdLy50ZXN0KG5hbWUyKSA/IHsgdHlwZTogIklkZW50aWZpZXIiLCBuYW1lOiBuYW1lMiB9IDogeyB0eXBlOiAiTGl0ZXJhbCIsIHZhbHVlOiBuYW1lMiB9OwogIH0KICBpZiAocmVzdWx0LnR5cGUgPT09ICJMaXRlcmFsIikgewogICAgY29uc3QgbmFtZTMgPSAoCiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVtYmVyfSAqLwogICAgICByZXN1bHQudmFsdWUKICAgICk7CiAgICByZXR1cm4gb3duLmNhbGwoc3RhdGUuY29tcG9uZW50cywgbmFtZTMpID8gc3RhdGUuY29tcG9uZW50c1tuYW1lM10gOiBuYW1lMzsKICB9CiAgaWYgKHN0YXRlLmV2YWx1YXRlcikgewogICAgcmV0dXJuIHN0YXRlLmV2YWx1YXRlci5ldmFsdWF0ZUV4cHJlc3Npb24ocmVzdWx0KTsKICB9CiAgY3Jhc2hFc3RyZWUoc3RhdGUpOwp9CmZ1bmN0aW9uIGNyYXNoRXN0cmVlKHN0YXRlLCBwbGFjZSkgewogIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVkZpbGVNZXNzYWdlKAogICAgIkNhbm5vdCBoYW5kbGUgTURYIGVzdHJlZXMgd2l0aG91dCBgY3JlYXRlRXZhbHVhdGVyYCIsCiAgICB7CiAgICAgIGFuY2VzdG9yczogc3RhdGUuYW5jZXN0b3JzLAogICAgICBwbGFjZSwKICAgICAgcnVsZUlkOiAibWR4LWVzdHJlZSIsCiAgICAgIHNvdXJjZTogImhhc3QtdXRpbC10by1qc3gtcnVudGltZSIKICAgIH0KICApOwogIG1lc3NhZ2UuZmlsZSA9IHN0YXRlLmZpbGVQYXRoIHx8IHZvaWQgMDsKICBtZXNzYWdlLnVybCA9IGRvY3MgKyAiI2Nhbm5vdC1oYW5kbGUtbWR4LWVzdHJlZXMtd2l0aG91dC1jcmVhdGVldmFsdWF0ZXIiOwogIHRocm93IG1lc3NhZ2U7Cn0KZnVuY3Rpb24gdHJhbnNmb3JtU3R5bGVzVG9Dc3NDYXNpbmcoZG9tQ2FzaW5nKSB7CiAgY29uc3QgY3NzQ2FzaW5nID0ge307CiAgbGV0IGZyb207CiAgZm9yIChmcm9tIGluIGRvbUNhc2luZykgewogICAgaWYgKG93bi5jYWxsKGRvbUNhc2luZywgZnJvbSkpIHsKICAgICAgY3NzQ2FzaW5nW3RyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSldID0gZG9tQ2FzaW5nW2Zyb21dOwogICAgfQogIH0KICByZXR1cm4gY3NzQ2FzaW5nOwp9CmZ1bmN0aW9uIHRyYW5zZm9ybVN0eWxlVG9Dc3NDYXNpbmcoZnJvbSkgewogIGxldCB0byA9IGZyb20ucmVwbGFjZShjYXAsIHRvRGFzaCk7CiAgaWYgKHRvLnNsaWNlKDAsIDMpID09PSAibXMtIikgdG8gPSAiLSIgKyB0bzsKICByZXR1cm4gdG87Cn0KZnVuY3Rpb24gdG9EYXNoKCQwKSB7CiAgcmV0dXJuICItIiArICQwLnRvTG93ZXJDYXNlKCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9odG1sLXVybC1hdHRyaWJ1dGVzL2xpYi9pbmRleC5qcwp2YXIgdXJsQXR0cmlidXRlcyA9IHsKICBhY3Rpb246IFsiZm9ybSJdLAogIGNpdGU6IFsiYmxvY2txdW90ZSIsICJkZWwiLCAiaW5zIiwgInEiXSwKICBkYXRhOiBbIm9iamVjdCJdLAogIGZvcm1BY3Rpb246IFsiYnV0dG9uIiwgImlucHV0Il0sCiAgaHJlZjogWyJhIiwgImFyZWEiLCAiYmFzZSIsICJsaW5rIl0sCiAgaWNvbjogWyJtZW51aXRlbSJdLAogIGl0ZW1JZDogbnVsbCwKICBtYW5pZmVzdDogWyJodG1sIl0sCiAgcGluZzogWyJhIiwgImFyZWEiXSwKICBwb3N0ZXI6IFsidmlkZW8iXSwKICBzcmM6IFsKICAgICJhdWRpbyIsCiAgICAiZW1iZWQiLAogICAgImlmcmFtZSIsCiAgICAiaW1nIiwKICAgICJpbnB1dCIsCiAgICAic2NyaXB0IiwKICAgICJzb3VyY2UiLAogICAgInRyYWNrIiwKICAgICJ2aWRlbyIKICBdCn07CgovLyBub2RlX21vZHVsZXMvcmVhY3QtbWFya2Rvd24vbGliL2luZGV4LmpzCnZhciBpbXBvcnRfanN4X3J1bnRpbWUgPSBfX3RvRVNNKHJlcXVpcmVfanN4X3J1bnRpbWUoKSwgMSk7CnZhciBpbXBvcnRfcmVhY3QgPSBfX3RvRVNNKHJlcXVpcmVfcmVhY3QoKSwgMSk7CgovLyBub2RlX21vZHVsZXMvbWljcm9tYXJrL2Rldi9saWIvY29tcGlsZS5qcwp2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTsKCi8vIG5vZGVfbW9kdWxlcy9taWNyb21hcmsvZGV2L2xpYi9pbml0aWFsaXplL2NvbnRlbnQuanMKdmFyIGNvbnRlbnQyID0geyB0b2tlbml6ZTogaW5pdGlhbGl6ZUNvbnRlbnQgfTsKZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnRlbnQoZWZmZWN0cykgewogIGNvbnN0IGNvbnRlbnRTdGFydCA9IGVmZmVjdHMuYXR0ZW1wdCgKICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuY29udGVudEluaXRpYWwsCiAgICBhZnRlckNvbnRlbnRTdGFydENvbnN0cnVjdCwKICAgIHBhcmFncmFwaEluaXRpYWwKICApOwogIGxldCBwcmV2aW91czsKICByZXR1cm4gY29udGVudFN0YXJ0OwogIGZ1bmN0aW9uIGFmdGVyQ29udGVudFN0YXJ0Q29uc3RydWN0KGNvZGUyKSB7CiAgICBvaygKICAgICAgY29kZTIgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZTIpLAogICAgICAiZXhwZWN0ZWQgZW9sIG9yIGVvZiIKICAgICk7CiAgICBpZiAoY29kZTIgPT09IGNvZGVzLmVvZikgewogICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZTIpOwogICAgICByZXR1cm47CiAgICB9CiAgICBlZmZlY3RzLmVudGVyKHR5cGVzLmxpbmVFbmRpbmcpOwogICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgIGVmZmVjdHMuZXhpdCh0eXBlcy5saW5lRW5kaW5nKTsKICAgIHJldHVybiBmYWN0b3J5U3BhY2UoZWZmZWN0cywgY29udGVudFN0YXJ0LCB0eXBlcy5saW5lUHJlZml4KTsKICB9CiAgZnVuY3Rpb24gcGFyYWdyYXBoSW5pdGlhbChjb2RlMikgewogICAgb2soCiAgICAgIGNvZGUyICE9PSBjb2Rlcy5lb2YgJiYgIW1hcmtkb3duTGluZUVuZGluZyhjb2RlMiksCiAgICAgICJleHBlY3RlZCBhbnl0aGluZyBvdGhlciB0aGFuIGEgbGluZSBlbmRpbmcgb3IgRU9GIgogICAgKTsKICAgIGVmZmVjdHMuZW50ZXIodHlwZXMucGFyYWdyYXBoKTsKICAgIHJldHVybiBsaW5lU3RhcnQoY29kZTIpOwogIH0KICBmdW5jdGlvbiBsaW5lU3RhcnQoY29kZTIpIHsKICAgIGNvbnN0IHRva2VuID0gZWZmZWN0cy5lbnRlcih0eXBlcy5jaHVua1RleHQsIHsKICAgICAgY29udGVudFR5cGU6IGNvbnN0YW50cy5jb250ZW50VHlwZVRleHQsCiAgICAgIHByZXZpb3VzCiAgICB9KTsKICAgIGlmIChwcmV2aW91cykgewogICAgICBwcmV2aW91cy5uZXh0ID0gdG9rZW47CiAgICB9CiAgICBwcmV2aW91cyA9IHRva2VuOwogICAgcmV0dXJuIGRhdGEoY29kZTIpOwogIH0KICBmdW5jdGlvbiBkYXRhKGNvZGUyKSB7CiAgICBpZiAoY29kZTIgPT09IGNvZGVzLmVvZikgewogICAgICBlZmZlY3RzLmV4aXQodHlwZXMuY2h1bmtUZXh0KTsKICAgICAgZWZmZWN0cy5leGl0KHR5cGVzLnBhcmFncmFwaCk7CiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlMik7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmIChtYXJrZG93bkxpbmVFbmRpbmcoY29kZTIpKSB7CiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlMik7CiAgICAgIGVmZmVjdHMuZXhpdCh0eXBlcy5jaHVua1RleHQpOwogICAgICByZXR1cm4gbGluZVN0YXJ0OwogICAgfQogICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgIHJldHVybiBkYXRhOwogIH0KfQoKLy8gbm9kZV9tb2R1bGVzL21pY3JvbWFyay9kZXYvbGliL2luaXRpYWxpemUvZG9jdW1lbnQuanMKdmFyIGRvY3VtZW50MiA9IHsgdG9rZW5pemU6IGluaXRpYWxpemVEb2N1bWVudCB9Owp2YXIgY29udGFpbmVyQ29uc3RydWN0ID0geyB0b2tlbml6ZTogdG9rZW5pemVDb250YWluZXIgfTsKZnVuY3Rpb24gaW5pdGlhbGl6ZURvY3VtZW50KGVmZmVjdHMpIHsKICBjb25zdCBzZWxmID0gdGhpczsKICBjb25zdCBzdGFjayA9IFtdOwogIGxldCBjb250aW51ZWQgPSAwOwogIGxldCBjaGlsZEZsb3c7CiAgbGV0IGNoaWxkVG9rZW47CiAgbGV0IGxpbmVTdGFydE9mZnNldDsKICByZXR1cm4gc3RhcnQyOwogIGZ1bmN0aW9uIHN0YXJ0Mihjb2RlMikgewogICAgaWYgKGNvbnRpbnVlZCA8IHN0YWNrLmxlbmd0aCkgewogICAgICBjb25zdCBpdGVtID0gc3RhY2tbY29udGludWVkXTsKICAgICAgc2VsZi5jb250YWluZXJTdGF0ZSA9IGl0ZW1bMV07CiAgICAgIG9rKAogICAgICAgIGl0ZW1bMF0uY29udGludWF0aW9uLAogICAgICAgICJleHBlY3RlZCBgY29udGludWF0aW9uYCB0byBiZSBkZWZpbmVkIG9uIGNvbnRhaW5lciBjb25zdHJ1Y3QiCiAgICAgICk7CiAgICAgIHJldHVybiBlZmZlY3RzLmF0dGVtcHQoCiAgICAgICAgaXRlbVswXS5jb250aW51YXRpb24sCiAgICAgICAgZG9jdW1lbnRDb250aW51ZSwKICAgICAgICBjaGVja05ld0NvbnRhaW5lcnMKICAgICAgKShjb2RlMik7CiAgICB9CiAgICByZXR1cm4gY2hlY2tOZXdDb250YWluZXJzKGNvZGUyKTsKICB9CiAgZnVuY3Rpb24gZG9jdW1lbnRDb250aW51ZShjb2RlMikgewogICAgb2soCiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUsCiAgICAgICJleHBlY3RlZCBgY29udGFpbmVyU3RhdGVgIHRvIGJlIGRlZmluZWQgYWZ0ZXIgY29udGludWF0aW9uIgogICAgKTsKICAgIGNvbnRpbnVlZCsrOwogICAgaWYgKHNlbGYuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdykgewogICAgICBzZWxmLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSB2b2lkIDA7CiAgICAgIGlmIChjaGlsZEZsb3cpIHsKICAgICAgICBjbG9zZUZsb3coKTsKICAgICAgfQogICAgICBjb25zdCBpbmRleEJlZm9yZUV4aXRzID0gc2VsZi5ldmVudHMubGVuZ3RoOwogICAgICBsZXQgaW5kZXhCZWZvcmVGbG93ID0gaW5kZXhCZWZvcmVFeGl0czsKICAgICAgbGV0IHBvaW50MzsKICAgICAgd2hpbGUgKGluZGV4QmVmb3JlRmxvdy0tKSB7CiAgICAgICAgaWYgKHNlbGYuZXZlbnRzW2luZGV4QmVmb3JlRmxvd11bMF0gPT09ICJleGl0IiAmJiBzZWxmLmV2ZW50c1tpbmRleEJlZm9yZUZsb3ddWzFdLnR5cGUgPT09IHR5cGVzLmNodW5rRmxvdykgewogICAgICAgICAgcG9pbnQzID0gc2VsZi5ldmVudHNbaW5kZXhCZWZvcmVGbG93XVsxXS5lbmQ7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgb2socG9pbnQzLCAiY291bGQgbm90IGZpbmQgcHJldmlvdXMgZmxvdyBjaHVuayIpOwogICAgICBleGl0Q29udGFpbmVycyhjb250aW51ZWQpOwogICAgICBsZXQgaW5kZXgyID0gaW5kZXhCZWZvcmVFeGl0czsKICAgICAgd2hpbGUgKGluZGV4MiA8IHNlbGYuZXZlbnRzLmxlbmd0aCkgewogICAgICAgIHNlbGYuZXZlbnRzW2luZGV4Ml1bMV0uZW5kID0geyAuLi5wb2ludDMgfTsKICAgICAgICBpbmRleDIrKzsKICAgICAgfQogICAgICBzcGxpY2UoCiAgICAgICAgc2VsZi5ldmVudHMsCiAgICAgICAgaW5kZXhCZWZvcmVGbG93ICsgMSwKICAgICAgICAwLAogICAgICAgIHNlbGYuZXZlbnRzLnNsaWNlKGluZGV4QmVmb3JlRXhpdHMpCiAgICAgICk7CiAgICAgIHNlbGYuZXZlbnRzLmxlbmd0aCA9IGluZGV4MjsKICAgICAgcmV0dXJuIGNoZWNrTmV3Q29udGFpbmVycyhjb2RlMik7CiAgICB9CiAgICByZXR1cm4gc3RhcnQyKGNvZGUyKTsKICB9CiAgZnVuY3Rpb24gY2hlY2tOZXdDb250YWluZXJzKGNvZGUyKSB7CiAgICBpZiAoY29udGludWVkID09PSBzdGFjay5sZW5ndGgpIHsKICAgICAgaWYgKCFjaGlsZEZsb3cpIHsKICAgICAgICByZXR1cm4gZG9jdW1lbnRDb250aW51ZWQoY29kZTIpOwogICAgICB9CiAgICAgIGlmIChjaGlsZEZsb3cuY3VycmVudENvbnN0cnVjdCAmJiBjaGlsZEZsb3cuY3VycmVudENvbnN0cnVjdC5jb25jcmV0ZSkgewogICAgICAgIHJldHVybiBmbG93U3RhcnQoY29kZTIpOwogICAgICB9CiAgICAgIHNlbGYuaW50ZXJydXB0ID0gQm9vbGVhbigKICAgICAgICBjaGlsZEZsb3cuY3VycmVudENvbnN0cnVjdCAmJiAhY2hpbGRGbG93Ll9nZm1UYWJsZUR5bmFtaWNJbnRlcnJ1cHRIYWNrCiAgICAgICk7CiAgICB9CiAgICBzZWxmLmNvbnRhaW5lclN0YXRlID0ge307CiAgICByZXR1cm4gZWZmZWN0cy5jaGVjaygKICAgICAgY29udGFpbmVyQ29uc3RydWN0LAogICAgICB0aGVyZUlzQU5ld0NvbnRhaW5lciwKICAgICAgdGhlcmVJc05vTmV3Q29udGFpbmVyCiAgICApKGNvZGUyKTsKICB9CiAgZnVuY3Rpb24gdGhlcmVJc0FOZXdDb250YWluZXIoY29kZTIpIHsKICAgIGlmIChjaGlsZEZsb3cpIGNsb3NlRmxvdygpOwogICAgZXhpdENvbnRhaW5lcnMoY29udGludWVkKTsKICAgIHJldHVybiBkb2N1bWVudENvbnRpbnVlZChjb2RlMik7CiAgfQogIGZ1bmN0aW9uIHRoZXJlSXNOb05ld0NvbnRhaW5lcihjb2RlMikgewogICAgc2VsZi5wYXJzZXIubGF6eVtzZWxmLm5vdygpLmxpbmVdID0gY29udGludWVkICE9PSBzdGFjay5sZW5ndGg7CiAgICBsaW5lU3RhcnRPZmZzZXQgPSBzZWxmLm5vdygpLm9mZnNldDsKICAgIHJldHVybiBmbG93U3RhcnQoY29kZTIpOwogIH0KICBmdW5jdGlvbiBkb2N1bWVudENvbnRpbnVlZChjb2RlMikgewogICAgc2VsZi5jb250YWluZXJTdGF0ZSA9IHt9OwogICAgcmV0dXJuIGVmZmVjdHMuYXR0ZW1wdCgKICAgICAgY29udGFpbmVyQ29uc3RydWN0LAogICAgICBjb250YWluZXJDb250aW51ZSwKICAgICAgZmxvd1N0YXJ0CiAgICApKGNvZGUyKTsKICB9CiAgZnVuY3Rpb24gY29udGFpbmVyQ29udGludWUoY29kZTIpIHsKICAgIG9rKAogICAgICBzZWxmLmN1cnJlbnRDb25zdHJ1Y3QsCiAgICAgICJleHBlY3RlZCBgY3VycmVudENvbnN0cnVjdGAgdG8gYmUgZGVmaW5lZCBvbiB0b2tlbml6ZXIiCiAgICApOwogICAgb2soCiAgICAgIHNlbGYuY29udGFpbmVyU3RhdGUsCiAgICAgICJleHBlY3RlZCBgY29udGFpbmVyU3RhdGVgIHRvIGJlIGRlZmluZWQgb24gdG9rZW5pemVyIgogICAgKTsKICAgIGNvbnRpbnVlZCsrOwogICAgc3RhY2sucHVzaChbc2VsZi5jdXJyZW50Q29uc3RydWN0LCBzZWxmLmNvbnRhaW5lclN0YXRlXSk7CiAgICByZXR1cm4gZG9jdW1lbnRDb250aW51ZWQoY29kZTIpOwogIH0KICBmdW5jdGlvbiBmbG93U3RhcnQoY29kZTIpIHsKICAgIGlmIChjb2RlMiA9PT0gY29kZXMuZW9mKSB7CiAgICAgIGlmIChjaGlsZEZsb3cpIGNsb3NlRmxvdygpOwogICAgICBleGl0Q29udGFpbmVycygwKTsKICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgY2hpbGRGbG93ID0gY2hpbGRGbG93IHx8IHNlbGYucGFyc2VyLmZsb3coc2VsZi5ub3coKSk7CiAgICBlZmZlY3RzLmVudGVyKHR5cGVzLmNodW5rRmxvdywgewogICAgICBfdG9rZW5pemVyOiBjaGlsZEZsb3csCiAgICAgIGNvbnRlbnRUeXBlOiBjb25zdGFudHMuY29udGVudFR5cGVGbG93LAogICAgICBwcmV2aW91czogY2hpbGRUb2tlbgogICAgfSk7CiAgICByZXR1cm4gZmxvd0NvbnRpbnVlKGNvZGUyKTsKICB9CiAgZnVuY3Rpb24gZmxvd0NvbnRpbnVlKGNvZGUyKSB7CiAgICBpZiAoY29kZTIgPT09IGNvZGVzLmVvZikgewogICAgICB3cml0ZVRvQ2hpbGQoZWZmZWN0cy5leGl0KHR5cGVzLmNodW5rRmxvdyksIHRydWUpOwogICAgICBleGl0Q29udGFpbmVycygwKTsKICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgaWYgKG1hcmtkb3duTGluZUVuZGluZyhjb2RlMikpIHsKICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgICAgd3JpdGVUb0NoaWxkKGVmZmVjdHMuZXhpdCh0eXBlcy5jaHVua0Zsb3cpKTsKICAgICAgY29udGludWVkID0gMDsKICAgICAgc2VsZi5pbnRlcnJ1cHQgPSB2b2lkIDA7CiAgICAgIHJldHVybiBzdGFydDI7CiAgICB9CiAgICBlZmZlY3RzLmNvbnN1bWUoY29kZTIpOwogICAgcmV0dXJuIGZsb3dDb250aW51ZTsKICB9CiAgZnVuY3Rpb24gd3JpdGVUb0NoaWxkKHRva2VuLCBlbmRPZkZpbGUpIHsKICAgIG9rKGNoaWxkRmxvdywgImV4cGVjdGVkIGBjaGlsZEZsb3dgIHRvIGJlIGRlZmluZWQgd2hlbiBjb250aW51aW5nIik7CiAgICBjb25zdCBzdHJlYW0gPSBzZWxmLnNsaWNlU3RyZWFtKHRva2VuKTsKICAgIGlmIChlbmRPZkZpbGUpIHN0cmVhbS5wdXNoKG51bGwpOwogICAgdG9rZW4ucHJldmlvdXMgPSBjaGlsZFRva2VuOwogICAgaWYgKGNoaWxkVG9rZW4pIGNoaWxkVG9rZW4ubmV4dCA9IHRva2VuOwogICAgY2hpbGRUb2tlbiA9IHRva2VuOwogICAgY2hpbGRGbG93LmRlZmluZVNraXAodG9rZW4uc3RhcnQpOwogICAgY2hpbGRGbG93LndyaXRlKHN0cmVhbSk7CiAgICBpZiAoc2VsZi5wYXJzZXIubGF6eVt0b2tlbi5zdGFydC5saW5lXSkgewogICAgICBsZXQgaW5kZXgyID0gY2hpbGRGbG93LmV2ZW50cy5sZW5ndGg7CiAgICAgIHdoaWxlIChpbmRleDItLSkgewogICAgICAgIGlmICgKICAgICAgICAgIC8vIFRoZSB0b2tlbiBzdGFydHMgYmVmb3JlIHRoZSBsaW5lIGVuZGluZ+KApgogICAgICAgICAgY2hpbGRGbG93LmV2ZW50c1tpbmRleDJdWzFdLnN0YXJ0Lm9mZnNldCA8IGxpbmVTdGFydE9mZnNldCAmJiAvLyDigKZhbmQgZWl0aGVyIGlzIG5vdCBlbmRlZCB5ZXTigKYKICAgICAgICAgICghY2hpbGRGbG93LmV2ZW50c1tpbmRleDJdWzFdLmVuZCB8fCAvLyDigKZvciBlbmRzIGFmdGVyIGl0LgogICAgICAgICAgY2hpbGRGbG93LmV2ZW50c1tpbmRleDJdWzFdLmVuZC5vZmZzZXQgPiBsaW5lU3RhcnRPZmZzZXQpCiAgICAgICAgKSB7CiAgICAgICAgICByZXR1cm47CiAgICAgICAgfQogICAgICB9CiAgICAgIGNvbnN0IGluZGV4QmVmb3JlRXhpdHMgPSBzZWxmLmV2ZW50cy5sZW5ndGg7CiAgICAgIGxldCBpbmRleEJlZm9yZUZsb3cgPSBpbmRleEJlZm9yZUV4aXRzOwogICAgICBsZXQgc2VlbjsKICAgICAgbGV0IHBvaW50MzsKICAgICAgd2hpbGUgKGluZGV4QmVmb3JlRmxvdy0tKSB7CiAgICAgICAgaWYgKHNlbGYuZXZlbnRzW2luZGV4QmVmb3JlRmxvd11bMF0gPT09ICJleGl0IiAmJiBzZWxmLmV2ZW50c1tpbmRleEJlZm9yZUZsb3ddWzFdLnR5cGUgPT09IHR5cGVzLmNodW5rRmxvdykgewogICAgICAgICAgaWYgKHNlZW4pIHsKICAgICAgICAgICAgcG9pbnQzID0gc2VsZi5ldmVudHNbaW5kZXhCZWZvcmVGbG93XVsxXS5lbmQ7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgc2VlbiA9IHRydWU7CiAgICAgICAgfQogICAgICB9CiAgICAgIG9rKHBvaW50MywgImNvdWxkIG5vdCBmaW5kIHByZXZpb3VzIGZsb3cgY2h1bmsiKTsKICAgICAgZXhpdENvbnRhaW5lcnMoY29udGludWVkKTsKICAgICAgaW5kZXgyID0gaW5kZXhCZWZvcmVFeGl0czsKICAgICAgd2hpbGUgKGluZGV4MiA8IHNlbGYuZXZlbnRzLmxlbmd0aCkgewogICAgICAgIHNlbGYuZXZlbnRzW2luZGV4Ml1bMV0uZW5kID0geyAuLi5wb2ludDMgfTsKICAgICAgICBpbmRleDIrKzsKICAgICAgfQogICAgICBzcGxpY2UoCiAgICAgICAgc2VsZi5ldmVudHMsCiAgICAgICAgaW5kZXhCZWZvcmVGbG93ICsgMSwKICAgICAgICAwLAogICAgICAgIHNlbGYuZXZlbnRzLnNsaWNlKGluZGV4QmVmb3JlRXhpdHMpCiAgICAgICk7CiAgICAgIHNlbGYuZXZlbnRzLmxlbmd0aCA9IGluZGV4MjsKICAgIH0KICB9CiAgZnVuY3Rpb24gZXhpdENvbnRhaW5lcnMoc2l6ZSkgewogICAgbGV0IGluZGV4MiA9IHN0YWNrLmxlbmd0aDsKICAgIHdoaWxlIChpbmRleDItLSA+IHNpemUpIHsKICAgICAgY29uc3QgZW50cnkgPSBzdGFja1tpbmRleDJdOwogICAgICBzZWxmLmNvbnRhaW5lclN0YXRlID0gZW50cnlbMV07CiAgICAgIG9rKAogICAgICAgIGVudHJ5WzBdLmV4aXQsCiAgICAgICAgImV4cGVjdGVkIGBleGl0YCB0byBiZSBkZWZpbmVkIG9uIGNvbnRhaW5lciBjb25zdHJ1Y3QiCiAgICAgICk7CiAgICAgIGVudHJ5WzBdLmV4aXQuY2FsbChzZWxmLCBlZmZlY3RzKTsKICAgIH0KICAgIHN0YWNrLmxlbmd0aCA9IHNpemU7CiAgfQogIGZ1bmN0aW9uIGNsb3NlRmxvdygpIHsKICAgIG9rKAogICAgICBzZWxmLmNvbnRhaW5lclN0YXRlLAogICAgICAiZXhwZWN0ZWQgYGNvbnRhaW5lclN0YXRlYCB0byBiZSBkZWZpbmVkIHdoZW4gY2xvc2luZyBmbG93IgogICAgKTsKICAgIG9rKGNoaWxkRmxvdywgImV4cGVjdGVkIGBjaGlsZEZsb3dgIHRvIGJlIGRlZmluZWQgd2hlbiBjbG9zaW5nIGl0Iik7CiAgICBjaGlsZEZsb3cud3JpdGUoW2NvZGVzLmVvZl0pOwogICAgY2hpbGRUb2tlbiA9IHZvaWQgMDsKICAgIGNoaWxkRmxvdyA9IHZvaWQgMDsKICAgIHNlbGYuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdyA9IHZvaWQgMDsKICB9Cn0KZnVuY3Rpb24gdG9rZW5pemVDb250YWluZXIoZWZmZWN0cywgb2syLCBub2spIHsKICBvaygKICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLAogICAgImV4cGVjdGVkIGBkaXNhYmxlLm51bGxgIHRvIGJlIHBvcHVsYXRlZCIKICApOwogIHJldHVybiBmYWN0b3J5U3BhY2UoCiAgICBlZmZlY3RzLAogICAgZWZmZWN0cy5hdHRlbXB0KHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZG9jdW1lbnQsIG9rMiwgbm9rKSwKICAgIHR5cGVzLmxpbmVQcmVmaXgsCiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcygiY29kZUluZGVudGVkIikgPyB2b2lkIDAgOiBjb25zdGFudHMudGFiU2l6ZQogICk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9taWNyb21hcmsvZGV2L2xpYi9pbml0aWFsaXplL2Zsb3cuanMKdmFyIGZsb3cgPSB7IHRva2VuaXplOiBpbml0aWFsaXplRmxvdyB9OwpmdW5jdGlvbiBpbml0aWFsaXplRmxvdyhlZmZlY3RzKSB7CiAgY29uc3Qgc2VsZiA9IHRoaXM7CiAgY29uc3QgaW5pdGlhbCA9IGVmZmVjdHMuYXR0ZW1wdCgKICAgIC8vIFRyeSB0byBwYXJzZSBhIGJsYW5rIGxpbmUuCiAgICBibGFua0xpbmUsCiAgICBhdEJsYW5rRW5kaW5nLAogICAgLy8gVHJ5IHRvIHBhcnNlIGluaXRpYWwgZmxvdyAoZXNzZW50aWFsbHksIG9ubHkgY29kZSkuCiAgICBlZmZlY3RzLmF0dGVtcHQoCiAgICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZmxvd0luaXRpYWwsCiAgICAgIGFmdGVyQ29uc3RydWN0LAogICAgICBmYWN0b3J5U3BhY2UoCiAgICAgICAgZWZmZWN0cywKICAgICAgICBlZmZlY3RzLmF0dGVtcHQoCiAgICAgICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3csCiAgICAgICAgICBhZnRlckNvbnN0cnVjdCwKICAgICAgICAgIGVmZmVjdHMuYXR0ZW1wdChjb250ZW50LCBhZnRlckNvbnN0cnVjdCkKICAgICAgICApLAogICAgICAgIHR5cGVzLmxpbmVQcmVmaXgKICAgICAgKQogICAgKQogICk7CiAgcmV0dXJuIGluaXRpYWw7CiAgZnVuY3Rpb24gYXRCbGFua0VuZGluZyhjb2RlMikgewogICAgb2soCiAgICAgIGNvZGUyID09PSBjb2Rlcy5lb2YgfHwgbWFya2Rvd25MaW5lRW5kaW5nKGNvZGUyKSwKICAgICAgImV4cGVjdGVkIGVvbCBvciBlb2YiCiAgICApOwogICAgaWYgKGNvZGUyID09PSBjb2Rlcy5lb2YpIHsKICAgICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgICAgcmV0dXJuOwogICAgfQogICAgZWZmZWN0cy5lbnRlcih0eXBlcy5saW5lRW5kaW5nQmxhbmspOwogICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgIGVmZmVjdHMuZXhpdCh0eXBlcy5saW5lRW5kaW5nQmxhbmspOwogICAgc2VsZi5jdXJyZW50Q29uc3RydWN0ID0gdm9pZCAwOwogICAgcmV0dXJuIGluaXRpYWw7CiAgfQogIGZ1bmN0aW9uIGFmdGVyQ29uc3RydWN0KGNvZGUyKSB7CiAgICBvaygKICAgICAgY29kZTIgPT09IGNvZGVzLmVvZiB8fCBtYXJrZG93bkxpbmVFbmRpbmcoY29kZTIpLAogICAgICAiZXhwZWN0ZWQgZW9sIG9yIGVvZiIKICAgICk7CiAgICBpZiAoY29kZTIgPT09IGNvZGVzLmVvZikgewogICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZTIpOwogICAgICByZXR1cm47CiAgICB9CiAgICBlZmZlY3RzLmVudGVyKHR5cGVzLmxpbmVFbmRpbmcpOwogICAgZWZmZWN0cy5jb25zdW1lKGNvZGUyKTsKICAgIGVmZmVjdHMuZXhpdCh0eXBlcy5saW5lRW5kaW5nKTsKICAgIHNlbGYuY3VycmVudENvbnN0cnVjdCA9IHZvaWQgMDsKICAgIHJldHVybiBpbml0aWFsOwogIH0KfQoKLy8gbm9kZV9tb2R1bGVzL21pY3JvbWFyay9kZXYvbGliL2luaXRpYWxpemUvdGV4dC5qcwp2YXIgcmVzb2x2ZXIgPSB7IHJlc29sdmVBbGw6IGNyZWF0ZVJlc29sdmVyKCkgfTsKdmFyIHN0cmluZyA9IGluaXRpYWxpemVGYWN0b3J5KCJzdHJpbmciKTsKdmFyIHRleHQyID0gaW5pdGlhbGl6ZUZhY3RvcnkoInRleHQiKTsKZnVuY3Rpb24gaW5pdGlhbGl6ZUZhY3RvcnkoZmllbGQpIHsKICByZXR1cm4gewogICAgcmVzb2x2ZUFsbDogY3JlYXRlUmVzb2x2ZXIoCiAgICAgIGZpZWxkID09PSAidGV4dCIgPyByZXNvbHZlQWxsTGluZVN1ZmZpeGVzIDogdm9pZCAwCiAgICApLAogICAgdG9rZW5pemU6IGluaXRpYWxpemVUZXh0CiAgfTsKICBmdW5jdGlvbiBpbml0aWFsaXplVGV4dChlZmZlY3RzKSB7CiAgICBjb25zdCBzZWxmID0gdGhpczsKICAgIGNvbnN0IGNvbnN0cnVjdHMgPSB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzW2ZpZWxkXTsKICAgIGNvbnN0IHRleHQ1ID0gZWZmZWN0cy5hdHRlbXB0KGNvbnN0cnVjdHMsIHN0YXJ0Miwgbm90VGV4dCk7CiAgICByZXR1cm4gc3RhcnQyOwogICAgZnVuY3Rpb24gc3RhcnQyKGNvZGUyKSB7CiAgICAgIHJldHVybiBhdEJyZWFrKGNvZGUyKSA/IHRleHQ1KGNvZGUyKSA6IG5vdFRleHQoY29kZTIpOwogICAgfQogICAgZnVuY3Rpb24gbm90VGV4dChjb2RlMikgewogICAgICBpZiAoY29kZTIgPT09IGNvZGVzLmVvZikgewogICAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlMik7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICAgIGVmZmVjdHMuZW50ZXIodHlwZXMuZGF0YSk7CiAgICAgIGVmZmVjdHMuY29uc3VtZShjb2RlMik7CiAgICAgIHJldHVybiBkYXRhOwogICAgfQogICAgZnVuY3Rpb24gZGF0YShjb2RlMikgewogICAgICBpZiAoYXRCcmVhayhjb2RlMikpIHsKICAgICAgICBlZmZlY3RzLmV4aXQodHlwZXMuZGF0YSk7CiAgICAgICAgcmV0dXJuIHRleHQ1KGNvZGUyKTsKICAgICAgfQogICAgICBlZmZlY3RzLmNvbnN1bWUoY29kZTIpOwogICAgICByZXR1cm4gZGF0YTsKICAgIH0KICAgIGZ1bmN0aW9uIGF0QnJlYWsoY29kZTIpIHsKICAgICAgaWYgKGNvZGUyID09PSBjb2Rlcy5lb2YpIHsKICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgfQogICAgICBjb25zdCBsaXN0MyA9IGNvbnN0cnVjdHNbY29kZTJdOwogICAgICBsZXQgaW5kZXgyID0gLTE7CiAgICAgIGlmIChsaXN0MykgewogICAgICAgIG9rKEFycmF5LmlzQXJyYXkobGlzdDMpLCAiZXhwZWN0ZWQgYGRpc2FibGUubnVsbGAgdG8gYmUgcG9wdWxhdGVkIik7CiAgICAgICAgd2hpbGUgKCsraW5kZXgyIDwgbGlzdDMubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCBpdGVtID0gbGlzdDNbaW5kZXgyXTsKICAgICAgICAgIGlmICghaXRlbS5wcmV2aW91cyB8fCBpdGVtLnByZXZpb3VzLmNhbGwoc2VsZiwgc2VsZi5wcmV2aW91cykpIHsKICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBmYWxzZTsKICAgIH0KICB9Cn0KZnVuY3Rpb24gY3JlYXRlUmVzb2x2ZXIoZXh0cmFSZXNvbHZlcikgewogIHJldHVybiByZXNvbHZlQWxsVGV4dDsKICBmdW5jdGlvbiByZXNvbHZlQWxsVGV4dChldmVudHMsIGNvbnRleHQpIHsKICAgIGxldCBpbmRleDIgPSAtMTsKICAgIGxldCBlbnRlcjsKICAgIHdoaWxlICgrK2luZGV4MiA8PSBldmVudHMubGVuZ3RoKSB7CiAgICAgIGlmIChlbnRlciA9PT0gdm9pZCAwKSB7CiAgICAgICAgaWYgKGV2ZW50c1tpbmRleDJdICYmIGV2ZW50c1tpbmRleDJdWzFdLnR5cGUgPT09IHR5cGVzLmRhdGEpIHsKICAgICAgICAgIGVudGVyID0gaW5kZXgyOwogICAgICAgICAgaW5kZXgyKys7CiAgICAgICAgfQogICAgICB9IGVsc2UgaWYgKCFldmVudHNbaW5kZXgyXSB8fCBldmVudHNbaW5kZXgyXVsxXS50eXBlICE9PSB0eXBlcy5kYXRhKSB7CiAgICAgICAgaWYgKGluZGV4MiAhPT0gZW50ZXIgKyAyKSB7CiAgICAgICAgICBldmVudHNbZW50ZXJdWzFdLmVuZCA9IGV2ZW50c1tpbmRleDIgLSAxXVsxXS5lbmQ7CiAgICAgICAgICBldmVudHMuc3BsaWNlKGVudGVyICsgMiwgaW5kZXgyIC0gZW50ZXIgLSAyKTsKICAgICAgICAgIGluZGV4MiA9IGVudGVyICsgMjsKICAgICAgICB9CiAgICAgICAgZW50ZXIgPSB2b2lkIDA7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBleHRyYVJlc29sdmVyID8gZXh0cmFSZXNvbHZlcihldmVudHMsIGNvbnRleHQpIDogZXZlbnRzOwogIH0KfQpmdW5jdGlvbiByZXNvbHZlQWxsTGluZVN1ZmZpeGVzKGV2ZW50cywgY29udGV4dCkgewogIGxldCBldmVudEluZGV4ID0gMDsKICB3aGlsZSAoKytldmVudEluZGV4IDw9IGV2ZW50cy5sZW5ndGgpIHsKICAgIGlmICgoZXZlbnRJbmRleCA9PT0gZXZlbnRzLmxlbmd0aCB8fCBldmVudHNbZXZlbnRJbmRleF1bMV0udHlwZSA9PT0gdHlwZXMubGluZUVuZGluZykgJiYgZXZlbnRzW2V2ZW50SW5kZXggLSAxXVsxXS50eXBlID09PSB0eXBlcy5kYXRhKSB7CiAgICAgIGNvbnN0IGRhdGEgPSBldmVudHNbZXZlbnRJbmRleCAtIDFdWzFdOwogICAgICBjb25zdCBjaHVua3MgPSBjb250ZXh0LnNsaWNlU3RyZWFtKGRhdGEpOwogICAgICBsZXQgaW5kZXgyID0gY2h1bmtzLmxlbmd0aDsKICAgICAgbGV0IGJ1ZmZlckluZGV4ID0gLTE7CiAgICAgIGxldCBzaXplID0gMDsKICAgICAgbGV0IHRhYnM7CiAgICAgIHdoaWxlIChpbmRleDItLSkgewogICAgICAgIGNvbnN0IGNodW5rID0gY2h1bmtzW2luZGV4Ml07CiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gInN0cmluZyIpIHsKICAgICAgICAgIGJ1ZmZlckluZGV4ID0gY2h1bmsubGVuZ3RoOwogICAgICAgICAgd2hpbGUgKGNodW5rLmNoYXJDb2RlQXQoYnVmZmVySW5kZXggLSAxKSA9PT0gY29kZXMuc3BhY2UpIHsKICAgICAgICAgICAgc2l6ZSsrOwogICAgICAgICAgICBidWZmZXJJbmRleC0tOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGJ1ZmZlckluZGV4KSBicmVhazsKICAgICAgICAgIGJ1ZmZlckluZGV4ID0gLTE7CiAgICAgICAgfSBlbHNlIGlmIChjaHVuayA9PT0gY29kZXMuaG9yaXpvbnRhbFRhYikgewogICAgICAgICAgdGFicyA9IHRydWU7CiAgICAgICAgICBzaXplKys7CiAgICAgICAgfSBlbHNlIGlmIChjaHVuayA9PT0gY29kZXMudmlydHVhbFNwYWNlKSB7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGluZGV4MisrOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChjb250ZXh0Ll9jb250ZW50VHlwZVRleHRUcmFpbGluZyAmJiBldmVudEluZGV4ID09PSBldmVudHMubGVuZ3RoKSB7CiAgICAgICAgc2l6ZSA9IDA7CiAgICAgIH0KICAgICAgaWYgKHNpemUpIHsKICAgICAgICBjb25zdCB0b2tlbiA9IHsKICAgICAgICAgIHR5cGU6IGV2ZW50SW5kZXggPT09IGV2ZW50cy5sZW5ndGggfHwgdGFicyB8fCBzaXplIDwgY29uc3RhbnRzLmhhcmRCcmVha1ByZWZpeFNpemVNaW4gPyB0eXBlcy5saW5lU3VmZml4IDogdHlwZXMuaGFyZEJyZWFrVHJhaWxpbmcsCiAgICAgICAgICBzdGFydDogewogICAgICAgICAgICBfYnVmZmVySW5kZXg6IGluZGV4MiA/IGJ1ZmZlckluZGV4IDogZGF0YS5zdGFydC5fYnVmZmVySW5kZXggKyBidWZmZXJJbmRleCwKICAgICAgICAgICAgX2luZGV4OiBkYXRhLnN0YXJ0Ll9pbmRleCArIGluZGV4MiwKICAgICAgICAgICAgbGluZTogZGF0YS5lbmQubGluZSwKICAgICAgICAgICAgY29sdW1uOiBkYXRhLmVuZC5jb2x1bW4gLSBzaXplLAogICAgICAgICAgICBvZmZzZXQ6IGRhdGEuZW5kLm9mZnNldCAtIHNpemUKICAgICAgICAgIH0sCiAgICAgICAgICBlbmQ6IHsgLi4uZGF0YS5lbmQgfQogICAgICAgIH07CiAgICAgICAgZGF0YS5lbmQgPSB7IC4uLnRva2VuLnN0YXJ0IH07CiAgICAgICAgaWYgKGRhdGEuc3RhcnQub2Zmc2V0ID09PSBkYXRhLmVuZC5vZmZzZXQpIHsKICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgdG9rZW4pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBldmVudHMuc3BsaWNlKAogICAgICAgICAgICBldmVudEluZGV4LAogICAgICAgICAgICAwLAogICAgICAgICAgICBbImVudGVyIiwgdG9rZW4sIGNvbnRleHRdLAogICAgICAgICAgICBbImV4aXQiLCB0b2tlbiwgY29udGV4dF0KICAgICAgICAgICk7CiAgICAgICAgICBldmVudEluZGV4ICs9IDI7CiAgICAgICAgfQogICAgICB9CiAgICAgIGV2ZW50SW5kZXgrKzsKICAgIH0KICB9CiAgcmV0dXJuIGV2ZW50czsKfQoKLy8gbm9kZV9tb2R1bGVzL21pY3JvbWFyay9kZXYvbGliL2NvbnN0cnVjdHMuanMKdmFyIGNvbnN0cnVjdHNfZXhwb3J0cyA9IHt9OwpfX2V4cG9ydChjb25zdHJ1Y3RzX2V4cG9ydHMsIHsKICBhdHRlbnRpb25NYXJrZXJzOiAoKSA9PiBhdHRlbnRpb25NYXJrZXJzLAogIGNvbnRlbnRJbml0aWFsOiAoKSA9PiBjb250ZW50SW5pdGlhbCwKICBkaXNhYmxlOiAoKSA9PiBkaXNhYmxlLAogIGRvY3VtZW50OiAoKSA9PiBkb2N1bWVudDMsCiAgZmxvdzogKCkgPT4gZmxvdzIsCiAgZmxvd0luaXRpYWw6ICgpID0+IGZsb3dJbml0aWFsLAogIGluc2lkZVNwYW46ICgpID0+IGluc2lkZVNwYW4sCiAgc3RyaW5nOiAoKSA9PiBzdHJpbmcyLAogIHRleHQ6ICgpID0+IHRleHQzCn0pOwp2YXIgZG9jdW1lbnQzID0gewogIFtjb2Rlcy5hc3Rlcmlza106IGxpc3QsCiAgW2NvZGVzLnBsdXNTaWduXTogbGlzdCwKICBbY29kZXMuZGFzaF06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0MF06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0MV06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0Ml06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0M106IGxpc3QsCiAgW2NvZGVzLmRpZ2l0NF06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0NV06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0Nl06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0N106IGxpc3QsCiAgW2NvZGVzLmRpZ2l0OF06IGxpc3QsCiAgW2NvZGVzLmRpZ2l0OV06IGxpc3QsCiAgW2NvZGVzLmdyZWF0ZXJUaGFuXTogYmxvY2tRdW90ZQp9Owp2YXIgY29udGVudEluaXRpYWwgPSB7CiAgW2NvZGVzLmxlZnRTcXVhcmVCcmFja2V0XTogZGVmaW5pdGlvbgp9Owp2YXIgZmxvd0luaXRpYWwgPSB7CiAgW2NvZGVzLmhvcml6b250YWxUYWJdOiBjb2RlSW5kZW50ZWQsCiAgW2NvZGVzLnZpcnR1YWxTcGFjZV06IGNvZGVJbmRlbnRlZCwKICBbY29kZXMuc3BhY2VdOiBjb2RlSW5kZW50ZWQKfTsKdmFyIGZsb3cyID0gewogIFtjb2Rlcy5udW1iZXJTaWduXTogaGVhZGluZ0F0eCwKICBbY29kZXMuYXN0ZXJpc2tdOiB0aGVtYXRpY0JyZWFrLAogIFtjb2Rlcy5kYXNoXTogW3NldGV4dFVuZGVybGluZSwgdGhlbWF0aWNCcmVha10sCiAgW2NvZGVzLmxlc3NUaGFuXTogaHRtbEZsb3csCiAgW2NvZGVzLmVxdWFsc1RvXTogc2V0ZXh0VW5kZXJsaW5lLAogIFtjb2Rlcy51bmRlcnNjb3JlXTogdGhlbWF0aWNCcmVhaywKICBbY29kZXMuZ3JhdmVBY2NlbnRdOiBjb2RlRmVuY2VkLAogIFtjb2Rlcy50aWxkZV06IGNvZGVGZW5jZWQKfTsKdmFyIHN0cmluZzIgPSB7CiAgW2NvZGVzLmFtcGVyc2FuZF06IGNoYXJhY3RlclJlZmVyZW5jZSwKICBbY29kZXMuYmFja3NsYXNoXTogY2hhcmFjdGVyRXNjYXBlCn07CnZhciB0ZXh0MyA9IHsKICBbY29kZXMuY2FycmlhZ2VSZXR1cm5dOiBsaW5lRW5kaW5nLAogIFtjb2Rlcy5saW5lRmVlZF06IGxpbmVFbmRpbmcsCiAgW2NvZGVzLmNhcnJpYWdlUmV0dXJuTGluZUZlZWRdOiBsaW5lRW5kaW5nLAogIFtjb2Rlcy5leGNsYW1hdGlvbk1hcmtdOiBsYWJlbFN0YXJ0SW1hZ2UsCiAgW2NvZGVzLmFtcGVyc2FuZF06IGNoYXJhY3RlclJlZmVyZW5jZSwKICBbY29kZXMuYXN0ZXJpc2tdOiBhdHRlbnRpb24sCiAgW2NvZGVzLmxlc3NUaGFuXTogW2F1dG9saW5rLCBodG1sVGV4dF0sCiAgW2NvZGVzLmxlZnRTcXVhcmVCcmFja2V0XTogbGFiZWxTdGFydExpbmssCiAgW2NvZGVzLmJhY2tzbGFzaF06IFtoYXJkQnJlYWtFc2NhcGUsIGNoYXJhY3RlckVzY2FwZV0sCiAgW2NvZGVzLnJpZ2h0U3F1YXJlQnJhY2tldF06IGxhYmVsRW5kLAogIFtjb2Rlcy51bmRlcnNjb3JlXTogYXR0ZW50aW9uLAogIFtjb2Rlcy5ncmF2ZUFjY2VudF06IGNvZGVUZXh0Cn07CnZhciBpbnNpZGVTcGFuID0geyBudWxsOiBbYXR0ZW50aW9uLCByZXNvbHZlcl0gfTsKdmFyIGF0dGVudGlvbk1hcmtlcnMgPSB7IG51bGw6IFtjb2Rlcy5hc3RlcmlzaywgY29kZXMudW5kZXJzY29yZV0gfTsKdmFyIGRpc2FibGUgPSB7IG51bGw6IFtdIH07CgovLyBub2RlX21vZHVsZXMvbWljcm9tYXJrL2Rldi9saWIvY3JlYXRlLXRva2VuaXplci5qcwp2YXIgaW1wb3J0X2RlYnVnID0gX190b0VTTShyZXF1aXJlX2Jyb3dzZXIoKSwgMSk7CnZhciBkZWJ1ZyA9ICgwLCBpbXBvcnRfZGVidWcuZGVmYXVsdCkoIm1pY3JvbWFyayIpOwpmdW5jdGlvbiBjcmVhdGVUb2tlbml6ZXIocGFyc2VyLCBpbml0aWFsaXplLCBmcm9tKSB7CiAgbGV0IHBvaW50MyA9IHsKICAgIF9idWZmZXJJbmRleDogLTEsCiAgICBfaW5kZXg6IDAsCiAgICBsaW5lOiBmcm9tICYmIGZyb20ubGluZSB8fCAxLAogICAgY29sdW1uOiBmcm9tICYmIGZyb20uY29sdW1uIHx8IDEsCiAgICBvZmZzZXQ6IGZyb20gJiYgZnJvbS5vZmZzZXQgfHwgMAogIH07CiAgY29uc3QgY29sdW1uU3RhcnQgPSB7fTsKICBjb25zdCByZXNvbHZlQWxsQ29uc3RydWN0cyA9IFtdOwogIGxldCBjaHVua3MgPSBbXTsKICBsZXQgc3RhY2sgPSBbXTsKICBsZXQgY29uc3VtZWQgPSB0cnVlOwogIGNvbnN0IGVmZmVjdHMgPSB7CiAgICBhdHRlbXB0OiBjb25zdHJ1Y3RGYWN0b3J5KG9uc3VjY2Vzc2Z1bGNvbnN0cnVjdCksCiAgICBjaGVjazogY29uc3RydWN0RmFjdG9yeShvbnN1Y2Nlc3NmdWxjaGVjayksCiAgICBjb25zdW1lLAogICAgZW50ZXIsCiAgICBleGl0LAogICAgaW50ZXJydXB0OiBjb25zdHJ1Y3RGYWN0b3J5KG9uc3VjY2Vzc2Z1bGNoZWNrLCB7IGludGVycnVwdDogdHJ1ZSB9KQogIH07CiAgY29uc3QgY29udGV4dCA9IHsKICAgIGNvZGU6IGNvZGVzLmVvZiwKICAgIGNvbnRhaW5lclN0YXRlOiB7fSwKICAgIGRlZmluZVNraXAsCiAgICBldmVudHM6IFtdLAogICAgbm93LAogICAgcGFyc2VyLAogICAgcHJldmlvdXM6IGNvZGVzLmVvZiwKICAgIHNsaWNlU2VyaWFsaXplLAogICAgc2xpY2VTdHJlYW0sCiAgICB3cml0ZQogIH07CiAgbGV0IHN0YXRlID0gaW5pdGlhbGl6ZS50b2tlbml6ZS5jYWxsKGNvbnRleHQsIGVmZmVjdHMpOwogIGxldCBleHBlY3RlZENvZGU7CiAgaWYgKGluaXRpYWxpemUucmVzb2x2ZUFsbCkgewogICAgcmVzb2x2ZUFsbENvbnN0cnVjdHMucHVzaChpbml0aWFsaXplKTsKICB9CiAgcmV0dXJuIGNvbnRleHQ7CiAgZnVuY3Rpb24gd3JpdGUoc2xpY2UpIHsKICAgIGNodW5rcyA9IHB1c2goY2h1bmtzLCBzbGljZSk7CiAgICBtYWluKCk7CiAgICBpZiAoY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXSAhPT0gY29kZXMuZW9mKSB7CiAgICAgIHJldHVybiBbXTsKICAgIH0KICAgIGFkZFJlc3VsdChpbml0aWFsaXplLCAwKTsKICAgIGNvbnRleHQuZXZlbnRzID0gcmVzb2x2ZUFsbChyZXNvbHZlQWxsQ29uc3RydWN0cywgY29udGV4dC5ldmVudHMsIGNvbnRleHQpOwogICAgcmV0dXJuIGNvbnRleHQuZXZlbnRzOwogIH0KICBmdW5jdGlvbiBzbGljZVNlcmlhbGl6ZSh0b2tlbiwgZXhwYW5kVGFicykgewogICAgcmV0dXJuIHNlcmlhbGl6ZUNodW5rcyhzbGljZVN0cmVhbSh0b2tlbiksIGV4cGFuZFRhYnMpOwogIH0KICBmdW5jdGlvbiBzbGljZVN0cmVhbSh0b2tlbikgewogICAgcmV0dXJuIHNsaWNlQ2h1bmtzKGNodW5rcywgdG9rZW4pOwogIH0KICBmdW5jdGlvbiBub3coKSB7CiAgICBjb25zdCB7IF9idWZmZXJJbmRleCwgX2luZGV4LCBsaW5lLCBjb2x1bW4sIG9mZnNldCB9ID0gcG9pbnQzOwogICAgcmV0dXJuIHsgX2J1ZmZlckluZGV4LCBfaW5kZXgsIGxpbmUsIGNvbHVtbiwgb2Zmc2V0IH07CiAgfQogIGZ1bmN0aW9uIGRlZmluZVNraXAodmFsdWUpIHsKICAgIGNvbHVtblN0YXJ0W3ZhbHVlLmxpbmVdID0gdmFsdWUuY29sdW1uOwogICAgYWNjb3VudEZvclBvdGVudGlhbFNraXAoKTsKICAgIGRlYnVnKCJwb3NpdGlvbjogZGVmaW5lIHNraXA6IGAlamAiLCBwb2ludDMpOwogIH0KICBmdW5jdGlvbiBtYWluKCkgewogICAgbGV0IGNodW5rSW5kZXg7CiAgICB3aGlsZSAocG9pbnQzLl9pbmRleCA8IGNodW5rcy5sZW5ndGgpIHsKICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbcG9pbnQzLl9pbmRleF07CiAgICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICJzdHJpbmciKSB7CiAgICAgICAgY2h1bmtJbmRleCA9IHBvaW50My5faW5kZXg7CiAgICAgICAgaWYgKHBvaW50My5fYnVmZmVySW5kZXggPCAwKSB7CiAgICAgICAgICBwb2ludDMuX2J1ZmZlckluZGV4ID0gMDsKICAgICAgICB9CiAgICAgICAgd2hpbGUgKHBvaW50My5faW5kZXggPT09IGNodW5rSW5kZXggJiYgcG9pbnQzLl9idWZmZXJJbmRleCA8IGNodW5rLmxlbmd0aCkgewogICAgICAgICAgZ28oY2h1bmsuY2hhckNvZGVBdChwb2ludDMuX2J1ZmZlckluZGV4KSk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGdvKGNodW5rKTsKICAgICAgfQogICAgfQogIH0KICBmdW5jdGlvbiBnbyhjb2RlMikgewogICAgb2soY29uc3VtZWQgPT09IHRydWUsICJleHBlY3RlZCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQiKTsKICAgIGNvbnN1bWVkID0gdm9pZCAwOwogICAgZGVidWcoIm1haW46IHBhc3NpbmcgYCVzYCB0byAlcyIsIGNvZGUyLCBzdGF0ZSAmJiBzdGF0ZS5uYW1lKTsKICAgIGV4cGVjdGVkQ29kZSA9IGNvZGUyOwogICAgb2sodHlwZW9mIHN0YXRlID09PSAiZnVuY3Rpb24iLCAiZXhwZWN0ZWQgc3RhdGUiKTsKICAgIHN0YXRlID0gc3RhdGUoY29kZTIpOwogIH0KICBmdW5jdGlvbiBjb25zdW1lKGNvZGUyKSB7CiAgICBvayhjb2RlMiA9PT0gZXhwZWN0ZWRDb2RlLCAiZXhwZWN0ZWQgZ2l2ZW4gY29kZSB0byBlcXVhbCBleHBlY3RlZCBjb2RlIik7CiAgICBkZWJ1ZygiY29uc3VtZTogYCVzYCIsIGNvZGUyKTsKICAgIG9rKAogICAgICBjb25zdW1lZCA9PT0gdm9pZCAwLAogICAgICAiZXhwZWN0ZWQgY29kZSB0byBub3QgaGF2ZSBiZWVuIGNvbnN1bWVkOiB0aGlzIG1pZ2h0IGJlIGJlY2F1c2UgYHJldHVybiB4KGNvZGUpYCBpbnN0ZWFkIG9mIGByZXR1cm4geGAgd2FzIHVzZWQiCiAgICApOwogICAgb2soCiAgICAgIGNvZGUyID09PSBudWxsID8gY29udGV4dC5ldmVudHMubGVuZ3RoID09PSAwIHx8IGNvbnRleHQuZXZlbnRzW2NvbnRleHQuZXZlbnRzLmxlbmd0aCAtIDFdWzBdID09PSAiZXhpdCIgOiBjb250ZXh0LmV2ZW50c1tjb250ZXh0LmV2ZW50cy5sZW5ndGggLSAxXVswXSA9PT0gImVudGVyIiwKICAgICAgImV4cGVjdGVkIGxhc3QgdG9rZW4gdG8gYmUgb3BlbiIKICAgICk7CiAgICBpZiAobWFya2Rvd25MaW5lRW5kaW5nKGNvZGUyKSkgewogICAgICBwb2ludDMubGluZSsrOwogICAgICBwb2ludDMuY29sdW1uID0gMTsKICAgICAgcG9pbnQzLm9mZnNldCArPSBjb2RlMiA9PT0gY29kZXMuY2FycmlhZ2VSZXR1cm5MaW5lRmVlZCA/IDIgOiAxOwogICAgICBhY2NvdW50Rm9yUG90ZW50aWFsU2tpcCgpOwogICAgICBkZWJ1ZygicG9zaXRpb246IGFmdGVyIGVvbDogYCVqYCIsIHBvaW50Myk7CiAgICB9IGVsc2UgaWYgKGNvZGUyICE9PSBjb2Rlcy52aXJ0dWFsU3BhY2UpIHsKICAgICAgcG9pbnQzLmNvbHVtbisrOwogICAgICBwb2ludDMub2Zmc2V0Kys7CiAgICB9CiAgICBpZiAocG9pbnQzLl9idWZmZXJJbmRleCA8IDApIHsKICAgICAgcG9pbnQzLl9pbmRleCsrOwogICAgfSBlbHNlIHsKICAgICAgcG9pbnQzLl9idWZmZXJJbmRleCsrOwogICAgICBpZiAocG9pbnQzLl9idWZmZXJJbmRleCA9PT0gLy8gUG9pbnRzIHcvIG5vbi1uZWdhdGl2ZSBgX2J1ZmZlckluZGV4YCByZWZlcmVuY2UKICAgICAgLy8gc3RyaW5ncy4KICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovCiAgICAgIGNodW5rc1twb2ludDMuX2luZGV4XS5sZW5ndGgpIHsKICAgICAgICBwb2ludDMuX2J1ZmZlckluZGV4ID0gLTE7CiAgICAgICAgcG9pbnQzLl9pbmRleCsrOwogICAgICB9CiAgICB9CiAgICBjb250ZXh0LnByZXZpb3VzID0gY29kZTI7CiAgICBjb25zdW1lZCA9IHRydWU7CiAgfQogIGZ1bmN0aW9uIGVudGVyKHR5cGUsIGZpZWxkcykgewogICAgY29uc3QgdG9rZW4gPSBmaWVsZHMgfHwge307CiAgICB0b2tlbi50eXBlID0gdHlwZTsKICAgIHRva2VuLnN0YXJ0ID0gbm93KCk7CiAgICBvayh0eXBlb2YgdHlwZSA9PT0gInN0cmluZyIsICJleHBlY3RlZCBzdHJpbmcgdHlwZSIpOwogICAgb2sodHlwZS5sZW5ndGggPiAwLCAiZXhwZWN0ZWQgbm9uLWVtcHR5IHN0cmluZyIpOwogICAgZGVidWcoImVudGVyOiBgJXNgIiwgdHlwZSk7CiAgICBjb250ZXh0LmV2ZW50cy5wdXNoKFsiZW50ZXIiLCB0b2tlbiwgY29udGV4dF0pOwogICAgc3RhY2sucHVzaCh0b2tlbik7CiAgICByZXR1cm4gdG9rZW47CiAgfQogIGZ1bmN0aW9uIGV4aXQodHlwZSkgewogICAgb2sodHlwZW9mIHR5cGUgPT09ICJzdHJpbmciLCAiZXhwZWN0ZWQgc3RyaW5nIHR5cGUiKTsKICAgIG9rKHR5cGUubGVuZ3RoID4gMCwgImV4cGVjdGVkIG5vbi1lbXB0eSBzdHJpbmciKTsKICAgIGNvbnN0IHRva2VuID0gc3RhY2sucG9wKCk7CiAgICBvayh0b2tlbiwgImNhbm5vdCBjbG9zZSB3L28gb3BlbiB0b2tlbnMiKTsKICAgIHRva2VuLmVuZCA9IG5vdygpOwogICAgb2sodHlwZSA9PT0gdG9rZW4udHlwZSwgImV4cGVjdGVkIGV4aXQgdG9rZW4gdG8gbWF0Y2ggY3VycmVudCB0b2tlbiIpOwogICAgb2soCiAgICAgICEodG9rZW4uc3RhcnQuX2luZGV4ID09PSB0b2tlbi5lbmQuX2luZGV4ICYmIHRva2VuLnN0YXJ0Ll9idWZmZXJJbmRleCA9PT0gdG9rZW4uZW5kLl9idWZmZXJJbmRleCksCiAgICAgICJleHBlY3RlZCBub24tZW1wdHkgdG9rZW4gKGAiICsgdHlwZSArICJgKSIKICAgICk7CiAgICBkZWJ1ZygiZXhpdDogYCVzYCIsIHRva2VuLnR5cGUpOwogICAgY29udGV4dC5ldmVudHMucHVzaChbImV4aXQiLCB0b2tlbiwgY29udGV4dF0pOwogICAgcmV0dXJuIHRva2VuOwogIH0KICBmdW5jdGlvbiBvbnN1Y2Nlc3NmdWxjb25zdHJ1Y3QoY29uc3RydWN0LCBpbmZvKSB7CiAgICBhZGRSZXN1bHQoY29uc3RydWN0LCBpbmZvLmZyb20pOwogIH0KICBmdW5jdGlvbiBvbnN1Y2Nlc3NmdWxjaGVjayhfLCBpbmZvKSB7CiAgICBpbmZvLnJlc3RvcmUoKTsKICB9CiAgZnVuY3Rpb24gY29uc3RydWN0RmFjdG9yeShvbnJldHVybiwgZmllbGRzKSB7CiAgICByZXR1cm4gaG9vazsKICAgIGZ1bmN0aW9uIGhvb2soY29uc3RydWN0cywgcmV0dXJuU3RhdGUsIGJvZ3VzU3RhdGUpIHsKICAgICAgbGV0IGxpc3RPZkNvbnN0cnVjdHM7CiAgICAgIGxldCBjb25zdHJ1Y3RJbmRleDsKICAgICAgbGV0IGN1cnJlbnRDb25zdHJ1Y3Q7CiAgICAgIGxldCBpbmZvOwogICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjb25zdHJ1Y3RzKSA/ICgKICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAxICovCiAgICAgICAgaGFuZGxlTGlzdE9mQ29uc3RydWN0cyhjb25zdHJ1Y3RzKQogICAgICApIDogInRva2VuaXplIiBpbiBjb25zdHJ1Y3RzID8gKAogICAgICAgIC8vIExvb2tzIGxpa2UgYSBjb25zdHJ1Y3QuCiAgICAgICAgaGFuZGxlTGlzdE9mQ29uc3RydWN0cyhbCiAgICAgICAgICAvKiogQHR5cGUge0NvbnN0cnVjdH0gKi8KICAgICAgICAgIGNvbnN0cnVjdHMKICAgICAgICBdKQogICAgICApIDogaGFuZGxlTWFwT2ZDb25zdHJ1Y3RzKGNvbnN0cnVjdHMpOwogICAgICBmdW5jdGlvbiBoYW5kbGVNYXBPZkNvbnN0cnVjdHMobWFwKSB7CiAgICAgICAgcmV0dXJuIHN0YXJ0MjsKICAgICAgICBmdW5jdGlvbiBzdGFydDIoY29kZTIpIHsKICAgICAgICAgIGNvbnN0IGxlZnQgPSBjb2RlMiAhPT0gbnVsbCAmJiBtYXBbY29kZTJdOwogICAgICAgICAgY29uc3QgYWxsID0gY29kZTIgIT09IG51bGwgJiYgbWFwLm51bGw7CiAgICAgICAgICBjb25zdCBsaXN0MyA9IFsKICAgICAgICAgICAgLy8gVG8gZG86IGFkZCBtb3JlIGV4dGVuc2lvbiB0ZXN0cy4KICAgICAgICAgICAgLyogYzggaWdub3JlIG5leHQgMiAqLwogICAgICAgICAgICAuLi5BcnJheS5pc0FycmF5KGxlZnQpID8gbGVmdCA6IGxlZnQgPyBbbGVmdF0gOiBbXSwKICAgICAgICAgICAgLi4uQXJyYXkuaXNBcnJheShhbGwpID8gYWxsIDogYWxsID8gW2FsbF0gOiBbXQogICAgICAgICAgXTsKICAgICAgICAgIHJldHVybiBoYW5kbGVMaXN0T2ZDb25zdHJ1Y3RzKGxpc3QzKShjb2RlMik7CiAgICAgICAgfQogICAgICB9CiAgICAgIGZ1bmN0aW9uIGhhbmRsZUxpc3RPZkNvbnN0cnVjdHMobGlzdDMpIHsKICAgICAgICBsaXN0T2ZDb25zdHJ1Y3RzID0gbGlzdDM7CiAgICAgICAgY29uc3RydWN0SW5kZXggPSAwOwogICAgICAgIGlmIChsaXN0My5sZW5ndGggPT09IDApIHsKICAgICAgICAgIG9rKGJvZ3VzU3RhdGUsICJleHBlY3RlZCBgYm9ndXNTdGF0ZWAgdG8gYmUgZ2l2ZW4iKTsKICAgICAgICAgIHJldHVybiBib2d1c1N0YXRlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gaGFuZGxlQ29uc3RydWN0KGxpc3QzW2NvbnN0cnVjdEluZGV4XSk7CiAgICAgIH0KICAgICAgZnVuY3Rpb24gaGFuZGxlQ29uc3RydWN0KGNvbnN0cnVjdCkgewogICAgICAgIHJldHVybiBzdGFydDI7CiAgICAgICAgZnVuY3Rpb24gc3RhcnQyKGNvZGUyKSB7CiAgICAgICAgICBpbmZvID0gc3RvcmUoKTsKICAgICAgICAgIGN1cnJlbnRDb25zdHJ1Y3QgPSBjb25zdHJ1Y3Q7CiAgICAgICAgICBpZiAoIWNvbnN0cnVjdC5wYXJ0aWFsKSB7CiAgICAgICAgICAgIGNvbnRleHQuY3VycmVudENvbnN0cnVjdCA9IGNvbnN0cnVjdDsKICAgICAgICAgIH0KICAgICAgICAgIG9rKAogICAgICAgICAgICBjb250ZXh0LnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbCwKICAgICAgICAgICAgImV4cGVjdGVkIGBkaXNhYmxlLm51bGxgIHRvIGJlIHBvcHVsYXRlZCIKICAgICAgICAgICk7CiAgICAgICAgICBpZiAoY29uc3RydWN0Lm5hbWUgJiYgY29udGV4dC5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoY29uc3RydWN0Lm5hbWUpKSB7CiAgICAgICAgICAgIHJldHVybiBub2soY29kZTIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGNvbnN0cnVjdC50b2tlbml6ZS5jYWxsKAogICAgICAgICAgICAvLyBJZiB3ZSBkbyBoYXZlIGZpZWxkcywgY3JlYXRlIGFuIG9iamVjdCB3LyBgY29udGV4dGAgYXMgaXRzCiAgICAgICAgICAgIC8vIHByb3RvdHlwZS4KICAgICAgICAgICAgLy8gVGhpcyBhbGxvd3MgYSDigJxsaXZlIGJpbmRpbmfigJ0sIHdoaWNoIGlzIG5lZWRlZCBmb3IgYGludGVycnVwdGAuCiAgICAgICAgICAgIGZpZWxkcyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShjb250ZXh0KSwgZmllbGRzKSA6IGNvbnRleHQsCiAgICAgICAgICAgIGVmZmVjdHMsCiAgICAgICAgICAgIG9rMiwKICAgICAgICAgICAgbm9rCiAgICAgICAgICApKGNvZGUyKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgZnVuY3Rpb24gb2syKGNvZGUyKSB7CiAgICAgICAgb2soY29kZTIgPT09IGV4cGVjdGVkQ29kZSwgImV4cGVjdGVkIGNvZGUiKTsKICAgICAgICBjb25zdW1lZCA9IHRydWU7CiAgICAgICAgb25yZXR1cm4oY3VycmVudENvbnN0cnVjdCwgaW5mbyk7CiAgICAgICAgcmV0dXJuIHJldHVyblN0YXRlOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIG5vayhjb2RlMikgewogICAgICAgIG9rKGNvZGUyID09PSBleHBlY3RlZENvZGUsICJleHBlY3RlZCBjb2RlIik7CiAgICAgICAgY29uc3VtZWQgPSB0cnVlOwogICAgICAgIGluZm8ucmVzdG9yZSgpOwogICAgICAgIGlmICgrK2NvbnN0cnVjdEluZGV4IDwgbGlzdE9mQ29uc3RydWN0cy5sZW5ndGgpIHsKICAgICAgICAgIHJldHVybiBoYW5kbGVDb25zdHJ1Y3QobGlzdE9mQ29uc3RydWN0c1tjb25zdHJ1Y3RJbmRleF0pOwogICAgICAgIH0KICAgICAgICByZXR1cm4gYm9ndXNTdGF0ZTsKICAgICAgfQogICAgfQogIH0KICBmdW5jdGlvbiBhZGRSZXN1bHQoY29uc3RydWN0LCBmcm9tMikgewogICAgaWYgKGNvbnN0cnVjdC5yZXNvbHZlQWxsICYmICFyZXNvbHZlQWxsQ29uc3RydWN0cy5pbmNsdWRlcyhjb25zdHJ1Y3QpKSB7CiAgICAgIHJlc29sdmVBbGxDb25zdHJ1Y3RzLnB1c2goY29uc3RydWN0KTsKICAgIH0KICAgIGlmIChjb25zdHJ1Y3QucmVzb2x2ZSkgewogICAgICBzcGxpY2UoCiAgICAgICAgY29udGV4dC5ldmVudHMsCiAgICAgICAgZnJvbTIsCiAgICAgICAgY29udGV4dC5ldmVudHMubGVuZ3RoIC0gZnJvbTIsCiAgICAgICAgY29uc3RydWN0LnJlc29sdmUoY29udGV4dC5ldmVudHMuc2xpY2UoZnJvbTIpLCBjb250ZXh0KQogICAgICApOwogICAgfQogICAgaWYgKGNvbnN0cnVjdC5yZXNvbHZlVG8pIHsKICAgICAgY29udGV4dC5ldmVudHMgPSBjb25zdHJ1Y3QucmVzb2x2ZVRvKGNvbnRleHQuZXZlbnRzLCBjb250ZXh0KTsKICAgIH0KICAgIG9rKAogICAgICBjb25zdHJ1Y3QucGFydGlhbCB8fCBjb250ZXh0LmV2ZW50cy5sZW5ndGggPT09IDAgfHwgY29udGV4dC5ldmVudHNbY29udGV4dC5ldmVudHMubGVuZ3RoIC0gMV1bMF0gPT09ICJleGl0IiwKICAgICAgImV4cGVjdGVkIGxhc3QgdG9rZW4gdG8gZW5kIgogICAgKTsKICB9CiAgZnVuY3Rpb24gc3RvcmUoKSB7CiAgICBjb25zdCBzdGFydFBvaW50ID0gbm93KCk7CiAgICBjb25zdCBzdGFydFByZXZpb3VzID0gY29udGV4dC5wcmV2aW91czsKICAgIGNvbnN0IHN0YXJ0Q3VycmVudENvbnN0cnVjdCA9IGNvbnRleHQuY3VycmVudENvbnN0cnVjdDsKICAgIGNvbnN0IHN0YXJ0RXZlbnRzSW5kZXggPSBjb250ZXh0LmV2ZW50cy5sZW5ndGg7CiAgICBjb25zdCBzdGFydFN0YWNrID0gQXJyYXkuZnJvbShzdGFjayk7CiAgICByZXR1cm4geyBmcm9tOiBzdGFydEV2ZW50c0luZGV4LCByZXN0b3JlIH07CiAgICBmdW5jdGlvbiByZXN0b3JlKCkgewogICAgICBwb2ludDMgPSBzdGFydFBvaW50OwogICAgICBjb250ZXh0LnByZXZpb3VzID0gc3RhcnRQcmV2aW91czsKICAgICAgY29udGV4dC5jdXJyZW50Q29uc3RydWN0ID0gc3RhcnRDdXJyZW50Q29uc3RydWN0OwogICAgICBjb250ZXh0LmV2ZW50cy5sZW5ndGggPSBzdGFydEV2ZW50c0luZGV4OwogICAgICBzdGFjayA9IHN0YXJ0U3RhY2s7CiAgICAgIGFjY291bnRGb3JQb3RlbnRpYWxTa2lwKCk7CiAgICAgIGRlYnVnKCJwb3NpdGlvbjogcmVzdG9yZTogYCVqYCIsIHBvaW50Myk7CiAgICB9CiAgfQogIGZ1bmN0aW9uIGFjY291bnRGb3JQb3RlbnRpYWxTa2lwKCkgewogICAgaWYgKHBvaW50My5saW5lIGluIGNvbHVtblN0YXJ0ICYmIHBvaW50My5jb2x1bW4gPCAyKSB7CiAgICAgIHBvaW50My5jb2x1bW4gPSBjb2x1bW5TdGFydFtwb2ludDMubGluZV07CiAgICAgIHBvaW50My5vZmZzZXQgKz0gY29sdW1uU3RhcnRbcG9pbnQzLmxpbmVdIC0gMTsKICAgIH0KICB9Cn0KZnVuY3Rpb24gc2xpY2VDaHVua3MoY2h1bmtzLCB0b2tlbikgewogIGNvbnN0IHN0YXJ0SW5kZXggPSB0b2tlbi5zdGFydC5faW5kZXg7CiAgY29uc3Qgc3RhcnRCdWZmZXJJbmRleCA9IHRva2VuLnN0YXJ0Ll9idWZmZXJJbmRleDsKICBjb25zdCBlbmRJbmRleCA9IHRva2VuLmVuZC5faW5kZXg7CiAgY29uc3QgZW5kQnVmZmVySW5kZXggPSB0b2tlbi5lbmQuX2J1ZmZlckluZGV4OwogIGxldCB2aWV3OwogIGlmIChzdGFydEluZGV4ID09PSBlbmRJbmRleCkgewogICAgb2soZW5kQnVmZmVySW5kZXggPiAtMSwgImV4cGVjdGVkIG5vbi1uZWdhdGl2ZSBlbmQgYnVmZmVyIGluZGV4Iik7CiAgICBvayhzdGFydEJ1ZmZlckluZGV4ID4gLTEsICJleHBlY3RlZCBub24tbmVnYXRpdmUgc3RhcnQgYnVmZmVyIGluZGV4Iik7CiAgICB2aWV3ID0gW2NodW5rc1tzdGFydEluZGV4XS5zbGljZShzdGFydEJ1ZmZlckluZGV4LCBlbmRCdWZmZXJJbmRleCldOwogIH0gZWxzZSB7CiAgICB2aWV3ID0gY2h1bmtzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTsKICAgIGlmIChzdGFydEJ1ZmZlckluZGV4ID4gLTEpIHsKICAgICAgY29uc3QgaGVhZCA9IHZpZXdbMF07CiAgICAgIGlmICh0eXBlb2YgaGVhZCA9PT0gInN0cmluZyIpIHsKICAgICAgICB2aWV3WzBdID0gaGVhZC5zbGljZShzdGFydEJ1ZmZlckluZGV4KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBvayhzdGFydEJ1ZmZlckluZGV4ID09PSAwLCAiZXhwZWN0ZWQgYHN0YXJ0QnVmZmVySW5kZXhgIHRvIGJlIGAwYCIpOwogICAgICAgIHZpZXcuc2hpZnQoKTsKICAgICAgfQogICAgfQogICAgaWYgKGVuZEJ1ZmZlckluZGV4ID4gMCkgewogICAgICB2aWV3LnB1c2goY2h1bmtzW2VuZEluZGV4XS5zbGljZSgwLCBlbmRCdWZmZXJJbmRleCkpOwogICAgfQogIH0KICByZXR1cm4gdmlldzsKfQpmdW5jdGlvbiBzZXJpYWxpemVDaHVua3MoY2h1bmtzLCBleHBhbmRUYWJzKSB7CiAgbGV0IGluZGV4MiA9IC0xOwogIGNvbnN0IHJlc3VsdCA9IFtdOwogIGxldCBhdFRhYjsKICB3aGlsZSAoKytpbmRleDIgPCBjaHVua3MubGVuZ3RoKSB7CiAgICBjb25zdCBjaHVuayA9IGNodW5rc1tpbmRleDJdOwogICAgbGV0IHZhbHVlOwogICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gInN0cmluZyIpIHsKICAgICAgdmFsdWUgPSBjaHVuazsKICAgIH0gZWxzZQogICAgICBzd2l0Y2ggKGNodW5rKSB7CiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybjogewogICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuY3I7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgY2FzZSBjb2Rlcy5saW5lRmVlZDogewogICAgICAgICAgdmFsdWUgPSB2YWx1ZXMubGY7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgY2FzZSBjb2Rlcy5jYXJyaWFnZVJldHVybkxpbmVGZWVkOiB7CiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5jciArIHZhbHVlcy5sZjsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBjYXNlIGNvZGVzLmhvcml6b250YWxUYWI6IHsKICAgICAgICAgIHZhbHVlID0gZXhwYW5kVGFicyA/IHZhbHVlcy5zcGFjZSA6IHZhbHVlcy5odDsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBjYXNlIGNvZGVzLnZpcnR1YWxTcGFjZTogewogICAgICAgICAgaWYgKCFleHBhbmRUYWJzICYmIGF0VGFiKSBjb250aW51ZTsKICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnNwYWNlOwogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGRlZmF1bHQ6IHsKICAgICAgICAgIG9rKHR5cGVvZiBjaHVuayA9PT0gIm51bWJlciIsICJleHBlY3RlZCBudW1iZXIiKTsKICAgICAgICAgIHZhbHVlID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHVuayk7CiAgICAgICAgfQogICAgICB9CiAgICBhdFRhYiA9IGNodW5rID09PSBjb2Rlcy5ob3Jpem9udGFsVGFiOwogICAgcmVzdWx0LnB1c2godmFsdWUpOwogIH0KICByZXR1cm4gcmVzdWx0LmpvaW4oIiIpOwp9CgovLyBub2RlX21vZHVsZXMvbWljcm9tYXJrL2Rldi9saWIvcGFyc2UuanMKZnVuY3Rpb24gcGFyc2Uob3B0aW9ucykgewogIGNvbnN0IHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fTsKICBjb25zdCBjb25zdHJ1Y3RzID0gKAogICAgLyoqIEB0eXBlIHtGdWxsTm9ybWFsaXplZEV4dGVuc2lvbn0gKi8KICAgIGNvbWJpbmVFeHRlbnNpb25zKFtjb25zdHJ1Y3RzX2V4cG9ydHMsIC4uLnNldHRpbmdzLmV4dGVuc2lvbnMgfHwgW11dKQogICk7CiAgY29uc3QgcGFyc2VyID0gewogICAgY29uc3RydWN0cywKICAgIGNvbnRlbnQ6IGNyZWF0ZShjb250ZW50MiksCiAgICBkZWZpbmVkOiBbXSwKICAgIGRvY3VtZW50OiBjcmVhdGUoZG9jdW1lbnQyKSwKICAgIGZsb3c6IGNyZWF0ZShmbG93KSwKICAgIGxhenk6IHt9LAogICAgc3RyaW5nOiBjcmVhdGUoc3RyaW5nKSwKICAgIHRleHQ6IGNyZWF0ZSh0ZXh0MikKICB9OwogIHJldHVybiBwYXJzZXI7CiAgZnVuY3Rpb24gY3JlYXRlKGluaXRpYWwpIHsKICAgIHJldHVybiBjcmVhdG9yOwogICAgZnVuY3Rpb24gY3JlYXRvcihmcm9tKSB7CiAgICAgIHJldHVybiBjcmVhdGVUb2tlbml6ZXIocGFyc2VyLCBpbml0aWFsLCBmcm9tKTsKICAgIH0KICB9Cn0KCi8vIG5vZGVfbW9kdWxlcy9taWNyb21hcmsvZGV2L2xpYi9wb3N0cHJvY2Vzcy5qcwpmdW5jdGlvbiBwb3N0cHJvY2VzcyhldmVudHMpIHsKICB3aGlsZSAoIXN1YnRva2VuaXplKGV2ZW50cykpIHsKICB9CiAgcmV0dXJuIGV2ZW50czsKfQoKLy8gbm9kZV9tb2R1bGVzL21pY3JvbWFyay9kZXYvbGliL3ByZXByb2Nlc3MuanMKdmFyIHNlYXJjaCA9IC9bXDBcdFxuXHJdL2c7CmZ1bmN0aW9uIHByZXByb2Nlc3MoKSB7CiAgbGV0IGNvbHVtbiA9IDE7CiAgbGV0IGJ1ZmZlciA9ICIiOwogIGxldCBzdGFydDIgPSB0cnVlOwogIGxldCBhdENhcnJpYWdlUmV0dXJuOwogIHJldHVybiBwcmVwcm9jZXNzb3I7CiAgZnVuY3Rpb24gcHJlcHJvY2Vzc29yKHZhbHVlLCBlbmNvZGluZywgZW5kKSB7CiAgICBjb25zdCBjaHVua3MgPSBbXTsKICAgIGxldCBtYXRjaDsKICAgIGxldCBuZXh0OwogICAgbGV0IHN0YXJ0UG9zaXRpb247CiAgICBsZXQgZW5kUG9zaXRpb247CiAgICBsZXQgY29kZTI7CiAgICB2YWx1ZSA9IGJ1ZmZlciArICh0eXBlb2YgdmFsdWUgPT09ICJzdHJpbmciID8gdmFsdWUudG9TdHJpbmcoKSA6IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZyB8fCB2b2lkIDApLmRlY29kZSh2YWx1ZSkpOwogICAgc3RhcnRQb3NpdGlvbiA9IDA7CiAgICBidWZmZXIgPSAiIjsKICAgIGlmIChzdGFydDIpIHsKICAgICAgaWYgKHZhbHVlLmNoYXJDb2RlQXQoMCkgPT09IGNvZGVzLmJ5dGVPcmRlck1hcmtlcikgewogICAgICAgIHN0YXJ0UG9zaXRpb24rKzsKICAgICAgfQogICAgICBzdGFydDIgPSB2b2lkIDA7CiAgICB9CiAgICB3aGlsZSAoc3RhcnRQb3NpdGlvbiA8IHZhbHVlLmxlbmd0aCkgewogICAgICBzZWFyY2gubGFzdEluZGV4ID0gc3RhcnRQb3NpdGlvbjsKICAgICAgbWF0Y2ggPSBzZWFyY2guZXhlYyh2YWx1ZSk7CiAgICAgIGVuZFBvc2l0aW9uID0gbWF0Y2ggJiYgbWF0Y2guaW5kZXggIT09IHZvaWQgMCA/IG1hdGNoLmluZGV4IDogdmFsdWUubGVuZ3RoOwogICAgICBjb2RlMiA9IHZhbHVlLmNoYXJDb2RlQXQoZW5kUG9zaXRpb24pOwogICAgICBpZiAoIW1hdGNoKSB7CiAgICAgICAgYnVmZmVyID0gdmFsdWUuc2xpY2Uoc3RhcnRQb3NpdGlvbik7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgaWYgKGNvZGUyID09PSBjb2Rlcy5sZiAmJiBzdGFydFBvc2l0aW9uID09PSBlbmRQb3NpdGlvbiAmJiBhdENhcnJpYWdlUmV0dXJuKSB7CiAgICAgICAgY2h1bmtzLnB1c2goY29kZXMuY2FycmlhZ2VSZXR1cm5MaW5lRmVlZCk7CiAgICAgICAgYXRDYXJyaWFnZVJldHVybiA9IHZvaWQgMDsKICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAoYXRDYXJyaWFnZVJldHVybikgewogICAgICAgICAgY2h1bmtzLnB1c2goY29kZXMuY2FycmlhZ2VSZXR1cm4pOwogICAgICAgICAgYXRDYXJyaWFnZVJldHVybiA9IHZvaWQgMDsKICAgICAgICB9CiAgICAgICAgaWYgKHN0YXJ0UG9zaXRpb24gPCBlbmRQb3NpdGlvbikgewogICAgICAgICAgY2h1bmtzLnB1c2godmFsdWUuc2xpY2Uoc3RhcnRQb3NpdGlvbiwgZW5kUG9zaXRpb24pKTsKICAgICAgICAgIGNvbHVtbiArPSBlbmRQb3NpdGlvbiAtIHN0YXJ0UG9zaXRpb247CiAgICAgICAgfQogICAgICAgIHN3aXRjaCAoY29kZTIpIHsKICAgICAgICAgIGNhc2UgY29kZXMubnVsOiB7CiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNvZGVzLnJlcGxhY2VtZW50Q2hhcmFjdGVyKTsKICAgICAgICAgICAgY29sdW1uKys7CiAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgfQogICAgICAgICAgY2FzZSBjb2Rlcy5odDogewogICAgICAgICAgICBuZXh0ID0gTWF0aC5jZWlsKGNvbHVtbiAvIGNvbnN0YW50cy50YWJTaXplKSAqIGNvbnN0YW50cy50YWJTaXplOwogICAgICAgICAgICBjaHVua3MucHVzaChjb2Rlcy5ob3Jpem9udGFsVGFiKTsKICAgICAgICAgICAgd2hpbGUgKGNvbHVtbisrIDwgbmV4dCkgY2h1bmtzLnB1c2goY29kZXMudmlydHVhbFNwYWNlKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBjYXNlIGNvZGVzLmxmOiB7CiAgICAgICAgICAgIGNodW5rcy5wdXNoKGNvZGVzLmxpbmVGZWVkKTsKICAgICAgICAgICAgY29sdW1uID0gMTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICAgIGF0Q2FycmlhZ2VSZXR1cm4gPSB0cnVlOwogICAgICAgICAgICBjb2x1bW4gPSAxOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICBzdGFydFBvc2l0aW9uID0gZW5kUG9zaXRpb24gKyAxOwogICAgfQogICAgaWYgKGVuZCkgewogICAgICBpZiAoYXRDYXJyaWFnZVJldHVybikgY2h1bmtzLnB1c2goY29kZXMuY2FycmlhZ2VSZXR1cm4pOwogICAgICBpZiAoYnVmZmVyKSBjaHVua3MucHVzaChidWZmZXIpOwogICAgICBjaHVua3MucHVzaChjb2Rlcy5lb2YpOwogICAgfQogICAgcmV0dXJuIGNodW5rczsKICB9Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLWZyb20tbWFya2Rvd24vZGV2L2xpYi9pbmRleC5qcwp2YXIgb3duMiA9IHt9Lmhhc093blByb3BlcnR5OwpmdW5jdGlvbiBmcm9tTWFya2Rvd24odmFsdWUsIGVuY29kaW5nLCBvcHRpb25zKSB7CiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gInN0cmluZyIpIHsKICAgIG9wdGlvbnMgPSBlbmNvZGluZzsKICAgIGVuY29kaW5nID0gdm9pZCAwOwogIH0KICByZXR1cm4gY29tcGlsZXIob3B0aW9ucykoCiAgICBwb3N0cHJvY2VzcygKICAgICAgcGFyc2Uob3B0aW9ucykuZG9jdW1lbnQoKS53cml0ZShwcmVwcm9jZXNzKCkodmFsdWUsIGVuY29kaW5nLCB0cnVlKSkKICAgICkKICApOwp9CmZ1bmN0aW9uIGNvbXBpbGVyKG9wdGlvbnMpIHsKICBjb25zdCBjb25maWcgPSB7CiAgICB0cmFuc2Zvcm1zOiBbXSwKICAgIGNhbkNvbnRhaW5Fb2xzOiBbImVtcGhhc2lzIiwgImZyYWdtZW50IiwgImhlYWRpbmciLCAicGFyYWdyYXBoIiwgInN0cm9uZyJdLAogICAgZW50ZXI6IHsKICAgICAgYXV0b2xpbms6IG9wZW5lcihsaW5rMiksCiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IG9uZW50ZXJkYXRhLAogICAgICBhdXRvbGlua0VtYWlsOiBvbmVudGVyZGF0YSwKICAgICAgYXR4SGVhZGluZzogb3BlbmVyKGhlYWRpbmcyKSwKICAgICAgYmxvY2tRdW90ZTogb3BlbmVyKGJsb2NrUXVvdGUyKSwKICAgICAgY2hhcmFjdGVyRXNjYXBlOiBvbmVudGVyZGF0YSwKICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlOiBvbmVudGVyZGF0YSwKICAgICAgY29kZUZlbmNlZDogb3BlbmVyKGNvZGVGbG93KSwKICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogYnVmZmVyLAogICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiBidWZmZXIsCiAgICAgIGNvZGVJbmRlbnRlZDogb3BlbmVyKGNvZGVGbG93LCBidWZmZXIpLAogICAgICBjb2RlVGV4dDogb3BlbmVyKGNvZGVUZXh0MiwgYnVmZmVyKSwKICAgICAgY29kZVRleHREYXRhOiBvbmVudGVyZGF0YSwKICAgICAgZGF0YTogb25lbnRlcmRhdGEsCiAgICAgIGNvZGVGbG93VmFsdWU6IG9uZW50ZXJkYXRhLAogICAgICBkZWZpbml0aW9uOiBvcGVuZXIoZGVmaW5pdGlvbjIpLAogICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IGJ1ZmZlciwKICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBidWZmZXIsCiAgICAgIGRlZmluaXRpb25UaXRsZVN0cmluZzogYnVmZmVyLAogICAgICBlbXBoYXNpczogb3BlbmVyKGVtcGhhc2lzMiksCiAgICAgIGhhcmRCcmVha0VzY2FwZTogb3BlbmVyKGhhcmRCcmVhazIpLAogICAgICBoYXJkQnJlYWtUcmFpbGluZzogb3BlbmVyKGhhcmRCcmVhazIpLAogICAgICBodG1sRmxvdzogb3BlbmVyKGh0bWwzLCBidWZmZXIpLAogICAgICBodG1sRmxvd0RhdGE6IG9uZW50ZXJkYXRhLAogICAgICBodG1sVGV4dDogb3BlbmVyKGh0bWwzLCBidWZmZXIpLAogICAgICBodG1sVGV4dERhdGE6IG9uZW50ZXJkYXRhLAogICAgICBpbWFnZTogb3BlbmVyKGltYWdlMiksCiAgICAgIGxhYmVsOiBidWZmZXIsCiAgICAgIGxpbms6IG9wZW5lcihsaW5rMiksCiAgICAgIGxpc3RJdGVtOiBvcGVuZXIobGlzdEl0ZW0yKSwKICAgICAgbGlzdEl0ZW1WYWx1ZTogb25lbnRlcmxpc3RpdGVtdmFsdWUsCiAgICAgIGxpc3RPcmRlcmVkOiBvcGVuZXIobGlzdDMsIG9uZW50ZXJsaXN0b3JkZXJlZCksCiAgICAgIGxpc3RVbm9yZGVyZWQ6IG9wZW5lcihsaXN0MyksCiAgICAgIHBhcmFncmFwaDogb3BlbmVyKHBhcmFncmFwaDIpLAogICAgICByZWZlcmVuY2U6IG9uZW50ZXJyZWZlcmVuY2UsCiAgICAgIHJlZmVyZW5jZVN0cmluZzogYnVmZmVyLAogICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBidWZmZXIsCiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IGJ1ZmZlciwKICAgICAgc2V0ZXh0SGVhZGluZzogb3BlbmVyKGhlYWRpbmcyKSwKICAgICAgc3Ryb25nOiBvcGVuZXIoc3Ryb25nMiksCiAgICAgIHRoZW1hdGljQnJlYWs6IG9wZW5lcih0aGVtYXRpY0JyZWFrMykKICAgIH0sCiAgICBleGl0OiB7CiAgICAgIGF0eEhlYWRpbmc6IGNsb3NlcigpLAogICAgICBhdHhIZWFkaW5nU2VxdWVuY2U6IG9uZXhpdGF0eGhlYWRpbmdzZXF1ZW5jZSwKICAgICAgYXV0b2xpbms6IGNsb3NlcigpLAogICAgICBhdXRvbGlua0VtYWlsOiBvbmV4aXRhdXRvbGlua2VtYWlsLAogICAgICBhdXRvbGlua1Byb3RvY29sOiBvbmV4aXRhdXRvbGlua3Byb3RvY29sLAogICAgICBibG9ja1F1b3RlOiBjbG9zZXIoKSwKICAgICAgY2hhcmFjdGVyRXNjYXBlVmFsdWU6IG9uZXhpdGRhdGEsCiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsOiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIsCiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWM6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZW1hcmtlciwKICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWU6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZXZhbHVlLAogICAgICBjaGFyYWN0ZXJSZWZlcmVuY2U6IG9uZXhpdGNoYXJhY3RlcnJlZmVyZW5jZSwKICAgICAgY29kZUZlbmNlZDogY2xvc2VyKG9uZXhpdGNvZGVmZW5jZWQpLAogICAgICBjb2RlRmVuY2VkRmVuY2U6IG9uZXhpdGNvZGVmZW5jZWRmZW5jZSwKICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbywKICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogb25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSwKICAgICAgY29kZUZsb3dWYWx1ZTogb25leGl0ZGF0YSwKICAgICAgY29kZUluZGVudGVkOiBjbG9zZXIob25leGl0Y29kZWluZGVudGVkKSwKICAgICAgY29kZVRleHQ6IGNsb3NlcihvbmV4aXRjb2RldGV4dCksCiAgICAgIGNvZGVUZXh0RGF0YTogb25leGl0ZGF0YSwKICAgICAgZGF0YTogb25leGl0ZGF0YSwKICAgICAgZGVmaW5pdGlvbjogY2xvc2VyKCksCiAgICAgIGRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZzogb25leGl0ZGVmaW5pdGlvbmRlc3RpbmF0aW9uc3RyaW5nLAogICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZywKICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBvbmV4aXRkZWZpbml0aW9udGl0bGVzdHJpbmcsCiAgICAgIGVtcGhhc2lzOiBjbG9zZXIoKSwKICAgICAgaGFyZEJyZWFrRXNjYXBlOiBjbG9zZXIob25leGl0aGFyZGJyZWFrKSwKICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IGNsb3NlcihvbmV4aXRoYXJkYnJlYWspLAogICAgICBodG1sRmxvdzogY2xvc2VyKG9uZXhpdGh0bWxmbG93KSwKICAgICAgaHRtbEZsb3dEYXRhOiBvbmV4aXRkYXRhLAogICAgICBodG1sVGV4dDogY2xvc2VyKG9uZXhpdGh0bWx0ZXh0KSwKICAgICAgaHRtbFRleHREYXRhOiBvbmV4aXRkYXRhLAogICAgICBpbWFnZTogY2xvc2VyKG9uZXhpdGltYWdlKSwKICAgICAgbGFiZWw6IG9uZXhpdGxhYmVsLAogICAgICBsYWJlbFRleHQ6IG9uZXhpdGxhYmVsdGV4dCwKICAgICAgbGluZUVuZGluZzogb25leGl0bGluZWVuZGluZywKICAgICAgbGluazogY2xvc2VyKG9uZXhpdGxpbmspLAogICAgICBsaXN0SXRlbTogY2xvc2VyKCksCiAgICAgIGxpc3RPcmRlcmVkOiBjbG9zZXIoKSwKICAgICAgbGlzdFVub3JkZXJlZDogY2xvc2VyKCksCiAgICAgIHBhcmFncmFwaDogY2xvc2VyKCksCiAgICAgIHJlZmVyZW5jZVN0cmluZzogb25leGl0cmVmZXJlbmNlc3RyaW5nLAogICAgICByZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nOiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nLAogICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nLAogICAgICByZXNvdXJjZTogb25leGl0cmVzb3VyY2UsCiAgICAgIHNldGV4dEhlYWRpbmc6IGNsb3NlcihvbmV4aXRzZXRleHRoZWFkaW5nKSwKICAgICAgc2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZTogb25leGl0c2V0ZXh0aGVhZGluZ2xpbmVzZXF1ZW5jZSwKICAgICAgc2V0ZXh0SGVhZGluZ1RleHQ6IG9uZXhpdHNldGV4dGhlYWRpbmd0ZXh0LAogICAgICBzdHJvbmc6IGNsb3NlcigpLAogICAgICB0aGVtYXRpY0JyZWFrOiBjbG9zZXIoKQogICAgfQogIH07CiAgY29uZmlndXJlKGNvbmZpZywgKG9wdGlvbnMgfHwge30pLm1kYXN0RXh0ZW5zaW9ucyB8fCBbXSk7CiAgY29uc3QgZGF0YSA9IHt9OwogIHJldHVybiBjb21waWxlMjsKICBmdW5jdGlvbiBjb21waWxlMihldmVudHMpIHsKICAgIGxldCB0cmVlID0geyB0eXBlOiAicm9vdCIsIGNoaWxkcmVuOiBbXSB9OwogICAgY29uc3QgY29udGV4dCA9IHsKICAgICAgc3RhY2s6IFt0cmVlXSwKICAgICAgdG9rZW5TdGFjazogW10sCiAgICAgIGNvbmZpZywKICAgICAgZW50ZXIsCiAgICAgIGV4aXQsCiAgICAgIGJ1ZmZlciwKICAgICAgcmVzdW1lLAogICAgICBkYXRhCiAgICB9OwogICAgY29uc3QgbGlzdFN0YWNrID0gW107CiAgICBsZXQgaW5kZXgyID0gLTE7CiAgICB3aGlsZSAoKytpbmRleDIgPCBldmVudHMubGVuZ3RoKSB7CiAgICAgIGlmIChldmVudHNbaW5kZXgyXVsxXS50eXBlID09PSB0eXBlcy5saXN0T3JkZXJlZCB8fCBldmVudHNbaW5kZXgyXVsxXS50eXBlID09PSB0eXBlcy5saXN0VW5vcmRlcmVkKSB7CiAgICAgICAgaWYgKGV2ZW50c1tpbmRleDJdWzBdID09PSAiZW50ZXIiKSB7CiAgICAgICAgICBsaXN0U3RhY2sucHVzaChpbmRleDIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBjb25zdCB0YWlsID0gbGlzdFN0YWNrLnBvcCgpOwogICAgICAgICAgb2sodHlwZW9mIHRhaWwgPT09ICJudW1iZXIiLCAiZXhwZWN0ZWQgbGlzdCBvdCBiZSBvcGVuIik7CiAgICAgICAgICBpbmRleDIgPSBwcmVwYXJlTGlzdChldmVudHMsIHRhaWwsIGluZGV4Mik7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBpbmRleDIgPSAtMTsKICAgIHdoaWxlICgrK2luZGV4MiA8IGV2ZW50cy5sZW5ndGgpIHsKICAgICAgY29uc3QgaGFuZGxlciA9IGNvbmZpZ1tldmVudHNbaW5kZXgyXVswXV07CiAgICAgIGlmIChvd24yLmNhbGwoaGFuZGxlciwgZXZlbnRzW2luZGV4Ml1bMV0udHlwZSkpIHsKICAgICAgICBoYW5kbGVyW2V2ZW50c1tpbmRleDJdWzFdLnR5cGVdLmNhbGwoCiAgICAgICAgICBPYmplY3QuYXNzaWduKAogICAgICAgICAgICB7IHNsaWNlU2VyaWFsaXplOiBldmVudHNbaW5kZXgyXVsyXS5zbGljZVNlcmlhbGl6ZSB9LAogICAgICAgICAgICBjb250ZXh0CiAgICAgICAgICApLAogICAgICAgICAgZXZlbnRzW2luZGV4Ml1bMV0KICAgICAgICApOwogICAgICB9CiAgICB9CiAgICBpZiAoY29udGV4dC50b2tlblN0YWNrLmxlbmd0aCA+IDApIHsKICAgICAgY29uc3QgdGFpbCA9IGNvbnRleHQudG9rZW5TdGFja1tjb250ZXh0LnRva2VuU3RhY2subGVuZ3RoIC0gMV07CiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0YWlsWzFdIHx8IGRlZmF1bHRPbkVycm9yOwogICAgICBoYW5kbGVyLmNhbGwoY29udGV4dCwgdm9pZCAwLCB0YWlsWzBdKTsKICAgIH0KICAgIHRyZWUucG9zaXRpb24gPSB7CiAgICAgIHN0YXJ0OiBwb2ludDIoCiAgICAgICAgZXZlbnRzLmxlbmd0aCA+IDAgPyBldmVudHNbMF1bMV0uc3RhcnQgOiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0KICAgICAgKSwKICAgICAgZW5kOiBwb2ludDIoCiAgICAgICAgZXZlbnRzLmxlbmd0aCA+IDAgPyBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDJdWzFdLmVuZCA6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfQogICAgICApCiAgICB9OwogICAgaW5kZXgyID0gLTE7CiAgICB3aGlsZSAoKytpbmRleDIgPCBjb25maWcudHJhbnNmb3Jtcy5sZW5ndGgpIHsKICAgICAgdHJlZSA9IGNvbmZpZy50cmFuc2Zvcm1zW2luZGV4Ml0odHJlZSkgfHwgdHJlZTsKICAgIH0KICAgIHJldHVybiB0cmVlOwogIH0KICBmdW5jdGlvbiBwcmVwYXJlTGlzdChldmVudHMsIHN0YXJ0MiwgbGVuZ3RoKSB7CiAgICBsZXQgaW5kZXgyID0gc3RhcnQyIC0gMTsKICAgIGxldCBjb250YWluZXJCYWxhbmNlID0gLTE7CiAgICBsZXQgbGlzdFNwcmVhZCA9IGZhbHNlOwogICAgbGV0IGxpc3RJdGVtMzsKICAgIGxldCBsaW5lSW5kZXg7CiAgICBsZXQgZmlyc3RCbGFua0xpbmVJbmRleDsKICAgIGxldCBhdE1hcmtlcjsKICAgIHdoaWxlICgrK2luZGV4MiA8PSBsZW5ndGgpIHsKICAgICAgY29uc3QgZXZlbnQgPSBldmVudHNbaW5kZXgyXTsKICAgICAgc3dpdGNoIChldmVudFsxXS50eXBlKSB7CiAgICAgICAgY2FzZSB0eXBlcy5saXN0VW5vcmRlcmVkOgogICAgICAgIGNhc2UgdHlwZXMubGlzdE9yZGVyZWQ6CiAgICAgICAgY2FzZSB0eXBlcy5ibG9ja1F1b3RlOiB7CiAgICAgICAgICBpZiAoZXZlbnRbMF0gPT09ICJlbnRlciIpIHsKICAgICAgICAgICAgY29udGFpbmVyQmFsYW5jZSsrOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29udGFpbmVyQmFsYW5jZS0tOwogICAgICAgICAgfQogICAgICAgICAgYXRNYXJrZXIgPSB2b2lkIDA7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgY2FzZSB0eXBlcy5saW5lRW5kaW5nQmxhbms6IHsKICAgICAgICAgIGlmIChldmVudFswXSA9PT0gImVudGVyIikgewogICAgICAgICAgICBpZiAobGlzdEl0ZW0zICYmICFhdE1hcmtlciAmJiAhY29udGFpbmVyQmFsYW5jZSAmJiAhZmlyc3RCbGFua0xpbmVJbmRleCkgewogICAgICAgICAgICAgIGZpcnN0QmxhbmtMaW5lSW5kZXggPSBpbmRleDI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYXRNYXJrZXIgPSB2b2lkIDA7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgY2FzZSB0eXBlcy5saW5lUHJlZml4OgogICAgICAgIGNhc2UgdHlwZXMubGlzdEl0ZW1WYWx1ZToKICAgICAgICBjYXNlIHR5cGVzLmxpc3RJdGVtTWFya2VyOgogICAgICAgIGNhc2UgdHlwZXMubGlzdEl0ZW1QcmVmaXg6CiAgICAgICAgY2FzZSB0eXBlcy5saXN0SXRlbVByZWZpeFdoaXRlc3BhY2U6IHsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgICBkZWZhdWx0OiB7CiAgICAgICAgICBhdE1hcmtlciA9IHZvaWQgMDsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKCFjb250YWluZXJCYWxhbmNlICYmIGV2ZW50WzBdID09PSAiZW50ZXIiICYmIGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtUHJlZml4IHx8IGNvbnRhaW5lckJhbGFuY2UgPT09IC0xICYmIGV2ZW50WzBdID09PSAiZXhpdCIgJiYgKGV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RVbm9yZGVyZWQgfHwgZXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGlzdE9yZGVyZWQpKSB7CiAgICAgICAgaWYgKGxpc3RJdGVtMykgewogICAgICAgICAgbGV0IHRhaWxJbmRleCA9IGluZGV4MjsKICAgICAgICAgIGxpbmVJbmRleCA9IHZvaWQgMDsKICAgICAgICAgIHdoaWxlICh0YWlsSW5kZXgtLSkgewogICAgICAgICAgICBjb25zdCB0YWlsRXZlbnQgPSBldmVudHNbdGFpbEluZGV4XTsKICAgICAgICAgICAgaWYgKHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nIHx8IHRhaWxFdmVudFsxXS50eXBlID09PSB0eXBlcy5saW5lRW5kaW5nQmxhbmspIHsKICAgICAgICAgICAgICBpZiAodGFpbEV2ZW50WzBdID09PSAiZXhpdCIpIGNvbnRpbnVlOwogICAgICAgICAgICAgIGlmIChsaW5lSW5kZXgpIHsKICAgICAgICAgICAgICAgIGV2ZW50c1tsaW5lSW5kZXhdWzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nQmxhbms7CiAgICAgICAgICAgICAgICBsaXN0U3ByZWFkID0gdHJ1ZTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdGFpbEV2ZW50WzFdLnR5cGUgPSB0eXBlcy5saW5lRW5kaW5nOwogICAgICAgICAgICAgIGxpbmVJbmRleCA9IHRhaWxJbmRleDsKICAgICAgICAgICAgfSBlbHNlIGlmICh0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMubGluZVByZWZpeCB8fCB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeCB8fCB0YWlsRXZlbnRbMV0udHlwZSA9PT0gdHlwZXMuYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2UgfHwgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmJsb2NrUXVvdGVNYXJrZXIgfHwgdGFpbEV2ZW50WzFdLnR5cGUgPT09IHR5cGVzLmxpc3RJdGVtSW5kZW50KSB7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChmaXJzdEJsYW5rTGluZUluZGV4ICYmICghbGluZUluZGV4IHx8IGZpcnN0QmxhbmtMaW5lSW5kZXggPCBsaW5lSW5kZXgpKSB7CiAgICAgICAgICAgIGxpc3RJdGVtMy5fc3ByZWFkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICAgIGxpc3RJdGVtMy5lbmQgPSBPYmplY3QuYXNzaWduKAogICAgICAgICAgICB7fSwKICAgICAgICAgICAgbGluZUluZGV4ID8gZXZlbnRzW2xpbmVJbmRleF1bMV0uc3RhcnQgOiBldmVudFsxXS5lbmQKICAgICAgICAgICk7CiAgICAgICAgICBldmVudHMuc3BsaWNlKGxpbmVJbmRleCB8fCBpbmRleDIsIDAsIFsiZXhpdCIsIGxpc3RJdGVtMywgZXZlbnRbMl1dKTsKICAgICAgICAgIGluZGV4MisrOwogICAgICAgICAgbGVuZ3RoKys7CiAgICAgICAgfQogICAgICAgIGlmIChldmVudFsxXS50eXBlID09PSB0eXBlcy5saXN0SXRlbVByZWZpeCkgewogICAgICAgICAgY29uc3QgaXRlbSA9IHsKICAgICAgICAgICAgdHlwZTogImxpc3RJdGVtIiwKICAgICAgICAgICAgX3NwcmVhZDogZmFsc2UsCiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBldmVudFsxXS5zdGFydCksCiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdl4oCZbGwgYWRkIGBlbmRgIGluIGEgc2Vjb25kLgogICAgICAgICAgICBlbmQ6IHZvaWQgMAogICAgICAgICAgfTsKICAgICAgICAgIGxpc3RJdGVtMyA9IGl0ZW07CiAgICAgICAgICBldmVudHMuc3BsaWNlKGluZGV4MiwgMCwgWyJlbnRlciIsIGl0ZW0sIGV2ZW50WzJdXSk7CiAgICAgICAgICBpbmRleDIrKzsKICAgICAgICAgIGxlbmd0aCsrOwogICAgICAgICAgZmlyc3RCbGFua0xpbmVJbmRleCA9IHZvaWQgMDsKICAgICAgICAgIGF0TWFya2VyID0gdHJ1ZTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGV2ZW50c1tzdGFydDJdWzFdLl9zcHJlYWQgPSBsaXN0U3ByZWFkOwogICAgcmV0dXJuIGxlbmd0aDsKICB9CiAgZnVuY3Rpb24gb3BlbmVyKGNyZWF0ZSwgYW5kKSB7CiAgICByZXR1cm4gb3BlbjsKICAgIGZ1bmN0aW9uIG9wZW4odG9rZW4pIHsKICAgICAgZW50ZXIuY2FsbCh0aGlzLCBjcmVhdGUodG9rZW4pLCB0b2tlbik7CiAgICAgIGlmIChhbmQpIGFuZC5jYWxsKHRoaXMsIHRva2VuKTsKICAgIH0KICB9CiAgZnVuY3Rpb24gYnVmZmVyKCkgewogICAgdGhpcy5zdGFjay5wdXNoKHsgdHlwZTogImZyYWdtZW50IiwgY2hpbGRyZW46IFtdIH0pOwogIH0KICBmdW5jdGlvbiBlbnRlcihub2RlLCB0b2tlbiwgZXJyb3JIYW5kbGVyKSB7CiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhwYXJlbnQsICJleHBlY3RlZCBgcGFyZW50YCIpOwogICAgb2soImNoaWxkcmVuIiBpbiBwYXJlbnQsICJleHBlY3RlZCBgcGFyZW50YCIpOwogICAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQuY2hpbGRyZW47CiAgICBzaWJsaW5ncy5wdXNoKG5vZGUpOwogICAgdGhpcy5zdGFjay5wdXNoKG5vZGUpOwogICAgdGhpcy50b2tlblN0YWNrLnB1c2goW3Rva2VuLCBlcnJvckhhbmRsZXIgfHwgdm9pZCAwXSk7CiAgICBub2RlLnBvc2l0aW9uID0gewogICAgICBzdGFydDogcG9pbnQyKHRva2VuLnN0YXJ0KSwKICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogYGVuZGAgd2lsbCBiZSBwYXRjaGVkIGxhdGVyLgogICAgICBlbmQ6IHZvaWQgMAogICAgfTsKICB9CiAgZnVuY3Rpb24gY2xvc2VyKGFuZCkgewogICAgcmV0dXJuIGNsb3NlOwogICAgZnVuY3Rpb24gY2xvc2UodG9rZW4pIHsKICAgICAgaWYgKGFuZCkgYW5kLmNhbGwodGhpcywgdG9rZW4pOwogICAgICBleGl0LmNhbGwodGhpcywgdG9rZW4pOwogICAgfQogIH0KICBmdW5jdGlvbiBleGl0KHRva2VuLCBvbkV4aXRFcnJvcikgewogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2sucG9wKCk7CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgYG5vZGVgIik7CiAgICBjb25zdCBvcGVuID0gdGhpcy50b2tlblN0YWNrLnBvcCgpOwogICAgaWYgKCFvcGVuKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgICAiQ2Fubm90IGNsb3NlIGAiICsgdG9rZW4udHlwZSArICJgICgiICsgc3RyaW5naWZ5UG9zaXRpb24oeyBzdGFydDogdG9rZW4uc3RhcnQsIGVuZDogdG9rZW4uZW5kIH0pICsgIik6IGl04oCZcyBub3Qgb3BlbiIKICAgICAgKTsKICAgIH0gZWxzZSBpZiAob3BlblswXS50eXBlICE9PSB0b2tlbi50eXBlKSB7CiAgICAgIGlmIChvbkV4aXRFcnJvcikgewogICAgICAgIG9uRXhpdEVycm9yLmNhbGwodGhpcywgdG9rZW4sIG9wZW5bMF0pOwogICAgICB9IGVsc2UgewogICAgICAgIGNvbnN0IGhhbmRsZXIgPSBvcGVuWzFdIHx8IGRlZmF1bHRPbkVycm9yOwogICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCB0b2tlbiwgb3BlblswXSk7CiAgICAgIH0KICAgIH0KICAgIG9rKG5vZGUudHlwZSAhPT0gImZyYWdtZW50IiwgInVuZXhwZWN0ZWQgZnJhZ21lbnQgYGV4aXRgZWQiKTsKICAgIG9rKG5vZGUucG9zaXRpb24sICJleHBlY3RlZCBgcG9zaXRpb25gIHRvIGJlIGRlZmluZWQiKTsKICAgIG5vZGUucG9zaXRpb24uZW5kID0gcG9pbnQyKHRva2VuLmVuZCk7CiAgfQogIGZ1bmN0aW9uIHJlc3VtZSgpIHsKICAgIHJldHVybiB0b1N0cmluZyh0aGlzLnN0YWNrLnBvcCgpKTsKICB9CiAgZnVuY3Rpb24gb25lbnRlcmxpc3RvcmRlcmVkKCkgewogICAgdGhpcy5kYXRhLmV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZSA9IHRydWU7CiAgfQogIGZ1bmN0aW9uIG9uZW50ZXJsaXN0aXRlbXZhbHVlKHRva2VuKSB7CiAgICBpZiAodGhpcy5kYXRhLmV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZSkgewogICAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTsKICAgICAgb2soYW5jZXN0b3IsICJleHBlY3RlZCBub2RlcyBvbiBzdGFjayIpOwogICAgICBvayhhbmNlc3Rvci50eXBlID09PSAibGlzdCIsICJleHBlY3RlZCBsaXN0IG9uIHN0YWNrIik7CiAgICAgIGFuY2VzdG9yLnN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KAogICAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pLAogICAgICAgIGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWwKICAgICAgKTsKICAgICAgdGhpcy5kYXRhLmV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZSA9IHZvaWQgMDsKICAgIH0KICB9CiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlaW5mbygpIHsKICAgIGNvbnN0IGRhdGEyID0gdGhpcy5yZXN1bWUoKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiY29kZSIsICJleHBlY3RlZCBjb2RlIG9uIHN0YWNrIik7CiAgICBub2RlLmxhbmcgPSBkYXRhMjsKICB9CiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlbWV0YSgpIHsKICAgIGNvbnN0IGRhdGEyID0gdGhpcy5yZXN1bWUoKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiY29kZSIsICJleHBlY3RlZCBjb2RlIG9uIHN0YWNrIik7CiAgICBub2RlLm1ldGEgPSBkYXRhMjsKICB9CiAgZnVuY3Rpb24gb25leGl0Y29kZWZlbmNlZGZlbmNlKCkgewogICAgaWYgKHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSkgcmV0dXJuOwogICAgdGhpcy5idWZmZXIoKTsKICAgIHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSA9IHRydWU7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGNvZGVmZW5jZWQoKSB7CiAgICBjb25zdCBkYXRhMiA9IHRoaXMucmVzdW1lKCk7CiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdOwogICAgb2sobm9kZSwgImV4cGVjdGVkIG5vZGUgb24gc3RhY2siKTsKICAgIG9rKG5vZGUudHlwZSA9PT0gImNvZGUiLCAiZXhwZWN0ZWQgY29kZSBvbiBzdGFjayIpOwogICAgbm9kZS52YWx1ZSA9IGRhdGEyLnJlcGxhY2UoL14oXHI/XG58XHIpfChccj9cbnxccikkL2csICIiKTsKICAgIHRoaXMuZGF0YS5mbG93Q29kZUluc2lkZSA9IHZvaWQgMDsKICB9CiAgZnVuY3Rpb24gb25leGl0Y29kZWluZGVudGVkKCkgewogICAgY29uc3QgZGF0YTIgPSB0aGlzLnJlc3VtZSgpOwogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhub2RlLnR5cGUgPT09ICJjb2RlIiwgImV4cGVjdGVkIGNvZGUgb24gc3RhY2siKTsKICAgIG5vZGUudmFsdWUgPSBkYXRhMi5yZXBsYWNlKC8oXHI/XG58XHIpJC9nLCAiIik7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25sYWJlbHN0cmluZyh0b2tlbikgewogICAgY29uc3QgbGFiZWwgPSB0aGlzLnJlc3VtZSgpOwogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhub2RlLnR5cGUgPT09ICJkZWZpbml0aW9uIiwgImV4cGVjdGVkIGRlZmluaXRpb24gb24gc3RhY2siKTsKICAgIG5vZGUubGFiZWwgPSBsYWJlbDsKICAgIG5vZGUuaWRlbnRpZmllciA9IG5vcm1hbGl6ZUlkZW50aWZpZXIoCiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pCiAgICApLnRvTG93ZXJDYXNlKCk7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb250aXRsZXN0cmluZygpIHsKICAgIGNvbnN0IGRhdGEyID0gdGhpcy5yZXN1bWUoKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiZGVmaW5pdGlvbiIsICJleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrIik7CiAgICBub2RlLnRpdGxlID0gZGF0YTI7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGRlZmluaXRpb25kZXN0aW5hdGlvbnN0cmluZygpIHsKICAgIGNvbnN0IGRhdGEyID0gdGhpcy5yZXN1bWUoKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiZGVmaW5pdGlvbiIsICJleHBlY3RlZCBkZWZpbml0aW9uIG9uIHN0YWNrIik7CiAgICBub2RlLnVybCA9IGRhdGEyOwogIH0KICBmdW5jdGlvbiBvbmV4aXRhdHhoZWFkaW5nc2VxdWVuY2UodG9rZW4pIHsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiaGVhZGluZyIsICJleHBlY3RlZCBoZWFkaW5nIG9uIHN0YWNrIik7CiAgICBpZiAoIW5vZGUuZGVwdGgpIHsKICAgICAgY29uc3QgZGVwdGggPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKS5sZW5ndGg7CiAgICAgIG9rKAogICAgICAgIGRlcHRoID09PSAxIHx8IGRlcHRoID09PSAyIHx8IGRlcHRoID09PSAzIHx8IGRlcHRoID09PSA0IHx8IGRlcHRoID09PSA1IHx8IGRlcHRoID09PSA2LAogICAgICAgICJleHBlY3RlZCBgZGVwdGhgIGJldHdlZW4gYDFgIGFuZCBgNmAiCiAgICAgICk7CiAgICAgIG5vZGUuZGVwdGggPSBkZXB0aDsKICAgIH0KICB9CiAgZnVuY3Rpb24gb25leGl0c2V0ZXh0aGVhZGluZ3RleHQoKSB7CiAgICB0aGlzLmRhdGEuc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZyA9IHRydWU7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmdsaW5lc2VxdWVuY2UodG9rZW4pIHsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiaGVhZGluZyIsICJleHBlY3RlZCBoZWFkaW5nIG9uIHN0YWNrIik7CiAgICBub2RlLmRlcHRoID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikuY29kZVBvaW50QXQoMCkgPT09IGNvZGVzLmVxdWFsc1RvID8gMSA6IDI7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdHNldGV4dGhlYWRpbmcoKSB7CiAgICB0aGlzLmRhdGEuc2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZyA9IHZvaWQgMDsKICB9CiAgZnVuY3Rpb24gb25lbnRlcmRhdGEodG9rZW4pIHsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2soImNoaWxkcmVuIiBpbiBub2RlLCAiZXhwZWN0ZWQgcGFyZW50IG9uIHN0YWNrIik7CiAgICBjb25zdCBzaWJsaW5ncyA9IG5vZGUuY2hpbGRyZW47CiAgICBsZXQgdGFpbCA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdOwogICAgaWYgKCF0YWlsIHx8IHRhaWwudHlwZSAhPT0gInRleHQiKSB7CiAgICAgIHRhaWwgPSB0ZXh0NSgpOwogICAgICB0YWlsLnBvc2l0aW9uID0gewogICAgICAgIHN0YXJ0OiBwb2ludDIodG9rZW4uc3RhcnQpLAogICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IHdl4oCZbGwgYWRkIGBlbmRgIGxhdGVyLgogICAgICAgIGVuZDogdm9pZCAwCiAgICAgIH07CiAgICAgIHNpYmxpbmdzLnB1c2godGFpbCk7CiAgICB9CiAgICB0aGlzLnN0YWNrLnB1c2godGFpbCk7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGRhdGEodG9rZW4pIHsKICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpOwogICAgb2sodGFpbCwgImV4cGVjdGVkIGEgYG5vZGVgIHRvIGJlIG9uIHRoZSBzdGFjayIpOwogICAgb2soInZhbHVlIiBpbiB0YWlsLCAiZXhwZWN0ZWQgYSBgbGl0ZXJhbGAgdG8gYmUgb24gdGhlIHN0YWNrIik7CiAgICBvayh0YWlsLnBvc2l0aW9uLCAiZXhwZWN0ZWQgYG5vZGVgIHRvIGhhdmUgYW4gb3BlbiBwb3NpdGlvbiIpOwogICAgdGFpbC52YWx1ZSArPSB0aGlzLnNsaWNlU2VyaWFsaXplKHRva2VuKTsKICAgIHRhaWwucG9zaXRpb24uZW5kID0gcG9pbnQyKHRva2VuLmVuZCk7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGxpbmVlbmRpbmcodG9rZW4pIHsKICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhjb250ZXh0LCAiZXhwZWN0ZWQgYG5vZGVgIik7CiAgICBpZiAodGhpcy5kYXRhLmF0SGFyZEJyZWFrKSB7CiAgICAgIG9rKCJjaGlsZHJlbiIgaW4gY29udGV4dCwgImV4cGVjdGVkIGBwYXJlbnRgIik7CiAgICAgIGNvbnN0IHRhaWwgPSBjb250ZXh0LmNoaWxkcmVuW2NvbnRleHQuY2hpbGRyZW4ubGVuZ3RoIC0gMV07CiAgICAgIG9rKHRhaWwucG9zaXRpb24sICJleHBlY3RlZCB0YWlsIHRvIGhhdmUgYSBzdGFydGluZyBwb3NpdGlvbiIpOwogICAgICB0YWlsLnBvc2l0aW9uLmVuZCA9IHBvaW50Mih0b2tlbi5lbmQpOwogICAgICB0aGlzLmRhdGEuYXRIYXJkQnJlYWsgPSB2b2lkIDA7CiAgICAgIHJldHVybjsKICAgIH0KICAgIGlmICghdGhpcy5kYXRhLnNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmcgJiYgY29uZmlnLmNhbkNvbnRhaW5Fb2xzLmluY2x1ZGVzKGNvbnRleHQudHlwZSkpIHsKICAgICAgb25lbnRlcmRhdGEuY2FsbCh0aGlzLCB0b2tlbik7CiAgICAgIG9uZXhpdGRhdGEuY2FsbCh0aGlzLCB0b2tlbik7CiAgICB9CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGhhcmRicmVhaygpIHsKICAgIHRoaXMuZGF0YS5hdEhhcmRCcmVhayA9IHRydWU7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGh0bWxmbG93KCkgewogICAgY29uc3QgZGF0YTIgPSB0aGlzLnJlc3VtZSgpOwogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhub2RlLnR5cGUgPT09ICJodG1sIiwgImV4cGVjdGVkIGh0bWwgb24gc3RhY2siKTsKICAgIG5vZGUudmFsdWUgPSBkYXRhMjsKICB9CiAgZnVuY3Rpb24gb25leGl0aHRtbHRleHQoKSB7CiAgICBjb25zdCBkYXRhMiA9IHRoaXMucmVzdW1lKCk7CiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdOwogICAgb2sobm9kZSwgImV4cGVjdGVkIG5vZGUgb24gc3RhY2siKTsKICAgIG9rKG5vZGUudHlwZSA9PT0gImh0bWwiLCAiZXhwZWN0ZWQgaHRtbCBvbiBzdGFjayIpOwogICAgbm9kZS52YWx1ZSA9IGRhdGEyOwogIH0KICBmdW5jdGlvbiBvbmV4aXRjb2RldGV4dCgpIHsKICAgIGNvbnN0IGRhdGEyID0gdGhpcy5yZXN1bWUoKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAiaW5saW5lQ29kZSIsICJleHBlY3RlZCBpbmxpbmUgY29kZSBvbiBzdGFjayIpOwogICAgbm9kZS52YWx1ZSA9IGRhdGEyOwogIH0KICBmdW5jdGlvbiBvbmV4aXRsaW5rKCkgewogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhub2RlLnR5cGUgPT09ICJsaW5rIiwgImV4cGVjdGVkIGxpbmsgb24gc3RhY2siKTsKICAgIGlmICh0aGlzLmRhdGEuaW5SZWZlcmVuY2UpIHsKICAgICAgY29uc3QgcmVmZXJlbmNlVHlwZSA9IHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlIHx8ICJzaG9ydGN1dCI7CiAgICAgIG5vZGUudHlwZSArPSAiUmVmZXJlbmNlIjsKICAgICAgbm9kZS5yZWZlcmVuY2VUeXBlID0gcmVmZXJlbmNlVHlwZTsKICAgICAgZGVsZXRlIG5vZGUudXJsOwogICAgICBkZWxldGUgbm9kZS50aXRsZTsKICAgIH0gZWxzZSB7CiAgICAgIGRlbGV0ZSBub2RlLmlkZW50aWZpZXI7CiAgICAgIGRlbGV0ZSBub2RlLmxhYmVsOwogICAgfQogICAgdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgPSB2b2lkIDA7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdGltYWdlKCkgewogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhub2RlLnR5cGUgPT09ICJpbWFnZSIsICJleHBlY3RlZCBpbWFnZSBvbiBzdGFjayIpOwogICAgaWYgKHRoaXMuZGF0YS5pblJlZmVyZW5jZSkgewogICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgfHwgInNob3J0Y3V0IjsKICAgICAgbm9kZS50eXBlICs9ICJSZWZlcmVuY2UiOwogICAgICBub2RlLnJlZmVyZW5jZVR5cGUgPSByZWZlcmVuY2VUeXBlOwogICAgICBkZWxldGUgbm9kZS51cmw7CiAgICAgIGRlbGV0ZSBub2RlLnRpdGxlOwogICAgfSBlbHNlIHsKICAgICAgZGVsZXRlIG5vZGUuaWRlbnRpZmllcjsKICAgICAgZGVsZXRlIG5vZGUubGFiZWw7CiAgICB9CiAgICB0aGlzLmRhdGEucmVmZXJlbmNlVHlwZSA9IHZvaWQgMDsKICB9CiAgZnVuY3Rpb24gb25leGl0bGFiZWx0ZXh0KHRva2VuKSB7CiAgICBjb25zdCBzdHJpbmczID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbik7CiAgICBjb25zdCBhbmNlc3RvciA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTsKICAgIG9rKGFuY2VzdG9yLCAiZXhwZWN0ZWQgYW5jZXN0b3Igb24gc3RhY2siKTsKICAgIG9rKAogICAgICBhbmNlc3Rvci50eXBlID09PSAiaW1hZ2UiIHx8IGFuY2VzdG9yLnR5cGUgPT09ICJsaW5rIiwKICAgICAgImV4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2siCiAgICApOwogICAgYW5jZXN0b3IubGFiZWwgPSBkZWNvZGVTdHJpbmcoc3RyaW5nMyk7CiAgICBhbmNlc3Rvci5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcihzdHJpbmczKS50b0xvd2VyQ2FzZSgpOwogIH0KICBmdW5jdGlvbiBvbmV4aXRsYWJlbCgpIHsKICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdOwogICAgb2soZnJhZ21lbnQsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhmcmFnbWVudC50eXBlID09PSAiZnJhZ21lbnQiLCAiZXhwZWN0ZWQgZnJhZ21lbnQgb24gc3RhY2siKTsKICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZXN1bWUoKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2soCiAgICAgIG5vZGUudHlwZSA9PT0gImltYWdlIiB8fCBub2RlLnR5cGUgPT09ICJsaW5rIiwKICAgICAgImV4cGVjdGVkIGltYWdlIG9yIGxpbmsgb24gc3RhY2siCiAgICApOwogICAgdGhpcy5kYXRhLmluUmVmZXJlbmNlID0gdHJ1ZTsKICAgIGlmIChub2RlLnR5cGUgPT09ICJsaW5rIikgewogICAgICBjb25zdCBjaGlsZHJlbiA9IGZyYWdtZW50LmNoaWxkcmVuOwogICAgICBub2RlLmNoaWxkcmVuID0gY2hpbGRyZW47CiAgICB9IGVsc2UgewogICAgICBub2RlLmFsdCA9IHZhbHVlOwogICAgfQogIH0KICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZWRlc3RpbmF0aW9uc3RyaW5nKCkgewogICAgY29uc3QgZGF0YTIgPSB0aGlzLnJlc3VtZSgpOwogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvaygKICAgICAgbm9kZS50eXBlID09PSAiaW1hZ2UiIHx8IG5vZGUudHlwZSA9PT0gImxpbmsiLAogICAgICAiZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjayIKICAgICk7CiAgICBub2RlLnVybCA9IGRhdGEyOwogIH0KICBmdW5jdGlvbiBvbmV4aXRyZXNvdXJjZXRpdGxlc3RyaW5nKCkgewogICAgY29uc3QgZGF0YTIgPSB0aGlzLnJlc3VtZSgpOwogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvaygKICAgICAgbm9kZS50eXBlID09PSAiaW1hZ2UiIHx8IG5vZGUudHlwZSA9PT0gImxpbmsiLAogICAgICAiZXhwZWN0ZWQgaW1hZ2Ugb3IgbGluayBvbiBzdGFjayIKICAgICk7CiAgICBub2RlLnRpdGxlID0gZGF0YTI7CiAgfQogIGZ1bmN0aW9uIG9uZXhpdHJlc291cmNlKCkgewogICAgdGhpcy5kYXRhLmluUmVmZXJlbmNlID0gdm9pZCAwOwogIH0KICBmdW5jdGlvbiBvbmVudGVycmVmZXJlbmNlKCkgewogICAgdGhpcy5kYXRhLnJlZmVyZW5jZVR5cGUgPSAiY29sbGFwc2VkIjsKICB9CiAgZnVuY3Rpb24gb25leGl0cmVmZXJlbmNlc3RyaW5nKHRva2VuKSB7CiAgICBjb25zdCBsYWJlbCA9IHRoaXMucmVzdW1lKCk7CiAgICBjb25zdCBub2RlID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdOwogICAgb2sobm9kZSwgImV4cGVjdGVkIG5vZGUgb24gc3RhY2siKTsKICAgIG9rKAogICAgICBub2RlLnR5cGUgPT09ICJpbWFnZSIgfHwgbm9kZS50eXBlID09PSAibGluayIsCiAgICAgICJleHBlY3RlZCBpbWFnZSByZWZlcmVuY2Ugb3IgbGluayByZWZlcmVuY2Ugb24gc3RhY2siCiAgICApOwogICAgbm9kZS5sYWJlbCA9IGxhYmVsOwogICAgbm9kZS5pZGVudGlmaWVyID0gbm9ybWFsaXplSWRlbnRpZmllcigKICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbikKICAgICkudG9Mb3dlckNhc2UoKTsKICAgIHRoaXMuZGF0YS5yZWZlcmVuY2VUeXBlID0gImZ1bGwiOwogIH0KICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2VtYXJrZXIodG9rZW4pIHsKICAgIG9rKAogICAgICB0b2tlbi50eXBlID09PSAiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYyIgfHwgdG9rZW4udHlwZSA9PT0gImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsIgogICAgKTsKICAgIHRoaXMuZGF0YS5jaGFyYWN0ZXJSZWZlcmVuY2VUeXBlID0gdG9rZW4udHlwZTsKICB9CiAgZnVuY3Rpb24gb25leGl0Y2hhcmFjdGVycmVmZXJlbmNldmFsdWUodG9rZW4pIHsKICAgIGNvbnN0IGRhdGEyID0gdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbik7CiAgICBjb25zdCB0eXBlID0gdGhpcy5kYXRhLmNoYXJhY3RlclJlZmVyZW5jZVR5cGU7CiAgICBsZXQgdmFsdWU7CiAgICBpZiAodHlwZSkgewogICAgICB2YWx1ZSA9IGRlY29kZU51bWVyaWNDaGFyYWN0ZXJSZWZlcmVuY2UoCiAgICAgICAgZGF0YTIsCiAgICAgICAgdHlwZSA9PT0gdHlwZXMuY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpYyA/IGNvbnN0YW50cy5udW1lcmljQmFzZURlY2ltYWwgOiBjb25zdGFudHMubnVtZXJpY0Jhc2VIZXhhZGVjaW1hbAogICAgICApOwogICAgICB0aGlzLmRhdGEuY2hhcmFjdGVyUmVmZXJlbmNlVHlwZSA9IHZvaWQgMDsKICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZU5hbWVkQ2hhcmFjdGVyUmVmZXJlbmNlKGRhdGEyKTsKICAgICAgb2socmVzdWx0ICE9PSBmYWxzZSwgImV4cGVjdGVkIHJlZmVyZW5jZSB0byBkZWNvZGUiKTsKICAgICAgdmFsdWUgPSByZXN1bHQ7CiAgICB9CiAgICBjb25zdCB0YWlsID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdOwogICAgb2sodGFpbCwgImV4cGVjdGVkIGBub2RlYCIpOwogICAgb2soInZhbHVlIiBpbiB0YWlsLCAiZXhwZWN0ZWQgYG5vZGUudmFsdWVgIik7CiAgICB0YWlsLnZhbHVlICs9IHZhbHVlOwogIH0KICBmdW5jdGlvbiBvbmV4aXRjaGFyYWN0ZXJyZWZlcmVuY2UodG9rZW4pIHsKICAgIGNvbnN0IHRhaWwgPSB0aGlzLnN0YWNrLnBvcCgpOwogICAgb2sodGFpbCwgImV4cGVjdGVkIGBub2RlYCIpOwogICAgb2sodGFpbC5wb3NpdGlvbiwgImV4cGVjdGVkIGBub2RlLnBvc2l0aW9uYCIpOwogICAgdGFpbC5wb3NpdGlvbi5lbmQgPSBwb2ludDIodG9rZW4uZW5kKTsKICB9CiAgZnVuY3Rpb24gb25leGl0YXV0b2xpbmtwcm90b2NvbCh0b2tlbikgewogICAgb25leGl0ZGF0YS5jYWxsKHRoaXMsIHRva2VuKTsKICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgICBvayhub2RlLCAiZXhwZWN0ZWQgbm9kZSBvbiBzdGFjayIpOwogICAgb2sobm9kZS50eXBlID09PSAibGluayIsICJleHBlY3RlZCBsaW5rIG9uIHN0YWNrIik7CiAgICBub2RlLnVybCA9IHRoaXMuc2xpY2VTZXJpYWxpemUodG9rZW4pOwogIH0KICBmdW5jdGlvbiBvbmV4aXRhdXRvbGlua2VtYWlsKHRva2VuKSB7CiAgICBvbmV4aXRkYXRhLmNhbGwodGhpcywgdG9rZW4pOwogICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTsKICAgIG9rKG5vZGUsICJleHBlY3RlZCBub2RlIG9uIHN0YWNrIik7CiAgICBvayhub2RlLnR5cGUgPT09ICJsaW5rIiwgImV4cGVjdGVkIGxpbmsgb24gc3RhY2siKTsKICAgIG5vZGUudXJsID0gIm1haWx0bzoiICsgdGhpcy5zbGljZVNlcmlhbGl6ZSh0b2tlbik7CiAgfQogIGZ1bmN0aW9uIGJsb2NrUXVvdGUyKCkgewogICAgcmV0dXJuIHsgdHlwZTogImJsb2NrcXVvdGUiLCBjaGlsZHJlbjogW10gfTsKICB9CiAgZnVuY3Rpb24gY29kZUZsb3coKSB7CiAgICByZXR1cm4geyB0eXBlOiAiY29kZSIsIGxhbmc6IG51bGwsIG1ldGE6IG51bGwsIHZhbHVlOiAiIiB9OwogIH0KICBmdW5jdGlvbiBjb2RlVGV4dDIoKSB7CiAgICByZXR1cm4geyB0eXBlOiAiaW5saW5lQ29kZSIsIHZhbHVlOiAiIiB9OwogIH0KICBmdW5jdGlvbiBkZWZpbml0aW9uMigpIHsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJkZWZpbml0aW9uIiwKICAgICAgaWRlbnRpZmllcjogIiIsCiAgICAgIGxhYmVsOiBudWxsLAogICAgICB0aXRsZTogbnVsbCwKICAgICAgdXJsOiAiIgogICAgfTsKICB9CiAgZnVuY3Rpb24gZW1waGFzaXMyKCkgewogICAgcmV0dXJuIHsgdHlwZTogImVtcGhhc2lzIiwgY2hpbGRyZW46IFtdIH07CiAgfQogIGZ1bmN0aW9uIGhlYWRpbmcyKCkgewogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImhlYWRpbmciLAogICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGBkZXB0aGAgd2lsbCBiZSBzZXQgbGF0ZXIuCiAgICAgIGRlcHRoOiAwLAogICAgICBjaGlsZHJlbjogW10KICAgIH07CiAgfQogIGZ1bmN0aW9uIGhhcmRCcmVhazIoKSB7CiAgICByZXR1cm4geyB0eXBlOiAiYnJlYWsiIH07CiAgfQogIGZ1bmN0aW9uIGh0bWwzKCkgewogICAgcmV0dXJuIHsgdHlwZTogImh0bWwiLCB2YWx1ZTogIiIgfTsKICB9CiAgZnVuY3Rpb24gaW1hZ2UyKCkgewogICAgcmV0dXJuIHsgdHlwZTogImltYWdlIiwgdGl0bGU6IG51bGwsIHVybDogIiIsIGFsdDogbnVsbCB9OwogIH0KICBmdW5jdGlvbiBsaW5rMigpIHsKICAgIHJldHVybiB7IHR5cGU6ICJsaW5rIiwgdGl0bGU6IG51bGwsIHVybDogIiIsIGNoaWxkcmVuOiBbXSB9OwogIH0KICBmdW5jdGlvbiBsaXN0Myh0b2tlbikgewogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImxpc3QiLAogICAgICBvcmRlcmVkOiB0b2tlbi50eXBlID09PSAibGlzdE9yZGVyZWQiLAogICAgICBzdGFydDogbnVsbCwKICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLAogICAgICBjaGlsZHJlbjogW10KICAgIH07CiAgfQogIGZ1bmN0aW9uIGxpc3RJdGVtMih0b2tlbikgewogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImxpc3RJdGVtIiwKICAgICAgc3ByZWFkOiB0b2tlbi5fc3ByZWFkLAogICAgICBjaGVja2VkOiBudWxsLAogICAgICBjaGlsZHJlbjogW10KICAgIH07CiAgfQogIGZ1bmN0aW9uIHBhcmFncmFwaDIoKSB7CiAgICByZXR1cm4geyB0eXBlOiAicGFyYWdyYXBoIiwgY2hpbGRyZW46IFtdIH07CiAgfQogIGZ1bmN0aW9uIHN0cm9uZzIoKSB7CiAgICByZXR1cm4geyB0eXBlOiAic3Ryb25nIiwgY2hpbGRyZW46IFtdIH07CiAgfQogIGZ1bmN0aW9uIHRleHQ1KCkgewogICAgcmV0dXJuIHsgdHlwZTogInRleHQiLCB2YWx1ZTogIiIgfTsKICB9CiAgZnVuY3Rpb24gdGhlbWF0aWNCcmVhazMoKSB7CiAgICByZXR1cm4geyB0eXBlOiAidGhlbWF0aWNCcmVhayIgfTsKICB9Cn0KZnVuY3Rpb24gcG9pbnQyKGQpIHsKICByZXR1cm4geyBsaW5lOiBkLmxpbmUsIGNvbHVtbjogZC5jb2x1bW4sIG9mZnNldDogZC5vZmZzZXQgfTsKfQpmdW5jdGlvbiBjb25maWd1cmUoY29tYmluZWQsIGV4dGVuc2lvbnMpIHsKICBsZXQgaW5kZXgyID0gLTE7CiAgd2hpbGUgKCsraW5kZXgyIDwgZXh0ZW5zaW9ucy5sZW5ndGgpIHsKICAgIGNvbnN0IHZhbHVlID0gZXh0ZW5zaW9uc1tpbmRleDJdOwogICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgIGNvbmZpZ3VyZShjb21iaW5lZCwgdmFsdWUpOwogICAgfSBlbHNlIHsKICAgICAgZXh0ZW5zaW9uKGNvbWJpbmVkLCB2YWx1ZSk7CiAgICB9CiAgfQp9CmZ1bmN0aW9uIGV4dGVuc2lvbihjb21iaW5lZCwgZXh0ZW5zaW9uMikgewogIGxldCBrZXk7CiAgZm9yIChrZXkgaW4gZXh0ZW5zaW9uMikgewogICAgaWYgKG93bjIuY2FsbChleHRlbnNpb24yLCBrZXkpKSB7CiAgICAgIHN3aXRjaCAoa2V5KSB7CiAgICAgICAgY2FzZSAiY2FuQ29udGFpbkVvbHMiOiB7CiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbjJba2V5XTsKICAgICAgICAgIGlmIChyaWdodCkgewogICAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGNhc2UgInRyYW5zZm9ybXMiOiB7CiAgICAgICAgICBjb25zdCByaWdodCA9IGV4dGVuc2lvbjJba2V5XTsKICAgICAgICAgIGlmIChyaWdodCkgewogICAgICAgICAgICBjb21iaW5lZFtrZXldLnB1c2goLi4ucmlnaHQpOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGNhc2UgImVudGVyIjoKICAgICAgICBjYXNlICJleGl0IjogewogICAgICAgICAgY29uc3QgcmlnaHQgPSBleHRlbnNpb24yW2tleV07CiAgICAgICAgICBpZiAocmlnaHQpIHsKICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihjb21iaW5lZFtrZXldLCByaWdodCk7CiAgICAgICAgICB9CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9Cn0KZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IobGVmdCwgcmlnaHQpIHsKICBpZiAobGVmdCkgewogICAgdGhyb3cgbmV3IEVycm9yKAogICAgICAiQ2Fubm90IGNsb3NlIGAiICsgbGVmdC50eXBlICsgImAgKCIgKyBzdHJpbmdpZnlQb3NpdGlvbih7IHN0YXJ0OiBsZWZ0LnN0YXJ0LCBlbmQ6IGxlZnQuZW5kIH0pICsgIik6IGEgZGlmZmVyZW50IHRva2VuIChgIiArIHJpZ2h0LnR5cGUgKyAiYCwgIiArIHN0cmluZ2lmeVBvc2l0aW9uKHsgc3RhcnQ6IHJpZ2h0LnN0YXJ0LCBlbmQ6IHJpZ2h0LmVuZCB9KSArICIpIGlzIG9wZW4iCiAgICApOwogIH0gZWxzZSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICJDYW5ub3QgY2xvc2UgZG9jdW1lbnQsIGEgdG9rZW4gKGAiICsgcmlnaHQudHlwZSArICJgLCAiICsgc3RyaW5naWZ5UG9zaXRpb24oeyBzdGFydDogcmlnaHQuc3RhcnQsIGVuZDogcmlnaHQuZW5kIH0pICsgIikgaXMgc3RpbGwgb3BlbiIKICAgICk7CiAgfQp9CgovLyBub2RlX21vZHVsZXMvcmVtYXJrLXBhcnNlL2xpYi9pbmRleC5qcwpmdW5jdGlvbiByZW1hcmtQYXJzZShvcHRpb25zKSB7CiAgY29uc3Qgc2VsZiA9IHRoaXM7CiAgc2VsZi5wYXJzZXIgPSBwYXJzZXI7CiAgZnVuY3Rpb24gcGFyc2VyKGRvYykgewogICAgcmV0dXJuIGZyb21NYXJrZG93bihkb2MsIHsKICAgICAgLi4uc2VsZi5kYXRhKCJzZXR0aW5ncyIpLAogICAgICAuLi5vcHRpb25zLAogICAgICAvLyBOb3RlOiB0aGVzZSBvcHRpb25zIGFyZSBub3QgaW4gdGhlIHJlYWRtZS4KICAgICAgLy8gVGhlIGdvYWwgaXMgZm9yIHRoZW0gdG8gYmUgc2V0IGJ5IHBsdWdpbnMgb24gYGRhdGFgIGluc3RlYWQgb2YgYmVpbmcKICAgICAgLy8gcGFzc2VkIGJ5IHVzZXJzLgogICAgICBleHRlbnNpb25zOiBzZWxmLmRhdGEoIm1pY3JvbWFya0V4dGVuc2lvbnMiKSB8fCBbXSwKICAgICAgbWRhc3RFeHRlbnNpb25zOiBzZWxmLmRhdGEoImZyb21NYXJrZG93bkV4dGVuc2lvbnMiKSB8fCBbXQogICAgfSk7CiAgfQp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9ibG9ja3F1b3RlLmpzCmZ1bmN0aW9uIGJsb2NrcXVvdGUoc3RhdGUsIG5vZGUpIHsKICBjb25zdCByZXN1bHQgPSB7CiAgICB0eXBlOiAiZWxlbWVudCIsCiAgICB0YWdOYW1lOiAiYmxvY2txdW90ZSIsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS53cmFwKHN0YXRlLmFsbChub2RlKSwgdHJ1ZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9icmVhay5qcwpmdW5jdGlvbiBoYXJkQnJlYWsoc3RhdGUsIG5vZGUpIHsKICBjb25zdCByZXN1bHQgPSB7IHR5cGU6ICJlbGVtZW50IiwgdGFnTmFtZTogImJyIiwgcHJvcGVydGllczoge30sIGNoaWxkcmVuOiBbXSB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIFtzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KSwgeyB0eXBlOiAidGV4dCIsIHZhbHVlOiAiXG4iIH1dOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9jb2RlLmpzCmZ1bmN0aW9uIGNvZGUoc3RhdGUsIG5vZGUpIHsKICBjb25zdCB2YWx1ZSA9IG5vZGUudmFsdWUgPyBub2RlLnZhbHVlICsgIlxuIiA6ICIiOwogIGNvbnN0IHByb3BlcnRpZXMgPSB7fTsKICBpZiAobm9kZS5sYW5nKSB7CiAgICBwcm9wZXJ0aWVzLmNsYXNzTmFtZSA9IFsibGFuZ3VhZ2UtIiArIG5vZGUubGFuZ107CiAgfQogIGxldCByZXN1bHQgPSB7CiAgICB0eXBlOiAiZWxlbWVudCIsCiAgICB0YWdOYW1lOiAiY29kZSIsCiAgICBwcm9wZXJ0aWVzLAogICAgY2hpbGRyZW46IFt7IHR5cGU6ICJ0ZXh0IiwgdmFsdWUgfV0KICB9OwogIGlmIChub2RlLm1ldGEpIHsKICAgIHJlc3VsdC5kYXRhID0geyBtZXRhOiBub2RlLm1ldGEgfTsKICB9CiAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICByZXN1bHQgPSBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKICByZXN1bHQgPSB7IHR5cGU6ICJlbGVtZW50IiwgdGFnTmFtZTogInByZSIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW3Jlc3VsdF0gfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiByZXN1bHQ7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL2RlbGV0ZS5qcwpmdW5jdGlvbiBzdHJpa2V0aHJvdWdoKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcmVzdWx0ID0gewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogImRlbCIsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS5hbGwobm9kZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9lbXBoYXNpcy5qcwpmdW5jdGlvbiBlbXBoYXNpcyhzdGF0ZSwgbm9kZSkgewogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJlbSIsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS5hbGwobm9kZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9mb290bm90ZS1yZWZlcmVuY2UuanMKZnVuY3Rpb24gZm9vdG5vdGVSZWZlcmVuY2Uoc3RhdGUsIG5vZGUpIHsKICBjb25zdCBjbG9iYmVyUHJlZml4ID0gdHlwZW9mIHN0YXRlLm9wdGlvbnMuY2xvYmJlclByZWZpeCA9PT0gInN0cmluZyIgPyBzdGF0ZS5vcHRpb25zLmNsb2JiZXJQcmVmaXggOiAidXNlci1jb250ZW50LSI7CiAgY29uc3QgaWQgPSBTdHJpbmcobm9kZS5pZGVudGlmaWVyKS50b1VwcGVyQ2FzZSgpOwogIGNvbnN0IHNhZmVJZCA9IG5vcm1hbGl6ZVVyaShpZC50b0xvd2VyQ2FzZSgpKTsKICBjb25zdCBpbmRleDIgPSBzdGF0ZS5mb290bm90ZU9yZGVyLmluZGV4T2YoaWQpOwogIGxldCBjb3VudGVyOwogIGxldCByZXVzZUNvdW50ZXIgPSBzdGF0ZS5mb290bm90ZUNvdW50cy5nZXQoaWQpOwogIGlmIChyZXVzZUNvdW50ZXIgPT09IHZvaWQgMCkgewogICAgcmV1c2VDb3VudGVyID0gMDsKICAgIHN0YXRlLmZvb3Rub3RlT3JkZXIucHVzaChpZCk7CiAgICBjb3VudGVyID0gc3RhdGUuZm9vdG5vdGVPcmRlci5sZW5ndGg7CiAgfSBlbHNlIHsKICAgIGNvdW50ZXIgPSBpbmRleDIgKyAxOwogIH0KICByZXVzZUNvdW50ZXIgKz0gMTsKICBzdGF0ZS5mb290bm90ZUNvdW50cy5zZXQoaWQsIHJldXNlQ291bnRlcik7CiAgY29uc3QgbGluazIgPSB7CiAgICB0eXBlOiAiZWxlbWVudCIsCiAgICB0YWdOYW1lOiAiYSIsCiAgICBwcm9wZXJ0aWVzOiB7CiAgICAgIGhyZWY6ICIjIiArIGNsb2JiZXJQcmVmaXggKyAiZm4tIiArIHNhZmVJZCwKICAgICAgaWQ6IGNsb2JiZXJQcmVmaXggKyAiZm5yZWYtIiArIHNhZmVJZCArIChyZXVzZUNvdW50ZXIgPiAxID8gIi0iICsgcmV1c2VDb3VudGVyIDogIiIpLAogICAgICBkYXRhRm9vdG5vdGVSZWY6IHRydWUsCiAgICAgIGFyaWFEZXNjcmliZWRCeTogWyJmb290bm90ZS1sYWJlbCJdCiAgICB9LAogICAgY2hpbGRyZW46IFt7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6IFN0cmluZyhjb3VudGVyKSB9XQogIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgbGluazIpOwogIGNvbnN0IHN1cCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJzdXAiLAogICAgcHJvcGVydGllczoge30sCiAgICBjaGlsZHJlbjogW2xpbmsyXQogIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgc3VwKTsKICByZXR1cm4gc3RhdGUuYXBwbHlEYXRhKG5vZGUsIHN1cCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL2hlYWRpbmcuanMKZnVuY3Rpb24gaGVhZGluZyhzdGF0ZSwgbm9kZSkgewogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJoIiArIG5vZGUuZGVwdGgsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS5hbGwobm9kZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9odG1sLmpzCmZ1bmN0aW9uIGh0bWwyKHN0YXRlLCBub2RlKSB7CiAgaWYgKHN0YXRlLm9wdGlvbnMuYWxsb3dEYW5nZXJvdXNIdG1sKSB7CiAgICBjb25zdCByZXN1bHQgPSB7IHR5cGU6ICJyYXciLCB2YWx1ZTogbm9kZS52YWx1ZSB9OwogICAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICAgIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKICB9CiAgcmV0dXJuIHZvaWQgMDsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvcmV2ZXJ0LmpzCmZ1bmN0aW9uIHJldmVydChzdGF0ZSwgbm9kZSkgewogIGNvbnN0IHN1YnR5cGUgPSBub2RlLnJlZmVyZW5jZVR5cGU7CiAgbGV0IHN1ZmZpeCA9ICJdIjsKICBpZiAoc3VidHlwZSA9PT0gImNvbGxhcHNlZCIpIHsKICAgIHN1ZmZpeCArPSAiW10iOwogIH0gZWxzZSBpZiAoc3VidHlwZSA9PT0gImZ1bGwiKSB7CiAgICBzdWZmaXggKz0gIlsiICsgKG5vZGUubGFiZWwgfHwgbm9kZS5pZGVudGlmaWVyKSArICJdIjsKICB9CiAgaWYgKG5vZGUudHlwZSA9PT0gImltYWdlUmVmZXJlbmNlIikgewogICAgcmV0dXJuIFt7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6ICIhWyIgKyBub2RlLmFsdCArIHN1ZmZpeCB9XTsKICB9CiAgY29uc3QgY29udGVudHMgPSBzdGF0ZS5hbGwobm9kZSk7CiAgY29uc3QgaGVhZCA9IGNvbnRlbnRzWzBdOwogIGlmIChoZWFkICYmIGhlYWQudHlwZSA9PT0gInRleHQiKSB7CiAgICBoZWFkLnZhbHVlID0gIlsiICsgaGVhZC52YWx1ZTsKICB9IGVsc2UgewogICAgY29udGVudHMudW5zaGlmdCh7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6ICJbIiB9KTsKICB9CiAgY29uc3QgdGFpbCA9IGNvbnRlbnRzW2NvbnRlbnRzLmxlbmd0aCAtIDFdOwogIGlmICh0YWlsICYmIHRhaWwudHlwZSA9PT0gInRleHQiKSB7CiAgICB0YWlsLnZhbHVlICs9IHN1ZmZpeDsKICB9IGVsc2UgewogICAgY29udGVudHMucHVzaCh7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6IHN1ZmZpeCB9KTsKICB9CiAgcmV0dXJuIGNvbnRlbnRzOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9pbWFnZS1yZWZlcmVuY2UuanMKZnVuY3Rpb24gaW1hZ2VSZWZlcmVuY2Uoc3RhdGUsIG5vZGUpIHsKICBjb25zdCBpZCA9IFN0cmluZyhub2RlLmlkZW50aWZpZXIpLnRvVXBwZXJDYXNlKCk7CiAgY29uc3QgZGVmaW5pdGlvbjIgPSBzdGF0ZS5kZWZpbml0aW9uQnlJZC5nZXQoaWQpOwogIGlmICghZGVmaW5pdGlvbjIpIHsKICAgIHJldHVybiByZXZlcnQoc3RhdGUsIG5vZGUpOwogIH0KICBjb25zdCBwcm9wZXJ0aWVzID0geyBzcmM6IG5vcm1hbGl6ZVVyaShkZWZpbml0aW9uMi51cmwgfHwgIiIpLCBhbHQ6IG5vZGUuYWx0IH07CiAgaWYgKGRlZmluaXRpb24yLnRpdGxlICE9PSBudWxsICYmIGRlZmluaXRpb24yLnRpdGxlICE9PSB2b2lkIDApIHsKICAgIHByb3BlcnRpZXMudGl0bGUgPSBkZWZpbml0aW9uMi50aXRsZTsKICB9CiAgY29uc3QgcmVzdWx0ID0geyB0eXBlOiAiZWxlbWVudCIsIHRhZ05hbWU6ICJpbWciLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbjogW10gfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvaGFuZGxlcnMvaW1hZ2UuanMKZnVuY3Rpb24gaW1hZ2Uoc3RhdGUsIG5vZGUpIHsKICBjb25zdCBwcm9wZXJ0aWVzID0geyBzcmM6IG5vcm1hbGl6ZVVyaShub2RlLnVybCkgfTsKICBpZiAobm9kZS5hbHQgIT09IG51bGwgJiYgbm9kZS5hbHQgIT09IHZvaWQgMCkgewogICAgcHJvcGVydGllcy5hbHQgPSBub2RlLmFsdDsKICB9CiAgaWYgKG5vZGUudGl0bGUgIT09IG51bGwgJiYgbm9kZS50aXRsZSAhPT0gdm9pZCAwKSB7CiAgICBwcm9wZXJ0aWVzLnRpdGxlID0gbm9kZS50aXRsZTsKICB9CiAgY29uc3QgcmVzdWx0ID0geyB0eXBlOiAiZWxlbWVudCIsIHRhZ05hbWU6ICJpbWciLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbjogW10gfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvaGFuZGxlcnMvaW5saW5lLWNvZGUuanMKZnVuY3Rpb24gaW5saW5lQ29kZShzdGF0ZSwgbm9kZSkgewogIGNvbnN0IHRleHQ1ID0geyB0eXBlOiAidGV4dCIsIHZhbHVlOiBub2RlLnZhbHVlLnJlcGxhY2UoL1xyP1xufFxyL2csICIgIikgfTsKICBzdGF0ZS5wYXRjaChub2RlLCB0ZXh0NSk7CiAgY29uc3QgcmVzdWx0ID0gewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogImNvZGUiLAogICAgcHJvcGVydGllczoge30sCiAgICBjaGlsZHJlbjogW3RleHQ1XQogIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICByZXR1cm4gc3RhdGUuYXBwbHlEYXRhKG5vZGUsIHJlc3VsdCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL2xpbmstcmVmZXJlbmNlLmpzCmZ1bmN0aW9uIGxpbmtSZWZlcmVuY2Uoc3RhdGUsIG5vZGUpIHsKICBjb25zdCBpZCA9IFN0cmluZyhub2RlLmlkZW50aWZpZXIpLnRvVXBwZXJDYXNlKCk7CiAgY29uc3QgZGVmaW5pdGlvbjIgPSBzdGF0ZS5kZWZpbml0aW9uQnlJZC5nZXQoaWQpOwogIGlmICghZGVmaW5pdGlvbjIpIHsKICAgIHJldHVybiByZXZlcnQoc3RhdGUsIG5vZGUpOwogIH0KICBjb25zdCBwcm9wZXJ0aWVzID0geyBocmVmOiBub3JtYWxpemVVcmkoZGVmaW5pdGlvbjIudXJsIHx8ICIiKSB9OwogIGlmIChkZWZpbml0aW9uMi50aXRsZSAhPT0gbnVsbCAmJiBkZWZpbml0aW9uMi50aXRsZSAhPT0gdm9pZCAwKSB7CiAgICBwcm9wZXJ0aWVzLnRpdGxlID0gZGVmaW5pdGlvbjIudGl0bGU7CiAgfQogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJhIiwKICAgIHByb3BlcnRpZXMsCiAgICBjaGlsZHJlbjogc3RhdGUuYWxsKG5vZGUpCiAgfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvaGFuZGxlcnMvbGluay5qcwpmdW5jdGlvbiBsaW5rKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcHJvcGVydGllcyA9IHsgaHJlZjogbm9ybWFsaXplVXJpKG5vZGUudXJsKSB9OwogIGlmIChub2RlLnRpdGxlICE9PSBudWxsICYmIG5vZGUudGl0bGUgIT09IHZvaWQgMCkgewogICAgcHJvcGVydGllcy50aXRsZSA9IG5vZGUudGl0bGU7CiAgfQogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJhIiwKICAgIHByb3BlcnRpZXMsCiAgICBjaGlsZHJlbjogc3RhdGUuYWxsKG5vZGUpCiAgfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvaGFuZGxlcnMvbGlzdC1pdGVtLmpzCmZ1bmN0aW9uIGxpc3RJdGVtKHN0YXRlLCBub2RlLCBwYXJlbnQpIHsKICBjb25zdCByZXN1bHRzID0gc3RhdGUuYWxsKG5vZGUpOwogIGNvbnN0IGxvb3NlID0gcGFyZW50ID8gbGlzdExvb3NlKHBhcmVudCkgOiBsaXN0SXRlbUxvb3NlKG5vZGUpOwogIGNvbnN0IHByb3BlcnRpZXMgPSB7fTsKICBjb25zdCBjaGlsZHJlbiA9IFtdOwogIGlmICh0eXBlb2Ygbm9kZS5jaGVja2VkID09PSAiYm9vbGVhbiIpIHsKICAgIGNvbnN0IGhlYWQgPSByZXN1bHRzWzBdOwogICAgbGV0IHBhcmFncmFwaDI7CiAgICBpZiAoaGVhZCAmJiBoZWFkLnR5cGUgPT09ICJlbGVtZW50IiAmJiBoZWFkLnRhZ05hbWUgPT09ICJwIikgewogICAgICBwYXJhZ3JhcGgyID0gaGVhZDsKICAgIH0gZWxzZSB7CiAgICAgIHBhcmFncmFwaDIgPSB7IHR5cGU6ICJlbGVtZW50IiwgdGFnTmFtZTogInAiLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW46IFtdIH07CiAgICAgIHJlc3VsdHMudW5zaGlmdChwYXJhZ3JhcGgyKTsKICAgIH0KICAgIGlmIChwYXJhZ3JhcGgyLmNoaWxkcmVuLmxlbmd0aCA+IDApIHsKICAgICAgcGFyYWdyYXBoMi5jaGlsZHJlbi51bnNoaWZ0KHsgdHlwZTogInRleHQiLCB2YWx1ZTogIiAiIH0pOwogICAgfQogICAgcGFyYWdyYXBoMi5jaGlsZHJlbi51bnNoaWZ0KHsKICAgICAgdHlwZTogImVsZW1lbnQiLAogICAgICB0YWdOYW1lOiAiaW5wdXQiLAogICAgICBwcm9wZXJ0aWVzOiB7IHR5cGU6ICJjaGVja2JveCIsIGNoZWNrZWQ6IG5vZGUuY2hlY2tlZCwgZGlzYWJsZWQ6IHRydWUgfSwKICAgICAgY2hpbGRyZW46IFtdCiAgICB9KTsKICAgIHByb3BlcnRpZXMuY2xhc3NOYW1lID0gWyJ0YXNrLWxpc3QtaXRlbSJdOwogIH0KICBsZXQgaW5kZXgyID0gLTE7CiAgd2hpbGUgKCsraW5kZXgyIDwgcmVzdWx0cy5sZW5ndGgpIHsKICAgIGNvbnN0IGNoaWxkID0gcmVzdWx0c1tpbmRleDJdOwogICAgaWYgKGxvb3NlIHx8IGluZGV4MiAhPT0gMCB8fCBjaGlsZC50eXBlICE9PSAiZWxlbWVudCIgfHwgY2hpbGQudGFnTmFtZSAhPT0gInAiKSB7CiAgICAgIGNoaWxkcmVuLnB1c2goeyB0eXBlOiAidGV4dCIsIHZhbHVlOiAiXG4iIH0pOwogICAgfQogICAgaWYgKGNoaWxkLnR5cGUgPT09ICJlbGVtZW50IiAmJiBjaGlsZC50YWdOYW1lID09PSAicCIgJiYgIWxvb3NlKSB7CiAgICAgIGNoaWxkcmVuLnB1c2goLi4uY2hpbGQuY2hpbGRyZW4pOwogICAgfSBlbHNlIHsKICAgICAgY2hpbGRyZW4ucHVzaChjaGlsZCk7CiAgICB9CiAgfQogIGNvbnN0IHRhaWwgPSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoIC0gMV07CiAgaWYgKHRhaWwgJiYgKGxvb3NlIHx8IHRhaWwudHlwZSAhPT0gImVsZW1lbnQiIHx8IHRhaWwudGFnTmFtZSAhPT0gInAiKSkgewogICAgY2hpbGRyZW4ucHVzaCh7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6ICJcbiIgfSk7CiAgfQogIGNvbnN0IHJlc3VsdCA9IHsgdHlwZTogImVsZW1lbnQiLCB0YWdOYW1lOiAibGkiLCBwcm9wZXJ0aWVzLCBjaGlsZHJlbiB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CmZ1bmN0aW9uIGxpc3RMb29zZShub2RlKSB7CiAgbGV0IGxvb3NlID0gZmFsc2U7CiAgaWYgKG5vZGUudHlwZSA9PT0gImxpc3QiKSB7CiAgICBsb29zZSA9IG5vZGUuc3ByZWFkIHx8IGZhbHNlOwogICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuOwogICAgbGV0IGluZGV4MiA9IC0xOwogICAgd2hpbGUgKCFsb29zZSAmJiArK2luZGV4MiA8IGNoaWxkcmVuLmxlbmd0aCkgewogICAgICBsb29zZSA9IGxpc3RJdGVtTG9vc2UoY2hpbGRyZW5baW5kZXgyXSk7CiAgICB9CiAgfQogIHJldHVybiBsb29zZTsKfQpmdW5jdGlvbiBsaXN0SXRlbUxvb3NlKG5vZGUpIHsKICBjb25zdCBzcHJlYWQgPSBub2RlLnNwcmVhZDsKICByZXR1cm4gc3ByZWFkID09PSBudWxsIHx8IHNwcmVhZCA9PT0gdm9pZCAwID8gbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAxIDogc3ByZWFkOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9saXN0LmpzCmZ1bmN0aW9uIGxpc3QyKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcHJvcGVydGllcyA9IHt9OwogIGNvbnN0IHJlc3VsdHMgPSBzdGF0ZS5hbGwobm9kZSk7CiAgbGV0IGluZGV4MiA9IC0xOwogIGlmICh0eXBlb2Ygbm9kZS5zdGFydCA9PT0gIm51bWJlciIgJiYgbm9kZS5zdGFydCAhPT0gMSkgewogICAgcHJvcGVydGllcy5zdGFydCA9IG5vZGUuc3RhcnQ7CiAgfQogIHdoaWxlICgrK2luZGV4MiA8IHJlc3VsdHMubGVuZ3RoKSB7CiAgICBjb25zdCBjaGlsZCA9IHJlc3VsdHNbaW5kZXgyXTsKICAgIGlmIChjaGlsZC50eXBlID09PSAiZWxlbWVudCIgJiYgY2hpbGQudGFnTmFtZSA9PT0gImxpIiAmJiBjaGlsZC5wcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkoY2hpbGQucHJvcGVydGllcy5jbGFzc05hbWUpICYmIGNoaWxkLnByb3BlcnRpZXMuY2xhc3NOYW1lLmluY2x1ZGVzKCJ0YXNrLWxpc3QtaXRlbSIpKSB7CiAgICAgIHByb3BlcnRpZXMuY2xhc3NOYW1lID0gWyJjb250YWlucy10YXNrLWxpc3QiXTsKICAgICAgYnJlYWs7CiAgICB9CiAgfQogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6IG5vZGUub3JkZXJlZCA/ICJvbCIgOiAidWwiLAogICAgcHJvcGVydGllcywKICAgIGNoaWxkcmVuOiBzdGF0ZS53cmFwKHJlc3VsdHMsIHRydWUpCiAgfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvaGFuZGxlcnMvcGFyYWdyYXBoLmpzCmZ1bmN0aW9uIHBhcmFncmFwaChzdGF0ZSwgbm9kZSkgewogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJwIiwKICAgIHByb3BlcnRpZXM6IHt9LAogICAgY2hpbGRyZW46IHN0YXRlLmFsbChub2RlKQogIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICByZXR1cm4gc3RhdGUuYXBwbHlEYXRhKG5vZGUsIHJlc3VsdCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL3Jvb3QuanMKZnVuY3Rpb24gcm9vdDIoc3RhdGUsIG5vZGUpIHsKICBjb25zdCByZXN1bHQgPSB7IHR5cGU6ICJyb290IiwgY2hpbGRyZW46IHN0YXRlLndyYXAoc3RhdGUuYWxsKG5vZGUpKSB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy9zdHJvbmcuanMKZnVuY3Rpb24gc3Ryb25nKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcmVzdWx0ID0gewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogInN0cm9uZyIsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS5hbGwobm9kZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9oYW5kbGVycy90YWJsZS5qcwpmdW5jdGlvbiB0YWJsZShzdGF0ZSwgbm9kZSkgewogIGNvbnN0IHJvd3MgPSBzdGF0ZS5hbGwobm9kZSk7CiAgY29uc3QgZmlyc3RSb3cgPSByb3dzLnNoaWZ0KCk7CiAgY29uc3QgdGFibGVDb250ZW50ID0gW107CiAgaWYgKGZpcnN0Um93KSB7CiAgICBjb25zdCBoZWFkID0gewogICAgICB0eXBlOiAiZWxlbWVudCIsCiAgICAgIHRhZ05hbWU6ICJ0aGVhZCIsCiAgICAgIHByb3BlcnRpZXM6IHt9LAogICAgICBjaGlsZHJlbjogc3RhdGUud3JhcChbZmlyc3RSb3ddLCB0cnVlKQogICAgfTsKICAgIHN0YXRlLnBhdGNoKG5vZGUuY2hpbGRyZW5bMF0sIGhlYWQpOwogICAgdGFibGVDb250ZW50LnB1c2goaGVhZCk7CiAgfQogIGlmIChyb3dzLmxlbmd0aCA+IDApIHsKICAgIGNvbnN0IGJvZHkgPSB7CiAgICAgIHR5cGU6ICJlbGVtZW50IiwKICAgICAgdGFnTmFtZTogInRib2R5IiwKICAgICAgcHJvcGVydGllczoge30sCiAgICAgIGNoaWxkcmVuOiBzdGF0ZS53cmFwKHJvd3MsIHRydWUpCiAgICB9OwogICAgY29uc3Qgc3RhcnQyID0gcG9pbnRTdGFydChub2RlLmNoaWxkcmVuWzFdKTsKICAgIGNvbnN0IGVuZCA9IHBvaW50RW5kKG5vZGUuY2hpbGRyZW5bbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxXSk7CiAgICBpZiAoc3RhcnQyICYmIGVuZCkgYm9keS5wb3NpdGlvbiA9IHsgc3RhcnQ6IHN0YXJ0MiwgZW5kIH07CiAgICB0YWJsZUNvbnRlbnQucHVzaChib2R5KTsKICB9CiAgY29uc3QgcmVzdWx0ID0gewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogInRhYmxlIiwKICAgIHByb3BlcnRpZXM6IHt9LAogICAgY2hpbGRyZW46IHN0YXRlLndyYXAodGFibGVDb250ZW50LCB0cnVlKQogIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICByZXR1cm4gc3RhdGUuYXBwbHlEYXRhKG5vZGUsIHJlc3VsdCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL3RhYmxlLXJvdy5qcwpmdW5jdGlvbiB0YWJsZVJvdyhzdGF0ZSwgbm9kZSwgcGFyZW50KSB7CiAgY29uc3Qgc2libGluZ3MgPSBwYXJlbnQgPyBwYXJlbnQuY2hpbGRyZW4gOiB2b2lkIDA7CiAgY29uc3Qgcm93SW5kZXggPSBzaWJsaW5ncyA/IHNpYmxpbmdzLmluZGV4T2Yobm9kZSkgOiAxOwogIGNvbnN0IHRhZ05hbWUgPSByb3dJbmRleCA9PT0gMCA/ICJ0aCIgOiAidGQiOwogIGNvbnN0IGFsaWduID0gcGFyZW50ICYmIHBhcmVudC50eXBlID09PSAidGFibGUiID8gcGFyZW50LmFsaWduIDogdm9pZCAwOwogIGNvbnN0IGxlbmd0aCA9IGFsaWduID8gYWxpZ24ubGVuZ3RoIDogbm9kZS5jaGlsZHJlbi5sZW5ndGg7CiAgbGV0IGNlbGxJbmRleCA9IC0xOwogIGNvbnN0IGNlbGxzID0gW107CiAgd2hpbGUgKCsrY2VsbEluZGV4IDwgbGVuZ3RoKSB7CiAgICBjb25zdCBjZWxsID0gbm9kZS5jaGlsZHJlbltjZWxsSW5kZXhdOwogICAgY29uc3QgcHJvcGVydGllcyA9IHt9OwogICAgY29uc3QgYWxpZ25WYWx1ZSA9IGFsaWduID8gYWxpZ25bY2VsbEluZGV4XSA6IHZvaWQgMDsKICAgIGlmIChhbGlnblZhbHVlKSB7CiAgICAgIHByb3BlcnRpZXMuYWxpZ24gPSBhbGlnblZhbHVlOwogICAgfQogICAgbGV0IHJlc3VsdDIgPSB7IHR5cGU6ICJlbGVtZW50IiwgdGFnTmFtZSwgcHJvcGVydGllcywgY2hpbGRyZW46IFtdIH07CiAgICBpZiAoY2VsbCkgewogICAgICByZXN1bHQyLmNoaWxkcmVuID0gc3RhdGUuYWxsKGNlbGwpOwogICAgICBzdGF0ZS5wYXRjaChjZWxsLCByZXN1bHQyKTsKICAgICAgcmVzdWx0MiA9IHN0YXRlLmFwcGx5RGF0YShjZWxsLCByZXN1bHQyKTsKICAgIH0KICAgIGNlbGxzLnB1c2gocmVzdWx0Mik7CiAgfQogIGNvbnN0IHJlc3VsdCA9IHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJ0ciIsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS53cmFwKGNlbGxzLCB0cnVlKQogIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICByZXR1cm4gc3RhdGUuYXBwbHlEYXRhKG5vZGUsIHJlc3VsdCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL3RhYmxlLWNlbGwuanMKZnVuY3Rpb24gdGFibGVDZWxsKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcmVzdWx0ID0gewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogInRkIiwKICAgIC8vIEFzc3VtZSBib2R5IGNlbGwuCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS5hbGwobm9kZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CgovLyBub2RlX21vZHVsZXMvdHJpbS1saW5lcy9pbmRleC5qcwp2YXIgdGFiID0gOTsKdmFyIHNwYWNlID0gMzI7CmZ1bmN0aW9uIHRyaW1MaW5lcyh2YWx1ZSkgewogIGNvbnN0IHNvdXJjZSA9IFN0cmluZyh2YWx1ZSk7CiAgY29uc3Qgc2VhcmNoMiA9IC9ccj9cbnxcci9nOwogIGxldCBtYXRjaCA9IHNlYXJjaDIuZXhlYyhzb3VyY2UpOwogIGxldCBsYXN0ID0gMDsKICBjb25zdCBsaW5lcyA9IFtdOwogIHdoaWxlIChtYXRjaCkgewogICAgbGluZXMucHVzaCgKICAgICAgdHJpbUxpbmUoc291cmNlLnNsaWNlKGxhc3QsIG1hdGNoLmluZGV4KSwgbGFzdCA+IDAsIHRydWUpLAogICAgICBtYXRjaFswXQogICAgKTsKICAgIGxhc3QgPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDsKICAgIG1hdGNoID0gc2VhcmNoMi5leGVjKHNvdXJjZSk7CiAgfQogIGxpbmVzLnB1c2godHJpbUxpbmUoc291cmNlLnNsaWNlKGxhc3QpLCBsYXN0ID4gMCwgZmFsc2UpKTsKICByZXR1cm4gbGluZXMuam9pbigiIik7Cn0KZnVuY3Rpb24gdHJpbUxpbmUodmFsdWUsIHN0YXJ0MiwgZW5kKSB7CiAgbGV0IHN0YXJ0SW5kZXggPSAwOwogIGxldCBlbmRJbmRleCA9IHZhbHVlLmxlbmd0aDsKICBpZiAoc3RhcnQyKSB7CiAgICBsZXQgY29kZTIgPSB2YWx1ZS5jb2RlUG9pbnRBdChzdGFydEluZGV4KTsKICAgIHdoaWxlIChjb2RlMiA9PT0gdGFiIHx8IGNvZGUyID09PSBzcGFjZSkgewogICAgICBzdGFydEluZGV4Kys7CiAgICAgIGNvZGUyID0gdmFsdWUuY29kZVBvaW50QXQoc3RhcnRJbmRleCk7CiAgICB9CiAgfQogIGlmIChlbmQpIHsKICAgIGxldCBjb2RlMiA9IHZhbHVlLmNvZGVQb2ludEF0KGVuZEluZGV4IC0gMSk7CiAgICB3aGlsZSAoY29kZTIgPT09IHRhYiB8fCBjb2RlMiA9PT0gc3BhY2UpIHsKICAgICAgZW5kSW5kZXgtLTsKICAgICAgY29kZTIgPSB2YWx1ZS5jb2RlUG9pbnRBdChlbmRJbmRleCAtIDEpOwogICAgfQogIH0KICByZXR1cm4gZW5kSW5kZXggPiBzdGFydEluZGV4ID8gdmFsdWUuc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpIDogIiI7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL3RleHQuanMKZnVuY3Rpb24gdGV4dDQoc3RhdGUsIG5vZGUpIHsKICBjb25zdCByZXN1bHQgPSB7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6IHRyaW1MaW5lcyhTdHJpbmcobm9kZS52YWx1ZSkpIH07CiAgc3RhdGUucGF0Y2gobm9kZSwgcmVzdWx0KTsKICByZXR1cm4gc3RhdGUuYXBwbHlEYXRhKG5vZGUsIHJlc3VsdCk7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2hhbmRsZXJzL3RoZW1hdGljLWJyZWFrLmpzCmZ1bmN0aW9uIHRoZW1hdGljQnJlYWsyKHN0YXRlLCBub2RlKSB7CiAgY29uc3QgcmVzdWx0ID0gewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogImhyIiwKICAgIHByb3BlcnRpZXM6IHt9LAogICAgY2hpbGRyZW46IFtdCiAgfTsKICBzdGF0ZS5wYXRjaChub2RlLCByZXN1bHQpOwogIHJldHVybiBzdGF0ZS5hcHBseURhdGEobm9kZSwgcmVzdWx0KTsKfQoKLy8gbm9kZV9tb2R1bGVzL21kYXN0LXV0aWwtdG8taGFzdC9saWIvaGFuZGxlcnMvaW5kZXguanMKdmFyIGhhbmRsZXJzID0gewogIGJsb2NrcXVvdGUsCiAgYnJlYWs6IGhhcmRCcmVhaywKICBjb2RlLAogIGRlbGV0ZTogc3RyaWtldGhyb3VnaCwKICBlbXBoYXNpcywKICBmb290bm90ZVJlZmVyZW5jZSwKICBoZWFkaW5nLAogIGh0bWw6IGh0bWwyLAogIGltYWdlUmVmZXJlbmNlLAogIGltYWdlLAogIGlubGluZUNvZGUsCiAgbGlua1JlZmVyZW5jZSwKICBsaW5rLAogIGxpc3RJdGVtLAogIGxpc3Q6IGxpc3QyLAogIHBhcmFncmFwaCwKICAvLyBAdHMtZXhwZWN0LWVycm9yOiByb290IGlzIGRpZmZlcmVudCwgYnV0IGhhcmQgdG8gdHlwZS4KICByb290OiByb290MiwKICBzdHJvbmcsCiAgdGFibGUsCiAgdGFibGVDZWxsLAogIHRhYmxlUm93LAogIHRleHQ6IHRleHQ0LAogIHRoZW1hdGljQnJlYWs6IHRoZW1hdGljQnJlYWsyLAogIHRvbWw6IGlnbm9yZSwKICB5YW1sOiBpZ25vcmUsCiAgZGVmaW5pdGlvbjogaWdub3JlLAogIGZvb3Rub3RlRGVmaW5pdGlvbjogaWdub3JlCn07CmZ1bmN0aW9uIGlnbm9yZSgpIHsKICByZXR1cm4gdm9pZCAwOwp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9mb290ZXIuanMKZnVuY3Rpb24gZGVmYXVsdEZvb3Rub3RlQmFja0NvbnRlbnQoXywgcmVyZWZlcmVuY2VJbmRleCkgewogIGNvbnN0IHJlc3VsdCA9IFt7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6ICLihqkiIH1dOwogIGlmIChyZXJlZmVyZW5jZUluZGV4ID4gMSkgewogICAgcmVzdWx0LnB1c2goewogICAgICB0eXBlOiAiZWxlbWVudCIsCiAgICAgIHRhZ05hbWU6ICJzdXAiLAogICAgICBwcm9wZXJ0aWVzOiB7fSwKICAgICAgY2hpbGRyZW46IFt7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6IFN0cmluZyhyZXJlZmVyZW5jZUluZGV4KSB9XQogICAgfSk7CiAgfQogIHJldHVybiByZXN1bHQ7Cn0KZnVuY3Rpb24gZGVmYXVsdEZvb3Rub3RlQmFja0xhYmVsKHJlZmVyZW5jZUluZGV4LCByZXJlZmVyZW5jZUluZGV4KSB7CiAgcmV0dXJuICJCYWNrIHRvIHJlZmVyZW5jZSAiICsgKHJlZmVyZW5jZUluZGV4ICsgMSkgKyAocmVyZWZlcmVuY2VJbmRleCA+IDEgPyAiLSIgKyByZXJlZmVyZW5jZUluZGV4IDogIiIpOwp9CmZ1bmN0aW9uIGZvb3RlcihzdGF0ZSkgewogIGNvbnN0IGNsb2JiZXJQcmVmaXggPSB0eXBlb2Ygc3RhdGUub3B0aW9ucy5jbG9iYmVyUHJlZml4ID09PSAic3RyaW5nIiA/IHN0YXRlLm9wdGlvbnMuY2xvYmJlclByZWZpeCA6ICJ1c2VyLWNvbnRlbnQtIjsKICBjb25zdCBmb290bm90ZUJhY2tDb250ZW50ID0gc3RhdGUub3B0aW9ucy5mb290bm90ZUJhY2tDb250ZW50IHx8IGRlZmF1bHRGb290bm90ZUJhY2tDb250ZW50OwogIGNvbnN0IGZvb3Rub3RlQmFja0xhYmVsID0gc3RhdGUub3B0aW9ucy5mb290bm90ZUJhY2tMYWJlbCB8fCBkZWZhdWx0Rm9vdG5vdGVCYWNrTGFiZWw7CiAgY29uc3QgZm9vdG5vdGVMYWJlbCA9IHN0YXRlLm9wdGlvbnMuZm9vdG5vdGVMYWJlbCB8fCAiRm9vdG5vdGVzIjsKICBjb25zdCBmb290bm90ZUxhYmVsVGFnTmFtZSA9IHN0YXRlLm9wdGlvbnMuZm9vdG5vdGVMYWJlbFRhZ05hbWUgfHwgImgyIjsKICBjb25zdCBmb290bm90ZUxhYmVsUHJvcGVydGllcyA9IHN0YXRlLm9wdGlvbnMuZm9vdG5vdGVMYWJlbFByb3BlcnRpZXMgfHwgewogICAgY2xhc3NOYW1lOiBbInNyLW9ubHkiXQogIH07CiAgY29uc3QgbGlzdEl0ZW1zID0gW107CiAgbGV0IHJlZmVyZW5jZUluZGV4ID0gLTE7CiAgd2hpbGUgKCsrcmVmZXJlbmNlSW5kZXggPCBzdGF0ZS5mb290bm90ZU9yZGVyLmxlbmd0aCkgewogICAgY29uc3QgZGVmaW5pdGlvbjIgPSBzdGF0ZS5mb290bm90ZUJ5SWQuZ2V0KAogICAgICBzdGF0ZS5mb290bm90ZU9yZGVyW3JlZmVyZW5jZUluZGV4XQogICAgKTsKICAgIGlmICghZGVmaW5pdGlvbjIpIHsKICAgICAgY29udGludWU7CiAgICB9CiAgICBjb25zdCBjb250ZW50MyA9IHN0YXRlLmFsbChkZWZpbml0aW9uMik7CiAgICBjb25zdCBpZCA9IFN0cmluZyhkZWZpbml0aW9uMi5pZGVudGlmaWVyKS50b1VwcGVyQ2FzZSgpOwogICAgY29uc3Qgc2FmZUlkID0gbm9ybWFsaXplVXJpKGlkLnRvTG93ZXJDYXNlKCkpOwogICAgbGV0IHJlcmVmZXJlbmNlSW5kZXggPSAwOwogICAgY29uc3QgYmFja1JlZmVyZW5jZXMgPSBbXTsKICAgIGNvbnN0IGNvdW50cyA9IHN0YXRlLmZvb3Rub3RlQ291bnRzLmdldChpZCk7CiAgICB3aGlsZSAoY291bnRzICE9PSB2b2lkIDAgJiYgKytyZXJlZmVyZW5jZUluZGV4IDw9IGNvdW50cykgewogICAgICBpZiAoYmFja1JlZmVyZW5jZXMubGVuZ3RoID4gMCkgewogICAgICAgIGJhY2tSZWZlcmVuY2VzLnB1c2goeyB0eXBlOiAidGV4dCIsIHZhbHVlOiAiICIgfSk7CiAgICAgIH0KICAgICAgbGV0IGNoaWxkcmVuID0gdHlwZW9mIGZvb3Rub3RlQmFja0NvbnRlbnQgPT09ICJzdHJpbmciID8gZm9vdG5vdGVCYWNrQ29udGVudCA6IGZvb3Rub3RlQmFja0NvbnRlbnQocmVmZXJlbmNlSW5kZXgsIHJlcmVmZXJlbmNlSW5kZXgpOwogICAgICBpZiAodHlwZW9mIGNoaWxkcmVuID09PSAic3RyaW5nIikgewogICAgICAgIGNoaWxkcmVuID0geyB0eXBlOiAidGV4dCIsIHZhbHVlOiBjaGlsZHJlbiB9OwogICAgICB9CiAgICAgIGJhY2tSZWZlcmVuY2VzLnB1c2goewogICAgICAgIHR5cGU6ICJlbGVtZW50IiwKICAgICAgICB0YWdOYW1lOiAiYSIsCiAgICAgICAgcHJvcGVydGllczogewogICAgICAgICAgaHJlZjogIiMiICsgY2xvYmJlclByZWZpeCArICJmbnJlZi0iICsgc2FmZUlkICsgKHJlcmVmZXJlbmNlSW5kZXggPiAxID8gIi0iICsgcmVyZWZlcmVuY2VJbmRleCA6ICIiKSwKICAgICAgICAgIGRhdGFGb290bm90ZUJhY2tyZWY6ICIiLAogICAgICAgICAgYXJpYUxhYmVsOiB0eXBlb2YgZm9vdG5vdGVCYWNrTGFiZWwgPT09ICJzdHJpbmciID8gZm9vdG5vdGVCYWNrTGFiZWwgOiBmb290bm90ZUJhY2tMYWJlbChyZWZlcmVuY2VJbmRleCwgcmVyZWZlcmVuY2VJbmRleCksCiAgICAgICAgICBjbGFzc05hbWU6IFsiZGF0YS1mb290bm90ZS1iYWNrcmVmIl0KICAgICAgICB9LAogICAgICAgIGNoaWxkcmVuOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKSA/IGNoaWxkcmVuIDogW2NoaWxkcmVuXQogICAgICB9KTsKICAgIH0KICAgIGNvbnN0IHRhaWwgPSBjb250ZW50M1tjb250ZW50My5sZW5ndGggLSAxXTsKICAgIGlmICh0YWlsICYmIHRhaWwudHlwZSA9PT0gImVsZW1lbnQiICYmIHRhaWwudGFnTmFtZSA9PT0gInAiKSB7CiAgICAgIGNvbnN0IHRhaWxUYWlsID0gdGFpbC5jaGlsZHJlblt0YWlsLmNoaWxkcmVuLmxlbmd0aCAtIDFdOwogICAgICBpZiAodGFpbFRhaWwgJiYgdGFpbFRhaWwudHlwZSA9PT0gInRleHQiKSB7CiAgICAgICAgdGFpbFRhaWwudmFsdWUgKz0gIiAiOwogICAgICB9IGVsc2UgewogICAgICAgIHRhaWwuY2hpbGRyZW4ucHVzaCh7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6ICIgIiB9KTsKICAgICAgfQogICAgICB0YWlsLmNoaWxkcmVuLnB1c2goLi4uYmFja1JlZmVyZW5jZXMpOwogICAgfSBlbHNlIHsKICAgICAgY29udGVudDMucHVzaCguLi5iYWNrUmVmZXJlbmNlcyk7CiAgICB9CiAgICBjb25zdCBsaXN0SXRlbTIgPSB7CiAgICAgIHR5cGU6ICJlbGVtZW50IiwKICAgICAgdGFnTmFtZTogImxpIiwKICAgICAgcHJvcGVydGllczogeyBpZDogY2xvYmJlclByZWZpeCArICJmbi0iICsgc2FmZUlkIH0sCiAgICAgIGNoaWxkcmVuOiBzdGF0ZS53cmFwKGNvbnRlbnQzLCB0cnVlKQogICAgfTsKICAgIHN0YXRlLnBhdGNoKGRlZmluaXRpb24yLCBsaXN0SXRlbTIpOwogICAgbGlzdEl0ZW1zLnB1c2gobGlzdEl0ZW0yKTsKICB9CiAgaWYgKGxpc3RJdGVtcy5sZW5ndGggPT09IDApIHsKICAgIHJldHVybjsKICB9CiAgcmV0dXJuIHsKICAgIHR5cGU6ICJlbGVtZW50IiwKICAgIHRhZ05hbWU6ICJzZWN0aW9uIiwKICAgIHByb3BlcnRpZXM6IHsgZGF0YUZvb3Rub3RlczogdHJ1ZSwgY2xhc3NOYW1lOiBbImZvb3Rub3RlcyJdIH0sCiAgICBjaGlsZHJlbjogWwogICAgICB7CiAgICAgICAgdHlwZTogImVsZW1lbnQiLAogICAgICAgIHRhZ05hbWU6IGZvb3Rub3RlTGFiZWxUYWdOYW1lLAogICAgICAgIHByb3BlcnRpZXM6IHsKICAgICAgICAgIC4uLmVzbV9kZWZhdWx0KGZvb3Rub3RlTGFiZWxQcm9wZXJ0aWVzKSwKICAgICAgICAgIGlkOiAiZm9vdG5vdGUtbGFiZWwiCiAgICAgICAgfSwKICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogInRleHQiLCB2YWx1ZTogZm9vdG5vdGVMYWJlbCB9XQogICAgICB9LAogICAgICB7IHR5cGU6ICJ0ZXh0IiwgdmFsdWU6ICJcbiIgfSwKICAgICAgewogICAgICAgIHR5cGU6ICJlbGVtZW50IiwKICAgICAgICB0YWdOYW1lOiAib2wiLAogICAgICAgIHByb3BlcnRpZXM6IHt9LAogICAgICAgIGNoaWxkcmVuOiBzdGF0ZS53cmFwKGxpc3RJdGVtcywgdHJ1ZSkKICAgICAgfSwKICAgICAgeyB0eXBlOiAidGV4dCIsIHZhbHVlOiAiXG4iIH0KICAgIF0KICB9Owp9CgovLyBub2RlX21vZHVsZXMvbWRhc3QtdXRpbC10by1oYXN0L2xpYi9zdGF0ZS5qcwp2YXIgb3duMyA9IHt9Lmhhc093blByb3BlcnR5Owp2YXIgZW1wdHlPcHRpb25zMiA9IHt9OwpmdW5jdGlvbiBjcmVhdGVTdGF0ZSh0cmVlLCBvcHRpb25zKSB7CiAgY29uc3Qgc2V0dGluZ3MgPSBvcHRpb25zIHx8IGVtcHR5T3B0aW9uczI7CiAgY29uc3QgZGVmaW5pdGlvbkJ5SWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwogIGNvbnN0IGZvb3Rub3RlQnlJZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7CiAgY29uc3QgZm9vdG5vdGVDb3VudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpOwogIGNvbnN0IGhhbmRsZXJzMiA9IHsgLi4uaGFuZGxlcnMsIC4uLnNldHRpbmdzLmhhbmRsZXJzIH07CiAgY29uc3Qgc3RhdGUgPSB7CiAgICBhbGwsCiAgICBhcHBseURhdGEsCiAgICBkZWZpbml0aW9uQnlJZCwKICAgIGZvb3Rub3RlQnlJZCwKICAgIGZvb3Rub3RlQ291bnRzLAogICAgZm9vdG5vdGVPcmRlcjogW10sCiAgICBoYW5kbGVyczogaGFuZGxlcnMyLAogICAgb25lOiBvbmUyLAogICAgb3B0aW9uczogc2V0dGluZ3MsCiAgICBwYXRjaCwKICAgIHdyYXAKICB9OwogIHZpc2l0KHRyZWUsIGZ1bmN0aW9uKG5vZGUpIHsKICAgIGlmIChub2RlLnR5cGUgPT09ICJkZWZpbml0aW9uIiB8fCBub2RlLnR5cGUgPT09ICJmb290bm90ZURlZmluaXRpb24iKSB7CiAgICAgIGNvbnN0IG1hcCA9IG5vZGUudHlwZSA9PT0gImRlZmluaXRpb24iID8gZGVmaW5pdGlvbkJ5SWQgOiBmb290bm90ZUJ5SWQ7CiAgICAgIGNvbnN0IGlkID0gU3RyaW5nKG5vZGUuaWRlbnRpZmllcikudG9VcHBlckNhc2UoKTsKICAgICAgaWYgKCFtYXAuaGFzKGlkKSkgewogICAgICAgIG1hcC5zZXQoaWQsIG5vZGUpOwogICAgICB9CiAgICB9CiAgfSk7CiAgcmV0dXJuIHN0YXRlOwogIGZ1bmN0aW9uIG9uZTIobm9kZSwgcGFyZW50KSB7CiAgICBjb25zdCB0eXBlID0gbm9kZS50eXBlOwogICAgY29uc3QgaGFuZGxlID0gc3RhdGUuaGFuZGxlcnNbdHlwZV07CiAgICBpZiAob3duMy5jYWxsKHN0YXRlLmhhbmRsZXJzLCB0eXBlKSAmJiBoYW5kbGUpIHsKICAgICAgcmV0dXJuIGhhbmRsZShzdGF0ZSwgbm9kZSwgcGFyZW50KTsKICAgIH0KICAgIGlmIChzdGF0ZS5vcHRpb25zLnBhc3NUaHJvdWdoICYmIHN0YXRlLm9wdGlvbnMucGFzc1Rocm91Z2guaW5jbHVkZXModHlwZSkpIHsKICAgICAgaWYgKCJjaGlsZHJlbiIgaW4gbm9kZSkgewogICAgICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLnNoYWxsb3cgfSA9IG5vZGU7CiAgICAgICAgY29uc3QgcmVzdWx0ID0gZXNtX2RlZmF1bHQoc2hhbGxvdyk7CiAgICAgICAgcmVzdWx0LmNoaWxkcmVuID0gc3RhdGUuYWxsKG5vZGUpOwogICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgIH0KICAgICAgcmV0dXJuIGVzbV9kZWZhdWx0KG5vZGUpOwogICAgfQogICAgY29uc3QgdW5rbm93biA9IHN0YXRlLm9wdGlvbnMudW5rbm93bkhhbmRsZXIgfHwgZGVmYXVsdFVua25vd25IYW5kbGVyOwogICAgcmV0dXJuIHVua25vd24oc3RhdGUsIG5vZGUsIHBhcmVudCk7CiAgfQogIGZ1bmN0aW9uIGFsbChwYXJlbnQpIHsKICAgIGNvbnN0IHZhbHVlczIgPSBbXTsKICAgIGlmICgiY2hpbGRyZW4iIGluIHBhcmVudCkgewogICAgICBjb25zdCBub2RlcyA9IHBhcmVudC5jaGlsZHJlbjsKICAgICAgbGV0IGluZGV4MiA9IC0xOwogICAgICB3aGlsZSAoKytpbmRleDIgPCBub2Rlcy5sZW5ndGgpIHsKICAgICAgICBjb25zdCByZXN1bHQgPSBzdGF0ZS5vbmUobm9kZXNbaW5kZXgyXSwgcGFyZW50KTsKICAgICAgICBpZiAocmVzdWx0KSB7CiAgICAgICAgICBpZiAoaW5kZXgyICYmIG5vZGVzW2luZGV4MiAtIDFdLnR5cGUgPT09ICJicmVhayIpIHsKICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LnR5cGUgPT09ICJ0ZXh0IikgewogICAgICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHRyaW1NYXJrZG93blNwYWNlU3RhcnQocmVzdWx0LnZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQudHlwZSA9PT0gImVsZW1lbnQiKSB7CiAgICAgICAgICAgICAgY29uc3QgaGVhZCA9IHJlc3VsdC5jaGlsZHJlblswXTsKICAgICAgICAgICAgICBpZiAoaGVhZCAmJiBoZWFkLnR5cGUgPT09ICJ0ZXh0IikgewogICAgICAgICAgICAgICAgaGVhZC52YWx1ZSA9IHRyaW1NYXJrZG93blNwYWNlU3RhcnQoaGVhZC52YWx1ZSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7CiAgICAgICAgICAgIHZhbHVlczIucHVzaCguLi5yZXN1bHQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFsdWVzMi5wdXNoKHJlc3VsdCk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gdmFsdWVzMjsKICB9Cn0KZnVuY3Rpb24gcGF0Y2goZnJvbSwgdG8pIHsKICBpZiAoZnJvbS5wb3NpdGlvbikgdG8ucG9zaXRpb24gPSBwb3NpdGlvbihmcm9tKTsKfQpmdW5jdGlvbiBhcHBseURhdGEoZnJvbSwgdG8pIHsKICBsZXQgcmVzdWx0ID0gdG87CiAgaWYgKGZyb20gJiYgZnJvbS5kYXRhKSB7CiAgICBjb25zdCBoTmFtZSA9IGZyb20uZGF0YS5oTmFtZTsKICAgIGNvbnN0IGhDaGlsZHJlbiA9IGZyb20uZGF0YS5oQ2hpbGRyZW47CiAgICBjb25zdCBoUHJvcGVydGllcyA9IGZyb20uZGF0YS5oUHJvcGVydGllczsKICAgIGlmICh0eXBlb2YgaE5hbWUgPT09ICJzdHJpbmciKSB7CiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gImVsZW1lbnQiKSB7CiAgICAgICAgcmVzdWx0LnRhZ05hbWUgPSBoTmFtZTsKICAgICAgfSBlbHNlIHsKICAgICAgICBjb25zdCBjaGlsZHJlbiA9ICJjaGlsZHJlbiIgaW4gcmVzdWx0ID8gcmVzdWx0LmNoaWxkcmVuIDogW3Jlc3VsdF07CiAgICAgICAgcmVzdWx0ID0geyB0eXBlOiAiZWxlbWVudCIsIHRhZ05hbWU6IGhOYW1lLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW4gfTsKICAgICAgfQogICAgfQogICAgaWYgKHJlc3VsdC50eXBlID09PSAiZWxlbWVudCIgJiYgaFByb3BlcnRpZXMpIHsKICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQucHJvcGVydGllcywgZXNtX2RlZmF1bHQoaFByb3BlcnRpZXMpKTsKICAgIH0KICAgIGlmICgiY2hpbGRyZW4iIGluIHJlc3VsdCAmJiByZXN1bHQuY2hpbGRyZW4gJiYgaENoaWxkcmVuICE9PSBudWxsICYmIGhDaGlsZHJlbiAhPT0gdm9pZCAwKSB7CiAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGhDaGlsZHJlbjsKICAgIH0KICB9CiAgcmV0dXJuIHJlc3VsdDsKfQpmdW5jdGlvbiBkZWZhdWx0VW5rbm93bkhhbmRsZXIoc3RhdGUsIG5vZGUpIHsKICBjb25zdCBkYXRhID0gbm9kZS5kYXRhIHx8IHt9OwogIGNvbnN0IHJlc3VsdCA9ICJ2YWx1ZSIgaW4gbm9kZSAmJiAhKG93bjMuY2FsbChkYXRhLCAiaFByb3BlcnRpZXMiKSB8fCBvd24zLmNhbGwoZGF0YSwgImhDaGlsZHJlbiIpKSA/IHsgdHlwZTogInRleHQiLCB2YWx1ZTogbm9kZS52YWx1ZSB9IDogewogICAgdHlwZTogImVsZW1lbnQiLAogICAgdGFnTmFtZTogImRpdiIsCiAgICBwcm9wZXJ0aWVzOiB7fSwKICAgIGNoaWxkcmVuOiBzdGF0ZS5hbGwobm9kZSkKICB9OwogIHN0YXRlLnBhdGNoKG5vZGUsIHJlc3VsdCk7CiAgcmV0dXJuIHN0YXRlLmFwcGx5RGF0YShub2RlLCByZXN1bHQpOwp9CmZ1bmN0aW9uIHdyYXAobm9kZXMsIGxvb3NlKSB7CiAgY29uc3QgcmVzdWx0ID0gW107CiAgbGV0IGluZGV4MiA9IC0xOwogIGlmIChsb29zZSkgewogICAgcmVzdWx0LnB1c2goeyB0eXBlOiAidGV4dCIsIHZhbHVlOiAiXG4iIH0pOwogIH0KICB3aGlsZSAoKytpbmRleDIgPCBub2Rlcy5sZW5ndGgpIHsKICAgIGlmIChpbmRleDIpIHJlc3VsdC5wdXNoKHsgdHlwZTogInRleHQiLCB2YWx1ZTogIlxuIiB9KTsKICAgIHJlc3VsdC5wdXNoKG5vZGVzW2luZGV4Ml0pOwogIH0KICBpZiAobG9vc2UgJiYgbm9kZXMubGVuZ3RoID4gMCkgewogICAgcmVzdWx0LnB1c2goeyB0eXBlOiAidGV4dCIsIHZhbHVlOiAiXG4iIH0pOwogIH0KICByZXR1cm4gcmVzdWx0Owp9CmZ1bmN0aW9uIHRyaW1NYXJrZG93blNwYWNlU3RhcnQodmFsdWUpIHsKICBsZXQgaW5kZXgyID0gMDsKICBsZXQgY29kZTIgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4Mik7CiAgd2hpbGUgKGNvZGUyID09PSA5IHx8IGNvZGUyID09PSAzMikgewogICAgaW5kZXgyKys7CiAgICBjb2RlMiA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgyKTsKICB9CiAgcmV0dXJuIHZhbHVlLnNsaWNlKGluZGV4Mik7Cn0KCi8vIG5vZGVfbW9kdWxlcy9tZGFzdC11dGlsLXRvLWhhc3QvbGliL2luZGV4LmpzCmZ1bmN0aW9uIHRvSGFzdCh0cmVlLCBvcHRpb25zKSB7CiAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdGF0ZSh0cmVlLCBvcHRpb25zKTsKICBjb25zdCBub2RlID0gc3RhdGUub25lKHRyZWUsIHZvaWQgMCk7CiAgY29uc3QgZm9vdCA9IGZvb3RlcihzdGF0ZSk7CiAgY29uc3QgcmVzdWx0ID0gQXJyYXkuaXNBcnJheShub2RlKSA/IHsgdHlwZTogInJvb3QiLCBjaGlsZHJlbjogbm9kZSB9IDogbm9kZSB8fCB7IHR5cGU6ICJyb290IiwgY2hpbGRyZW46IFtdIH07CiAgaWYgKGZvb3QpIHsKICAgIG9rKCJjaGlsZHJlbiIgaW4gcmVzdWx0KTsKICAgIHJlc3VsdC5jaGlsZHJlbi5wdXNoKHsgdHlwZTogInRleHQiLCB2YWx1ZTogIlxuIiB9LCBmb290KTsKICB9CiAgcmV0dXJuIHJlc3VsdDsKfQoKLy8gbm9kZV9tb2R1bGVzL3JlbWFyay1yZWh5cGUvbGliL2luZGV4LmpzCmZ1bmN0aW9uIHJlbWFya1JlaHlwZShkZXN0aW5hdGlvbiwgb3B0aW9ucykgewogIGlmIChkZXN0aW5hdGlvbiAmJiAicnVuIiBpbiBkZXN0aW5hdGlvbikgewogICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uKHRyZWUsIGZpbGUpIHsKICAgICAgY29uc3QgaGFzdFRyZWUgPSAoCiAgICAgICAgLyoqIEB0eXBlIHtIYXN0Um9vdH0gKi8KICAgICAgICB0b0hhc3QodHJlZSwgeyBmaWxlLCAuLi5vcHRpb25zIH0pCiAgICAgICk7CiAgICAgIGF3YWl0IGRlc3RpbmF0aW9uLnJ1bihoYXN0VHJlZSwgZmlsZSk7CiAgICB9OwogIH0KICByZXR1cm4gZnVuY3Rpb24odHJlZSwgZmlsZSkgewogICAgcmV0dXJuICgKICAgICAgLyoqIEB0eXBlIHtIYXN0Um9vdH0gKi8KICAgICAgdG9IYXN0KHRyZWUsIHsgZmlsZSwgLi4uZGVzdGluYXRpb24gfHwgb3B0aW9ucyB9KQogICAgKTsKICB9Owp9CgovLyBub2RlX21vZHVsZXMvYmFpbC9pbmRleC5qcwpmdW5jdGlvbiBiYWlsKGVycm9yKSB7CiAgaWYgKGVycm9yKSB7CiAgICB0aHJvdyBlcnJvcjsKICB9Cn0KCi8vIG5vZGVfbW9kdWxlcy91bmlmaWVkL2xpYi9pbmRleC5qcwp2YXIgaW1wb3J0X2V4dGVuZCA9IF9fdG9FU00ocmVxdWlyZV9leHRlbmQoKSwgMSk7CgovLyBub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzCmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHsKICBpZiAodHlwZW9mIHZhbHVlICE9PSAib2JqZWN0IiB8fCB2YWx1ZSA9PT0gbnVsbCkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpOwogIHJldHVybiAocHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdmFsdWUpICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlKTsKfQoKLy8gbm9kZV9tb2R1bGVzL3Ryb3VnaC9saWIvaW5kZXguanMKZnVuY3Rpb24gdHJvdWdoKCkgewogIGNvbnN0IGZucyA9IFtdOwogIGNvbnN0IHBpcGVsaW5lID0geyBydW4sIHVzZSB9OwogIHJldHVybiBwaXBlbGluZTsKICBmdW5jdGlvbiBydW4oLi4udmFsdWVzMikgewogICAgbGV0IG1pZGRsZXdhcmVJbmRleCA9IC0xOwogICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZXMyLnBvcCgpOwogICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gImZ1bmN0aW9uIikgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RlZCBmdW5jdGlvbiBhcyBsYXN0IGFyZ3VtZW50LCBub3QgIiArIGNhbGxiYWNrKTsKICAgIH0KICAgIG5leHQobnVsbCwgLi4udmFsdWVzMik7CiAgICBmdW5jdGlvbiBuZXh0KGVycm9yLCAuLi5vdXRwdXQpIHsKICAgICAgY29uc3QgZm4gPSBmbnNbKyttaWRkbGV3YXJlSW5kZXhdOwogICAgICBsZXQgaW5kZXgyID0gLTE7CiAgICAgIGlmIChlcnJvcikgewogICAgICAgIGNhbGxiYWNrKGVycm9yKTsKICAgICAgICByZXR1cm47CiAgICAgIH0KICAgICAgd2hpbGUgKCsraW5kZXgyIDwgdmFsdWVzMi5sZW5ndGgpIHsKICAgICAgICBpZiAob3V0cHV0W2luZGV4Ml0gPT09IG51bGwgfHwgb3V0cHV0W2luZGV4Ml0gPT09IHZvaWQgMCkgewogICAgICAgICAgb3V0cHV0W2luZGV4Ml0gPSB2YWx1ZXMyW2luZGV4Ml07CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhbHVlczIgPSBvdXRwdXQ7CiAgICAgIGlmIChmbikgewogICAgICAgIHdyYXAyKGZuLCBuZXh0KSguLi5vdXRwdXQpOwogICAgICB9IGVsc2UgewogICAgICAgIGNhbGxiYWNrKG51bGwsIC4uLm91dHB1dCk7CiAgICAgIH0KICAgIH0KICB9CiAgZnVuY3Rpb24gdXNlKG1pZGRlbHdhcmUpIHsKICAgIGlmICh0eXBlb2YgbWlkZGVsd2FyZSAhPT0gImZ1bmN0aW9uIikgewogICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKAogICAgICAgICJFeHBlY3RlZCBgbWlkZGVsd2FyZWAgdG8gYmUgYSBmdW5jdGlvbiwgbm90ICIgKyBtaWRkZWx3YXJlCiAgICAgICk7CiAgICB9CiAgICBmbnMucHVzaChtaWRkZWx3YXJlKTsKICAgIHJldHVybiBwaXBlbGluZTsKICB9Cn0KZnVuY3Rpb24gd3JhcDIobWlkZGxld2FyZSwgY2FsbGJhY2spIHsKICBsZXQgY2FsbGVkOwogIHJldHVybiB3cmFwcGVkOwogIGZ1bmN0aW9uIHdyYXBwZWQoLi4ucGFyYW1ldGVycykgewogICAgY29uc3QgZm5FeHBlY3RzQ2FsbGJhY2sgPSBtaWRkbGV3YXJlLmxlbmd0aCA+IHBhcmFtZXRlcnMubGVuZ3RoOwogICAgbGV0IHJlc3VsdDsKICAgIGlmIChmbkV4cGVjdHNDYWxsYmFjaykgewogICAgICBwYXJhbWV0ZXJzLnB1c2goZG9uZSk7CiAgICB9CiAgICB0cnkgewogICAgICByZXN1bHQgPSBtaWRkbGV3YXJlLmFwcGx5KHRoaXMsIHBhcmFtZXRlcnMpOwogICAgfSBjYXRjaCAoZXJyb3IpIHsKICAgICAgY29uc3QgZXhjZXB0aW9uID0gKAogICAgICAgIC8qKiBAdHlwZSB7RXJyb3J9ICovCiAgICAgICAgZXJyb3IKICAgICAgKTsKICAgICAgaWYgKGZuRXhwZWN0c0NhbGxiYWNrICYmIGNhbGxlZCkgewogICAgICAgIHRocm93IGV4Y2VwdGlvbjsKICAgICAgfQogICAgICByZXR1cm4gZG9uZShleGNlcHRpb24pOwogICAgfQogICAgaWYgKCFmbkV4cGVjdHNDYWxsYmFjaykgewogICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdC50aGVuICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gImZ1bmN0aW9uIikgewogICAgICAgIHJlc3VsdC50aGVuKHRoZW4sIGRvbmUpOwogICAgICB9IGVsc2UgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIEVycm9yKSB7CiAgICAgICAgZG9uZShyZXN1bHQpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoZW4ocmVzdWx0KTsKICAgICAgfQogICAgfQogIH0KICBmdW5jdGlvbiBkb25lKGVycm9yLCAuLi5vdXRwdXQpIHsKICAgIGlmICghY2FsbGVkKSB7CiAgICAgIGNhbGxlZCA9IHRydWU7CiAgICAgIGNhbGxiYWNrKGVycm9yLCAuLi5vdXRwdXQpOwogICAgfQogIH0KICBmdW5jdGlvbiB0aGVuKHZhbHVlKSB7CiAgICBkb25lKG51bGwsIHZhbHVlKTsKICB9Cn0KCi8vIG5vZGVfbW9kdWxlcy92ZmlsZS9saWIvbWlucGF0aC5icm93c2VyLmpzCnZhciBtaW5wYXRoID0geyBiYXNlbmFtZSwgZGlybmFtZSwgZXh0bmFtZSwgam9pbiwgc2VwOiAiLyIgfTsKZnVuY3Rpb24gYmFzZW5hbWUocGF0aCwgZXh0bmFtZTIpIHsKICBpZiAoZXh0bmFtZTIgIT09IHZvaWQgMCAmJiB0eXBlb2YgZXh0bmFtZTIgIT09ICJzdHJpbmciKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCciZXh0IiBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJyk7CiAgfQogIGFzc2VydFBhdGgocGF0aCk7CiAgbGV0IHN0YXJ0MiA9IDA7CiAgbGV0IGVuZCA9IC0xOwogIGxldCBpbmRleDIgPSBwYXRoLmxlbmd0aDsKICBsZXQgc2Vlbk5vblNsYXNoOwogIGlmIChleHRuYW1lMiA9PT0gdm9pZCAwIHx8IGV4dG5hbWUyLmxlbmd0aCA9PT0gMCB8fCBleHRuYW1lMi5sZW5ndGggPiBwYXRoLmxlbmd0aCkgewogICAgd2hpbGUgKGluZGV4Mi0tKSB7CiAgICAgIGlmIChwYXRoLmNvZGVQb2ludEF0KGluZGV4MikgPT09IDQ3KSB7CiAgICAgICAgaWYgKHNlZW5Ob25TbGFzaCkgewogICAgICAgICAgc3RhcnQyID0gaW5kZXgyICsgMTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChlbmQgPCAwKSB7CiAgICAgICAgc2Vlbk5vblNsYXNoID0gdHJ1ZTsKICAgICAgICBlbmQgPSBpbmRleDIgKyAxOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gZW5kIDwgMCA/ICIiIDogcGF0aC5zbGljZShzdGFydDIsIGVuZCk7CiAgfQogIGlmIChleHRuYW1lMiA9PT0gcGF0aCkgewogICAgcmV0dXJuICIiOwogIH0KICBsZXQgZmlyc3ROb25TbGFzaEVuZCA9IC0xOwogIGxldCBleHRuYW1lSW5kZXggPSBleHRuYW1lMi5sZW5ndGggLSAxOwogIHdoaWxlIChpbmRleDItLSkgewogICAgaWYgKHBhdGguY29kZVBvaW50QXQoaW5kZXgyKSA9PT0gNDcpIHsKICAgICAgaWYgKHNlZW5Ob25TbGFzaCkgewogICAgICAgIHN0YXJ0MiA9IGluZGV4MiArIDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGlmIChmaXJzdE5vblNsYXNoRW5kIDwgMCkgewogICAgICAgIHNlZW5Ob25TbGFzaCA9IHRydWU7CiAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGluZGV4MiArIDE7CiAgICAgIH0KICAgICAgaWYgKGV4dG5hbWVJbmRleCA+IC0xKSB7CiAgICAgICAgaWYgKHBhdGguY29kZVBvaW50QXQoaW5kZXgyKSA9PT0gZXh0bmFtZTIuY29kZVBvaW50QXQoZXh0bmFtZUluZGV4LS0pKSB7CiAgICAgICAgICBpZiAoZXh0bmFtZUluZGV4IDwgMCkgewogICAgICAgICAgICBlbmQgPSBpbmRleDI7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGV4dG5hbWVJbmRleCA9IC0xOwogICAgICAgICAgZW5kID0gZmlyc3ROb25TbGFzaEVuZDsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgaWYgKHN0YXJ0MiA9PT0gZW5kKSB7CiAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kOwogIH0gZWxzZSBpZiAoZW5kIDwgMCkgewogICAgZW5kID0gcGF0aC5sZW5ndGg7CiAgfQogIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0MiwgZW5kKTsKfQpmdW5jdGlvbiBkaXJuYW1lKHBhdGgpIHsKICBhc3NlcnRQYXRoKHBhdGgpOwogIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkgewogICAgcmV0dXJuICIuIjsKICB9CiAgbGV0IGVuZCA9IC0xOwogIGxldCBpbmRleDIgPSBwYXRoLmxlbmd0aDsKICBsZXQgdW5tYXRjaGVkU2xhc2g7CiAgd2hpbGUgKC0taW5kZXgyKSB7CiAgICBpZiAocGF0aC5jb2RlUG9pbnRBdChpbmRleDIpID09PSA0NykgewogICAgICBpZiAodW5tYXRjaGVkU2xhc2gpIHsKICAgICAgICBlbmQgPSBpbmRleDI7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoIXVubWF0Y2hlZFNsYXNoKSB7CiAgICAgIHVubWF0Y2hlZFNsYXNoID0gdHJ1ZTsKICAgIH0KICB9CiAgcmV0dXJuIGVuZCA8IDAgPyBwYXRoLmNvZGVQb2ludEF0KDApID09PSA0NyA/ICIvIiA6ICIuIiA6IGVuZCA9PT0gMSAmJiBwYXRoLmNvZGVQb2ludEF0KDApID09PSA0NyA/ICIvLyIgOiBwYXRoLnNsaWNlKDAsIGVuZCk7Cn0KZnVuY3Rpb24gZXh0bmFtZShwYXRoKSB7CiAgYXNzZXJ0UGF0aChwYXRoKTsKICBsZXQgaW5kZXgyID0gcGF0aC5sZW5ndGg7CiAgbGV0IGVuZCA9IC0xOwogIGxldCBzdGFydFBhcnQgPSAwOwogIGxldCBzdGFydERvdCA9IC0xOwogIGxldCBwcmVEb3RTdGF0ZSA9IDA7CiAgbGV0IHVubWF0Y2hlZFNsYXNoOwogIHdoaWxlIChpbmRleDItLSkgewogICAgY29uc3QgY29kZTIgPSBwYXRoLmNvZGVQb2ludEF0KGluZGV4Mik7CiAgICBpZiAoY29kZTIgPT09IDQ3KSB7CiAgICAgIGlmICh1bm1hdGNoZWRTbGFzaCkgewogICAgICAgIHN0YXJ0UGFydCA9IGluZGV4MiArIDE7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgY29udGludWU7CiAgICB9CiAgICBpZiAoZW5kIDwgMCkgewogICAgICB1bm1hdGNoZWRTbGFzaCA9IHRydWU7CiAgICAgIGVuZCA9IGluZGV4MiArIDE7CiAgICB9CiAgICBpZiAoY29kZTIgPT09IDQ2KSB7CiAgICAgIGlmIChzdGFydERvdCA8IDApIHsKICAgICAgICBzdGFydERvdCA9IGluZGV4MjsKICAgICAgfSBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkgewogICAgICAgIHByZURvdFN0YXRlID0gMTsKICAgICAgfQogICAgfSBlbHNlIGlmIChzdGFydERvdCA+IC0xKSB7CiAgICAgIHByZURvdFN0YXRlID0gLTE7CiAgICB9CiAgfQogIGlmIChzdGFydERvdCA8IDAgfHwgZW5kIDwgMCB8fCAvLyBXZSBzYXcgYSBub24tZG90IGNoYXJhY3RlciBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGRvdC4KICBwcmVEb3RTdGF0ZSA9PT0gMCB8fCAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSBgLi5gLgogIHByZURvdFN0YXRlID09PSAxICYmIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSB7CiAgICByZXR1cm4gIiI7CiAgfQogIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpOwp9CmZ1bmN0aW9uIGpvaW4oLi4uc2VnbWVudHMpIHsKICBsZXQgaW5kZXgyID0gLTE7CiAgbGV0IGpvaW5lZDsKICB3aGlsZSAoKytpbmRleDIgPCBzZWdtZW50cy5sZW5ndGgpIHsKICAgIGFzc2VydFBhdGgoc2VnbWVudHNbaW5kZXgyXSk7CiAgICBpZiAoc2VnbWVudHNbaW5kZXgyXSkgewogICAgICBqb2luZWQgPSBqb2luZWQgPT09IHZvaWQgMCA/IHNlZ21lbnRzW2luZGV4Ml0gOiBqb2luZWQgKyAiLyIgKyBzZWdtZW50c1tpbmRleDJdOwogICAgfQogIH0KICByZXR1cm4gam9pbmVkID09PSB2b2lkIDAgPyAiLiIgOiBub3JtYWxpemUoam9pbmVkKTsKfQpmdW5jdGlvbiBub3JtYWxpemUocGF0aCkgewogIGFzc2VydFBhdGgocGF0aCk7CiAgY29uc3QgYWJzb2x1dGUgPSBwYXRoLmNvZGVQb2ludEF0KDApID09PSA0NzsKICBsZXQgdmFsdWUgPSBub3JtYWxpemVTdHJpbmcocGF0aCwgIWFic29sdXRlKTsKICBpZiAodmFsdWUubGVuZ3RoID09PSAwICYmICFhYnNvbHV0ZSkgewogICAgdmFsdWUgPSAiLiI7CiAgfQogIGlmICh2YWx1ZS5sZW5ndGggPiAwICYmIHBhdGguY29kZVBvaW50QXQocGF0aC5sZW5ndGggLSAxKSA9PT0gNDcpIHsKICAgIHZhbHVlICs9ICIvIjsKICB9CiAgcmV0dXJuIGFic29sdXRlID8gIi8iICsgdmFsdWUgOiB2YWx1ZTsKfQpmdW5jdGlvbiBub3JtYWxpemVTdHJpbmcocGF0aCwgYWxsb3dBYm92ZVJvb3QpIHsKICBsZXQgcmVzdWx0ID0gIiI7CiAgbGV0IGxhc3RTZWdtZW50TGVuZ3RoID0gMDsKICBsZXQgbGFzdFNsYXNoID0gLTE7CiAgbGV0IGRvdHMgPSAwOwogIGxldCBpbmRleDIgPSAtMTsKICBsZXQgY29kZTI7CiAgbGV0IGxhc3RTbGFzaEluZGV4OwogIHdoaWxlICgrK2luZGV4MiA8PSBwYXRoLmxlbmd0aCkgewogICAgaWYgKGluZGV4MiA8IHBhdGgubGVuZ3RoKSB7CiAgICAgIGNvZGUyID0gcGF0aC5jb2RlUG9pbnRBdChpbmRleDIpOwogICAgfSBlbHNlIGlmIChjb2RlMiA9PT0gNDcpIHsKICAgICAgYnJlYWs7CiAgICB9IGVsc2UgewogICAgICBjb2RlMiA9IDQ3OwogICAgfQogICAgaWYgKGNvZGUyID09PSA0NykgewogICAgICBpZiAobGFzdFNsYXNoID09PSBpbmRleDIgLSAxIHx8IGRvdHMgPT09IDEpIHsKICAgICAgfSBlbHNlIGlmIChsYXN0U2xhc2ggIT09IGluZGV4MiAtIDEgJiYgZG90cyA9PT0gMikgewogICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fCByZXN1bHQuY29kZVBvaW50QXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSA0NiB8fCByZXN1bHQuY29kZVBvaW50QXQocmVzdWx0Lmxlbmd0aCAtIDIpICE9PSA0NikgewogICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAyKSB7CiAgICAgICAgICAgIGxhc3RTbGFzaEluZGV4ID0gcmVzdWx0Lmxhc3RJbmRleE9mKCIvIik7CiAgICAgICAgICAgIGlmIChsYXN0U2xhc2hJbmRleCAhPT0gcmVzdWx0Lmxlbmd0aCAtIDEpIHsKICAgICAgICAgICAgICBpZiAobGFzdFNsYXNoSW5kZXggPCAwKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSAiIjsKICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIGxhc3RTbGFzaEluZGV4KTsKICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCAtIDEgLSByZXN1bHQubGFzdEluZGV4T2YoIi8iKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaW5kZXgyOwogICAgICAgICAgICAgIGRvdHMgPSAwOwogICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIHJlc3VsdCA9ICIiOwogICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7CiAgICAgICAgICAgIGxhc3RTbGFzaCA9IGluZGV4MjsKICAgICAgICAgICAgZG90cyA9IDA7CiAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHsKICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5sZW5ndGggPiAwID8gcmVzdWx0ICsgIi8uLiIgOiAiLi4iOwogICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSAyOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDApIHsKICAgICAgICAgIHJlc3VsdCArPSAiLyIgKyBwYXRoLnNsaWNlKGxhc3RTbGFzaCArIDEsIGluZGV4Mik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJlc3VsdCA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaW5kZXgyKTsKICAgICAgICB9CiAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSBpbmRleDIgLSBsYXN0U2xhc2ggLSAxOwogICAgICB9CiAgICAgIGxhc3RTbGFzaCA9IGluZGV4MjsKICAgICAgZG90cyA9IDA7CiAgICB9IGVsc2UgaWYgKGNvZGUyID09PSA0NiAmJiBkb3RzID4gLTEpIHsKICAgICAgZG90cysrOwogICAgfSBlbHNlIHsKICAgICAgZG90cyA9IC0xOwogICAgfQogIH0KICByZXR1cm4gcmVzdWx0Owp9CmZ1bmN0aW9uIGFzc2VydFBhdGgocGF0aCkgewogIGlmICh0eXBlb2YgcGF0aCAhPT0gInN0cmluZyIpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICJQYXRoIG11c3QgYmUgYSBzdHJpbmcuIFJlY2VpdmVkICIgKyBKU09OLnN0cmluZ2lmeShwYXRoKQogICAgKTsKICB9Cn0KCi8vIG5vZGVfbW9kdWxlcy92ZmlsZS9saWIvbWlucHJvYy5icm93c2VyLmpzCnZhciBtaW5wcm9jID0geyBjd2QgfTsKZnVuY3Rpb24gY3dkKCkgewogIHJldHVybiAiLyI7Cn0KCi8vIG5vZGVfbW9kdWxlcy92ZmlsZS9saWIvbWludXJsLnNoYXJlZC5qcwpmdW5jdGlvbiBpc1VybChmaWxlVXJsT3JQYXRoKSB7CiAgcmV0dXJuIEJvb2xlYW4oCiAgICBmaWxlVXJsT3JQYXRoICE9PSBudWxsICYmIHR5cGVvZiBmaWxlVXJsT3JQYXRoID09PSAib2JqZWN0IiAmJiAiaHJlZiIgaW4gZmlsZVVybE9yUGF0aCAmJiBmaWxlVXJsT3JQYXRoLmhyZWYgJiYgInByb3RvY29sIiBpbiBmaWxlVXJsT3JQYXRoICYmIGZpbGVVcmxPclBhdGgucHJvdG9jb2wgJiYgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW5kZXhpbmcgaXMgZmluZS4KICAgIGZpbGVVcmxPclBhdGguYXV0aCA9PT0gdm9pZCAwCiAgKTsKfQoKLy8gbm9kZV9tb2R1bGVzL3ZmaWxlL2xpYi9taW51cmwuYnJvd3Nlci5qcwpmdW5jdGlvbiB1cmxUb1BhdGgocGF0aCkgewogIGlmICh0eXBlb2YgcGF0aCA9PT0gInN0cmluZyIpIHsKICAgIHBhdGggPSBuZXcgVVJMKHBhdGgpOwogIH0gZWxzZSBpZiAoIWlzVXJsKHBhdGgpKSB7CiAgICBjb25zdCBlcnJvciA9IG5ldyBUeXBlRXJyb3IoCiAgICAgICdUaGUgInBhdGgiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgYW4gaW5zdGFuY2Ugb2YgVVJMLiBSZWNlaXZlZCBgJyArIHBhdGggKyAiYCIKICAgICk7CiAgICBlcnJvci5jb2RlID0gIkVSUl9JTlZBTElEX0FSR19UWVBFIjsKICAgIHRocm93IGVycm9yOwogIH0KICBpZiAocGF0aC5wcm90b2NvbCAhPT0gImZpbGU6IikgewogICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCJUaGUgVVJMIG11c3QgYmUgb2Ygc2NoZW1lIGZpbGUiKTsKICAgIGVycm9yLmNvZGUgPSAiRVJSX0lOVkFMSURfVVJMX1NDSEVNRSI7CiAgICB0aHJvdyBlcnJvcjsKICB9CiAgcmV0dXJuIGdldFBhdGhGcm9tVVJMUG9zaXgocGF0aCk7Cn0KZnVuY3Rpb24gZ2V0UGF0aEZyb21VUkxQb3NpeCh1cmwpIHsKICBpZiAodXJsLmhvc3RuYW1lICE9PSAiIikgewogICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKAogICAgICAnRmlsZSBVUkwgaG9zdCBtdXN0IGJlICJsb2NhbGhvc3QiIG9yIGVtcHR5IG9uIGRhcndpbicKICAgICk7CiAgICBlcnJvci5jb2RlID0gIkVSUl9JTlZBTElEX0ZJTEVfVVJMX0hPU1QiOwogICAgdGhyb3cgZXJyb3I7CiAgfQogIGNvbnN0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lOwogIGxldCBpbmRleDIgPSAtMTsKICB3aGlsZSAoKytpbmRleDIgPCBwYXRobmFtZS5sZW5ndGgpIHsKICAgIGlmIChwYXRobmFtZS5jb2RlUG9pbnRBdChpbmRleDIpID09PSAzNyAmJiBwYXRobmFtZS5jb2RlUG9pbnRBdChpbmRleDIgKyAxKSA9PT0gNTApIHsKICAgICAgY29uc3QgdGhpcmQgPSBwYXRobmFtZS5jb2RlUG9pbnRBdChpbmRleDIgKyAyKTsKICAgICAgaWYgKHRoaXJkID09PSA3MCB8fCB0aGlyZCA9PT0gMTAyKSB7CiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKAogICAgICAgICAgIkZpbGUgVVJMIHBhdGggbXVzdCBub3QgaW5jbHVkZSBlbmNvZGVkIC8gY2hhcmFjdGVycyIKICAgICAgICApOwogICAgICAgIGVycm9yLmNvZGUgPSAiRVJSX0lOVkFMSURfRklMRV9VUkxfUEFUSCI7CiAgICAgICAgdGhyb3cgZXJyb3I7CiAgICAgIH0KICAgIH0KICB9CiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChwYXRobmFtZSk7Cn0KCi8vIG5vZGVfbW9kdWxlcy92ZmlsZS9saWIvaW5kZXguanMKdmFyIG9yZGVyID0gKAogIC8qKiBAdHlwZSB7Y29uc3R9ICovCiAgWwogICAgImhpc3RvcnkiLAogICAgInBhdGgiLAogICAgImJhc2VuYW1lIiwKICAgICJzdGVtIiwKICAgICJleHRuYW1lIiwKICAgICJkaXJuYW1lIgogIF0KKTsKdmFyIFZGaWxlID0gY2xhc3MgewogIC8qKgogICAqIENyZWF0ZSBhIG5ldyB2aXJ0dWFsIGZpbGUuCiAgICoKICAgKiBgb3B0aW9uc2AgaXMgdHJlYXRlZCBhczoKICAgKgogICAqICogICBgc3RyaW5nYCBvciBgVWludDhBcnJheWAg4oCUIGB7dmFsdWU6IG9wdGlvbnN9YAogICAqICogICBgVVJMYCDigJQgYHtwYXRoOiBvcHRpb25zfWAKICAgKiAqICAgYFZGaWxlYCDigJQgc2hhbGxvdyBjb3BpZXMgaXRzIGRhdGEgb3ZlciB0byB0aGUgbmV3IGZpbGUKICAgKiAqICAgYG9iamVjdGAg4oCUIGFsbCBmaWVsZHMgYXJlIHNoYWxsb3cgY29waWVkIG92ZXIgdG8gdGhlIG5ldyBmaWxlCiAgICoKICAgKiBQYXRoIHJlbGF0ZWQgZmllbGRzIGFyZSBzZXQgaW4gdGhlIGZvbGxvd2luZyBvcmRlciAobGVhc3Qgc3BlY2lmaWMgdG8KICAgKiBtb3N0IHNwZWNpZmljKTogYGhpc3RvcnlgLCBgcGF0aGAsIGBiYXNlbmFtZWAsIGBzdGVtYCwgYGV4dG5hbWVgLAogICAqIGBkaXJuYW1lYC4KICAgKgogICAqIFlvdSBjYW5ub3Qgc2V0IGBkaXJuYW1lYCBvciBgZXh0bmFtZWAgd2l0aG91dCBzZXR0aW5nIGVpdGhlciBgaGlzdG9yeWAsCiAgICogYHBhdGhgLCBgYmFzZW5hbWVgLCBvciBgc3RlbWAgdG9vLgogICAqCiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ZhbHVlXQogICAqICAgRmlsZSB2YWx1ZS4KICAgKiBAcmV0dXJucwogICAqICAgTmV3IGluc3RhbmNlLgogICAqLwogIGNvbnN0cnVjdG9yKHZhbHVlKSB7CiAgICBsZXQgb3B0aW9uczsKICAgIGlmICghdmFsdWUpIHsKICAgICAgb3B0aW9ucyA9IHt9OwogICAgfSBlbHNlIGlmIChpc1VybCh2YWx1ZSkpIHsKICAgICAgb3B0aW9ucyA9IHsgcGF0aDogdmFsdWUgfTsKICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAic3RyaW5nIiB8fCBpc1VpbnQ4QXJyYXkodmFsdWUpKSB7CiAgICAgIG9wdGlvbnMgPSB7IHZhbHVlIH07CiAgICB9IGVsc2UgewogICAgICBvcHRpb25zID0gdmFsdWU7CiAgICB9CiAgICB0aGlzLmN3ZCA9ICJjd2QiIGluIG9wdGlvbnMgPyAiIiA6IG1pbnByb2MuY3dkKCk7CiAgICB0aGlzLmRhdGEgPSB7fTsKICAgIHRoaXMuaGlzdG9yeSA9IFtdOwogICAgdGhpcy5tZXNzYWdlcyA9IFtdOwogICAgdGhpcy52YWx1ZTsKICAgIHRoaXMubWFwOwogICAgdGhpcy5yZXN1bHQ7CiAgICB0aGlzLnN0b3JlZDsKICAgIGxldCBpbmRleDIgPSAtMTsKICAgIHdoaWxlICgrK2luZGV4MiA8IG9yZGVyLmxlbmd0aCkgewogICAgICBjb25zdCBmaWVsZDIgPSBvcmRlcltpbmRleDJdOwogICAgICBpZiAoZmllbGQyIGluIG9wdGlvbnMgJiYgb3B0aW9uc1tmaWVsZDJdICE9PSB2b2lkIDAgJiYgb3B0aW9uc1tmaWVsZDJdICE9PSBudWxsKSB7CiAgICAgICAgdGhpc1tmaWVsZDJdID0gZmllbGQyID09PSAiaGlzdG9yeSIgPyBbLi4ub3B0aW9uc1tmaWVsZDJdXSA6IG9wdGlvbnNbZmllbGQyXTsKICAgICAgfQogICAgfQogICAgbGV0IGZpZWxkOwogICAgZm9yIChmaWVsZCBpbiBvcHRpb25zKSB7CiAgICAgIGlmICghb3JkZXIuaW5jbHVkZXMoZmllbGQpKSB7CiAgICAgICAgdGhpc1tmaWVsZF0gPSBvcHRpb25zW2ZpZWxkXTsKICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBHZXQgdGhlIGJhc2VuYW1lIChpbmNsdWRpbmcgZXh0bmFtZSkgKGV4YW1wbGU6IGAnaW5kZXgubWluLmpzJ2ApLgogICAqCiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0KICAgKiAgIEJhc2VuYW1lLgogICAqLwogIGdldCBiYXNlbmFtZSgpIHsKICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09PSAic3RyaW5nIiA/IG1pbnBhdGguYmFzZW5hbWUodGhpcy5wYXRoKSA6IHZvaWQgMDsKICB9CiAgLyoqCiAgICogU2V0IGJhc2VuYW1lIChpbmNsdWRpbmcgZXh0bmFtZSkgKGAnaW5kZXgubWluLmpzJ2ApLgogICAqCiAgICogQ2Fubm90IGNvbnRhaW4gcGF0aCBzZXBhcmF0b3JzIChgJy8nYCBvbiB1bml4LCBtYWNPUywgYW5kIGJyb3dzZXJzLCBgJ1wnYAogICAqIG9uIHdpbmRvd3MpLgogICAqIENhbm5vdCBiZSBudWxsaWZpZWQgKHVzZSBgZmlsZS5wYXRoID0gZmlsZS5kaXJuYW1lYCBpbnN0ZWFkKS4KICAgKgogICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlbmFtZQogICAqICAgQmFzZW5hbWUuCiAgICogQHJldHVybnMge3VuZGVmaW5lZH0KICAgKiAgIE5vdGhpbmcuCiAgICovCiAgc2V0IGJhc2VuYW1lKGJhc2VuYW1lMikgewogICAgYXNzZXJ0Tm9uRW1wdHkoYmFzZW5hbWUyLCAiYmFzZW5hbWUiKTsKICAgIGFzc2VydFBhcnQoYmFzZW5hbWUyLCAiYmFzZW5hbWUiKTsKICAgIHRoaXMucGF0aCA9IG1pbnBhdGguam9pbih0aGlzLmRpcm5hbWUgfHwgIiIsIGJhc2VuYW1lMik7CiAgfQogIC8qKgogICAqIEdldCB0aGUgcGFyZW50IHBhdGggKGV4YW1wbGU6IGAnfidgKS4KICAgKgogICAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9CiAgICogICBEaXJuYW1lLgogICAqLwogIGdldCBkaXJuYW1lKCkgewogICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBhdGggPT09ICJzdHJpbmciID8gbWlucGF0aC5kaXJuYW1lKHRoaXMucGF0aCkgOiB2b2lkIDA7CiAgfQogIC8qKgogICAqIFNldCB0aGUgcGFyZW50IHBhdGggKGV4YW1wbGU6IGAnfidgKS4KICAgKgogICAqIENhbm5vdCBiZSBzZXQgaWYgdGhlcmXigJlzIG5vIGBwYXRoYCB5ZXQuCiAgICoKICAgKiBAcGFyYW0ge3N0cmluZyB8IHVuZGVmaW5lZH0gZGlybmFtZQogICAqICAgRGlybmFtZS4KICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfQogICAqICAgTm90aGluZy4KICAgKi8KICBzZXQgZGlybmFtZShkaXJuYW1lMikgewogICAgYXNzZXJ0UGF0aDIodGhpcy5iYXNlbmFtZSwgImRpcm5hbWUiKTsKICAgIHRoaXMucGF0aCA9IG1pbnBhdGguam9pbihkaXJuYW1lMiB8fCAiIiwgdGhpcy5iYXNlbmFtZSk7CiAgfQogIC8qKgogICAqIEdldCB0aGUgZXh0bmFtZSAoaW5jbHVkaW5nIGRvdCkgKGV4YW1wbGU6IGAnLmpzJ2ApLgogICAqCiAgICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0KICAgKiAgIEV4dG5hbWUuCiAgICovCiAgZ2V0IGV4dG5hbWUoKSB7CiAgICByZXR1cm4gdHlwZW9mIHRoaXMucGF0aCA9PT0gInN0cmluZyIgPyBtaW5wYXRoLmV4dG5hbWUodGhpcy5wYXRoKSA6IHZvaWQgMDsKICB9CiAgLyoqCiAgICogU2V0IHRoZSBleHRuYW1lIChpbmNsdWRpbmcgZG90KSAoZXhhbXBsZTogYCcuanMnYCkuCiAgICoKICAgKiBDYW5ub3QgY29udGFpbiBwYXRoIHNlcGFyYXRvcnMgKGAnLydgIG9uIHVuaXgsIG1hY09TLCBhbmQgYnJvd3NlcnMsIGAnXCdgCiAgICogb24gd2luZG93cykuCiAgICogQ2Fubm90IGJlIHNldCBpZiB0aGVyZeKAmXMgbm8gYHBhdGhgIHlldC4KICAgKgogICAqIEBwYXJhbSB7c3RyaW5nIHwgdW5kZWZpbmVkfSBleHRuYW1lCiAgICogICBFeHRuYW1lLgogICAqIEByZXR1cm5zIHt1bmRlZmluZWR9CiAgICogICBOb3RoaW5nLgogICAqLwogIHNldCBleHRuYW1lKGV4dG5hbWUyKSB7CiAgICBhc3NlcnRQYXJ0KGV4dG5hbWUyLCAiZXh0bmFtZSIpOwogICAgYXNzZXJ0UGF0aDIodGhpcy5kaXJuYW1lLCAiZXh0bmFtZSIpOwogICAgaWYgKGV4dG5hbWUyKSB7CiAgICAgIGlmIChleHRuYW1lMi5jb2RlUG9pbnRBdCgwKSAhPT0gNDYpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImBleHRuYW1lYCBtdXN0IHN0YXJ0IHdpdGggYC5gIik7CiAgICAgIH0KICAgICAgaWYgKGV4dG5hbWUyLmluY2x1ZGVzKCIuIiwgMSkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoImBleHRuYW1lYCBjYW5ub3QgY29udGFpbiBtdWx0aXBsZSBkb3RzIik7CiAgICAgIH0KICAgIH0KICAgIHRoaXMucGF0aCA9IG1pbnBhdGguam9pbih0aGlzLmRpcm5hbWUsIHRoaXMuc3RlbSArIChleHRuYW1lMiB8fCAiIikpOwogIH0KICAvKioKICAgKiBHZXQgdGhlIGZ1bGwgcGF0aCAoZXhhbXBsZTogYCd+L2luZGV4Lm1pbi5qcydgKS4KICAgKgogICAqIEByZXR1cm5zIHtzdHJpbmd9CiAgICogICBQYXRoLgogICAqLwogIGdldCBwYXRoKCkgewogICAgcmV0dXJuIHRoaXMuaGlzdG9yeVt0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMV07CiAgfQogIC8qKgogICAqIFNldCB0aGUgZnVsbCBwYXRoIChleGFtcGxlOiBgJ34vaW5kZXgubWluLmpzJ2ApLgogICAqCiAgICogQ2Fubm90IGJlIG51bGxpZmllZC4KICAgKiBZb3UgY2FuIHNldCBhIGZpbGUgVVJMIChhIGBVUkxgIG9iamVjdCB3aXRoIGEgYGZpbGU6YCBwcm90b2NvbCkgd2hpY2ggd2lsbAogICAqIGJlIHR1cm5lZCBpbnRvIGEgcGF0aCB3aXRoIGB1cmwuZmlsZVVSTFRvUGF0aGAuCiAgICoKICAgKiBAcGFyYW0ge1VSTCB8IHN0cmluZ30gcGF0aAogICAqICAgUGF0aC4KICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfQogICAqICAgTm90aGluZy4KICAgKi8KICBzZXQgcGF0aChwYXRoKSB7CiAgICBpZiAoaXNVcmwocGF0aCkpIHsKICAgICAgcGF0aCA9IHVybFRvUGF0aChwYXRoKTsKICAgIH0KICAgIGFzc2VydE5vbkVtcHR5KHBhdGgsICJwYXRoIik7CiAgICBpZiAodGhpcy5wYXRoICE9PSBwYXRoKSB7CiAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHBhdGgpOwogICAgfQogIH0KICAvKioKICAgKiBHZXQgdGhlIHN0ZW0gKGJhc2VuYW1lIHcvbyBleHRuYW1lKSAoZXhhbXBsZTogYCdpbmRleC5taW4nYCkuCiAgICoKICAgKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfQogICAqICAgU3RlbS4KICAgKi8KICBnZXQgc3RlbSgpIHsKICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09PSAic3RyaW5nIiA/IG1pbnBhdGguYmFzZW5hbWUodGhpcy5wYXRoLCB0aGlzLmV4dG5hbWUpIDogdm9pZCAwOwogIH0KICAvKioKICAgKiBTZXQgdGhlIHN0ZW0gKGJhc2VuYW1lIHcvbyBleHRuYW1lKSAoZXhhbXBsZTogYCdpbmRleC5taW4nYCkuCiAgICoKICAgKiBDYW5ub3QgY29udGFpbiBwYXRoIHNlcGFyYXRvcnMgKGAnLydgIG9uIHVuaXgsIG1hY09TLCBhbmQgYnJvd3NlcnMsIGAnXCdgCiAgICogb24gd2luZG93cykuCiAgICogQ2Fubm90IGJlIG51bGxpZmllZCAodXNlIGBmaWxlLnBhdGggPSBmaWxlLmRpcm5hbWVgIGluc3RlYWQpLgogICAqCiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ZW0KICAgKiAgIFN0ZW0uCiAgICogQHJldHVybnMge3VuZGVmaW5lZH0KICAgKiAgIE5vdGhpbmcuCiAgICovCiAgc2V0IHN0ZW0oc3RlbSkgewogICAgYXNzZXJ0Tm9uRW1wdHkoc3RlbSwgInN0ZW0iKTsKICAgIGFzc2VydFBhcnQoc3RlbSwgInN0ZW0iKTsKICAgIHRoaXMucGF0aCA9IG1pbnBhdGguam9pbih0aGlzLmRpcm5hbWUgfHwgIiIsIHN0ZW0gKyAodGhpcy5leHRuYW1lIHx8ICIiKSk7CiAgfQogIC8vIE5vcm1hbCBwcm90b3R5cGFsIG1ldGhvZHMuCiAgLyoqCiAgICogQ3JlYXRlIGEgZmF0YWwgbWVzc2FnZSBmb3IgYHJlYXNvbmAgYXNzb2NpYXRlZCB3aXRoIHRoZSBmaWxlLgogICAqCiAgICogVGhlIGBmYXRhbGAgZmllbGQgb2YgdGhlIG1lc3NhZ2UgaXMgc2V0IHRvIGB0cnVlYCAoZXJyb3I7IGZpbGUgbm90IHVzYWJsZSkKICAgKiBhbmQgdGhlIGBmaWxlYCBmaWVsZCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgZmlsZSBwYXRoLgogICAqIFRoZSBtZXNzYWdlIGlzIGFkZGVkIHRvIHRoZSBgbWVzc2FnZXNgIGZpZWxkIG9uIGBmaWxlYC4KICAgKgogICAqID4g8J+qpiAqKk5vdGUqKjogYWxzbyBoYXMgb2Jzb2xldGUgc2lnbmF0dXJlcy4KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24KICAgKiBAcGFyYW0ge01lc3NhZ2VPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdCiAgICogQHJldHVybnMge25ldmVyfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbgogICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGFyZW50CiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zIHtuZXZlcn0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24KICAgKiBAcGFyYW0ge1BvaW50IHwgUG9zaXRpb24gfCBudWxsIHwgdW5kZWZpbmVkfSBwbGFjZQogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7bmV2ZXJ9CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uCiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zIHtuZXZlcn0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2V9IGNhdXNlCiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXJlbnQKICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge25ldmVyfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2UKICAgKiBAcGFyYW0ge1BvaW50IHwgUG9zaXRpb24gfCBudWxsIHwgdW5kZWZpbmVkfSBwbGFjZQogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7bmV2ZXJ9CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlfSBjYXVzZQogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7bmV2ZXJ9CiAgICoKICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlIHwgc3RyaW5nfSBjYXVzZU9yUmVhc29uCiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHNob3VsZCB1c2UgbWFya2Rvd24uCiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBNZXNzYWdlT3B0aW9ucyB8IFBvaW50IHwgUG9zaXRpb24gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc09yUGFyZW50T3JQbGFjZV0KICAgKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS4KICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6CiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS4KICAgKiBAcmV0dXJucyB7bmV2ZXJ9CiAgICogICBOZXZlci4KICAgKiBAdGhyb3dzIHtWRmlsZU1lc3NhZ2V9CiAgICogICBNZXNzYWdlLgogICAqLwogIGZhaWwoY2F1c2VPclJlYXNvbiwgb3B0aW9uc09yUGFyZW50T3JQbGFjZSwgb3JpZ2luKSB7CiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5tZXNzYWdlKGNhdXNlT3JSZWFzb24sIG9wdGlvbnNPclBhcmVudE9yUGxhY2UsIG9yaWdpbik7CiAgICBtZXNzYWdlLmZhdGFsID0gdHJ1ZTsKICAgIHRocm93IG1lc3NhZ2U7CiAgfQogIC8qKgogICAqIENyZWF0ZSBhbiBpbmZvIG1lc3NhZ2UgZm9yIGByZWFzb25gIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZS4KICAgKgogICAqIFRoZSBgZmF0YWxgIGZpZWxkIG9mIHRoZSBtZXNzYWdlIGlzIHNldCB0byBgdW5kZWZpbmVkYCAoaW5mbzsgY2hhbmdlCiAgICogbGlrZWx5IG5vdCBuZWVkZWQpIGFuZCB0aGUgYGZpbGVgIGZpZWxkIGlzIHNldCB0byB0aGUgY3VycmVudCBmaWxlIHBhdGguCiAgICogVGhlIG1lc3NhZ2UgaXMgYWRkZWQgdG8gdGhlIGBtZXNzYWdlc2AgZmllbGQgb24gYGZpbGVgLgogICAqCiAgICogPiDwn6qmICoqTm90ZSoqOiBhbHNvIGhhcyBvYnNvbGV0ZSBzaWduYXR1cmVzLgogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbgogICAqIEBwYXJhbSB7TWVzc2FnZU9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc10KICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbgogICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGFyZW50CiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uCiAgICogQHBhcmFtIHtQb2ludCB8IFBvc2l0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGxhY2UKICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24KICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2V9IGNhdXNlCiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXJlbnQKICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2V9IGNhdXNlCiAgICogQHBhcmFtIHtQb2ludCB8IFBvc2l0aW9uIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGxhY2UKICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2V9IGNhdXNlCiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXQogICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9CiAgICoKICAgKiBAcGFyYW0ge0Vycm9yIHwgVkZpbGVNZXNzYWdlIHwgc3RyaW5nfSBjYXVzZU9yUmVhc29uCiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHNob3VsZCB1c2UgbWFya2Rvd24uCiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBNZXNzYWdlT3B0aW9ucyB8IFBvaW50IHwgUG9zaXRpb24gfCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc09yUGFyZW50T3JQbGFjZV0KICAgKiAgIENvbmZpZ3VyYXRpb24gKG9wdGlvbmFsKS4KICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6CiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS4KICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfQogICAqICAgTWVzc2FnZS4KICAgKi8KICBpbmZvKGNhdXNlT3JSZWFzb24sIG9wdGlvbnNPclBhcmVudE9yUGxhY2UsIG9yaWdpbikgewogICAgY29uc3QgbWVzc2FnZSA9IHRoaXMubWVzc2FnZShjYXVzZU9yUmVhc29uLCBvcHRpb25zT3JQYXJlbnRPclBsYWNlLCBvcmlnaW4pOwogICAgbWVzc2FnZS5mYXRhbCA9IHZvaWQgMDsKICAgIHJldHVybiBtZXNzYWdlOwogIH0KICAvKioKICAgKiBDcmVhdGUgYSBtZXNzYWdlIGZvciBgcmVhc29uYCBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuCiAgICoKICAgKiBUaGUgYGZhdGFsYCBmaWVsZCBvZiB0aGUgbWVzc2FnZSBpcyBzZXQgdG8gYGZhbHNlYCAod2FybmluZzsgY2hhbmdlIG1heSBiZQogICAqIG5lZWRlZCkgYW5kIHRoZSBgZmlsZWAgZmllbGQgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGZpbGUgcGF0aC4KICAgKiBUaGUgbWVzc2FnZSBpcyBhZGRlZCB0byB0aGUgYG1lc3NhZ2VzYCBmaWVsZCBvbiBgZmlsZWAuCiAgICoKICAgKiA+IPCfqqYgKipOb3RlKio6IGFsc28gaGFzIG9ic29sZXRlIHNpZ25hdHVyZXMuCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uCiAgICogQHBhcmFtIHtNZXNzYWdlT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zXQogICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uCiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBudWxsIHwgdW5kZWZpbmVkfSBwYXJlbnQKICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7c3RyaW5nfSByZWFzb24KICAgKiBAcGFyYW0ge1BvaW50IHwgUG9zaXRpb24gfCBudWxsIHwgdW5kZWZpbmVkfSBwbGFjZQogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvbgogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2UKICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IG51bGwgfCB1bmRlZmluZWR9IHBhcmVudAogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2UKICAgKiBAcGFyYW0ge1BvaW50IHwgUG9zaXRpb24gfCBudWxsIHwgdW5kZWZpbmVkfSBwbGFjZQogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtFcnJvciB8IFZGaWxlTWVzc2FnZX0gY2F1c2UKICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dCiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX0KICAgKgogICAqIEBwYXJhbSB7RXJyb3IgfCBWRmlsZU1lc3NhZ2UgfCBzdHJpbmd9IGNhdXNlT3JSZWFzb24KICAgKiAgIFJlYXNvbiBmb3IgbWVzc2FnZSwgc2hvdWxkIHVzZSBtYXJrZG93bi4KICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IE1lc3NhZ2VPcHRpb25zIHwgUG9pbnQgfCBQb3NpdGlvbiB8IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcHRpb25zT3JQYXJlbnRPclBsYWNlXQogICAqICAgQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpLgogICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl0KICAgKiAgIFBsYWNlIGluIGNvZGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb3JpZ2luYXRlcyAoZXhhbXBsZToKICAgKiAgIGAnbXktcGFja2FnZTpteS1ydWxlJ2Agb3IgYCdteS1ydWxlJ2ApLgogICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9CiAgICogICBNZXNzYWdlLgogICAqLwogIG1lc3NhZ2UoY2F1c2VPclJlYXNvbiwgb3B0aW9uc09yUGFyZW50T3JQbGFjZSwgb3JpZ2luKSB7CiAgICBjb25zdCBtZXNzYWdlID0gbmV3IFZGaWxlTWVzc2FnZSgKICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogdGhlIG92ZXJsb2FkcyBhcmUgZmluZS4KICAgICAgY2F1c2VPclJlYXNvbiwKICAgICAgb3B0aW9uc09yUGFyZW50T3JQbGFjZSwKICAgICAgb3JpZ2luCiAgICApOwogICAgaWYgKHRoaXMucGF0aCkgewogICAgICBtZXNzYWdlLm5hbWUgPSB0aGlzLnBhdGggKyAiOiIgKyBtZXNzYWdlLm5hbWU7CiAgICAgIG1lc3NhZ2UuZmlsZSA9IHRoaXMucGF0aDsKICAgIH0KICAgIG1lc3NhZ2UuZmF0YWwgPSBmYWxzZTsKICAgIHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTsKICAgIHJldHVybiBtZXNzYWdlOwogIH0KICAvKioKICAgKiBTZXJpYWxpemUgdGhlIGZpbGUuCiAgICoKICAgKiA+ICoqTm90ZSoqOiB3aGljaCBlbmNvZGluZ3MgYXJlIHN1cHBvcnRlZCBkZXBlbmRzIG9uIHRoZSBlbmdpbmUuCiAgICogPiBGb3IgaW5mbyBvbiBOb2RlLmpzLCBzZWU6CiAgICogPiA8aHR0cHM6Ly9ub2RlanMub3JnL2FwaS91dGlsLmh0bWwjd2hhdHdnLXN1cHBvcnRlZC1lbmNvZGluZ3M+LgogICAqCiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbZW5jb2Rpbmc9J3V0ZjgnXQogICAqICAgQ2hhcmFjdGVyIGVuY29kaW5nIHRvIHVuZGVyc3RhbmQgYHZhbHVlYCBhcyB3aGVuIGl04oCZcyBhIGBVaW50OEFycmF5YAogICAqICAgKGRlZmF1bHQ6IGAndXRmLTgnYCkuCiAgICogQHJldHVybnMge3N0cmluZ30KICAgKiAgIFNlcmlhbGl6ZWQgZmlsZS4KICAgKi8KICB0b1N0cmluZyhlbmNvZGluZykgewogICAgaWYgKHRoaXMudmFsdWUgPT09IHZvaWQgMCkgewogICAgICByZXR1cm4gIiI7CiAgICB9CiAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICJzdHJpbmciKSB7CiAgICAgIHJldHVybiB0aGlzLnZhbHVlOwogICAgfQogICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZyB8fCB2b2lkIDApOwogICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKHRoaXMudmFsdWUpOwogIH0KfTsKZnVuY3Rpb24gYXNzZXJ0UGFydChwYXJ0LCBuYW1lMikgewogIGlmIChwYXJ0ICYmIHBhcnQuaW5jbHVkZXMobWlucGF0aC5zZXApKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICJgIiArIG5hbWUyICsgImAgY2Fubm90IGJlIGEgcGF0aDogZGlkIG5vdCBleHBlY3QgYCIgKyBtaW5wYXRoLnNlcCArICJgIgogICAgKTsKICB9Cn0KZnVuY3Rpb24gYXNzZXJ0Tm9uRW1wdHkocGFydCwgbmFtZTIpIHsKICBpZiAoIXBhcnQpIHsKICAgIHRocm93IG5ldyBFcnJvcigiYCIgKyBuYW1lMiArICJgIGNhbm5vdCBiZSBlbXB0eSIpOwogIH0KfQpmdW5jdGlvbiBhc3NlcnRQYXRoMihwYXRoLCBuYW1lMikgewogIGlmICghcGF0aCkgewogICAgdGhyb3cgbmV3IEVycm9yKCJTZXR0aW5nIGAiICsgbmFtZTIgKyAiYCByZXF1aXJlcyBgcGF0aGAgdG8gYmUgc2V0IHRvbyIpOwogIH0KfQpmdW5jdGlvbiBpc1VpbnQ4QXJyYXkodmFsdWUpIHsKICByZXR1cm4gQm9vbGVhbigKICAgIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gIm9iamVjdCIgJiYgImJ5dGVMZW5ndGgiIGluIHZhbHVlICYmICJieXRlT2Zmc2V0IiBpbiB2YWx1ZQogICk7Cn0KCi8vIG5vZGVfbW9kdWxlcy91bmlmaWVkL2xpYi9jYWxsYWJsZS1pbnN0YW5jZS5qcwp2YXIgQ2FsbGFibGVJbnN0YW5jZSA9ICgKICAvKioKICAgKiBAdHlwZSB7bmV3IDxQYXJhbWV0ZXJzIGV4dGVuZHMgQXJyYXk8dW5rbm93bj4sIFJlc3VsdD4ocHJvcGVydHk6IHN0cmluZyB8IHN5bWJvbCkgPT4gKC4uLnBhcmFtZXRlcnM6IFBhcmFtZXRlcnMpID0+IFJlc3VsdH0KICAgKi8KICAvKiogQHR5cGUge3Vua25vd259ICovCiAgLyoqCiAgICogQHRoaXMge0Z1bmN0aW9ufQogICAqIEBwYXJhbSB7c3RyaW5nIHwgc3ltYm9sfSBwcm9wZXJ0eQogICAqIEByZXR1cm5zIHsoLi4ucGFyYW1ldGVyczogQXJyYXk8dW5rbm93bj4pID0+IHVua25vd259CiAgICovCiAgZnVuY3Rpb24ocHJvcGVydHkpIHsKICAgIGNvbnN0IHNlbGYgPSB0aGlzOwogICAgY29uc3QgY29uc3RyID0gc2VsZi5jb25zdHJ1Y3RvcjsKICAgIGNvbnN0IHByb3RvID0gKAogICAgICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcgfCBzeW1ib2wsIEZ1bmN0aW9uPn0gKi8KICAgICAgLy8gUHJvdG90eXBlcyBkbyBleGlzdC4KICAgICAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lCiAgICAgIGNvbnN0ci5wcm90b3R5cGUKICAgICk7CiAgICBjb25zdCB2YWx1ZSA9IHByb3RvW3Byb3BlcnR5XTsKICAgIGNvbnN0IGFwcGx5ID0gZnVuY3Rpb24oKSB7CiAgICAgIHJldHVybiB2YWx1ZS5hcHBseShhcHBseSwgYXJndW1lbnRzKTsKICAgIH07CiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXBwbHksIHByb3RvKTsKICAgIHJldHVybiBhcHBseTsKICB9Cik7CgovLyBub2RlX21vZHVsZXMvdW5pZmllZC9saWIvaW5kZXguanMKdmFyIG93bjQgPSB7fS5oYXNPd25Qcm9wZXJ0eTsKdmFyIFByb2Nlc3NvciA9IGNsYXNzIF9Qcm9jZXNzb3IgZXh0ZW5kcyBDYWxsYWJsZUluc3RhbmNlIHsKICAvKioKICAgKiBDcmVhdGUgYSBwcm9jZXNzb3IuCiAgICovCiAgY29uc3RydWN0b3IoKSB7CiAgICBzdXBlcigiY29weSIpOwogICAgdGhpcy5Db21waWxlciA9IHZvaWQgMDsKICAgIHRoaXMuUGFyc2VyID0gdm9pZCAwOwogICAgdGhpcy5hdHRhY2hlcnMgPSBbXTsKICAgIHRoaXMuY29tcGlsZXIgPSB2b2lkIDA7CiAgICB0aGlzLmZyZWV6ZUluZGV4ID0gLTE7CiAgICB0aGlzLmZyb3plbiA9IHZvaWQgMDsKICAgIHRoaXMubmFtZXNwYWNlID0ge307CiAgICB0aGlzLnBhcnNlciA9IHZvaWQgMDsKICAgIHRoaXMudHJhbnNmb3JtZXJzID0gdHJvdWdoKCk7CiAgfQogIC8qKgogICAqIENvcHkgYSBwcm9jZXNzb3IuCiAgICoKICAgKiBAZGVwcmVjYXRlZAogICAqICAgVGhpcyBpcyBhIHByaXZhdGUgaW50ZXJuYWwgbWV0aG9kIGFuZCBzaG91bGQgbm90IGJlIHVzZWQuCiAgICogQHJldHVybnMge1Byb2Nlc3NvcjxQYXJzZVRyZWUsIEhlYWRUcmVlLCBUYWlsVHJlZSwgQ29tcGlsZVRyZWUsIENvbXBpbGVSZXN1bHQ+fQogICAqICAgTmV3ICp1bmZyb3plbiogcHJvY2Vzc29yICh7QGxpbmtjb2RlIFByb2Nlc3Nvcn0pIHRoYXQgaXMKICAgKiAgIGNvbmZpZ3VyZWQgdG8gd29yayB0aGUgc2FtZSBhcyBpdHMgYW5jZXN0b3IuCiAgICogICBXaGVuIHRoZSBkZXNjZW5kYW50IHByb2Nlc3NvciBpcyBjb25maWd1cmVkIGluIHRoZSBmdXR1cmUgaXQgZG9lcyBub3QKICAgKiAgIGFmZmVjdCB0aGUgYW5jZXN0cmFsIHByb2Nlc3Nvci4KICAgKi8KICBjb3B5KCkgewogICAgY29uc3QgZGVzdGluYXRpb24gPSAoCiAgICAgIC8qKiBAdHlwZSB7UHJvY2Vzc29yPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdD59ICovCiAgICAgIG5ldyBfUHJvY2Vzc29yKCkKICAgICk7CiAgICBsZXQgaW5kZXgyID0gLTE7CiAgICB3aGlsZSAoKytpbmRleDIgPCB0aGlzLmF0dGFjaGVycy5sZW5ndGgpIHsKICAgICAgY29uc3QgYXR0YWNoZXIgPSB0aGlzLmF0dGFjaGVyc1tpbmRleDJdOwogICAgICBkZXN0aW5hdGlvbi51c2UoLi4uYXR0YWNoZXIpOwogICAgfQogICAgZGVzdGluYXRpb24uZGF0YSgoMCwgaW1wb3J0X2V4dGVuZC5kZWZhdWx0KSh0cnVlLCB7fSwgdGhpcy5uYW1lc3BhY2UpKTsKICAgIHJldHVybiBkZXN0aW5hdGlvbjsKICB9CiAgLyoqCiAgICogQ29uZmlndXJlIHRoZSBwcm9jZXNzb3Igd2l0aCBpbmZvIGF2YWlsYWJsZSB0byBhbGwgcGx1Z2lucy4KICAgKiBJbmZvcm1hdGlvbiBpcyBzdG9yZWQgaW4gYW4gb2JqZWN0LgogICAqCiAgICogVHlwaWNhbGx5LCBvcHRpb25zIGNhbiBiZSBnaXZlbiB0byBhIHNwZWNpZmljIHBsdWdpbiwgYnV0IHNvbWV0aW1lcyBpdAogICAqIG1ha2VzIHNlbnNlIHRvIGhhdmUgaW5mb3JtYXRpb24gc2hhcmVkIHdpdGggc2V2ZXJhbCBwbHVnaW5zLgogICAqIEZvciBleGFtcGxlLCBhIGxpc3Qgb2YgSFRNTCBlbGVtZW50cyB0aGF0IGFyZSBzZWxmLWNsb3NpbmcsIHdoaWNoIGlzCiAgICogbmVlZGVkIGR1cmluZyBhbGwgcGhhc2VzLgogICAqCiAgICogPiAqKk5vdGUqKjogc2V0dGluZyBpbmZvcm1hdGlvbiBjYW5ub3Qgb2NjdXIgb24gKmZyb3plbiogcHJvY2Vzc29ycy4KICAgKiA+IENhbGwgdGhlIHByb2Nlc3NvciBmaXJzdCB0byBjcmVhdGUgYSBuZXcgdW5mcm96ZW4gcHJvY2Vzc29yLgogICAqCiAgICogPiAqKk5vdGUqKjogdG8gcmVnaXN0ZXIgY3VzdG9tIGRhdGEgaW4gVHlwZVNjcmlwdCwgYXVnbWVudCB0aGUKICAgKiA+IHtAbGlua2NvZGUgRGF0YX0gaW50ZXJmYWNlLgogICAqCiAgICogQGV4YW1wbGUKICAgKiAgIFRoaXMgZXhhbXBsZSBzaG93IGhvdyB0byBnZXQgYW5kIHNldCBpbmZvOgogICAqCiAgICogICBgYGBqcwogICAqICAgaW1wb3J0IHt1bmlmaWVkfSBmcm9tICd1bmlmaWVkJwogICAqCiAgICogICBjb25zdCBwcm9jZXNzb3IgPSB1bmlmaWVkKCkuZGF0YSgnYWxwaGEnLCAnYnJhdm8nKQogICAqCiAgICogICBwcm9jZXNzb3IuZGF0YSgnYWxwaGEnKSAvLyA9PiAnYnJhdm8nCiAgICoKICAgKiAgIHByb2Nlc3Nvci5kYXRhKCkgLy8gPT4ge2FscGhhOiAnYnJhdm8nfQogICAqCiAgICogICBwcm9jZXNzb3IuZGF0YSh7Y2hhcmxpZTogJ2RlbHRhJ30pCiAgICoKICAgKiAgIHByb2Nlc3Nvci5kYXRhKCkgLy8gPT4ge2NoYXJsaWU6ICdkZWx0YSd9CiAgICogICBgYGAKICAgKgogICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRGF0YX0gS2V5CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcmV0dXJucyB7RGF0YX0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7RGF0YX0gZGF0YXNldAogICAqIEByZXR1cm5zIHtQcm9jZXNzb3I8UGFyc2VUcmVlLCBIZWFkVHJlZSwgVGFpbFRyZWUsIENvbXBpbGVUcmVlLCBDb21waWxlUmVzdWx0Pn0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7S2V5fSBrZXkKICAgKiBAcmV0dXJucyB7RGF0YVtLZXldfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtLZXl9IGtleQogICAqIEBwYXJhbSB7RGF0YVtLZXldfSB2YWx1ZQogICAqIEByZXR1cm5zIHtQcm9jZXNzb3I8UGFyc2VUcmVlLCBIZWFkVHJlZSwgVGFpbFRyZWUsIENvbXBpbGVUcmVlLCBDb21waWxlUmVzdWx0Pn0KICAgKgogICAqIEBwYXJhbSB7RGF0YSB8IEtleX0gW2tleV0KICAgKiAgIEtleSB0byBnZXQgb3Igc2V0LCBvciBlbnRpcmUgZGF0YXNldCB0byBzZXQsIG9yIG5vdGhpbmcgdG8gZ2V0IHRoZQogICAqICAgZW50aXJlIGRhdGFzZXQgKG9wdGlvbmFsKS4KICAgKiBAcGFyYW0ge0RhdGFbS2V5XX0gW3ZhbHVlXQogICAqICAgVmFsdWUgdG8gc2V0IChvcHRpb25hbCkuCiAgICogQHJldHVybnMge3Vua25vd259CiAgICogICBUaGUgY3VycmVudCBwcm9jZXNzb3Igd2hlbiBzZXR0aW5nLCB0aGUgdmFsdWUgYXQgYGtleWAgd2hlbiBnZXR0aW5nLCBvcgogICAqICAgdGhlIGVudGlyZSBkYXRhc2V0IHdoZW4gZ2V0dGluZyB3aXRob3V0IGtleS4KICAgKi8KICBkYXRhKGtleSwgdmFsdWUpIHsKICAgIGlmICh0eXBlb2Yga2V5ID09PSAic3RyaW5nIikgewogICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgewogICAgICAgIGFzc2VydFVuZnJvemVuKCJkYXRhIiwgdGhpcy5mcm96ZW4pOwogICAgICAgIHRoaXMubmFtZXNwYWNlW2tleV0gPSB2YWx1ZTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfQogICAgICByZXR1cm4gb3duNC5jYWxsKHRoaXMubmFtZXNwYWNlLCBrZXkpICYmIHRoaXMubmFtZXNwYWNlW2tleV0gfHwgdm9pZCAwOwogICAgfQogICAgaWYgKGtleSkgewogICAgICBhc3NlcnRVbmZyb3plbigiZGF0YSIsIHRoaXMuZnJvemVuKTsKICAgICAgdGhpcy5uYW1lc3BhY2UgPSBrZXk7CiAgICAgIHJldHVybiB0aGlzOwogICAgfQogICAgcmV0dXJuIHRoaXMubmFtZXNwYWNlOwogIH0KICAvKioKICAgKiBGcmVlemUgYSBwcm9jZXNzb3IuCiAgICoKICAgKiBGcm96ZW4gcHJvY2Vzc29ycyBhcmUgbWVhbnQgdG8gYmUgZXh0ZW5kZWQgYW5kIG5vdCB0byBiZSBjb25maWd1cmVkCiAgICogZGlyZWN0bHkuCiAgICoKICAgKiBXaGVuIGEgcHJvY2Vzc29yIGlzIGZyb3plbiBpdCBjYW5ub3QgYmUgdW5mcm96ZW4uCiAgICogTmV3IHByb2Nlc3NvcnMgd29ya2luZyB0aGUgc2FtZSB3YXkgY2FuIGJlIGNyZWF0ZWQgYnkgY2FsbGluZyB0aGUKICAgKiBwcm9jZXNzb3IuCiAgICoKICAgKiBJdOKAmXMgcG9zc2libGUgdG8gZnJlZXplIHByb2Nlc3NvcnMgZXhwbGljaXRseSBieSBjYWxsaW5nIGAuZnJlZXplKClgLgogICAqIFByb2Nlc3NvcnMgZnJlZXplIGF1dG9tYXRpY2FsbHkgd2hlbiBgLnBhcnNlKClgLCBgLnJ1bigpYCwgYC5ydW5TeW5jKClgLAogICAqIGAuc3RyaW5naWZ5KClgLCBgLnByb2Nlc3MoKWAsIG9yIGAucHJvY2Vzc1N5bmMoKWAgYXJlIGNhbGxlZC4KICAgKgogICAqIEByZXR1cm5zIHtQcm9jZXNzb3I8UGFyc2VUcmVlLCBIZWFkVHJlZSwgVGFpbFRyZWUsIENvbXBpbGVUcmVlLCBDb21waWxlUmVzdWx0Pn0KICAgKiAgIFRoZSBjdXJyZW50IHByb2Nlc3Nvci4KICAgKi8KICBmcmVlemUoKSB7CiAgICBpZiAodGhpcy5mcm96ZW4pIHsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9CiAgICBjb25zdCBzZWxmID0gKAogICAgICAvKiogQHR5cGUge1Byb2Nlc3Nvcn0gKi8KICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqLwogICAgICB0aGlzCiAgICApOwogICAgd2hpbGUgKCsrdGhpcy5mcmVlemVJbmRleCA8IHRoaXMuYXR0YWNoZXJzLmxlbmd0aCkgewogICAgICBjb25zdCBbYXR0YWNoZXIsIC4uLm9wdGlvbnNdID0gdGhpcy5hdHRhY2hlcnNbdGhpcy5mcmVlemVJbmRleF07CiAgICAgIGlmIChvcHRpb25zWzBdID09PSBmYWxzZSkgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIGlmIChvcHRpb25zWzBdID09PSB0cnVlKSB7CiAgICAgICAgb3B0aW9uc1swXSA9IHZvaWQgMDsKICAgICAgfQogICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGF0dGFjaGVyLmNhbGwoc2VsZiwgLi4ub3B0aW9ucyk7CiAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtZXIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICB0aGlzLnRyYW5zZm9ybWVycy51c2UodHJhbnNmb3JtZXIpOwogICAgICB9CiAgICB9CiAgICB0aGlzLmZyb3plbiA9IHRydWU7CiAgICB0aGlzLmZyZWV6ZUluZGV4ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOwogICAgcmV0dXJuIHRoaXM7CiAgfQogIC8qKgogICAqIFBhcnNlIHRleHQgdG8gYSBzeW50YXggdHJlZS4KICAgKgogICAqID4gKipOb3RlKio6IGBwYXJzZWAgZnJlZXplcyB0aGUgcHJvY2Vzc29yIGlmIG5vdCBhbHJlYWR5ICpmcm96ZW4qLgogICAqCiAgICogPiAqKk5vdGUqKjogYHBhcnNlYCBwZXJmb3JtcyB0aGUgcGFyc2UgcGhhc2UsIG5vdCB0aGUgcnVuIHBoYXNlIG9yIG90aGVyCiAgICogPiBwaGFzZXMuCiAgICoKICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXQogICAqICAgZmlsZSB0byBwYXJzZSAob3B0aW9uYWwpOyB0eXBpY2FsbHkgYHN0cmluZ2Agb3IgYFZGaWxlYDsgYW55IHZhbHVlCiAgICogICBhY2NlcHRlZCBhcyBgeGAgaW4gYG5ldyBWRmlsZSh4KWAuCiAgICogQHJldHVybnMge1BhcnNlVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBQYXJzZVRyZWV9CiAgICogICBTeW50YXggdHJlZSByZXByZXNlbnRpbmcgYGZpbGVgLgogICAqLwogIHBhcnNlKGZpbGUpIHsKICAgIHRoaXMuZnJlZXplKCk7CiAgICBjb25zdCByZWFsRmlsZSA9IHZmaWxlKGZpbGUpOwogICAgY29uc3QgcGFyc2VyID0gdGhpcy5wYXJzZXIgfHwgdGhpcy5QYXJzZXI7CiAgICBhc3NlcnRQYXJzZXIoInBhcnNlIiwgcGFyc2VyKTsKICAgIHJldHVybiBwYXJzZXIoU3RyaW5nKHJlYWxGaWxlKSwgcmVhbEZpbGUpOwogIH0KICAvKioKICAgKiBQcm9jZXNzIHRoZSBnaXZlbiBmaWxlIGFzIGNvbmZpZ3VyZWQgb24gdGhlIHByb2Nlc3Nvci4KICAgKgogICAqID4gKipOb3RlKio6IGBwcm9jZXNzYCBmcmVlemVzIHRoZSBwcm9jZXNzb3IgaWYgbm90IGFscmVhZHkgKmZyb3plbiouCiAgICoKICAgKiA+ICoqTm90ZSoqOiBgcHJvY2Vzc2AgcGVyZm9ybXMgdGhlIHBhcnNlLCBydW4sIGFuZCBzdHJpbmdpZnkgcGhhc2VzLgogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgdW5kZWZpbmVkfSBmaWxlCiAgICogQHBhcmFtIHtQcm9jZXNzQ2FsbGJhY2s8VkZpbGVXaXRoT3V0cHV0PENvbXBpbGVSZXN1bHQ+Pn0gZG9uZQogICAqIEByZXR1cm5zIHt1bmRlZmluZWR9CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXQogICAqIEByZXR1cm5zIHtQcm9taXNlPFZGaWxlV2l0aE91dHB1dDxDb21waWxlUmVzdWx0Pj59CiAgICoKICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXQogICAqICAgRmlsZSAob3B0aW9uYWwpOyB0eXBpY2FsbHkgYHN0cmluZ2Agb3IgYFZGaWxlYF07IGFueSB2YWx1ZSBhY2NlcHRlZCBhcwogICAqICAgYHhgIGluIGBuZXcgVkZpbGUoeClgLgogICAqIEBwYXJhbSB7UHJvY2Vzc0NhbGxiYWNrPFZGaWxlV2l0aE91dHB1dDxDb21waWxlUmVzdWx0Pj4gfCB1bmRlZmluZWR9IFtkb25lXQogICAqICAgQ2FsbGJhY2sgKG9wdGlvbmFsKS4KICAgKiBAcmV0dXJucyB7UHJvbWlzZTxWRmlsZT4gfCB1bmRlZmluZWR9CiAgICogICBOb3RoaW5nIGlmIGBkb25lYCBpcyBnaXZlbi4KICAgKiAgIE90aGVyd2lzZSBhIHByb21pc2UsIHJlamVjdGVkIHdpdGggYSBmYXRhbCBlcnJvciBvciByZXNvbHZlZCB3aXRoIHRoZQogICAqICAgcHJvY2Vzc2VkIGZpbGUuCiAgICoKICAgKiAgIFRoZSBwYXJzZWQsIHRyYW5zZm9ybWVkLCBhbmQgY29tcGlsZWQgdmFsdWUgaXMgYXZhaWxhYmxlIGF0CiAgICogICBgZmlsZS52YWx1ZWAgKHNlZSBub3RlKS4KICAgKgogICAqICAgPiAqKk5vdGUqKjogdW5pZmllZCB0eXBpY2FsbHkgY29tcGlsZXMgYnkgc2VyaWFsaXppbmc6IG1vc3QKICAgKiAgID4gY29tcGlsZXJzIHJldHVybiBgc3RyaW5nYCAob3IgYFVpbnQ4QXJyYXlgKS4KICAgKiAgID4gU29tZSBjb21waWxlcnMsIHN1Y2ggYXMgdGhlIG9uZSBjb25maWd1cmVkIHdpdGgKICAgKiAgID4gW2ByZWh5cGUtcmVhY3RgXVtyZWh5cGUtcmVhY3RdLCByZXR1cm4gb3RoZXIgdmFsdWVzIChpbiB0aGlzIGNhc2UsIGEKICAgKiAgID4gUmVhY3QgdHJlZSkuCiAgICogICA+IElmIHlvdeKAmXJlIHVzaW5nIGEgY29tcGlsZXIgdGhhdCBkb2VzbuKAmXQgc2VyaWFsaXplLCBleHBlY3QgZGlmZmVyZW50CiAgICogICA+IHJlc3VsdCB2YWx1ZXMuCiAgICogICA+CiAgICogICA+IFRvIHJlZ2lzdGVyIGN1c3RvbSByZXN1bHRzIGluIFR5cGVTY3JpcHQsIGFkZCB0aGVtIHRvCiAgICogICA+IHtAbGlua2NvZGUgQ29tcGlsZVJlc3VsdE1hcH0uCiAgICoKICAgKiAgIFtyZWh5cGUtcmVhY3RdOiBodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0CiAgICovCiAgcHJvY2VzcyhmaWxlLCBkb25lKSB7CiAgICBjb25zdCBzZWxmID0gdGhpczsKICAgIHRoaXMuZnJlZXplKCk7CiAgICBhc3NlcnRQYXJzZXIoInByb2Nlc3MiLCB0aGlzLnBhcnNlciB8fCB0aGlzLlBhcnNlcik7CiAgICBhc3NlcnRDb21waWxlcigicHJvY2VzcyIsIHRoaXMuY29tcGlsZXIgfHwgdGhpcy5Db21waWxlcik7CiAgICByZXR1cm4gZG9uZSA/IGV4ZWN1dG9yKHZvaWQgMCwgZG9uZSkgOiBuZXcgUHJvbWlzZShleGVjdXRvcik7CiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHsKICAgICAgY29uc3QgcmVhbEZpbGUgPSB2ZmlsZShmaWxlKTsKICAgICAgY29uc3QgcGFyc2VUcmVlID0gKAogICAgICAgIC8qKiBAdHlwZSB7SGVhZFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogSGVhZFRyZWV9ICovCiAgICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqLwogICAgICAgIHNlbGYucGFyc2UocmVhbEZpbGUpCiAgICAgICk7CiAgICAgIHNlbGYucnVuKHBhcnNlVHJlZSwgcmVhbEZpbGUsIGZ1bmN0aW9uKGVycm9yLCB0cmVlLCBmaWxlMikgewogICAgICAgIGlmIChlcnJvciB8fCAhdHJlZSB8fCAhZmlsZTIpIHsKICAgICAgICAgIHJldHVybiByZWFsRG9uZShlcnJvcik7CiAgICAgICAgfQogICAgICAgIGNvbnN0IGNvbXBpbGVUcmVlID0gKAogICAgICAgICAgLyoqIEB0eXBlIHtDb21waWxlVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBDb21waWxlVHJlZX0gKi8KICAgICAgICAgIC8qKiBAdHlwZSB7dW5rbm93bn0gKi8KICAgICAgICAgIHRyZWUKICAgICAgICApOwogICAgICAgIGNvbnN0IGNvbXBpbGVSZXN1bHQgPSBzZWxmLnN0cmluZ2lmeShjb21waWxlVHJlZSwgZmlsZTIpOwogICAgICAgIGlmIChsb29rc0xpa2VBVmFsdWUoY29tcGlsZVJlc3VsdCkpIHsKICAgICAgICAgIGZpbGUyLnZhbHVlID0gY29tcGlsZVJlc3VsdDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgZmlsZTIucmVzdWx0ID0gY29tcGlsZVJlc3VsdDsKICAgICAgICB9CiAgICAgICAgcmVhbERvbmUoCiAgICAgICAgICBlcnJvciwKICAgICAgICAgIC8qKiBAdHlwZSB7VkZpbGVXaXRoT3V0cHV0PENvbXBpbGVSZXN1bHQ+fSAqLwogICAgICAgICAgZmlsZTIKICAgICAgICApOwogICAgICB9KTsKICAgICAgZnVuY3Rpb24gcmVhbERvbmUoZXJyb3IsIGZpbGUyKSB7CiAgICAgICAgaWYgKGVycm9yIHx8ICFmaWxlMikgewogICAgICAgICAgcmVqZWN0KGVycm9yKTsKICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmUpIHsKICAgICAgICAgIHJlc29sdmUoZmlsZTIpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvayhkb25lLCAiYGRvbmVgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdCIpOwogICAgICAgICAgZG9uZSh2b2lkIDAsIGZpbGUyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogUHJvY2VzcyB0aGUgZ2l2ZW4gZmlsZSBhcyBjb25maWd1cmVkIG9uIHRoZSBwcm9jZXNzb3IuCiAgICoKICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgYXN5bmNocm9ub3VzIHRyYW5zZm9ybXMgYXJlIGNvbmZpZ3VyZWQuCiAgICoKICAgKiA+ICoqTm90ZSoqOiBgcHJvY2Vzc1N5bmNgIGZyZWV6ZXMgdGhlIHByb2Nlc3NvciBpZiBub3QgYWxyZWFkeSAqZnJvemVuKi4KICAgKgogICAqID4gKipOb3RlKio6IGBwcm9jZXNzU3luY2AgcGVyZm9ybXMgdGhlIHBhcnNlLCBydW4sIGFuZCBzdHJpbmdpZnkgcGhhc2VzLgogICAqCiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgdW5kZWZpbmVkfSBbZmlsZV0KICAgKiAgIEZpbGUgKG9wdGlvbmFsKTsgdHlwaWNhbGx5IGBzdHJpbmdgIG9yIGBWRmlsZWA7IGFueSB2YWx1ZSBhY2NlcHRlZCBhcwogICAqICAgYHhgIGluIGBuZXcgVkZpbGUoeClgLgogICAqIEByZXR1cm5zIHtWRmlsZVdpdGhPdXRwdXQ8Q29tcGlsZVJlc3VsdD59CiAgICogICBUaGUgcHJvY2Vzc2VkIGZpbGUuCiAgICoKICAgKiAgIFRoZSBwYXJzZWQsIHRyYW5zZm9ybWVkLCBhbmQgY29tcGlsZWQgdmFsdWUgaXMgYXZhaWxhYmxlIGF0CiAgICogICBgZmlsZS52YWx1ZWAgKHNlZSBub3RlKS4KICAgKgogICAqICAgPiAqKk5vdGUqKjogdW5pZmllZCB0eXBpY2FsbHkgY29tcGlsZXMgYnkgc2VyaWFsaXppbmc6IG1vc3QKICAgKiAgID4gY29tcGlsZXJzIHJldHVybiBgc3RyaW5nYCAob3IgYFVpbnQ4QXJyYXlgKS4KICAgKiAgID4gU29tZSBjb21waWxlcnMsIHN1Y2ggYXMgdGhlIG9uZSBjb25maWd1cmVkIHdpdGgKICAgKiAgID4gW2ByZWh5cGUtcmVhY3RgXVtyZWh5cGUtcmVhY3RdLCByZXR1cm4gb3RoZXIgdmFsdWVzIChpbiB0aGlzIGNhc2UsIGEKICAgKiAgID4gUmVhY3QgdHJlZSkuCiAgICogICA+IElmIHlvdeKAmXJlIHVzaW5nIGEgY29tcGlsZXIgdGhhdCBkb2VzbuKAmXQgc2VyaWFsaXplLCBleHBlY3QgZGlmZmVyZW50CiAgICogICA+IHJlc3VsdCB2YWx1ZXMuCiAgICogICA+CiAgICogICA+IFRvIHJlZ2lzdGVyIGN1c3RvbSByZXN1bHRzIGluIFR5cGVTY3JpcHQsIGFkZCB0aGVtIHRvCiAgICogICA+IHtAbGlua2NvZGUgQ29tcGlsZVJlc3VsdE1hcH0uCiAgICoKICAgKiAgIFtyZWh5cGUtcmVhY3RdOiBodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0CiAgICovCiAgcHJvY2Vzc1N5bmMoZmlsZSkgewogICAgbGV0IGNvbXBsZXRlID0gZmFsc2U7CiAgICBsZXQgcmVzdWx0OwogICAgdGhpcy5mcmVlemUoKTsKICAgIGFzc2VydFBhcnNlcigicHJvY2Vzc1N5bmMiLCB0aGlzLnBhcnNlciB8fCB0aGlzLlBhcnNlcik7CiAgICBhc3NlcnRDb21waWxlcigicHJvY2Vzc1N5bmMiLCB0aGlzLmNvbXBpbGVyIHx8IHRoaXMuQ29tcGlsZXIpOwogICAgdGhpcy5wcm9jZXNzKGZpbGUsIHJlYWxEb25lKTsKICAgIGFzc2VydERvbmUoInByb2Nlc3NTeW5jIiwgInByb2Nlc3MiLCBjb21wbGV0ZSk7CiAgICBvayhyZXN1bHQsICJ3ZSBlaXRoZXIgYmFpbGVkIG9uIGFuIGVycm9yIG9yIGhhdmUgYSB0cmVlIik7CiAgICByZXR1cm4gcmVzdWx0OwogICAgZnVuY3Rpb24gcmVhbERvbmUoZXJyb3IsIGZpbGUyKSB7CiAgICAgIGNvbXBsZXRlID0gdHJ1ZTsKICAgICAgYmFpbChlcnJvcik7CiAgICAgIHJlc3VsdCA9IGZpbGUyOwogICAgfQogIH0KICAvKioKICAgKiBSdW4gKnRyYW5zZm9ybWVycyogb24gYSBzeW50YXggdHJlZS4KICAgKgogICAqID4gKipOb3RlKio6IGBydW5gIGZyZWV6ZXMgdGhlIHByb2Nlc3NvciBpZiBub3QgYWxyZWFkeSAqZnJvemVuKi4KICAgKgogICAqID4gKipOb3RlKio6IGBydW5gIHBlcmZvcm1zIHRoZSBydW4gcGhhc2UsIG5vdCBvdGhlciBwaGFzZXMuCiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge0hlYWRUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IEhlYWRUcmVlfSB0cmVlCiAgICogQHBhcmFtIHtSdW5DYWxsYmFjazxUYWlsVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBUYWlsVHJlZT59IGRvbmUKICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfQogICAqCiAgICogQG92ZXJsb2FkCiAgICogQHBhcmFtIHtIZWFkVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBIZWFkVHJlZX0gdHJlZQogICAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IHVuZGVmaW5lZH0gZmlsZQogICAqIEBwYXJhbSB7UnVuQ2FsbGJhY2s8VGFpbFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogVGFpbFRyZWU+fSBkb25lCiAgICogQHJldHVybnMge3VuZGVmaW5lZH0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7SGVhZFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogSGVhZFRyZWV9IHRyZWUKICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXQogICAqIEByZXR1cm5zIHtQcm9taXNlPFRhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlPn0KICAgKgogICAqIEBwYXJhbSB7SGVhZFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogSGVhZFRyZWV9IHRyZWUKICAgKiAgIFRyZWUgdG8gdHJhbnNmb3JtIGFuZCBpbnNwZWN0LgogICAqIEBwYXJhbSB7KAogICAqICAgUnVuQ2FsbGJhY2s8VGFpbFRyZWUgZXh0ZW5kcyB1bmRlZmluZWQgPyBOb2RlIDogVGFpbFRyZWU+IHwKICAgKiAgIENvbXBhdGlibGUKICAgKiApfSBbZmlsZV0KICAgKiAgIEZpbGUgYXNzb2NpYXRlZCB3aXRoIGBub2RlYCAob3B0aW9uYWwpOyBhbnkgdmFsdWUgYWNjZXB0ZWQgYXMgYHhgIGluCiAgICogICBgbmV3IFZGaWxlKHgpYC4KICAgKiBAcGFyYW0ge1J1bkNhbGxiYWNrPFRhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlPn0gW2RvbmVdCiAgICogICBDYWxsYmFjayAob3B0aW9uYWwpLgogICAqIEByZXR1cm5zIHtQcm9taXNlPFRhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlPiB8IHVuZGVmaW5lZH0KICAgKiAgIE5vdGhpbmcgaWYgYGRvbmVgIGlzIGdpdmVuLgogICAqICAgT3RoZXJ3aXNlLCBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBhIGZhdGFsIGVycm9yIG9yIHJlc29sdmVkIHdpdGggdGhlCiAgICogICB0cmFuc2Zvcm1lZCB0cmVlLgogICAqLwogIHJ1bih0cmVlLCBmaWxlLCBkb25lKSB7CiAgICBhc3NlcnROb2RlKHRyZWUpOwogICAgdGhpcy5mcmVlemUoKTsKICAgIGNvbnN0IHRyYW5zZm9ybWVycyA9IHRoaXMudHJhbnNmb3JtZXJzOwogICAgaWYgKCFkb25lICYmIHR5cGVvZiBmaWxlID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGRvbmUgPSBmaWxlOwogICAgICBmaWxlID0gdm9pZCAwOwogICAgfQogICAgcmV0dXJuIGRvbmUgPyBleGVjdXRvcih2b2lkIDAsIGRvbmUpIDogbmV3IFByb21pc2UoZXhlY3V0b3IpOwogICAgZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgIG9rKAogICAgICAgIHR5cGVvZiBmaWxlICE9PSAiZnVuY3Rpb24iLAogICAgICAgICJgZmlsZWAgY2Fu4oCZdCBiZSBhIGBkb25lYCBhbnltb3JlLCB3ZSBjaGVja2VkIgogICAgICApOwogICAgICBjb25zdCByZWFsRmlsZSA9IHZmaWxlKGZpbGUpOwogICAgICB0cmFuc2Zvcm1lcnMucnVuKHRyZWUsIHJlYWxGaWxlLCByZWFsRG9uZSk7CiAgICAgIGZ1bmN0aW9uIHJlYWxEb25lKGVycm9yLCBvdXRwdXRUcmVlLCBmaWxlMikgewogICAgICAgIGNvbnN0IHJlc3VsdGluZ1RyZWUgPSAoCiAgICAgICAgICAvKiogQHR5cGUge1RhaWxUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IFRhaWxUcmVlfSAqLwogICAgICAgICAgb3V0cHV0VHJlZSB8fCB0cmVlCiAgICAgICAgKTsKICAgICAgICBpZiAoZXJyb3IpIHsKICAgICAgICAgIHJlamVjdChlcnJvcik7CiAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlKSB7CiAgICAgICAgICByZXNvbHZlKHJlc3VsdGluZ1RyZWUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBvayhkb25lLCAiYGRvbmVgIGlzIGRlZmluZWQgaWYgYHJlc29sdmVgIGlzIG5vdCIpOwogICAgICAgICAgZG9uZSh2b2lkIDAsIHJlc3VsdGluZ1RyZWUsIGZpbGUyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogUnVuICp0cmFuc2Zvcm1lcnMqIG9uIGEgc3ludGF4IHRyZWUuCiAgICoKICAgKiBBbiBlcnJvciBpcyB0aHJvd24gaWYgYXN5bmNocm9ub3VzIHRyYW5zZm9ybXMgYXJlIGNvbmZpZ3VyZWQuCiAgICoKICAgKiA+ICoqTm90ZSoqOiBgcnVuU3luY2AgZnJlZXplcyB0aGUgcHJvY2Vzc29yIGlmIG5vdCBhbHJlYWR5ICpmcm96ZW4qLgogICAqCiAgICogPiAqKk5vdGUqKjogYHJ1blN5bmNgIHBlcmZvcm1zIHRoZSBydW4gcGhhc2UsIG5vdCBvdGhlciBwaGFzZXMuCiAgICoKICAgKiBAcGFyYW0ge0hlYWRUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IEhlYWRUcmVlfSB0cmVlCiAgICogICBUcmVlIHRvIHRyYW5zZm9ybSBhbmQgaW5zcGVjdC4KICAgKiBAcGFyYW0ge0NvbXBhdGlibGUgfCB1bmRlZmluZWR9IFtmaWxlXQogICAqICAgRmlsZSBhc3NvY2lhdGVkIHdpdGggYG5vZGVgIChvcHRpb25hbCk7IGFueSB2YWx1ZSBhY2NlcHRlZCBhcyBgeGAgaW4KICAgKiAgIGBuZXcgVkZpbGUoeClgLgogICAqIEByZXR1cm5zIHtUYWlsVHJlZSBleHRlbmRzIHVuZGVmaW5lZCA/IE5vZGUgOiBUYWlsVHJlZX0KICAgKiAgIFRyYW5zZm9ybWVkIHRyZWUuCiAgICovCiAgcnVuU3luYyh0cmVlLCBmaWxlKSB7CiAgICBsZXQgY29tcGxldGUgPSBmYWxzZTsKICAgIGxldCByZXN1bHQ7CiAgICB0aGlzLnJ1bih0cmVlLCBmaWxlLCByZWFsRG9uZSk7CiAgICBhc3NlcnREb25lKCJydW5TeW5jIiwgInJ1biIsIGNvbXBsZXRlKTsKICAgIG9rKHJlc3VsdCwgIndlIGVpdGhlciBiYWlsZWQgb24gYW4gZXJyb3Igb3IgaGF2ZSBhIHRyZWUiKTsKICAgIHJldHVybiByZXN1bHQ7CiAgICBmdW5jdGlvbiByZWFsRG9uZShlcnJvciwgdHJlZTIpIHsKICAgICAgYmFpbChlcnJvcik7CiAgICAgIHJlc3VsdCA9IHRyZWUyOwogICAgICBjb21wbGV0ZSA9IHRydWU7CiAgICB9CiAgfQogIC8qKgogICAqIENvbXBpbGUgYSBzeW50YXggdHJlZS4KICAgKgogICAqID4gKipOb3RlKio6IGBzdHJpbmdpZnlgIGZyZWV6ZXMgdGhlIHByb2Nlc3NvciBpZiBub3QgYWxyZWFkeSAqZnJvemVuKi4KICAgKgogICAqID4gKipOb3RlKio6IGBzdHJpbmdpZnlgIHBlcmZvcm1zIHRoZSBzdHJpbmdpZnkgcGhhc2UsIG5vdCB0aGUgcnVuIHBoYXNlCiAgICogPiBvciBvdGhlciBwaGFzZXMuCiAgICoKICAgKiBAcGFyYW0ge0NvbXBpbGVUcmVlIGV4dGVuZHMgdW5kZWZpbmVkID8gTm9kZSA6IENvbXBpbGVUcmVlfSB0cmVlCiAgICogICBUcmVlIHRvIGNvbXBpbGUuCiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgdW5kZWZpbmVkfSBbZmlsZV0KICAgKiAgIEZpbGUgYXNzb2NpYXRlZCB3aXRoIGBub2RlYCAob3B0aW9uYWwpOyBhbnkgdmFsdWUgYWNjZXB0ZWQgYXMgYHhgIGluCiAgICogICBgbmV3IFZGaWxlKHgpYC4KICAgKiBAcmV0dXJucyB7Q29tcGlsZVJlc3VsdCBleHRlbmRzIHVuZGVmaW5lZCA/IFZhbHVlIDogQ29tcGlsZVJlc3VsdH0KICAgKiAgIFRleHR1YWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyZWUgKHNlZSBub3RlKS4KICAgKgogICAqICAgPiAqKk5vdGUqKjogdW5pZmllZCB0eXBpY2FsbHkgY29tcGlsZXMgYnkgc2VyaWFsaXppbmc6IG1vc3QgY29tcGlsZXJzCiAgICogICA+IHJldHVybiBgc3RyaW5nYCAob3IgYFVpbnQ4QXJyYXlgKS4KICAgKiAgID4gU29tZSBjb21waWxlcnMsIHN1Y2ggYXMgdGhlIG9uZSBjb25maWd1cmVkIHdpdGgKICAgKiAgID4gW2ByZWh5cGUtcmVhY3RgXVtyZWh5cGUtcmVhY3RdLCByZXR1cm4gb3RoZXIgdmFsdWVzIChpbiB0aGlzIGNhc2UsIGEKICAgKiAgID4gUmVhY3QgdHJlZSkuCiAgICogICA+IElmIHlvdeKAmXJlIHVzaW5nIGEgY29tcGlsZXIgdGhhdCBkb2VzbuKAmXQgc2VyaWFsaXplLCBleHBlY3QgZGlmZmVyZW50CiAgICogICA+IHJlc3VsdCB2YWx1ZXMuCiAgICogICA+CiAgICogICA+IFRvIHJlZ2lzdGVyIGN1c3RvbSByZXN1bHRzIGluIFR5cGVTY3JpcHQsIGFkZCB0aGVtIHRvCiAgICogICA+IHtAbGlua2NvZGUgQ29tcGlsZVJlc3VsdE1hcH0uCiAgICoKICAgKiAgIFtyZWh5cGUtcmVhY3RdOiBodHRwczovL2dpdGh1Yi5jb20vcmVoeXBlanMvcmVoeXBlLXJlYWN0CiAgICovCiAgc3RyaW5naWZ5KHRyZWUsIGZpbGUpIHsKICAgIHRoaXMuZnJlZXplKCk7CiAgICBjb25zdCByZWFsRmlsZSA9IHZmaWxlKGZpbGUpOwogICAgY29uc3QgY29tcGlsZXIyID0gdGhpcy5jb21waWxlciB8fCB0aGlzLkNvbXBpbGVyOwogICAgYXNzZXJ0Q29tcGlsZXIoInN0cmluZ2lmeSIsIGNvbXBpbGVyMik7CiAgICBhc3NlcnROb2RlKHRyZWUpOwogICAgcmV0dXJuIGNvbXBpbGVyMih0cmVlLCByZWFsRmlsZSk7CiAgfQogIC8qKgogICAqIENvbmZpZ3VyZSB0aGUgcHJvY2Vzc29yIHRvIHVzZSBhIHBsdWdpbiwgYSBsaXN0IG9mIHVzYWJsZSB2YWx1ZXMsIG9yIGEKICAgKiBwcmVzZXQuCiAgICoKICAgKiBJZiB0aGUgcHJvY2Vzc29yIGlzIGFscmVhZHkgdXNpbmcgYSBwbHVnaW4sIHRoZSBwcmV2aW91cyBwbHVnaW4KICAgKiBjb25maWd1cmF0aW9uIGlzIGNoYW5nZWQgYmFzZWQgb24gdGhlIG9wdGlvbnMgdGhhdCBhcmUgcGFzc2VkIGluLgogICAqIEluIG90aGVyIHdvcmRzLCB0aGUgcGx1Z2luIGlzIG5vdCBhZGRlZCBhIHNlY29uZCB0aW1lLgogICAqCiAgICogPiAqKk5vdGUqKjogYHVzZWAgY2Fubm90IGJlIGNhbGxlZCBvbiAqZnJvemVuKiBwcm9jZXNzb3JzLgogICAqID4gQ2FsbCB0aGUgcHJvY2Vzc29yIGZpcnN0IHRvIGNyZWF0ZSBhIG5ldyB1bmZyb3plbiBwcm9jZXNzb3IuCiAgICoKICAgKiBAZXhhbXBsZQogICAqICAgVGhlcmUgYXJlIG1hbnkgd2F5cyB0byBwYXNzIHBsdWdpbnMgdG8gYC51c2UoKWAuCiAgICogICBUaGlzIGV4YW1wbGUgZ2l2ZXMgYW4gb3ZlcnZpZXc6CiAgICoKICAgKiAgIGBgYGpzCiAgICogICBpbXBvcnQge3VuaWZpZWR9IGZyb20gJ3VuaWZpZWQnCiAgICoKICAgKiAgIHVuaWZpZWQoKQogICAqICAgICAvLyBQbHVnaW4gd2l0aCBvcHRpb25zOgogICAqICAgICAudXNlKHBsdWdpbkEsIHt4OiB0cnVlLCB5OiB0cnVlfSkKICAgKiAgICAgLy8gUGFzc2luZyB0aGUgc2FtZSBwbHVnaW4gYWdhaW4gbWVyZ2VzIGNvbmZpZ3VyYXRpb24gKHRvIGB7eDogdHJ1ZSwgeTogZmFsc2UsIHo6IHRydWV9YCk6CiAgICogICAgIC51c2UocGx1Z2luQSwge3k6IGZhbHNlLCB6OiB0cnVlfSkKICAgKiAgICAgLy8gUGx1Z2luczoKICAgKiAgICAgLnVzZShbcGx1Z2luQiwgcGx1Z2luQ10pCiAgICogICAgIC8vIFR3byBwbHVnaW5zLCB0aGUgc2Vjb25kIHdpdGggb3B0aW9uczoKICAgKiAgICAgLnVzZShbcGx1Z2luRCwgW3BsdWdpbkUsIHt9XV0pCiAgICogICAgIC8vIFByZXNldCB3aXRoIHBsdWdpbnMgYW5kIHNldHRpbmdzOgogICAqICAgICAudXNlKHtwbHVnaW5zOiBbcGx1Z2luRiwgW3BsdWdpbkcsIHt9XV0sIHNldHRpbmdzOiB7cG9zaXRpb246IGZhbHNlfX0pCiAgICogICAgIC8vIFNldHRpbmdzIG9ubHk6CiAgICogICAgIC51c2Uoe3NldHRpbmdzOiB7cG9zaXRpb246IGZhbHNlfX0pCiAgICogICBgYGAKICAgKgogICAqIEB0ZW1wbGF0ZSB7QXJyYXk8dW5rbm93bj59IFtQYXJhbWV0ZXJzPVtdXQogICAqIEB0ZW1wbGF0ZSB7Tm9kZSB8IHN0cmluZyB8IHVuZGVmaW5lZH0gW0lucHV0PXVuZGVmaW5lZF0KICAgKiBAdGVtcGxhdGUgW091dHB1dD1JbnB1dF0KICAgKgogICAqIEBvdmVybG9hZAogICAqIEBwYXJhbSB7UHJlc2V0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ByZXNldF0KICAgKiBAcmV0dXJucyB7UHJvY2Vzc29yPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdD59CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge1BsdWdnYWJsZUxpc3R9IGxpc3QKICAgKiBAcmV0dXJucyB7UHJvY2Vzc29yPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdD59CiAgICoKICAgKiBAb3ZlcmxvYWQKICAgKiBAcGFyYW0ge1BsdWdpbjxQYXJhbWV0ZXJzLCBJbnB1dCwgT3V0cHV0Pn0gcGx1Z2luCiAgICogQHBhcmFtIHsuLi4oUGFyYW1ldGVycyB8IFtib29sZWFuXSl9IHBhcmFtZXRlcnMKICAgKiBAcmV0dXJucyB7VXNlUGx1Z2luPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdCwgSW5wdXQsIE91dHB1dD59CiAgICoKICAgKiBAcGFyYW0ge1BsdWdnYWJsZUxpc3QgfCBQbHVnaW4gfCBQcmVzZXQgfCBudWxsIHwgdW5kZWZpbmVkfSB2YWx1ZQogICAqICAgVXNhYmxlIHZhbHVlLgogICAqIEBwYXJhbSB7Li4udW5rbm93bn0gcGFyYW1ldGVycwogICAqICAgUGFyYW1ldGVycywgd2hlbiBhIHBsdWdpbiBpcyBnaXZlbiBhcyBhIHVzYWJsZSB2YWx1ZS4KICAgKiBAcmV0dXJucyB7UHJvY2Vzc29yPFBhcnNlVHJlZSwgSGVhZFRyZWUsIFRhaWxUcmVlLCBDb21waWxlVHJlZSwgQ29tcGlsZVJlc3VsdD59CiAgICogICBDdXJyZW50IHByb2Nlc3Nvci4KICAgKi8KICB1c2UodmFsdWUsIC4uLnBhcmFtZXRlcnMpIHsKICAgIGNvbnN0IGF0dGFjaGVycyA9IHRoaXMuYXR0YWNoZXJzOwogICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2U7CiAgICBhc3NlcnRVbmZyb3plbigidXNlIiwgdGhpcy5mcm96ZW4pOwogICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB2b2lkIDApIHsKICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAiZnVuY3Rpb24iKSB7CiAgICAgIGFkZFBsdWdpbih2YWx1ZSwgcGFyYW1ldGVycyk7CiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gIm9iamVjdCIpIHsKICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7CiAgICAgICAgYWRkTGlzdCh2YWx1ZSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYWRkUHJlc2V0KHZhbHVlKTsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0ZWQgdXNhYmxlIHZhbHVlLCBub3QgYCIgKyB2YWx1ZSArICJgIik7CiAgICB9CiAgICByZXR1cm4gdGhpczsKICAgIGZ1bmN0aW9uIGFkZCh2YWx1ZTIpIHsKICAgICAgaWYgKHR5cGVvZiB2YWx1ZTIgPT09ICJmdW5jdGlvbiIpIHsKICAgICAgICBhZGRQbHVnaW4odmFsdWUyLCBbXSk7CiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlMiA9PT0gIm9iamVjdCIpIHsKICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZTIpKSB7CiAgICAgICAgICBjb25zdCBbcGx1Z2luLCAuLi5wYXJhbWV0ZXJzMl0gPSAoCiAgICAgICAgICAgIC8qKiBAdHlwZSB7UGx1Z2luVHVwbGU8QXJyYXk8dW5rbm93bj4+fSAqLwogICAgICAgICAgICB2YWx1ZTIKICAgICAgICAgICk7CiAgICAgICAgICBhZGRQbHVnaW4ocGx1Z2luLCBwYXJhbWV0ZXJzMik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGFkZFByZXNldCh2YWx1ZTIpOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgIiArIHZhbHVlMiArICJgIik7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGFkZFByZXNldChyZXN1bHQpIHsKICAgICAgaWYgKCEoInBsdWdpbnMiIGluIHJlc3VsdCkgJiYgISgic2V0dGluZ3MiIGluIHJlc3VsdCkpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAiRXhwZWN0ZWQgdXNhYmxlIHZhbHVlIGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBwcmVzZXQsIHdoaWNoIGlzIHByb2JhYmx5IGEgbWlzdGFrZTogcHJlc2V0cyB0eXBpY2FsbHkgY29tZSB3aXRoIGBwbHVnaW5zYCBhbmQgc29tZXRpbWVzIHdpdGggYHNldHRpbmdzYCwgYnV0IHRoaXMgaGFzIG5laXRoZXIiCiAgICAgICAgKTsKICAgICAgfQogICAgICBhZGRMaXN0KHJlc3VsdC5wbHVnaW5zKTsKICAgICAgaWYgKHJlc3VsdC5zZXR0aW5ncykgewogICAgICAgIG5hbWVzcGFjZS5zZXR0aW5ncyA9ICgwLCBpbXBvcnRfZXh0ZW5kLmRlZmF1bHQpKHRydWUsIG5hbWVzcGFjZS5zZXR0aW5ncywgcmVzdWx0LnNldHRpbmdzKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gYWRkTGlzdChwbHVnaW5zKSB7CiAgICAgIGxldCBpbmRleDIgPSAtMTsKICAgICAgaWYgKHBsdWdpbnMgPT09IG51bGwgfHwgcGx1Z2lucyA9PT0gdm9pZCAwKSB7CiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwbHVnaW5zKSkgewogICAgICAgIHdoaWxlICgrK2luZGV4MiA8IHBsdWdpbnMubGVuZ3RoKSB7CiAgICAgICAgICBjb25zdCB0aGluZyA9IHBsdWdpbnNbaW5kZXgyXTsKICAgICAgICAgIGFkZCh0aGluZyk7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkV4cGVjdGVkIGEgbGlzdCBvZiBwbHVnaW5zLCBub3QgYCIgKyBwbHVnaW5zICsgImAiKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbiwgcGFyYW1ldGVyczIpIHsKICAgICAgbGV0IGluZGV4MiA9IC0xOwogICAgICBsZXQgZW50cnlJbmRleCA9IC0xOwogICAgICB3aGlsZSAoKytpbmRleDIgPCBhdHRhY2hlcnMubGVuZ3RoKSB7CiAgICAgICAgaWYgKGF0dGFjaGVyc1tpbmRleDJdWzBdID09PSBwbHVnaW4pIHsKICAgICAgICAgIGVudHJ5SW5kZXggPSBpbmRleDI7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKGVudHJ5SW5kZXggPT09IC0xKSB7CiAgICAgICAgYXR0YWNoZXJzLnB1c2goW3BsdWdpbiwgLi4ucGFyYW1ldGVyczJdKTsKICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzMi5sZW5ndGggPiAwKSB7CiAgICAgICAgbGV0IFtwcmltYXJ5LCAuLi5yZXN0XSA9IHBhcmFtZXRlcnMyOwogICAgICAgIGNvbnN0IGN1cnJlbnRQcmltYXJ5ID0gYXR0YWNoZXJzW2VudHJ5SW5kZXhdWzFdOwogICAgICAgIGlmIChpc1BsYWluT2JqZWN0KGN1cnJlbnRQcmltYXJ5KSAmJiBpc1BsYWluT2JqZWN0KHByaW1hcnkpKSB7CiAgICAgICAgICBwcmltYXJ5ID0gKDAsIGltcG9ydF9leHRlbmQuZGVmYXVsdCkodHJ1ZSwgY3VycmVudFByaW1hcnksIHByaW1hcnkpOwogICAgICAgIH0KICAgICAgICBhdHRhY2hlcnNbZW50cnlJbmRleF0gPSBbcGx1Z2luLCBwcmltYXJ5LCAuLi5yZXN0XTsKICAgICAgfQogICAgfQogIH0KfTsKdmFyIHVuaWZpZWQgPSBuZXcgUHJvY2Vzc29yKCkuZnJlZXplKCk7CmZ1bmN0aW9uIGFzc2VydFBhcnNlcihuYW1lMiwgdmFsdWUpIHsKICBpZiAodHlwZW9mIHZhbHVlICE9PSAiZnVuY3Rpb24iKSB7CiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgYCIgKyBuYW1lMiArICJgIHdpdGhvdXQgYHBhcnNlcmAiKTsKICB9Cn0KZnVuY3Rpb24gYXNzZXJ0Q29tcGlsZXIobmFtZTIsIHZhbHVlKSB7CiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gImZ1bmN0aW9uIikgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiQ2Fubm90IGAiICsgbmFtZTIgKyAiYCB3aXRob3V0IGBjb21waWxlcmAiKTsKICB9Cn0KZnVuY3Rpb24gYXNzZXJ0VW5mcm96ZW4obmFtZTIsIGZyb3plbikgewogIGlmIChmcm96ZW4pIHsKICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgIkNhbm5vdCBjYWxsIGAiICsgbmFtZTIgKyAiYCBvbiBhIGZyb3plbiBwcm9jZXNzb3IuXG5DcmVhdGUgYSBuZXcgcHJvY2Vzc29yIGZpcnN0LCBieSBjYWxsaW5nIGl0OiB1c2UgYHByb2Nlc3NvcigpYCBpbnN0ZWFkIG9mIGBwcm9jZXNzb3JgLiIKICAgICk7CiAgfQp9CmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkgewogIGlmICghaXNQbGFpbk9iamVjdChub2RlKSB8fCB0eXBlb2Ygbm9kZS50eXBlICE9PSAic3RyaW5nIikgewogICAgdGhyb3cgbmV3IFR5cGVFcnJvcigiRXhwZWN0ZWQgbm9kZSwgZ290IGAiICsgbm9kZSArICJgIik7CiAgfQp9CmZ1bmN0aW9uIGFzc2VydERvbmUobmFtZTIsIGFzeW5jTmFtZSwgY29tcGxldGUpIHsKICBpZiAoIWNvbXBsZXRlKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICJgIiArIG5hbWUyICsgImAgZmluaXNoZWQgYXN5bmMuIFVzZSBgIiArIGFzeW5jTmFtZSArICJgIGluc3RlYWQiCiAgICApOwogIH0KfQpmdW5jdGlvbiB2ZmlsZSh2YWx1ZSkgewogIHJldHVybiBsb29rc0xpa2VBVkZpbGUodmFsdWUpID8gdmFsdWUgOiBuZXcgVkZpbGUodmFsdWUpOwp9CmZ1bmN0aW9uIGxvb2tzTGlrZUFWRmlsZSh2YWx1ZSkgewogIHJldHVybiBCb29sZWFuKAogICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAib2JqZWN0IiAmJiAibWVzc2FnZSIgaW4gdmFsdWUgJiYgIm1lc3NhZ2VzIiBpbiB2YWx1ZQogICk7Cn0KZnVuY3Rpb24gbG9va3NMaWtlQVZhbHVlKHZhbHVlKSB7CiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gInN0cmluZyIgfHwgaXNVaW50OEFycmF5Mih2YWx1ZSk7Cn0KZnVuY3Rpb24gaXNVaW50OEFycmF5Mih2YWx1ZSkgewogIHJldHVybiBCb29sZWFuKAogICAgdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAib2JqZWN0IiAmJiAiYnl0ZUxlbmd0aCIgaW4gdmFsdWUgJiYgImJ5dGVPZmZzZXQiIGluIHZhbHVlCiAgKTsKfQoKLy8gbm9kZV9tb2R1bGVzL3JlYWN0LW1hcmtkb3duL2xpYi9pbmRleC5qcwp2YXIgY2hhbmdlbG9nID0gImh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZWFjdC1tYXJrZG93bi9ibG9iL21haW4vY2hhbmdlbG9nLm1kIjsKdmFyIGVtcHR5UGx1Z2lucyA9IFtdOwp2YXIgZW1wdHlSZW1hcmtSZWh5cGVPcHRpb25zID0geyBhbGxvd0Rhbmdlcm91c0h0bWw6IHRydWUgfTsKdmFyIHNhZmVQcm90b2NvbCA9IC9eKGh0dHBzP3xpcmNzP3xtYWlsdG98eG1wcCkkL2k7CnZhciBkZXByZWNhdGlvbnMgPSBbCiAgeyBmcm9tOiAiYXN0UGx1Z2lucyIsIGlkOiAicmVtb3ZlLWJ1Z2d5LWh0bWwtaW4tbWFya2Rvd24tcGFyc2VyIiB9LAogIHsgZnJvbTogImFsbG93RGFuZ2Vyb3VzSHRtbCIsIGlkOiAicmVtb3ZlLWJ1Z2d5LWh0bWwtaW4tbWFya2Rvd24tcGFyc2VyIiB9LAogIHsKICAgIGZyb206ICJhbGxvd05vZGUiLAogICAgaWQ6ICJyZXBsYWNlLWFsbG93bm9kZS1hbGxvd2VkdHlwZXMtYW5kLWRpc2FsbG93ZWR0eXBlcyIsCiAgICB0bzogImFsbG93RWxlbWVudCIKICB9LAogIHsKICAgIGZyb206ICJhbGxvd2VkVHlwZXMiLAogICAgaWQ6ICJyZXBsYWNlLWFsbG93bm9kZS1hbGxvd2VkdHlwZXMtYW5kLWRpc2FsbG93ZWR0eXBlcyIsCiAgICB0bzogImFsbG93ZWRFbGVtZW50cyIKICB9LAogIHsgZnJvbTogImNsYXNzTmFtZSIsIGlkOiAicmVtb3ZlLWNsYXNzbmFtZSIgfSwKICB7CiAgICBmcm9tOiAiZGlzYWxsb3dlZFR5cGVzIiwKICAgIGlkOiAicmVwbGFjZS1hbGxvd25vZGUtYWxsb3dlZHR5cGVzLWFuZC1kaXNhbGxvd2VkdHlwZXMiLAogICAgdG86ICJkaXNhbGxvd2VkRWxlbWVudHMiCiAgfSwKICB7IGZyb206ICJlc2NhcGVIdG1sIiwgaWQ6ICJyZW1vdmUtYnVnZ3ktaHRtbC1pbi1tYXJrZG93bi1wYXJzZXIiIH0sCiAgeyBmcm9tOiAiaW5jbHVkZUVsZW1lbnRJbmRleCIsIGlkOiAiI3JlbW92ZS1pbmNsdWRlZWxlbWVudGluZGV4IiB9LAogIHsKICAgIGZyb206ICJpbmNsdWRlTm9kZUluZGV4IiwKICAgIGlkOiAiY2hhbmdlLWluY2x1ZGVub2RlaW5kZXgtdG8taW5jbHVkZWVsZW1lbnRpbmRleCIKICB9LAogIHsgZnJvbTogImxpbmtUYXJnZXQiLCBpZDogInJlbW92ZS1saW5rdGFyZ2V0IiB9LAogIHsgZnJvbTogInBsdWdpbnMiLCBpZDogImNoYW5nZS1wbHVnaW5zLXRvLXJlbWFya3BsdWdpbnMiLCB0bzogInJlbWFya1BsdWdpbnMiIH0sCiAgeyBmcm9tOiAicmF3U291cmNlUG9zIiwgaWQ6ICIjcmVtb3ZlLXJhd3NvdXJjZXBvcyIgfSwKICB7IGZyb206ICJyZW5kZXJlcnMiLCBpZDogImNoYW5nZS1yZW5kZXJlcnMtdG8tY29tcG9uZW50cyIsIHRvOiAiY29tcG9uZW50cyIgfSwKICB7IGZyb206ICJzb3VyY2UiLCBpZDogImNoYW5nZS1zb3VyY2UtdG8tY2hpbGRyZW4iLCB0bzogImNoaWxkcmVuIiB9LAogIHsgZnJvbTogInNvdXJjZVBvcyIsIGlkOiAiI3JlbW92ZS1zb3VyY2Vwb3MiIH0sCiAgeyBmcm9tOiAidHJhbnNmb3JtSW1hZ2VVcmkiLCBpZDogIiNhZGQtdXJsdHJhbnNmb3JtIiwgdG86ICJ1cmxUcmFuc2Zvcm0iIH0sCiAgeyBmcm9tOiAidHJhbnNmb3JtTGlua1VyaSIsIGlkOiAiI2FkZC11cmx0cmFuc2Zvcm0iLCB0bzogInVybFRyYW5zZm9ybSIgfQpdOwpmdW5jdGlvbiBNYXJrZG93bihvcHRpb25zKSB7CiAgY29uc3QgcHJvY2Vzc29yID0gY3JlYXRlUHJvY2Vzc29yKG9wdGlvbnMpOwogIGNvbnN0IGZpbGUgPSBjcmVhdGVGaWxlKG9wdGlvbnMpOwogIHJldHVybiBwb3N0KHByb2Nlc3Nvci5ydW5TeW5jKHByb2Nlc3Nvci5wYXJzZShmaWxlKSwgZmlsZSksIG9wdGlvbnMpOwp9CmFzeW5jIGZ1bmN0aW9uIE1hcmtkb3duQXN5bmMob3B0aW9ucykgewogIGNvbnN0IHByb2Nlc3NvciA9IGNyZWF0ZVByb2Nlc3NvcihvcHRpb25zKTsKICBjb25zdCBmaWxlID0gY3JlYXRlRmlsZShvcHRpb25zKTsKICBjb25zdCB0cmVlID0gYXdhaXQgcHJvY2Vzc29yLnJ1bihwcm9jZXNzb3IucGFyc2UoZmlsZSksIGZpbGUpOwogIHJldHVybiBwb3N0KHRyZWUsIG9wdGlvbnMpOwp9CmZ1bmN0aW9uIE1hcmtkb3duSG9va3Mob3B0aW9ucykgewogIGNvbnN0IHByb2Nlc3NvciA9IGNyZWF0ZVByb2Nlc3NvcihvcHRpb25zKTsKICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9ICgwLCBpbXBvcnRfcmVhY3QudXNlU3RhdGUpKAogICAgLyoqIEB0eXBlIHtFcnJvciB8IHVuZGVmaW5lZH0gKi8KICAgIHZvaWQgMAogICk7CiAgY29uc3QgW3RyZWUsIHNldFRyZWVdID0gKDAsIGltcG9ydF9yZWFjdC51c2VTdGF0ZSkoCiAgICAvKiogQHR5cGUge1Jvb3QgfCB1bmRlZmluZWR9ICovCiAgICB2b2lkIDAKICApOwogICgwLCBpbXBvcnRfcmVhY3QudXNlRWZmZWN0KSgKICAgIGZ1bmN0aW9uKCkgewogICAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7CiAgICAgIGNvbnN0IGZpbGUgPSBjcmVhdGVGaWxlKG9wdGlvbnMpOwogICAgICBwcm9jZXNzb3IucnVuKHByb2Nlc3Nvci5wYXJzZShmaWxlKSwgZmlsZSwgZnVuY3Rpb24oZXJyb3IyLCB0cmVlMikgewogICAgICAgIGlmICghY2FuY2VsbGVkKSB7CiAgICAgICAgICBzZXRFcnJvcihlcnJvcjIpOwogICAgICAgICAgc2V0VHJlZSh0cmVlMik7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkgewogICAgICAgIGNhbmNlbGxlZCA9IHRydWU7CiAgICAgIH07CiAgICB9LAogICAgWwogICAgICBvcHRpb25zLmNoaWxkcmVuLAogICAgICBvcHRpb25zLnJlaHlwZVBsdWdpbnMsCiAgICAgIG9wdGlvbnMucmVtYXJrUGx1Z2lucywKICAgICAgb3B0aW9ucy5yZW1hcmtSZWh5cGVPcHRpb25zCiAgICBdCiAgKTsKICBpZiAoZXJyb3IpIHRocm93IGVycm9yOwogIHJldHVybiB0cmVlID8gcG9zdCh0cmVlLCBvcHRpb25zKSA6IG9wdGlvbnMuZmFsbGJhY2s7Cn0KZnVuY3Rpb24gY3JlYXRlUHJvY2Vzc29yKG9wdGlvbnMpIHsKICBjb25zdCByZWh5cGVQbHVnaW5zID0gb3B0aW9ucy5yZWh5cGVQbHVnaW5zIHx8IGVtcHR5UGx1Z2luczsKICBjb25zdCByZW1hcmtQbHVnaW5zID0gb3B0aW9ucy5yZW1hcmtQbHVnaW5zIHx8IGVtcHR5UGx1Z2luczsKICBjb25zdCByZW1hcmtSZWh5cGVPcHRpb25zID0gb3B0aW9ucy5yZW1hcmtSZWh5cGVPcHRpb25zID8geyAuLi5vcHRpb25zLnJlbWFya1JlaHlwZU9wdGlvbnMsIC4uLmVtcHR5UmVtYXJrUmVoeXBlT3B0aW9ucyB9IDogZW1wdHlSZW1hcmtSZWh5cGVPcHRpb25zOwogIGNvbnN0IHByb2Nlc3NvciA9IHVuaWZpZWQoKS51c2UocmVtYXJrUGFyc2UpLnVzZShyZW1hcmtQbHVnaW5zKS51c2UocmVtYXJrUmVoeXBlLCByZW1hcmtSZWh5cGVPcHRpb25zKS51c2UocmVoeXBlUGx1Z2lucyk7CiAgcmV0dXJuIHByb2Nlc3NvcjsKfQpmdW5jdGlvbiBjcmVhdGVGaWxlKG9wdGlvbnMpIHsKICBjb25zdCBjaGlsZHJlbiA9IG9wdGlvbnMuY2hpbGRyZW4gfHwgIiI7CiAgY29uc3QgZmlsZSA9IG5ldyBWRmlsZSgpOwogIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICJzdHJpbmciKSB7CiAgICBmaWxlLnZhbHVlID0gY2hpbGRyZW47CiAgfSBlbHNlIHsKICAgIHVucmVhY2hhYmxlKAogICAgICAiVW5leHBlY3RlZCB2YWx1ZSBgIiArIGNoaWxkcmVuICsgImAgZm9yIGBjaGlsZHJlbmAgcHJvcCwgZXhwZWN0ZWQgYHN0cmluZ2AiCiAgICApOwogIH0KICByZXR1cm4gZmlsZTsKfQpmdW5jdGlvbiBwb3N0KHRyZWUsIG9wdGlvbnMpIHsKICBjb25zdCBhbGxvd2VkRWxlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRFbGVtZW50czsKICBjb25zdCBhbGxvd0VsZW1lbnQgPSBvcHRpb25zLmFsbG93RWxlbWVudDsKICBjb25zdCBjb21wb25lbnRzID0gb3B0aW9ucy5jb21wb25lbnRzOwogIGNvbnN0IGRpc2FsbG93ZWRFbGVtZW50cyA9IG9wdGlvbnMuZGlzYWxsb3dlZEVsZW1lbnRzOwogIGNvbnN0IHNraXBIdG1sID0gb3B0aW9ucy5za2lwSHRtbDsKICBjb25zdCB1bndyYXBEaXNhbGxvd2VkID0gb3B0aW9ucy51bndyYXBEaXNhbGxvd2VkOwogIGNvbnN0IHVybFRyYW5zZm9ybSA9IG9wdGlvbnMudXJsVHJhbnNmb3JtIHx8IGRlZmF1bHRVcmxUcmFuc2Zvcm07CiAgZm9yIChjb25zdCBkZXByZWNhdGlvbiBvZiBkZXByZWNhdGlvbnMpIHsKICAgIGlmIChPYmplY3QuaGFzT3duKG9wdGlvbnMsIGRlcHJlY2F0aW9uLmZyb20pKSB7CiAgICAgIHVucmVhY2hhYmxlKAogICAgICAgICJVbmV4cGVjdGVkIGAiICsgZGVwcmVjYXRpb24uZnJvbSArICJgIHByb3AsICIgKyAoZGVwcmVjYXRpb24udG8gPyAidXNlIGAiICsgZGVwcmVjYXRpb24udG8gKyAiYCBpbnN0ZWFkIiA6ICJyZW1vdmUgaXQiKSArICIgKHNlZSA8IiArIGNoYW5nZWxvZyArICIjIiArIGRlcHJlY2F0aW9uLmlkICsgIj4gZm9yIG1vcmUgaW5mbykiCiAgICAgICk7CiAgICB9CiAgfQogIGlmIChhbGxvd2VkRWxlbWVudHMgJiYgZGlzYWxsb3dlZEVsZW1lbnRzKSB7CiAgICB1bnJlYWNoYWJsZSgKICAgICAgIlVuZXhwZWN0ZWQgY29tYmluZWQgYGFsbG93ZWRFbGVtZW50c2AgYW5kIGBkaXNhbGxvd2VkRWxlbWVudHNgLCBleHBlY3RlZCBvbmUgb3IgdGhlIG90aGVyIgogICAgKTsKICB9CiAgdmlzaXQodHJlZSwgdHJhbnNmb3JtKTsKICByZXR1cm4gdG9Kc3hSdW50aW1lKHRyZWUsIHsKICAgIEZyYWdtZW50OiBpbXBvcnRfanN4X3J1bnRpbWUuRnJhZ21lbnQsCiAgICBjb21wb25lbnRzLAogICAgaWdub3JlSW52YWxpZFN0eWxlOiB0cnVlLAogICAganN4OiBpbXBvcnRfanN4X3J1bnRpbWUuanN4LAogICAganN4czogaW1wb3J0X2pzeF9ydW50aW1lLmpzeHMsCiAgICBwYXNzS2V5czogdHJ1ZSwKICAgIHBhc3NOb2RlOiB0cnVlCiAgfSk7CiAgZnVuY3Rpb24gdHJhbnNmb3JtKG5vZGUsIGluZGV4MiwgcGFyZW50KSB7CiAgICBpZiAobm9kZS50eXBlID09PSAicmF3IiAmJiBwYXJlbnQgJiYgdHlwZW9mIGluZGV4MiA9PT0gIm51bWJlciIpIHsKICAgICAgaWYgKHNraXBIdG1sKSB7CiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleDIsIDEpOwogICAgICB9IGVsc2UgewogICAgICAgIHBhcmVudC5jaGlsZHJlbltpbmRleDJdID0geyB0eXBlOiAidGV4dCIsIHZhbHVlOiBub2RlLnZhbHVlIH07CiAgICAgIH0KICAgICAgcmV0dXJuIGluZGV4MjsKICAgIH0KICAgIGlmIChub2RlLnR5cGUgPT09ICJlbGVtZW50IikgewogICAgICBsZXQga2V5OwogICAgICBmb3IgKGtleSBpbiB1cmxBdHRyaWJ1dGVzKSB7CiAgICAgICAgaWYgKE9iamVjdC5oYXNPd24odXJsQXR0cmlidXRlcywga2V5KSAmJiBPYmplY3QuaGFzT3duKG5vZGUucHJvcGVydGllcywga2V5KSkgewogICAgICAgICAgY29uc3QgdmFsdWUgPSBub2RlLnByb3BlcnRpZXNba2V5XTsKICAgICAgICAgIGNvbnN0IHRlc3QgPSB1cmxBdHRyaWJ1dGVzW2tleV07CiAgICAgICAgICBpZiAodGVzdCA9PT0gbnVsbCB8fCB0ZXN0LmluY2x1ZGVzKG5vZGUudGFnTmFtZSkpIHsKICAgICAgICAgICAgbm9kZS5wcm9wZXJ0aWVzW2tleV0gPSB1cmxUcmFuc2Zvcm0oU3RyaW5nKHZhbHVlIHx8ICIiKSwga2V5LCBub2RlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChub2RlLnR5cGUgPT09ICJlbGVtZW50IikgewogICAgICBsZXQgcmVtb3ZlID0gYWxsb3dlZEVsZW1lbnRzID8gIWFsbG93ZWRFbGVtZW50cy5pbmNsdWRlcyhub2RlLnRhZ05hbWUpIDogZGlzYWxsb3dlZEVsZW1lbnRzID8gZGlzYWxsb3dlZEVsZW1lbnRzLmluY2x1ZGVzKG5vZGUudGFnTmFtZSkgOiBmYWxzZTsKICAgICAgaWYgKCFyZW1vdmUgJiYgYWxsb3dFbGVtZW50ICYmIHR5cGVvZiBpbmRleDIgPT09ICJudW1iZXIiKSB7CiAgICAgICAgcmVtb3ZlID0gIWFsbG93RWxlbWVudChub2RlLCBpbmRleDIsIHBhcmVudCk7CiAgICAgIH0KICAgICAgaWYgKHJlbW92ZSAmJiBwYXJlbnQgJiYgdHlwZW9mIGluZGV4MiA9PT0gIm51bWJlciIpIHsKICAgICAgICBpZiAodW53cmFwRGlzYWxsb3dlZCAmJiBub2RlLmNoaWxkcmVuKSB7CiAgICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4MiwgMSwgLi4ubm9kZS5jaGlsZHJlbik7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHBhcmVudC5jaGlsZHJlbi5zcGxpY2UoaW5kZXgyLCAxKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGluZGV4MjsKICAgICAgfQogICAgfQogIH0KfQpmdW5jdGlvbiBkZWZhdWx0VXJsVHJhbnNmb3JtKHZhbHVlKSB7CiAgY29uc3QgY29sb24gPSB2YWx1ZS5pbmRleE9mKCI6Iik7CiAgY29uc3QgcXVlc3Rpb25NYXJrID0gdmFsdWUuaW5kZXhPZigiPyIpOwogIGNvbnN0IG51bWJlclNpZ24gPSB2YWx1ZS5pbmRleE9mKCIjIik7CiAgY29uc3Qgc2xhc2ggPSB2YWx1ZS5pbmRleE9mKCIvIik7CiAgaWYgKAogICAgLy8gSWYgdGhlcmUgaXMgbm8gcHJvdG9jb2wsIGl04oCZcyByZWxhdGl2ZS4KICAgIGNvbG9uID09PSAtMSB8fCAvLyBJZiB0aGUgZmlyc3QgY29sb24gaXMgYWZ0ZXIgYSBgP2AsIGAjYCwgb3IgYC9gLCBpdOKAmXMgbm90IGEgcHJvdG9jb2wuCiAgICBzbGFzaCAhPT0gLTEgJiYgY29sb24gPiBzbGFzaCB8fCBxdWVzdGlvbk1hcmsgIT09IC0xICYmIGNvbG9uID4gcXVlc3Rpb25NYXJrIHx8IG51bWJlclNpZ24gIT09IC0xICYmIGNvbG9uID4gbnVtYmVyU2lnbiB8fCAvLyBJdCBpcyBhIHByb3RvY29sLCBpdCBzaG91bGQgYmUgYWxsb3dlZC4KICAgIHNhZmVQcm90b2NvbC50ZXN0KHZhbHVlLnNsaWNlKDAsIGNvbG9uKSkKICApIHsKICAgIHJldHVybiB2YWx1ZTsKICB9CiAgcmV0dXJuICIiOwp9CmV4cG9ydCB7CiAgTWFya2Rvd25Bc3luYywKICBNYXJrZG93bkhvb2tzLAogIE1hcmtkb3duIGFzIGRlZmF1bHQsCiAgZGVmYXVsdFVybFRyYW5zZm9ybQp9OwovLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1tYXJrZG93bi5qcy5tYXAK",
            "encoding": "base64"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.741Z",
        "time": 3.0430000006163027,
        "timings": {
          "blocked": 0.9309999994253739,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.6029999996575062,
          "receive": 1.5090000015334226,
          "_blocked_queueing": 0.857999999425374,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "lineNumber": 19
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-gfm.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "96492"
            },
            {
              "name": "Etag",
              "value": "W/\"178ec-1Me9PpHVXcbasJ9Id4qK6GPNpW4\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 96492,
            "mimeType": "text/javascript",
            "text": "import {\n  blankLine,\n  classifyCharacter,\n  combineExtensions,\n  normalizeIdentifier,\n  resolveAll,\n  splice,\n  toString,\n  visit\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-WKZH733J.js?v=2a7591ed\";\nimport {\n  EXIT,\n  convert,\n  visitParents\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-XHSSKPCH.js?v=2a7591ed\";\nimport {\n  longestStreak\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-Y7LV7UOF.js?v=2a7591ed\";\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiControl,\n  codes,\n  constants,\n  factorySpace,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace,\n  ok,\n  types,\n  unicodePunctuation,\n  unicodeWhitespace\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-EIBGEDEJ.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/ccount/index.js\nfunction ccount(value, character) {\n  const source = String(value);\n  if (typeof character !== \"string\") {\n    throw new TypeError(\"Expected character\");\n  }\n  let count = 0;\n  let index = source.indexOf(character);\n  while (index !== -1) {\n    count++;\n    index = source.indexOf(character, index + character.length);\n  }\n  return count;\n}\n\n// node_modules/mdast-util-find-and-replace/node_modules/escape-string-regexp/index.js\nfunction escapeStringRegexp(string) {\n  if (typeof string !== \"string\") {\n    throw new TypeError(\"Expected a string\");\n  }\n  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");\n}\n\n// node_modules/mdast-util-find-and-replace/lib/index.js\nfunction findAndReplace(tree, list2, options) {\n  const settings = options || {};\n  const ignored = convert(settings.ignore || []);\n  const pairs = toPairs(list2);\n  let pairIndex = -1;\n  while (++pairIndex < pairs.length) {\n    visitParents(tree, \"text\", visitor);\n  }\n  function visitor(node, parents) {\n    let index = -1;\n    let grandparent;\n    while (++index < parents.length) {\n      const parent = parents[index];\n      const siblings = grandparent ? grandparent.children : void 0;\n      if (ignored(\n        parent,\n        siblings ? siblings.indexOf(parent) : void 0,\n        grandparent\n      )) {\n        return;\n      }\n      grandparent = parent;\n    }\n    if (grandparent) {\n      return handler(node, parents);\n    }\n  }\n  function handler(node, parents) {\n    const parent = parents[parents.length - 1];\n    const find = pairs[pairIndex][0];\n    const replace2 = pairs[pairIndex][1];\n    let start = 0;\n    const siblings = parent.children;\n    const index = siblings.indexOf(node);\n    let change = false;\n    let nodes = [];\n    find.lastIndex = 0;\n    let match = find.exec(node.value);\n    while (match) {\n      const position = match.index;\n      const matchObject = {\n        index: match.index,\n        input: match.input,\n        stack: [...parents, node]\n      };\n      let value = replace2(...match, matchObject);\n      if (typeof value === \"string\") {\n        value = value.length > 0 ? { type: \"text\", value } : void 0;\n      }\n      if (value === false) {\n        find.lastIndex = position + 1;\n      } else {\n        if (start !== position) {\n          nodes.push({\n            type: \"text\",\n            value: node.value.slice(start, position)\n          });\n        }\n        if (Array.isArray(value)) {\n          nodes.push(...value);\n        } else if (value) {\n          nodes.push(value);\n        }\n        start = position + match[0].length;\n        change = true;\n      }\n      if (!find.global) {\n        break;\n      }\n      match = find.exec(node.value);\n    }\n    if (change) {\n      if (start < node.value.length) {\n        nodes.push({ type: \"text\", value: node.value.slice(start) });\n      }\n      parent.children.splice(index, 1, ...nodes);\n    } else {\n      nodes = [node];\n    }\n    return index + nodes.length;\n  }\n}\nfunction toPairs(tupleOrList) {\n  const result = [];\n  if (!Array.isArray(tupleOrList)) {\n    throw new TypeError(\"Expected find and replace tuple or list of tuples\");\n  }\n  const list2 = !tupleOrList[0] || Array.isArray(tupleOrList[0]) ? tupleOrList : [tupleOrList];\n  let index = -1;\n  while (++index < list2.length) {\n    const tuple = list2[index];\n    result.push([toExpression(tuple[0]), toFunction(tuple[1])]);\n  }\n  return result;\n}\nfunction toExpression(find) {\n  return typeof find === \"string\" ? new RegExp(escapeStringRegexp(find), \"g\") : find;\n}\nfunction toFunction(replace2) {\n  return typeof replace2 === \"function\" ? replace2 : function() {\n    return replace2;\n  };\n}\n\n// node_modules/mdast-util-gfm-autolink-literal/lib/index.js\nvar inConstruct = \"phrasing\";\nvar notInConstruct = [\"autolink\", \"link\", \"image\", \"label\"];\nfunction gfmAutolinkLiteralFromMarkdown() {\n  return {\n    transforms: [transformGfmAutolinkLiterals],\n    enter: {\n      literalAutolink: enterLiteralAutolink,\n      literalAutolinkEmail: enterLiteralAutolinkValue,\n      literalAutolinkHttp: enterLiteralAutolinkValue,\n      literalAutolinkWww: enterLiteralAutolinkValue\n    },\n    exit: {\n      literalAutolink: exitLiteralAutolink,\n      literalAutolinkEmail: exitLiteralAutolinkEmail,\n      literalAutolinkHttp: exitLiteralAutolinkHttp,\n      literalAutolinkWww: exitLiteralAutolinkWww\n    }\n  };\n}\nfunction gfmAutolinkLiteralToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: \"@\",\n        before: \"[+\\\\-.\\\\w]\",\n        after: \"[\\\\-.\\\\w]\",\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: \".\",\n        before: \"[Ww]\",\n        after: \"[\\\\-.\\\\w]\",\n        inConstruct,\n        notInConstruct\n      },\n      {\n        character: \":\",\n        before: \"[ps]\",\n        after: \"\\\\/\",\n        inConstruct,\n        notInConstruct\n      }\n    ]\n  };\n}\nfunction enterLiteralAutolink(token) {\n  this.enter({ type: \"link\", title: null, url: \"\", children: [] }, token);\n}\nfunction enterLiteralAutolinkValue(token) {\n  this.config.enter.autolinkProtocol.call(this, token);\n}\nfunction exitLiteralAutolinkHttp(token) {\n  this.config.exit.autolinkProtocol.call(this, token);\n}\nfunction exitLiteralAutolinkWww(token) {\n  this.config.exit.data.call(this, token);\n  const node = this.stack[this.stack.length - 1];\n  ok(node.type === \"link\");\n  node.url = \"http://\" + this.sliceSerialize(token);\n}\nfunction exitLiteralAutolinkEmail(token) {\n  this.config.exit.autolinkEmail.call(this, token);\n}\nfunction exitLiteralAutolink(token) {\n  this.exit(token);\n}\nfunction transformGfmAutolinkLiterals(tree) {\n  findAndReplace(\n    tree,\n    [\n      [/(https?:\\/\\/|www(?=\\.))([-.\\w]+)([^ \\t\\r\\n]*)/gi, findUrl],\n      [new RegExp(\"(?<=^|\\\\s|\\\\p{P}|\\\\p{S})([-.\\\\w+]+)@([-\\\\w]+(?:\\\\.[-\\\\w]+)+)\", \"gu\"), findEmail]\n    ],\n    { ignore: [\"link\", \"linkReference\"] }\n  );\n}\nfunction findUrl(_, protocol, domain2, path2, match) {\n  let prefix = \"\";\n  if (!previous(match)) {\n    return false;\n  }\n  if (/^w/i.test(protocol)) {\n    domain2 = protocol + domain2;\n    protocol = \"\";\n    prefix = \"http://\";\n  }\n  if (!isCorrectDomain(domain2)) {\n    return false;\n  }\n  const parts = splitUrl(domain2 + path2);\n  if (!parts[0]) return false;\n  const result = {\n    type: \"link\",\n    title: null,\n    url: prefix + protocol + parts[0],\n    children: [{ type: \"text\", value: protocol + parts[0] }]\n  };\n  if (parts[1]) {\n    return [result, { type: \"text\", value: parts[1] }];\n  }\n  return result;\n}\nfunction findEmail(_, atext, label, match) {\n  if (\n    // Not an expected previous character.\n    !previous(match, true) || // Label ends in not allowed character.\n    /[-\\d_]$/.test(label)\n  ) {\n    return false;\n  }\n  return {\n    type: \"link\",\n    title: null,\n    url: \"mailto:\" + atext + \"@\" + label,\n    children: [{ type: \"text\", value: atext + \"@\" + label }]\n  };\n}\nfunction isCorrectDomain(domain2) {\n  const parts = domain2.split(\".\");\n  if (parts.length < 2 || parts[parts.length - 1] && (/_/.test(parts[parts.length - 1]) || !/[a-zA-Z\\d]/.test(parts[parts.length - 1])) || parts[parts.length - 2] && (/_/.test(parts[parts.length - 2]) || !/[a-zA-Z\\d]/.test(parts[parts.length - 2]))) {\n    return false;\n  }\n  return true;\n}\nfunction splitUrl(url) {\n  const trailExec = /[!\"&'),.:;<>?\\]}]+$/.exec(url);\n  if (!trailExec) {\n    return [url, void 0];\n  }\n  url = url.slice(0, trailExec.index);\n  let trail2 = trailExec[0];\n  let closingParenIndex = trail2.indexOf(\")\");\n  const openingParens = ccount(url, \"(\");\n  let closingParens = ccount(url, \")\");\n  while (closingParenIndex !== -1 && openingParens > closingParens) {\n    url += trail2.slice(0, closingParenIndex + 1);\n    trail2 = trail2.slice(closingParenIndex + 1);\n    closingParenIndex = trail2.indexOf(\")\");\n    closingParens++;\n  }\n  return [url, trail2];\n}\nfunction previous(match, email) {\n  const code3 = match.input.charCodeAt(match.index - 1);\n  return (match.index === 0 || unicodeWhitespace(code3) || unicodePunctuation(code3)) && // If its an email, the previous character should not be a slash.\n  (!email || code3 !== 47);\n}\n\n// node_modules/mdast-util-gfm-footnote/lib/index.js\nfootnoteReference.peek = footnoteReferencePeek;\nfunction enterFootnoteCallString() {\n  this.buffer();\n}\nfunction enterFootnoteCall(token) {\n  this.enter({ type: \"footnoteReference\", identifier: \"\", label: \"\" }, token);\n}\nfunction enterFootnoteDefinitionLabelString() {\n  this.buffer();\n}\nfunction enterFootnoteDefinition(token) {\n  this.enter(\n    { type: \"footnoteDefinition\", identifier: \"\", label: \"\", children: [] },\n    token\n  );\n}\nfunction exitFootnoteCallString(token) {\n  const label = this.resume();\n  const node = this.stack[this.stack.length - 1];\n  ok(node.type === \"footnoteReference\");\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase();\n  node.label = label;\n}\nfunction exitFootnoteCall(token) {\n  this.exit(token);\n}\nfunction exitFootnoteDefinitionLabelString(token) {\n  const label = this.resume();\n  const node = this.stack[this.stack.length - 1];\n  ok(node.type === \"footnoteDefinition\");\n  node.identifier = normalizeIdentifier(\n    this.sliceSerialize(token)\n  ).toLowerCase();\n  node.label = label;\n}\nfunction exitFootnoteDefinition(token) {\n  this.exit(token);\n}\nfunction footnoteReferencePeek() {\n  return \"[\";\n}\nfunction footnoteReference(node, _, state, info) {\n  const tracker = state.createTracker(info);\n  let value = tracker.move(\"[^\");\n  const exit2 = state.enter(\"footnoteReference\");\n  const subexit = state.enter(\"reference\");\n  value += tracker.move(\n    state.safe(state.associationId(node), { after: \"]\", before: value })\n  );\n  subexit();\n  exit2();\n  value += tracker.move(\"]\");\n  return value;\n}\nfunction gfmFootnoteFromMarkdown() {\n  return {\n    enter: {\n      gfmFootnoteCallString: enterFootnoteCallString,\n      gfmFootnoteCall: enterFootnoteCall,\n      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: enterFootnoteDefinition\n    },\n    exit: {\n      gfmFootnoteCallString: exitFootnoteCallString,\n      gfmFootnoteCall: exitFootnoteCall,\n      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,\n      gfmFootnoteDefinition: exitFootnoteDefinition\n    }\n  };\n}\nfunction gfmFootnoteToMarkdown(options) {\n  let firstLineBlank = false;\n  if (options && options.firstLineBlank) {\n    firstLineBlank = true;\n  }\n  return {\n    handlers: { footnoteDefinition, footnoteReference },\n    // This is on by default already.\n    unsafe: [{ character: \"[\", inConstruct: [\"label\", \"phrasing\", \"reference\"] }]\n  };\n  function footnoteDefinition(node, _, state, info) {\n    const tracker = state.createTracker(info);\n    let value = tracker.move(\"[^\");\n    const exit2 = state.enter(\"footnoteDefinition\");\n    const subexit = state.enter(\"label\");\n    value += tracker.move(\n      state.safe(state.associationId(node), { before: value, after: \"]\" })\n    );\n    subexit();\n    value += tracker.move(\"]:\");\n    if (node.children && node.children.length > 0) {\n      tracker.shift(4);\n      value += tracker.move(\n        (firstLineBlank ? \"\\n\" : \" \") + state.indentLines(\n          state.containerFlow(node, tracker.current()),\n          firstLineBlank ? mapAll : mapExceptFirst\n        )\n      );\n    }\n    exit2();\n    return value;\n  }\n}\nfunction mapExceptFirst(line, index, blank) {\n  return index === 0 ? line : mapAll(line, index, blank);\n}\nfunction mapAll(line, index, blank) {\n  return (blank ? \"\" : \"    \") + line;\n}\n\n// node_modules/mdast-util-gfm-strikethrough/lib/index.js\nvar constructsWithoutStrikethrough = [\n  \"autolink\",\n  \"destinationLiteral\",\n  \"destinationRaw\",\n  \"reference\",\n  \"titleQuote\",\n  \"titleApostrophe\"\n];\nhandleDelete.peek = peekDelete;\nfunction gfmStrikethroughFromMarkdown() {\n  return {\n    canContainEols: [\"delete\"],\n    enter: { strikethrough: enterStrikethrough },\n    exit: { strikethrough: exitStrikethrough }\n  };\n}\nfunction gfmStrikethroughToMarkdown() {\n  return {\n    unsafe: [\n      {\n        character: \"~\",\n        inConstruct: \"phrasing\",\n        notInConstruct: constructsWithoutStrikethrough\n      }\n    ],\n    handlers: { delete: handleDelete }\n  };\n}\nfunction enterStrikethrough(token) {\n  this.enter({ type: \"delete\", children: [] }, token);\n}\nfunction exitStrikethrough(token) {\n  this.exit(token);\n}\nfunction handleDelete(node, _, state, info) {\n  const tracker = state.createTracker(info);\n  const exit2 = state.enter(\"strikethrough\");\n  let value = tracker.move(\"~~\");\n  value += state.containerPhrasing(node, {\n    ...tracker.current(),\n    before: value,\n    after: \"~\"\n  });\n  value += tracker.move(\"~~\");\n  exit2();\n  return value;\n}\nfunction peekDelete() {\n  return \"~\";\n}\n\n// node_modules/markdown-table/index.js\nfunction defaultStringLength(value) {\n  return value.length;\n}\nfunction markdownTable(table, options) {\n  const settings = options || {};\n  const align = (settings.align || []).concat();\n  const stringLength = settings.stringLength || defaultStringLength;\n  const alignments = [];\n  const cellMatrix = [];\n  const sizeMatrix = [];\n  const longestCellByColumn = [];\n  let mostCellsPerRow = 0;\n  let rowIndex = -1;\n  while (++rowIndex < table.length) {\n    const row2 = [];\n    const sizes2 = [];\n    let columnIndex2 = -1;\n    if (table[rowIndex].length > mostCellsPerRow) {\n      mostCellsPerRow = table[rowIndex].length;\n    }\n    while (++columnIndex2 < table[rowIndex].length) {\n      const cell = serialize(table[rowIndex][columnIndex2]);\n      if (settings.alignDelimiters !== false) {\n        const size = stringLength(cell);\n        sizes2[columnIndex2] = size;\n        if (longestCellByColumn[columnIndex2] === void 0 || size > longestCellByColumn[columnIndex2]) {\n          longestCellByColumn[columnIndex2] = size;\n        }\n      }\n      row2.push(cell);\n    }\n    cellMatrix[rowIndex] = row2;\n    sizeMatrix[rowIndex] = sizes2;\n  }\n  let columnIndex = -1;\n  if (typeof align === \"object\" && \"length\" in align) {\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = toAlignment(align[columnIndex]);\n    }\n  } else {\n    const code3 = toAlignment(align);\n    while (++columnIndex < mostCellsPerRow) {\n      alignments[columnIndex] = code3;\n    }\n  }\n  columnIndex = -1;\n  const row = [];\n  const sizes = [];\n  while (++columnIndex < mostCellsPerRow) {\n    const code3 = alignments[columnIndex];\n    let before = \"\";\n    let after = \"\";\n    if (code3 === 99) {\n      before = \":\";\n      after = \":\";\n    } else if (code3 === 108) {\n      before = \":\";\n    } else if (code3 === 114) {\n      after = \":\";\n    }\n    let size = settings.alignDelimiters === false ? 1 : Math.max(\n      1,\n      longestCellByColumn[columnIndex] - before.length - after.length\n    );\n    const cell = before + \"-\".repeat(size) + after;\n    if (settings.alignDelimiters !== false) {\n      size = before.length + size + after.length;\n      if (size > longestCellByColumn[columnIndex]) {\n        longestCellByColumn[columnIndex] = size;\n      }\n      sizes[columnIndex] = size;\n    }\n    row[columnIndex] = cell;\n  }\n  cellMatrix.splice(1, 0, row);\n  sizeMatrix.splice(1, 0, sizes);\n  rowIndex = -1;\n  const lines = [];\n  while (++rowIndex < cellMatrix.length) {\n    const row2 = cellMatrix[rowIndex];\n    const sizes2 = sizeMatrix[rowIndex];\n    columnIndex = -1;\n    const line = [];\n    while (++columnIndex < mostCellsPerRow) {\n      const cell = row2[columnIndex] || \"\";\n      let before = \"\";\n      let after = \"\";\n      if (settings.alignDelimiters !== false) {\n        const size = longestCellByColumn[columnIndex] - (sizes2[columnIndex] || 0);\n        const code3 = alignments[columnIndex];\n        if (code3 === 114) {\n          before = \" \".repeat(size);\n        } else if (code3 === 99) {\n          if (size % 2) {\n            before = \" \".repeat(size / 2 + 0.5);\n            after = \" \".repeat(size / 2 - 0.5);\n          } else {\n            before = \" \".repeat(size / 2);\n            after = before;\n          }\n        } else {\n          after = \" \".repeat(size);\n        }\n      }\n      if (settings.delimiterStart !== false && !columnIndex) {\n        line.push(\"|\");\n      }\n      if (settings.padding !== false && // Dont add the opening space if were not aligning and the cell is\n      // empty: there will be a closing space.\n      !(settings.alignDelimiters === false && cell === \"\") && (settings.delimiterStart !== false || columnIndex)) {\n        line.push(\" \");\n      }\n      if (settings.alignDelimiters !== false) {\n        line.push(before);\n      }\n      line.push(cell);\n      if (settings.alignDelimiters !== false) {\n        line.push(after);\n      }\n      if (settings.padding !== false) {\n        line.push(\" \");\n      }\n      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {\n        line.push(\"|\");\n      }\n    }\n    lines.push(\n      settings.delimiterEnd === false ? line.join(\"\").replace(/ +$/, \"\") : line.join(\"\")\n    );\n  }\n  return lines.join(\"\\n\");\n}\nfunction serialize(value) {\n  return value === null || value === void 0 ? \"\" : String(value);\n}\nfunction toAlignment(value) {\n  const code3 = typeof value === \"string\" ? value.codePointAt(0) : 0;\n  return code3 === 67 || code3 === 99 ? 99 : code3 === 76 || code3 === 108 ? 108 : code3 === 82 || code3 === 114 ? 114 : 0;\n}\n\n// node_modules/zwitch/index.js\nvar own = {}.hasOwnProperty;\n\n// node_modules/mdast-util-to-markdown/lib/configure.js\nvar own2 = {}.hasOwnProperty;\n\n// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js\nfunction blockquote(node, _, state, info) {\n  const exit2 = state.enter(\"blockquote\");\n  const tracker = state.createTracker(info);\n  tracker.move(\"> \");\n  tracker.shift(2);\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  );\n  exit2();\n  return value;\n}\nfunction map(line, _, blank) {\n  return \">\" + (blank ? \"\" : \" \") + line;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js\nfunction patternInScope(stack, pattern) {\n  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);\n}\nfunction listInScope(stack, list2, none) {\n  if (typeof list2 === \"string\") {\n    list2 = [list2];\n  }\n  if (!list2 || list2.length === 0) {\n    return none;\n  }\n  let index = -1;\n  while (++index < list2.length) {\n    if (stack.includes(list2[index])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/break.js\nfunction hardBreak(_, _1, state, info) {\n  let index = -1;\n  while (++index < state.unsafe.length) {\n    if (state.unsafe[index].character === \"\\n\" && patternInScope(state.stack, state.unsafe[index])) {\n      return /[ \\t]/.test(info.before) ? \"\" : \" \";\n    }\n  }\n  return \"\\\\\\n\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js\nfunction formatCodeAsIndented(node, state) {\n  return Boolean(\n    state.options.fences === false && node.value && // If theres no info\n    !node.lang && // And theres a non-whitespace character\n    /[^ \\r\\n]/.test(node.value) && // And the value doesnt start or end in a blank\n    !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  );\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-fence.js\nfunction checkFence(state) {\n  const marker = state.options.fence || \"`\";\n  if (marker !== \"`\" && marker !== \"~\") {\n    throw new Error(\n      \"Cannot serialize code with `\" + marker + \"` for `options.fence`, expected `` ` `` or `~`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/code.js\nfunction code(node, _, state, info) {\n  const marker = checkFence(state);\n  const raw = node.value || \"\";\n  const suffix = marker === \"`\" ? \"GraveAccent\" : \"Tilde\";\n  if (formatCodeAsIndented(node, state)) {\n    const exit3 = state.enter(\"codeIndented\");\n    const value2 = state.indentLines(raw, map2);\n    exit3();\n    return value2;\n  }\n  const tracker = state.createTracker(info);\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));\n  const exit2 = state.enter(\"codeFenced\");\n  let value = tracker.move(sequence);\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`);\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: \" \",\n        encode: [\"`\"],\n        ...tracker.current()\n      })\n    );\n    subexit();\n  }\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`);\n    value += tracker.move(\" \");\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: \"\\n\",\n        encode: [\"`\"],\n        ...tracker.current()\n      })\n    );\n    subexit();\n  }\n  value += tracker.move(\"\\n\");\n  if (raw) {\n    value += tracker.move(raw + \"\\n\");\n  }\n  value += tracker.move(sequence);\n  exit2();\n  return value;\n}\nfunction map2(line, _, blank) {\n  return (blank ? \"\" : \"    \") + line;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-quote.js\nfunction checkQuote(state) {\n  const marker = state.options.quote || '\"';\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      \"Cannot serialize title with `\" + marker + \"` for `options.quote`, expected `\\\"`, or `'`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/definition.js\nfunction definition(node, _, state, info) {\n  const quote = checkQuote(state);\n  const suffix = quote === '\"' ? \"Quote\" : \"Apostrophe\";\n  const exit2 = state.enter(\"definition\");\n  let subexit = state.enter(\"label\");\n  const tracker = state.createTracker(info);\n  let value = tracker.move(\"[\");\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: \"]\",\n      ...tracker.current()\n    })\n  );\n  value += tracker.move(\"]: \");\n  subexit();\n  if (\n    // If theres no url, or\n    !node.url || // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter(\"destinationLiteral\");\n    value += tracker.move(\"<\");\n    value += tracker.move(\n      state.safe(node.url, { before: value, after: \">\", ...tracker.current() })\n    );\n    value += tracker.move(\">\");\n  } else {\n    subexit = state.enter(\"destinationRaw\");\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? \" \" : \"\\n\",\n        ...tracker.current()\n      })\n    );\n  }\n  subexit();\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`);\n    value += tracker.move(\" \" + quote);\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    );\n    value += tracker.move(quote);\n    subexit();\n  }\n  exit2();\n  return value;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js\nfunction checkEmphasis(state) {\n  const marker = state.options.emphasis || \"*\";\n  if (marker !== \"*\" && marker !== \"_\") {\n    throw new Error(\n      \"Cannot serialize emphasis with `\" + marker + \"` for `options.emphasis`, expected `*`, or `_`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/encode-character-reference.js\nfunction encodeCharacterReference(code3) {\n  return \"&#x\" + code3.toString(16).toUpperCase() + \";\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/encode-info.js\nfunction encodeInfo(outside, inside, marker) {\n  const outsideKind = classifyCharacter(outside);\n  const insideKind = classifyCharacter(inside);\n  if (outsideKind === void 0) {\n    return insideKind === void 0 ? (\n      // Letter inside:\n      // we have to encode *both* letters for `_` as it is looser.\n      // it already forms for `*` (and GFMs `~`).\n      marker === \"_\" ? { inside: true, outside: true } : { inside: false, outside: false }\n    ) : insideKind === 1 ? (\n      // Whitespace inside: encode both (letter, whitespace).\n      { inside: true, outside: true }\n    ) : (\n      // Punctuation inside: encode outer (letter)\n      { inside: false, outside: true }\n    );\n  }\n  if (outsideKind === 1) {\n    return insideKind === void 0 ? (\n      // Letter inside: already forms.\n      { inside: false, outside: false }\n    ) : insideKind === 1 ? (\n      // Whitespace inside: encode both (whitespace).\n      { inside: true, outside: true }\n    ) : (\n      // Punctuation inside: already forms.\n      { inside: false, outside: false }\n    );\n  }\n  return insideKind === void 0 ? (\n    // Letter inside: already forms.\n    { inside: false, outside: false }\n  ) : insideKind === 1 ? (\n    // Whitespace inside: encode inner (whitespace).\n    { inside: true, outside: false }\n  ) : (\n    // Punctuation inside: already forms.\n    { inside: false, outside: false }\n  );\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js\nemphasis.peek = emphasisPeek;\nfunction emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state);\n  const exit2 = state.enter(\"emphasis\");\n  const tracker = state.createTracker(info);\n  const before = tracker.move(marker);\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  );\n  const betweenHead = between.charCodeAt(0);\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  );\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1);\n  }\n  const betweenTail = between.charCodeAt(between.length - 1);\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);\n  }\n  const after = tracker.move(marker);\n  exit2();\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  };\n  return before + between + after;\n}\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || \"*\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js\nfunction formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false;\n  visit(node, function(node2) {\n    if (\"value\" in node2 && /\\r?\\n|\\r/.test(node2.value) || node2.type === \"break\") {\n      literalWithBreak = true;\n      return EXIT;\n    }\n  });\n  return Boolean(\n    (!node.depth || node.depth < 3) && toString(node) && (state.options.setext || literalWithBreak)\n  );\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/heading.js\nfunction heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1);\n  const tracker = state.createTracker(info);\n  if (formatHeadingAsSetext(node, state)) {\n    const exit3 = state.enter(\"headingSetext\");\n    const subexit2 = state.enter(\"phrasing\");\n    const value2 = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: \"\\n\",\n      after: \"\\n\"\n    });\n    subexit2();\n    exit3();\n    return value2 + \"\\n\" + (rank === 1 ? \"=\" : \"-\").repeat(\n      // The whole size\n      value2.length - // Minus the position of the character after the last EOL (or\n      // 0 if there is none)\n      (Math.max(value2.lastIndexOf(\"\\r\"), value2.lastIndexOf(\"\\n\")) + 1)\n    );\n  }\n  const sequence = \"#\".repeat(rank);\n  const exit2 = state.enter(\"headingAtx\");\n  const subexit = state.enter(\"phrasing\");\n  tracker.move(sequence + \" \");\n  let value = state.containerPhrasing(node, {\n    before: \"# \",\n    after: \"\\n\",\n    ...tracker.current()\n  });\n  if (/^[\\t ]/.test(value)) {\n    value = encodeCharacterReference(value.charCodeAt(0)) + value.slice(1);\n  }\n  value = value ? sequence + \" \" + value : sequence;\n  if (state.options.closeAtx) {\n    value += \" \" + sequence;\n  }\n  subexit();\n  exit2();\n  return value;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/html.js\nhtml.peek = htmlPeek;\nfunction html(node) {\n  return node.value || \"\";\n}\nfunction htmlPeek() {\n  return \"<\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/image.js\nimage.peek = imagePeek;\nfunction image(node, _, state, info) {\n  const quote = checkQuote(state);\n  const suffix = quote === '\"' ? \"Quote\" : \"Apostrophe\";\n  const exit2 = state.enter(\"image\");\n  let subexit = state.enter(\"label\");\n  const tracker = state.createTracker(info);\n  let value = tracker.move(\"![\");\n  value += tracker.move(\n    state.safe(node.alt, { before: value, after: \"]\", ...tracker.current() })\n  );\n  value += tracker.move(\"](\");\n  subexit();\n  if (\n    // If theres no url but there is a title\n    !node.url && node.title || // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter(\"destinationLiteral\");\n    value += tracker.move(\"<\");\n    value += tracker.move(\n      state.safe(node.url, { before: value, after: \">\", ...tracker.current() })\n    );\n    value += tracker.move(\">\");\n  } else {\n    subexit = state.enter(\"destinationRaw\");\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? \" \" : \")\",\n        ...tracker.current()\n      })\n    );\n  }\n  subexit();\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`);\n    value += tracker.move(\" \" + quote);\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    );\n    value += tracker.move(quote);\n    subexit();\n  }\n  value += tracker.move(\")\");\n  exit2();\n  return value;\n}\nfunction imagePeek() {\n  return \"!\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js\nimageReference.peek = imageReferencePeek;\nfunction imageReference(node, _, state, info) {\n  const type = node.referenceType;\n  const exit2 = state.enter(\"imageReference\");\n  let subexit = state.enter(\"label\");\n  const tracker = state.createTracker(info);\n  let value = tracker.move(\"![\");\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: \"]\",\n    ...tracker.current()\n  });\n  value += tracker.move(alt + \"][\");\n  subexit();\n  const stack = state.stack;\n  state.stack = [];\n  subexit = state.enter(\"reference\");\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: \"]\",\n    ...tracker.current()\n  });\n  subexit();\n  state.stack = stack;\n  exit2();\n  if (type === \"full\" || !alt || alt !== reference) {\n    value += tracker.move(reference + \"]\");\n  } else if (type === \"shortcut\") {\n    value = value.slice(0, -1);\n  } else {\n    value += tracker.move(\"]\");\n  }\n  return value;\n}\nfunction imageReferencePeek() {\n  return \"!\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js\ninlineCode.peek = inlineCodePeek;\nfunction inlineCode(node, _, state) {\n  let value = node.value || \"\";\n  let sequence = \"`\";\n  let index = -1;\n  while (new RegExp(\"(^|[^`])\" + sequence + \"([^`]|$)\").test(value)) {\n    sequence += \"`\";\n  }\n  if (/[^ \\r\\n]/.test(value) && (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || /^`|`$/.test(value))) {\n    value = \" \" + value + \" \";\n  }\n  while (++index < state.unsafe.length) {\n    const pattern = state.unsafe[index];\n    const expression = state.compilePattern(pattern);\n    let match;\n    if (!pattern.atBreak) continue;\n    while (match = expression.exec(value)) {\n      let position = match.index;\n      if (value.charCodeAt(position) === 10 && value.charCodeAt(position - 1) === 13) {\n        position--;\n      }\n      value = value.slice(0, position) + \" \" + value.slice(match.index + 1);\n    }\n  }\n  return sequence + value + sequence;\n}\nfunction inlineCodePeek() {\n  return \"`\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js\nfunction formatLinkAsAutolink(node, state) {\n  const raw = toString(node);\n  return Boolean(\n    !state.options.resourceLink && // If theres a url\n    node.url && // And theres a no title\n    !node.title && // And the content of `node` is a single text node\n    node.children && node.children.length === 1 && node.children[0].type === \"text\" && // And if the url is the same as the content\n    (raw === node.url || \"mailto:\" + raw === node.url) && // And that starts w/ a protocol\n    /^[a-z][a-z+.-]+:/i.test(node.url) && // And that doesnt contain ASCII control codes (character escapes and\n    // references dont work), space, or angle brackets\n    !/[\\0- <>\\u007F]/.test(node.url)\n  );\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/link.js\nlink.peek = linkPeek;\nfunction link(node, _, state, info) {\n  const quote = checkQuote(state);\n  const suffix = quote === '\"' ? \"Quote\" : \"Apostrophe\";\n  const tracker = state.createTracker(info);\n  let exit2;\n  let subexit;\n  if (formatLinkAsAutolink(node, state)) {\n    const stack = state.stack;\n    state.stack = [];\n    exit2 = state.enter(\"autolink\");\n    let value2 = tracker.move(\"<\");\n    value2 += tracker.move(\n      state.containerPhrasing(node, {\n        before: value2,\n        after: \">\",\n        ...tracker.current()\n      })\n    );\n    value2 += tracker.move(\">\");\n    exit2();\n    state.stack = stack;\n    return value2;\n  }\n  exit2 = state.enter(\"link\");\n  subexit = state.enter(\"label\");\n  let value = tracker.move(\"[\");\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: \"](\",\n      ...tracker.current()\n    })\n  );\n  value += tracker.move(\"](\");\n  subexit();\n  if (\n    // If theres no url but there is a title\n    !node.url && node.title || // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter(\"destinationLiteral\");\n    value += tracker.move(\"<\");\n    value += tracker.move(\n      state.safe(node.url, { before: value, after: \">\", ...tracker.current() })\n    );\n    value += tracker.move(\">\");\n  } else {\n    subexit = state.enter(\"destinationRaw\");\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? \" \" : \")\",\n        ...tracker.current()\n      })\n    );\n  }\n  subexit();\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`);\n    value += tracker.move(\" \" + quote);\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    );\n    value += tracker.move(quote);\n    subexit();\n  }\n  value += tracker.move(\")\");\n  exit2();\n  return value;\n}\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? \"<\" : \"[\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js\nlinkReference.peek = linkReferencePeek;\nfunction linkReference(node, _, state, info) {\n  const type = node.referenceType;\n  const exit2 = state.enter(\"linkReference\");\n  let subexit = state.enter(\"label\");\n  const tracker = state.createTracker(info);\n  let value = tracker.move(\"[\");\n  const text3 = state.containerPhrasing(node, {\n    before: value,\n    after: \"]\",\n    ...tracker.current()\n  });\n  value += tracker.move(text3 + \"][\");\n  subexit();\n  const stack = state.stack;\n  state.stack = [];\n  subexit = state.enter(\"reference\");\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: \"]\",\n    ...tracker.current()\n  });\n  subexit();\n  state.stack = stack;\n  exit2();\n  if (type === \"full\" || !text3 || text3 !== reference) {\n    value += tracker.move(reference + \"]\");\n  } else if (type === \"shortcut\") {\n    value = value.slice(0, -1);\n  } else {\n    value += tracker.move(\"]\");\n  }\n  return value;\n}\nfunction linkReferencePeek() {\n  return \"[\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js\nfunction checkBullet(state) {\n  const marker = state.options.bullet || \"*\";\n  if (marker !== \"*\" && marker !== \"+\" && marker !== \"-\") {\n    throw new Error(\n      \"Cannot serialize items with `\" + marker + \"` for `options.bullet`, expected `*`, `+`, or `-`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js\nfunction checkBulletOther(state) {\n  const bullet = checkBullet(state);\n  const bulletOther = state.options.bulletOther;\n  if (!bulletOther) {\n    return bullet === \"*\" ? \"-\" : \"*\";\n  }\n  if (bulletOther !== \"*\" && bulletOther !== \"+\" && bulletOther !== \"-\") {\n    throw new Error(\n      \"Cannot serialize items with `\" + bulletOther + \"` for `options.bulletOther`, expected `*`, `+`, or `-`\"\n    );\n  }\n  if (bulletOther === bullet) {\n    throw new Error(\n      \"Expected `bullet` (`\" + bullet + \"`) and `bulletOther` (`\" + bulletOther + \"`) to be different\"\n    );\n  }\n  return bulletOther;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js\nfunction checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || \".\";\n  if (marker !== \".\" && marker !== \")\") {\n    throw new Error(\n      \"Cannot serialize items with `\" + marker + \"` for `options.bulletOrdered`, expected `.` or `)`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-rule.js\nfunction checkRule(state) {\n  const marker = state.options.rule || \"*\";\n  if (marker !== \"*\" && marker !== \"-\" && marker !== \"_\") {\n    throw new Error(\n      \"Cannot serialize rules with `\" + marker + \"` for `options.rule`, expected `*`, `-`, or `_`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/list.js\nfunction list(node, parent, state, info) {\n  const exit2 = state.enter(\"list\");\n  const bulletCurrent = state.bulletCurrent;\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state);\n  const bulletOther = node.ordered ? bullet === \".\" ? \")\" : \".\" : checkBulletOther(state);\n  let useDifferentMarker = parent && state.bulletLastUsed ? bullet === state.bulletLastUsed : false;\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : void 0;\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === \"*\" || bullet === \"-\") && // Empty first list item:\n      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:\n      state.stack[state.stack.length - 1] === \"list\" && state.stack[state.stack.length - 2] === \"listItem\" && state.stack[state.stack.length - 3] === \"list\" && state.stack[state.stack.length - 4] === \"listItem\" && // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true;\n    }\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1;\n      while (++index < node.children.length) {\n        const item = node.children[index];\n        if (item && item.type === \"listItem\" && item.children && item.children[0] && item.children[0].type === \"thematicBreak\") {\n          useDifferentMarker = true;\n          break;\n        }\n      }\n    }\n  }\n  if (useDifferentMarker) {\n    bullet = bulletOther;\n  }\n  state.bulletCurrent = bullet;\n  const value = state.containerFlow(node, info);\n  state.bulletLastUsed = bullet;\n  state.bulletCurrent = bulletCurrent;\n  exit2();\n  return value;\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js\nfunction checkListItemIndent(state) {\n  const style = state.options.listItemIndent || \"one\";\n  if (style !== \"tab\" && style !== \"one\" && style !== \"mixed\") {\n    throw new Error(\n      \"Cannot serialize items with `\" + style + \"` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`\"\n    );\n  }\n  return style;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/list-item.js\nfunction listItem(node, parent, state, info) {\n  const listItemIndent = checkListItemIndent(state);\n  let bullet = state.bulletCurrent || checkBullet(state);\n  if (parent && parent.type === \"list\" && parent.ordered) {\n    bullet = (typeof parent.start === \"number\" && parent.start > -1 ? parent.start : 1) + (state.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + bullet;\n  }\n  let size = bullet.length + 1;\n  if (listItemIndent === \"tab\" || listItemIndent === \"mixed\" && (parent && parent.type === \"list\" && parent.spread || node.spread)) {\n    size = Math.ceil(size / 4) * 4;\n  }\n  const tracker = state.createTracker(info);\n  tracker.move(bullet + \" \".repeat(size - bullet.length));\n  tracker.shift(size);\n  const exit2 = state.enter(\"listItem\");\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map3\n  );\n  exit2();\n  return value;\n  function map3(line, index, blank) {\n    if (index) {\n      return (blank ? \"\" : \" \".repeat(size)) + line;\n    }\n    return (blank ? bullet : bullet + \" \".repeat(size - bullet.length)) + line;\n  }\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js\nfunction paragraph(node, _, state, info) {\n  const exit2 = state.enter(\"paragraph\");\n  const subexit = state.enter(\"phrasing\");\n  const value = state.containerPhrasing(node, info);\n  subexit();\n  exit2();\n  return value;\n}\n\n// node_modules/mdast-util-phrasing/lib/index.js\nvar phrasing = (\n  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */\n  convert([\n    \"break\",\n    \"delete\",\n    \"emphasis\",\n    // To do: next major: removed since footnotes were added to GFM.\n    \"footnote\",\n    \"footnoteReference\",\n    \"image\",\n    \"imageReference\",\n    \"inlineCode\",\n    // Enabled by `mdast-util-math`:\n    \"inlineMath\",\n    \"link\",\n    \"linkReference\",\n    // Enabled by `mdast-util-mdx`:\n    \"mdxJsxTextElement\",\n    // Enabled by `mdast-util-mdx`:\n    \"mdxTextExpression\",\n    \"strong\",\n    \"text\",\n    // Enabled by `mdast-util-directive`:\n    \"textDirective\"\n  ])\n);\n\n// node_modules/mdast-util-to-markdown/lib/handle/root.js\nfunction root(node, _, state, info) {\n  const hasPhrasing = node.children.some(function(d) {\n    return phrasing(d);\n  });\n  const container = hasPhrasing ? state.containerPhrasing : state.containerFlow;\n  return container.call(state, node, info);\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-strong.js\nfunction checkStrong(state) {\n  const marker = state.options.strong || \"*\";\n  if (marker !== \"*\" && marker !== \"_\") {\n    throw new Error(\n      \"Cannot serialize strong with `\" + marker + \"` for `options.strong`, expected `*`, or `_`\"\n    );\n  }\n  return marker;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/strong.js\nstrong.peek = strongPeek;\nfunction strong(node, _, state, info) {\n  const marker = checkStrong(state);\n  const exit2 = state.enter(\"strong\");\n  const tracker = state.createTracker(info);\n  const before = tracker.move(marker + marker);\n  let between = tracker.move(\n    state.containerPhrasing(node, {\n      after: marker,\n      before,\n      ...tracker.current()\n    })\n  );\n  const betweenHead = between.charCodeAt(0);\n  const open = encodeInfo(\n    info.before.charCodeAt(info.before.length - 1),\n    betweenHead,\n    marker\n  );\n  if (open.inside) {\n    between = encodeCharacterReference(betweenHead) + between.slice(1);\n  }\n  const betweenTail = between.charCodeAt(between.length - 1);\n  const close = encodeInfo(info.after.charCodeAt(0), betweenTail, marker);\n  if (close.inside) {\n    between = between.slice(0, -1) + encodeCharacterReference(betweenTail);\n  }\n  const after = tracker.move(marker + marker);\n  exit2();\n  state.attentionEncodeSurroundingInfo = {\n    after: close.outside,\n    before: open.outside\n  };\n  return before + between + after;\n}\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || \"*\";\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/text.js\nfunction text(node, _, state, info) {\n  return state.safe(node.value, info);\n}\n\n// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js\nfunction checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3;\n  if (repetition < 3) {\n    throw new Error(\n      \"Cannot serialize rules with repetition `\" + repetition + \"` for `options.ruleRepetition`, expected `3` or more\"\n    );\n  }\n  return repetition;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js\nfunction thematicBreak(_, _1, state) {\n  const value = (checkRule(state) + (state.options.ruleSpaces ? \" \" : \"\")).repeat(checkRuleRepetition(state));\n  return state.options.ruleSpaces ? value.slice(0, -1) : value;\n}\n\n// node_modules/mdast-util-to-markdown/lib/handle/index.js\nvar handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n};\n\n// node_modules/mdast-util-gfm-table/lib/index.js\nfunction gfmTableFromMarkdown() {\n  return {\n    enter: {\n      table: enterTable,\n      tableData: enterCell,\n      tableHeader: enterCell,\n      tableRow: enterRow\n    },\n    exit: {\n      codeText: exitCodeText,\n      table: exitTable,\n      tableData: exit,\n      tableHeader: exit,\n      tableRow: exit\n    }\n  };\n}\nfunction enterTable(token) {\n  const align = token._align;\n  ok(align, \"expected `_align` on table\");\n  this.enter(\n    {\n      type: \"table\",\n      align: align.map(function(d) {\n        return d === \"none\" ? null : d;\n      }),\n      children: []\n    },\n    token\n  );\n  this.data.inTable = true;\n}\nfunction exitTable(token) {\n  this.exit(token);\n  this.data.inTable = void 0;\n}\nfunction enterRow(token) {\n  this.enter({ type: \"tableRow\", children: [] }, token);\n}\nfunction exit(token) {\n  this.exit(token);\n}\nfunction enterCell(token) {\n  this.enter({ type: \"tableCell\", children: [] }, token);\n}\nfunction exitCodeText(token) {\n  let value = this.resume();\n  if (this.data.inTable) {\n    value = value.replace(/\\\\([\\\\|])/g, replace);\n  }\n  const node = this.stack[this.stack.length - 1];\n  ok(node.type === \"inlineCode\");\n  node.value = value;\n  this.exit(token);\n}\nfunction replace($0, $1) {\n  return $1 === \"|\" ? $1 : $0;\n}\nfunction gfmTableToMarkdown(options) {\n  const settings = options || {};\n  const padding = settings.tableCellPadding;\n  const alignDelimiters = settings.tablePipeAlign;\n  const stringLength = settings.stringLength;\n  const around = padding ? \" \" : \"|\";\n  return {\n    unsafe: [\n      { character: \"\\r\", inConstruct: \"tableCell\" },\n      { character: \"\\n\", inConstruct: \"tableCell\" },\n      // A pipe, when followed by a tab or space (padding), or a dash or colon\n      // (unpadded delimiter row), could result in a table.\n      { atBreak: true, character: \"|\", after: \"[\t :-]\" },\n      // A pipe in a cell must be encoded.\n      { character: \"|\", inConstruct: \"tableCell\" },\n      // A colon must be followed by a dash, in which case it could start a\n      // delimiter row.\n      { atBreak: true, character: \":\", after: \"-\" },\n      // A delimiter row can also start with a dash, when followed by more\n      // dashes, a colon, or a pipe.\n      // This is a stricter version than the built in check for lists, thematic\n      // breaks, and setex heading underlines though:\n      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>\n      { atBreak: true, character: \"-\", after: \"[:|-]\" }\n    ],\n    handlers: {\n      inlineCode: inlineCodeWithTable,\n      table: handleTable,\n      tableCell: handleTableCell,\n      tableRow: handleTableRow\n    }\n  };\n  function handleTable(node, _, state, info) {\n    return serializeData(handleTableAsData(node, state, info), node.align);\n  }\n  function handleTableRow(node, _, state, info) {\n    const row = handleTableRowAsData(node, state, info);\n    const value = serializeData([row]);\n    return value.slice(0, value.indexOf(\"\\n\"));\n  }\n  function handleTableCell(node, _, state, info) {\n    const exit2 = state.enter(\"tableCell\");\n    const subexit = state.enter(\"phrasing\");\n    const value = state.containerPhrasing(node, {\n      ...info,\n      before: around,\n      after: around\n    });\n    subexit();\n    exit2();\n    return value;\n  }\n  function serializeData(matrix, align) {\n    return markdownTable(matrix, {\n      align,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      alignDelimiters,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      padding,\n      // @ts-expect-error: `markdown-table` types should support `null`.\n      stringLength\n    });\n  }\n  function handleTableAsData(node, state, info) {\n    const children = node.children;\n    let index = -1;\n    const result = [];\n    const subexit = state.enter(\"table\");\n    while (++index < children.length) {\n      result[index] = handleTableRowAsData(children[index], state, info);\n    }\n    subexit();\n    return result;\n  }\n  function handleTableRowAsData(node, state, info) {\n    const children = node.children;\n    let index = -1;\n    const result = [];\n    const subexit = state.enter(\"tableRow\");\n    while (++index < children.length) {\n      result[index] = handleTableCell(children[index], node, state, info);\n    }\n    subexit();\n    return result;\n  }\n  function inlineCodeWithTable(node, parent, state) {\n    let value = handle.inlineCode(node, parent, state);\n    if (state.stack.includes(\"tableCell\")) {\n      value = value.replace(/\\|/g, \"\\\\$&\");\n    }\n    return value;\n  }\n}\n\n// node_modules/mdast-util-gfm-task-list-item/lib/index.js\nfunction gfmTaskListItemFromMarkdown() {\n  return {\n    exit: {\n      taskListCheckValueChecked: exitCheck,\n      taskListCheckValueUnchecked: exitCheck,\n      paragraph: exitParagraphWithTaskListItem\n    }\n  };\n}\nfunction gfmTaskListItemToMarkdown() {\n  return {\n    unsafe: [{ atBreak: true, character: \"-\", after: \"[:|-]\" }],\n    handlers: { listItem: listItemWithTaskListItem }\n  };\n}\nfunction exitCheck(token) {\n  const node = this.stack[this.stack.length - 2];\n  ok(node.type === \"listItem\");\n  node.checked = token.type === \"taskListCheckValueChecked\";\n}\nfunction exitParagraphWithTaskListItem(token) {\n  const parent = this.stack[this.stack.length - 2];\n  if (parent && parent.type === \"listItem\" && typeof parent.checked === \"boolean\") {\n    const node = this.stack[this.stack.length - 1];\n    ok(node.type === \"paragraph\");\n    const head = node.children[0];\n    if (head && head.type === \"text\") {\n      const siblings = parent.children;\n      let index = -1;\n      let firstParaghraph;\n      while (++index < siblings.length) {\n        const sibling = siblings[index];\n        if (sibling.type === \"paragraph\") {\n          firstParaghraph = sibling;\n          break;\n        }\n      }\n      if (firstParaghraph === node) {\n        head.value = head.value.slice(1);\n        if (head.value.length === 0) {\n          node.children.shift();\n        } else if (node.position && head.position && typeof head.position.start.offset === \"number\") {\n          head.position.start.column++;\n          head.position.start.offset++;\n          node.position.start = Object.assign({}, head.position.start);\n        }\n      }\n    }\n  }\n  this.exit(token);\n}\nfunction listItemWithTaskListItem(node, parent, state, info) {\n  const head = node.children[0];\n  const checkable = typeof node.checked === \"boolean\" && head && head.type === \"paragraph\";\n  const checkbox = \"[\" + (node.checked ? \"x\" : \" \") + \"] \";\n  const tracker = state.createTracker(info);\n  if (checkable) {\n    tracker.move(checkbox);\n  }\n  let value = handle.listItem(node, parent, state, {\n    ...info,\n    ...tracker.current()\n  });\n  if (checkable) {\n    value = value.replace(/^(?:[*+-]|\\d+\\.)([\\r\\n]| {1,3})/, check);\n  }\n  return value;\n  function check($0) {\n    return $0 + checkbox;\n  }\n}\n\n// node_modules/mdast-util-gfm/lib/index.js\nfunction gfmFromMarkdown() {\n  return [\n    gfmAutolinkLiteralFromMarkdown(),\n    gfmFootnoteFromMarkdown(),\n    gfmStrikethroughFromMarkdown(),\n    gfmTableFromMarkdown(),\n    gfmTaskListItemFromMarkdown()\n  ];\n}\nfunction gfmToMarkdown(options) {\n  return {\n    extensions: [\n      gfmAutolinkLiteralToMarkdown(),\n      gfmFootnoteToMarkdown(options),\n      gfmStrikethroughToMarkdown(),\n      gfmTableToMarkdown(options),\n      gfmTaskListItemToMarkdown()\n    ]\n  };\n}\n\n// node_modules/micromark-extension-gfm-autolink-literal/dev/lib/syntax.js\nvar wwwPrefix = { tokenize: tokenizeWwwPrefix, partial: true };\nvar domain = { tokenize: tokenizeDomain, partial: true };\nvar path = { tokenize: tokenizePath, partial: true };\nvar trail = { tokenize: tokenizeTrail, partial: true };\nvar emailDomainDotTrail = {\n  tokenize: tokenizeEmailDomainDotTrail,\n  partial: true\n};\nvar wwwAutolink = {\n  name: \"wwwAutolink\",\n  tokenize: tokenizeWwwAutolink,\n  previous: previousWww\n};\nvar protocolAutolink = {\n  name: \"protocolAutolink\",\n  tokenize: tokenizeProtocolAutolink,\n  previous: previousProtocol\n};\nvar emailAutolink = {\n  name: \"emailAutolink\",\n  tokenize: tokenizeEmailAutolink,\n  previous: previousEmail\n};\nvar text2 = {};\nfunction gfmAutolinkLiteral() {\n  return { text: text2 };\n}\nvar code2 = codes.digit0;\nwhile (code2 < codes.leftCurlyBrace) {\n  text2[code2] = emailAutolink;\n  code2++;\n  if (code2 === codes.colon) code2 = codes.uppercaseA;\n  else if (code2 === codes.leftSquareBracket) code2 = codes.lowercaseA;\n}\ntext2[codes.plusSign] = emailAutolink;\ntext2[codes.dash] = emailAutolink;\ntext2[codes.dot] = emailAutolink;\ntext2[codes.underscore] = emailAutolink;\ntext2[codes.uppercaseH] = [emailAutolink, protocolAutolink];\ntext2[codes.lowercaseH] = [emailAutolink, protocolAutolink];\ntext2[codes.uppercaseW] = [emailAutolink, wwwAutolink];\ntext2[codes.lowercaseW] = [emailAutolink, wwwAutolink];\nfunction tokenizeEmailAutolink(effects, ok2, nok) {\n  const self = this;\n  let dot;\n  let data;\n  return start;\n  function start(code3) {\n    if (!gfmAtext(code3) || !previousEmail.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code3);\n    }\n    effects.enter(\"literalAutolink\");\n    effects.enter(\"literalAutolinkEmail\");\n    return atext(code3);\n  }\n  function atext(code3) {\n    if (gfmAtext(code3)) {\n      effects.consume(code3);\n      return atext;\n    }\n    if (code3 === codes.atSign) {\n      effects.consume(code3);\n      return emailDomain;\n    }\n    return nok(code3);\n  }\n  function emailDomain(code3) {\n    if (code3 === codes.dot) {\n      return effects.check(\n        emailDomainDotTrail,\n        emailDomainAfter,\n        emailDomainDot\n      )(code3);\n    }\n    if (code3 === codes.dash || code3 === codes.underscore || asciiAlphanumeric(code3)) {\n      data = true;\n      effects.consume(code3);\n      return emailDomain;\n    }\n    return emailDomainAfter(code3);\n  }\n  function emailDomainDot(code3) {\n    effects.consume(code3);\n    dot = true;\n    return emailDomain;\n  }\n  function emailDomainAfter(code3) {\n    if (data && dot && asciiAlpha(self.previous)) {\n      effects.exit(\"literalAutolinkEmail\");\n      effects.exit(\"literalAutolink\");\n      return ok2(code3);\n    }\n    return nok(code3);\n  }\n}\nfunction tokenizeWwwAutolink(effects, ok2, nok) {\n  const self = this;\n  return wwwStart;\n  function wwwStart(code3) {\n    if (code3 !== codes.uppercaseW && code3 !== codes.lowercaseW || !previousWww.call(self, self.previous) || previousUnbalanced(self.events)) {\n      return nok(code3);\n    }\n    effects.enter(\"literalAutolink\");\n    effects.enter(\"literalAutolinkWww\");\n    return effects.check(\n      wwwPrefix,\n      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),\n      nok\n    )(code3);\n  }\n  function wwwAfter(code3) {\n    effects.exit(\"literalAutolinkWww\");\n    effects.exit(\"literalAutolink\");\n    return ok2(code3);\n  }\n}\nfunction tokenizeProtocolAutolink(effects, ok2, nok) {\n  const self = this;\n  let buffer = \"\";\n  let seen = false;\n  return protocolStart;\n  function protocolStart(code3) {\n    if ((code3 === codes.uppercaseH || code3 === codes.lowercaseH) && previousProtocol.call(self, self.previous) && !previousUnbalanced(self.events)) {\n      effects.enter(\"literalAutolink\");\n      effects.enter(\"literalAutolinkHttp\");\n      buffer += String.fromCodePoint(code3);\n      effects.consume(code3);\n      return protocolPrefixInside;\n    }\n    return nok(code3);\n  }\n  function protocolPrefixInside(code3) {\n    if (asciiAlpha(code3) && buffer.length < 5) {\n      buffer += String.fromCodePoint(code3);\n      effects.consume(code3);\n      return protocolPrefixInside;\n    }\n    if (code3 === codes.colon) {\n      const protocol = buffer.toLowerCase();\n      if (protocol === \"http\" || protocol === \"https\") {\n        effects.consume(code3);\n        return protocolSlashesInside;\n      }\n    }\n    return nok(code3);\n  }\n  function protocolSlashesInside(code3) {\n    if (code3 === codes.slash) {\n      effects.consume(code3);\n      if (seen) {\n        return afterProtocol;\n      }\n      seen = true;\n      return protocolSlashesInside;\n    }\n    return nok(code3);\n  }\n  function afterProtocol(code3) {\n    return code3 === codes.eof || asciiControl(code3) || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || unicodePunctuation(code3) ? nok(code3) : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code3);\n  }\n  function protocolAfter(code3) {\n    effects.exit(\"literalAutolinkHttp\");\n    effects.exit(\"literalAutolink\");\n    return ok2(code3);\n  }\n}\nfunction tokenizeWwwPrefix(effects, ok2, nok) {\n  let size = 0;\n  return wwwPrefixInside;\n  function wwwPrefixInside(code3) {\n    if ((code3 === codes.uppercaseW || code3 === codes.lowercaseW) && size < 3) {\n      size++;\n      effects.consume(code3);\n      return wwwPrefixInside;\n    }\n    if (code3 === codes.dot && size === 3) {\n      effects.consume(code3);\n      return wwwPrefixAfter;\n    }\n    return nok(code3);\n  }\n  function wwwPrefixAfter(code3) {\n    return code3 === codes.eof ? nok(code3) : ok2(code3);\n  }\n}\nfunction tokenizeDomain(effects, ok2, nok) {\n  let underscoreInLastSegment;\n  let underscoreInLastLastSegment;\n  let seen;\n  return domainInside;\n  function domainInside(code3) {\n    if (code3 === codes.dot || code3 === codes.underscore) {\n      return effects.check(trail, domainAfter, domainAtPunctuation)(code3);\n    }\n    if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3) || code3 !== codes.dash && unicodePunctuation(code3)) {\n      return domainAfter(code3);\n    }\n    seen = true;\n    effects.consume(code3);\n    return domainInside;\n  }\n  function domainAtPunctuation(code3) {\n    if (code3 === codes.underscore) {\n      underscoreInLastSegment = true;\n    } else {\n      underscoreInLastLastSegment = underscoreInLastSegment;\n      underscoreInLastSegment = void 0;\n    }\n    effects.consume(code3);\n    return domainInside;\n  }\n  function domainAfter(code3) {\n    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {\n      return nok(code3);\n    }\n    return ok2(code3);\n  }\n}\nfunction tokenizePath(effects, ok2) {\n  let sizeOpen = 0;\n  let sizeClose = 0;\n  return pathInside;\n  function pathInside(code3) {\n    if (code3 === codes.leftParenthesis) {\n      sizeOpen++;\n      effects.consume(code3);\n      return pathInside;\n    }\n    if (code3 === codes.rightParenthesis && sizeClose < sizeOpen) {\n      return pathAtPunctuation(code3);\n    }\n    if (code3 === codes.exclamationMark || code3 === codes.quotationMark || code3 === codes.ampersand || code3 === codes.apostrophe || code3 === codes.rightParenthesis || code3 === codes.asterisk || code3 === codes.comma || code3 === codes.dot || code3 === codes.colon || code3 === codes.semicolon || code3 === codes.lessThan || code3 === codes.questionMark || code3 === codes.rightSquareBracket || code3 === codes.underscore || code3 === codes.tilde) {\n      return effects.check(trail, ok2, pathAtPunctuation)(code3);\n    }\n    if (code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {\n      return ok2(code3);\n    }\n    effects.consume(code3);\n    return pathInside;\n  }\n  function pathAtPunctuation(code3) {\n    if (code3 === codes.rightParenthesis) {\n      sizeClose++;\n    }\n    effects.consume(code3);\n    return pathInside;\n  }\n}\nfunction tokenizeTrail(effects, ok2, nok) {\n  return trail2;\n  function trail2(code3) {\n    if (code3 === codes.exclamationMark || code3 === codes.quotationMark || code3 === codes.apostrophe || code3 === codes.rightParenthesis || code3 === codes.asterisk || code3 === codes.comma || code3 === codes.dot || code3 === codes.colon || code3 === codes.semicolon || code3 === codes.questionMark || code3 === codes.underscore || code3 === codes.tilde) {\n      effects.consume(code3);\n      return trail2;\n    }\n    if (code3 === codes.ampersand) {\n      effects.consume(code3);\n      return trailCharacterReferenceStart;\n    }\n    if (code3 === codes.rightSquareBracket) {\n      effects.consume(code3);\n      return trailBracketAfter;\n    }\n    if (\n      // `<` is an end.\n      code3 === codes.lessThan || // So is whitespace.\n      code3 === codes.eof || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)\n    ) {\n      return ok2(code3);\n    }\n    return nok(code3);\n  }\n  function trailBracketAfter(code3) {\n    if (code3 === codes.eof || code3 === codes.leftParenthesis || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {\n      return ok2(code3);\n    }\n    return trail2(code3);\n  }\n  function trailCharacterReferenceStart(code3) {\n    return asciiAlpha(code3) ? trailCharacterReferenceInside(code3) : nok(code3);\n  }\n  function trailCharacterReferenceInside(code3) {\n    if (code3 === codes.semicolon) {\n      effects.consume(code3);\n      return trail2;\n    }\n    if (asciiAlpha(code3)) {\n      effects.consume(code3);\n      return trailCharacterReferenceInside;\n    }\n    return nok(code3);\n  }\n}\nfunction tokenizeEmailDomainDotTrail(effects, ok2, nok) {\n  return start;\n  function start(code3) {\n    effects.consume(code3);\n    return after;\n  }\n  function after(code3) {\n    return asciiAlphanumeric(code3) ? nok(code3) : ok2(code3);\n  }\n}\nfunction previousWww(code3) {\n  return code3 === codes.eof || code3 === codes.leftParenthesis || code3 === codes.asterisk || code3 === codes.underscore || code3 === codes.leftSquareBracket || code3 === codes.rightSquareBracket || code3 === codes.tilde || markdownLineEndingOrSpace(code3);\n}\nfunction previousProtocol(code3) {\n  return !asciiAlpha(code3);\n}\nfunction previousEmail(code3) {\n  return !(code3 === codes.slash || gfmAtext(code3));\n}\nfunction gfmAtext(code3) {\n  return code3 === codes.plusSign || code3 === codes.dash || code3 === codes.dot || code3 === codes.underscore || asciiAlphanumeric(code3);\n}\nfunction previousUnbalanced(events) {\n  let index = events.length;\n  let result = false;\n  while (index--) {\n    const token = events[index][1];\n    if ((token.type === \"labelLink\" || token.type === \"labelImage\") && !token._balanced) {\n      result = true;\n      break;\n    }\n    if (token._gfmAutolinkLiteralWalkedInto) {\n      result = false;\n      break;\n    }\n  }\n  if (events.length > 0 && !result) {\n    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;\n  }\n  return result;\n}\n\n// node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js\nvar indent = { tokenize: tokenizeIndent, partial: true };\nfunction gfmFootnote() {\n  return {\n    document: {\n      [codes.leftSquareBracket]: {\n        name: \"gfmFootnoteDefinition\",\n        tokenize: tokenizeDefinitionStart,\n        continuation: { tokenize: tokenizeDefinitionContinuation },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [codes.leftSquareBracket]: {\n        name: \"gfmFootnoteCall\",\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [codes.rightSquareBracket]: {\n        name: \"gfmPotentialFootnoteCall\",\n        add: \"after\",\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  };\n}\nfunction tokenizePotentialGfmFootnoteCall(effects, ok2, nok) {\n  const self = this;\n  let index = self.events.length;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let labelStart;\n  while (index--) {\n    const token = self.events[index][1];\n    if (token.type === types.labelImage) {\n      labelStart = token;\n      break;\n    }\n    if (token.type === \"gfmFootnoteCall\" || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {\n      break;\n    }\n  }\n  return start;\n  function start(code3) {\n    ok(code3 === codes.rightSquareBracket, \"expected `]`\");\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code3);\n    }\n    const id = normalizeIdentifier(\n      self.sliceSerialize({ start: labelStart.end, end: self.now() })\n    );\n    if (id.codePointAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\n      return nok(code3);\n    }\n    effects.enter(\"gfmFootnoteCallLabelMarker\");\n    effects.consume(code3);\n    effects.exit(\"gfmFootnoteCallLabelMarker\");\n    return ok2(code3);\n  }\n}\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length;\n  let labelStart;\n  while (index--) {\n    if (events[index][1].type === types.labelImage && events[index][0] === \"enter\") {\n      labelStart = events[index][1];\n      break;\n    }\n  }\n  ok(labelStart, \"expected `labelStart` to resolve\");\n  events[index + 1][1].type = types.data;\n  events[index + 3][1].type = \"gfmFootnoteCallLabelMarker\";\n  const call = {\n    type: \"gfmFootnoteCall\",\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  };\n  const marker = {\n    type: \"gfmFootnoteCallMarker\",\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  };\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  const string = {\n    type: \"gfmFootnoteCallString\",\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  const chunk = {\n    type: types.chunkString,\n    contentType: \"string\",\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    [\"enter\", call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    [\"enter\", marker, context],\n    [\"exit\", marker, context],\n    // Everything in between.\n    [\"enter\", string, context],\n    [\"enter\", chunk, context],\n    [\"exit\", chunk, context],\n    [\"exit\", string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    [\"exit\", call, context]\n  ];\n  events.splice(index, events.length - index + 1, ...replacement);\n  return events;\n}\nfunction tokenizeGfmFootnoteCall(effects, ok2, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let size = 0;\n  let data;\n  return start;\n  function start(code3) {\n    ok(code3 === codes.leftSquareBracket, \"expected `[`\");\n    effects.enter(\"gfmFootnoteCall\");\n    effects.enter(\"gfmFootnoteCallLabelMarker\");\n    effects.consume(code3);\n    effects.exit(\"gfmFootnoteCallLabelMarker\");\n    return callStart;\n  }\n  function callStart(code3) {\n    if (code3 !== codes.caret) return nok(code3);\n    effects.enter(\"gfmFootnoteCallMarker\");\n    effects.consume(code3);\n    effects.exit(\"gfmFootnoteCallMarker\");\n    effects.enter(\"gfmFootnoteCallString\");\n    effects.enter(\"chunkString\").contentType = \"string\";\n    return callData;\n  }\n  function callData(code3) {\n    if (\n      // Too long.\n      size > constants.linkReferenceSizeMax || // Closing brace with nothing.\n      code3 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code3 === codes.eof || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3)\n    ) {\n      return nok(code3);\n    }\n    if (code3 === codes.rightSquareBracket) {\n      effects.exit(\"chunkString\");\n      const token = effects.exit(\"gfmFootnoteCallString\");\n      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {\n        return nok(code3);\n      }\n      effects.enter(\"gfmFootnoteCallLabelMarker\");\n      effects.consume(code3);\n      effects.exit(\"gfmFootnoteCallLabelMarker\");\n      effects.exit(\"gfmFootnoteCall\");\n      return ok2;\n    }\n    if (!markdownLineEndingOrSpace(code3)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code3);\n    return code3 === codes.backslash ? callEscape : callData;\n  }\n  function callEscape(code3) {\n    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {\n      effects.consume(code3);\n      size++;\n      return callData;\n    }\n    return callData(code3);\n  }\n}\nfunction tokenizeDefinitionStart(effects, ok2, nok) {\n  const self = this;\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let identifier;\n  let size = 0;\n  let data;\n  return start;\n  function start(code3) {\n    ok(code3 === codes.leftSquareBracket, \"expected `[`\");\n    effects.enter(\"gfmFootnoteDefinition\")._container = true;\n    effects.enter(\"gfmFootnoteDefinitionLabel\");\n    effects.enter(\"gfmFootnoteDefinitionLabelMarker\");\n    effects.consume(code3);\n    effects.exit(\"gfmFootnoteDefinitionLabelMarker\");\n    return labelAtMarker;\n  }\n  function labelAtMarker(code3) {\n    if (code3 === codes.caret) {\n      effects.enter(\"gfmFootnoteDefinitionMarker\");\n      effects.consume(code3);\n      effects.exit(\"gfmFootnoteDefinitionMarker\");\n      effects.enter(\"gfmFootnoteDefinitionLabelString\");\n      effects.enter(\"chunkString\").contentType = \"string\";\n      return labelInside;\n    }\n    return nok(code3);\n  }\n  function labelInside(code3) {\n    if (\n      // Too long.\n      size > constants.linkReferenceSizeMax || // Closing brace with nothing.\n      code3 === codes.rightSquareBracket && !data || // Space or tab is not supported by GFM for some reason.\n      // `\\n` and `[` not being supported makes sense.\n      code3 === codes.eof || code3 === codes.leftSquareBracket || markdownLineEndingOrSpace(code3)\n    ) {\n      return nok(code3);\n    }\n    if (code3 === codes.rightSquareBracket) {\n      effects.exit(\"chunkString\");\n      const token = effects.exit(\"gfmFootnoteDefinitionLabelString\");\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter(\"gfmFootnoteDefinitionLabelMarker\");\n      effects.consume(code3);\n      effects.exit(\"gfmFootnoteDefinitionLabelMarker\");\n      effects.exit(\"gfmFootnoteDefinitionLabel\");\n      return labelAfter;\n    }\n    if (!markdownLineEndingOrSpace(code3)) {\n      data = true;\n    }\n    size++;\n    effects.consume(code3);\n    return code3 === codes.backslash ? labelEscape : labelInside;\n  }\n  function labelEscape(code3) {\n    if (code3 === codes.leftSquareBracket || code3 === codes.backslash || code3 === codes.rightSquareBracket) {\n      effects.consume(code3);\n      size++;\n      return labelInside;\n    }\n    return labelInside(code3);\n  }\n  function labelAfter(code3) {\n    if (code3 === codes.colon) {\n      effects.enter(\"definitionMarker\");\n      effects.consume(code3);\n      effects.exit(\"definitionMarker\");\n      if (!defined.includes(identifier)) {\n        defined.push(identifier);\n      }\n      return factorySpace(\n        effects,\n        whitespaceAfter,\n        \"gfmFootnoteDefinitionWhitespace\"\n      );\n    }\n    return nok(code3);\n  }\n  function whitespaceAfter(code3) {\n    return ok2(code3);\n  }\n}\nfunction tokenizeDefinitionContinuation(effects, ok2, nok) {\n  return effects.check(blankLine, ok2, effects.attempt(indent, ok2, nok));\n}\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit(\"gfmFootnoteDefinition\");\n}\nfunction tokenizeIndent(effects, ok2, nok) {\n  const self = this;\n  return factorySpace(\n    effects,\n    afterPrefix,\n    \"gfmFootnoteDefinitionIndent\",\n    constants.tabSize + 1\n  );\n  function afterPrefix(code3) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === \"gfmFootnoteDefinitionIndent\" && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok2(code3) : nok(code3);\n  }\n}\n\n// node_modules/micromark-extension-gfm-footnote/dev/lib/html.js\nvar own3 = {}.hasOwnProperty;\n\n// node_modules/micromark-extension-gfm-strikethrough/dev/lib/syntax.js\nfunction gfmStrikethrough(options) {\n  const options_ = options || {};\n  let single = options_.singleTilde;\n  const tokenizer = {\n    name: \"strikethrough\",\n    tokenize: tokenizeStrikethrough,\n    resolveAll: resolveAllStrikethrough\n  };\n  if (single === null || single === void 0) {\n    single = true;\n  }\n  return {\n    text: { [codes.tilde]: tokenizer },\n    insideSpan: { null: [tokenizer] },\n    attentionMarkers: { null: [codes.tilde] }\n  };\n  function resolveAllStrikethrough(events, context) {\n    let index = -1;\n    while (++index < events.length) {\n      if (events[index][0] === \"enter\" && events[index][1].type === \"strikethroughSequenceTemporary\" && events[index][1]._close) {\n        let open = index;\n        while (open--) {\n          if (events[open][0] === \"exit\" && events[open][1].type === \"strikethroughSequenceTemporary\" && events[open][1]._open && // If the sizes are the same:\n          events[index][1].end.offset - events[index][1].start.offset === events[open][1].end.offset - events[open][1].start.offset) {\n            events[index][1].type = \"strikethroughSequence\";\n            events[open][1].type = \"strikethroughSequence\";\n            const strikethrough = {\n              type: \"strikethrough\",\n              start: Object.assign({}, events[open][1].start),\n              end: Object.assign({}, events[index][1].end)\n            };\n            const text3 = {\n              type: \"strikethroughText\",\n              start: Object.assign({}, events[open][1].end),\n              end: Object.assign({}, events[index][1].start)\n            };\n            const nextEvents = [\n              [\"enter\", strikethrough, context],\n              [\"enter\", events[open][1], context],\n              [\"exit\", events[open][1], context],\n              [\"enter\", text3, context]\n            ];\n            const insideSpan = context.parser.constructs.insideSpan.null;\n            if (insideSpan) {\n              splice(\n                nextEvents,\n                nextEvents.length,\n                0,\n                resolveAll(insideSpan, events.slice(open + 1, index), context)\n              );\n            }\n            splice(nextEvents, nextEvents.length, 0, [\n              [\"exit\", text3, context],\n              [\"enter\", events[index][1], context],\n              [\"exit\", events[index][1], context],\n              [\"exit\", strikethrough, context]\n            ]);\n            splice(events, open - 1, index - open + 3, nextEvents);\n            index = open + nextEvents.length - 2;\n            break;\n          }\n        }\n      }\n    }\n    index = -1;\n    while (++index < events.length) {\n      if (events[index][1].type === \"strikethroughSequenceTemporary\") {\n        events[index][1].type = types.data;\n      }\n    }\n    return events;\n  }\n  function tokenizeStrikethrough(effects, ok2, nok) {\n    const previous2 = this.previous;\n    const events = this.events;\n    let size = 0;\n    return start;\n    function start(code3) {\n      ok(code3 === codes.tilde, \"expected `~`\");\n      if (previous2 === codes.tilde && events[events.length - 1][1].type !== types.characterEscape) {\n        return nok(code3);\n      }\n      effects.enter(\"strikethroughSequenceTemporary\");\n      return more(code3);\n    }\n    function more(code3) {\n      const before = classifyCharacter(previous2);\n      if (code3 === codes.tilde) {\n        if (size > 1) return nok(code3);\n        effects.consume(code3);\n        size++;\n        return more;\n      }\n      if (size < 2 && !single) return nok(code3);\n      const token = effects.exit(\"strikethroughSequenceTemporary\");\n      const after = classifyCharacter(code3);\n      token._open = !after || after === constants.attentionSideAfter && Boolean(before);\n      token._close = !before || before === constants.attentionSideAfter && Boolean(after);\n      return ok2(code3);\n    }\n  }\n}\n\n// node_modules/micromark-extension-gfm-table/dev/lib/edit-map.js\nvar EditMap = class {\n  /**\n   * Create a new edit map.\n   */\n  constructor() {\n    this.map = [];\n  }\n  /**\n   * Create an edit: a remove and/or add at a certain place.\n   *\n   * @param {number} index\n   * @param {number} remove\n   * @param {Array<Event>} add\n   * @returns {undefined}\n   */\n  add(index, remove, add) {\n    addImplementation(this, index, remove, add);\n  }\n  // To do: add this when moving to `micromark`.\n  // /**\n  //  * Create an edit: but insert `add` before existing additions.\n  //  *\n  //  * @param {number} index\n  //  * @param {number} remove\n  //  * @param {Array<Event>} add\n  //  * @returns {undefined}\n  //  */\n  // addBefore(index, remove, add) {\n  //   addImplementation(this, index, remove, add, true)\n  // }\n  /**\n   * Done, change the events.\n   *\n   * @param {Array<Event>} events\n   * @returns {undefined}\n   */\n  consume(events) {\n    this.map.sort(function(a, b) {\n      return a[0] - b[0];\n    });\n    if (this.map.length === 0) {\n      return;\n    }\n    let index = this.map.length;\n    const vecs = [];\n    while (index > 0) {\n      index -= 1;\n      vecs.push(\n        events.slice(this.map[index][0] + this.map[index][1]),\n        this.map[index][2]\n      );\n      events.length = this.map[index][0];\n    }\n    vecs.push(events.slice());\n    events.length = 0;\n    let slice = vecs.pop();\n    while (slice) {\n      for (const element of slice) {\n        events.push(element);\n      }\n      slice = vecs.pop();\n    }\n    this.map.length = 0;\n  }\n};\nfunction addImplementation(editMap, at, remove, add) {\n  let index = 0;\n  if (remove === 0 && add.length === 0) {\n    return;\n  }\n  while (index < editMap.map.length) {\n    if (editMap.map[index][0] === at) {\n      editMap.map[index][1] += remove;\n      editMap.map[index][2].push(...add);\n      return;\n    }\n    index += 1;\n  }\n  editMap.map.push([at, remove, add]);\n}\n\n// node_modules/micromark-extension-gfm-table/dev/lib/infer.js\nfunction gfmTableAlign(events, index) {\n  ok(events[index][1].type === \"table\", \"expected table\");\n  let inDelimiterRow = false;\n  const align = [];\n  while (index < events.length) {\n    const event = events[index];\n    if (inDelimiterRow) {\n      if (event[0] === \"enter\") {\n        if (event[1].type === \"tableContent\") {\n          align.push(\n            events[index + 1][1].type === \"tableDelimiterMarker\" ? \"left\" : \"none\"\n          );\n        }\n      } else if (event[1].type === \"tableContent\") {\n        if (events[index - 1][1].type === \"tableDelimiterMarker\") {\n          const alignIndex = align.length - 1;\n          align[alignIndex] = align[alignIndex] === \"left\" ? \"center\" : \"right\";\n        }\n      } else if (event[1].type === \"tableDelimiterRow\") {\n        break;\n      }\n    } else if (event[0] === \"enter\" && event[1].type === \"tableDelimiterRow\") {\n      inDelimiterRow = true;\n    }\n    index += 1;\n  }\n  return align;\n}\n\n// node_modules/micromark-extension-gfm-table/dev/lib/syntax.js\nfunction gfmTable() {\n  return {\n    flow: {\n      null: { name: \"table\", tokenize: tokenizeTable, resolveAll: resolveTable }\n    }\n  };\n}\nfunction tokenizeTable(effects, ok2, nok) {\n  const self = this;\n  let size = 0;\n  let sizeB = 0;\n  let seen;\n  return start;\n  function start(code3) {\n    let index = self.events.length - 1;\n    while (index > -1) {\n      const type = self.events[index][1].type;\n      if (type === types.lineEnding || // Note: markdown-rs uses `whitespace` instead of `linePrefix`\n      type === types.linePrefix)\n        index--;\n      else break;\n    }\n    const tail = index > -1 ? self.events[index][1].type : null;\n    const next = tail === \"tableHead\" || tail === \"tableRow\" ? bodyRowStart : headRowBefore;\n    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {\n      return nok(code3);\n    }\n    return next(code3);\n  }\n  function headRowBefore(code3) {\n    effects.enter(\"tableHead\");\n    effects.enter(\"tableRow\");\n    return headRowStart(code3);\n  }\n  function headRowStart(code3) {\n    if (code3 === codes.verticalBar) {\n      return headRowBreak(code3);\n    }\n    seen = true;\n    sizeB += 1;\n    return headRowBreak(code3);\n  }\n  function headRowBreak(code3) {\n    if (code3 === codes.eof) {\n      return nok(code3);\n    }\n    if (markdownLineEnding(code3)) {\n      if (sizeB > 1) {\n        sizeB = 0;\n        self.interrupt = true;\n        effects.exit(\"tableRow\");\n        effects.enter(types.lineEnding);\n        effects.consume(code3);\n        effects.exit(types.lineEnding);\n        return headDelimiterStart;\n      }\n      return nok(code3);\n    }\n    if (markdownSpace(code3)) {\n      return factorySpace(effects, headRowBreak, types.whitespace)(code3);\n    }\n    sizeB += 1;\n    if (seen) {\n      seen = false;\n      size += 1;\n    }\n    if (code3 === codes.verticalBar) {\n      effects.enter(\"tableCellDivider\");\n      effects.consume(code3);\n      effects.exit(\"tableCellDivider\");\n      seen = true;\n      return headRowBreak;\n    }\n    effects.enter(types.data);\n    return headRowData(code3);\n  }\n  function headRowData(code3) {\n    if (code3 === codes.eof || code3 === codes.verticalBar || markdownLineEndingOrSpace(code3)) {\n      effects.exit(types.data);\n      return headRowBreak(code3);\n    }\n    effects.consume(code3);\n    return code3 === codes.backslash ? headRowEscape : headRowData;\n  }\n  function headRowEscape(code3) {\n    if (code3 === codes.backslash || code3 === codes.verticalBar) {\n      effects.consume(code3);\n      return headRowData;\n    }\n    return headRowData(code3);\n  }\n  function headDelimiterStart(code3) {\n    self.interrupt = false;\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code3);\n    }\n    effects.enter(\"tableDelimiterRow\");\n    seen = false;\n    if (markdownSpace(code3)) {\n      ok(self.parser.constructs.disable.null, \"expected `disabled.null`\");\n      return factorySpace(\n        effects,\n        headDelimiterBefore,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize\n      )(code3);\n    }\n    return headDelimiterBefore(code3);\n  }\n  function headDelimiterBefore(code3) {\n    if (code3 === codes.dash || code3 === codes.colon) {\n      return headDelimiterValueBefore(code3);\n    }\n    if (code3 === codes.verticalBar) {\n      seen = true;\n      effects.enter(\"tableCellDivider\");\n      effects.consume(code3);\n      effects.exit(\"tableCellDivider\");\n      return headDelimiterCellBefore;\n    }\n    return headDelimiterNok(code3);\n  }\n  function headDelimiterCellBefore(code3) {\n    if (markdownSpace(code3)) {\n      return factorySpace(\n        effects,\n        headDelimiterValueBefore,\n        types.whitespace\n      )(code3);\n    }\n    return headDelimiterValueBefore(code3);\n  }\n  function headDelimiterValueBefore(code3) {\n    if (code3 === codes.colon) {\n      sizeB += 1;\n      seen = true;\n      effects.enter(\"tableDelimiterMarker\");\n      effects.consume(code3);\n      effects.exit(\"tableDelimiterMarker\");\n      return headDelimiterLeftAlignmentAfter;\n    }\n    if (code3 === codes.dash) {\n      sizeB += 1;\n      return headDelimiterLeftAlignmentAfter(code3);\n    }\n    if (code3 === codes.eof || markdownLineEnding(code3)) {\n      return headDelimiterCellAfter(code3);\n    }\n    return headDelimiterNok(code3);\n  }\n  function headDelimiterLeftAlignmentAfter(code3) {\n    if (code3 === codes.dash) {\n      effects.enter(\"tableDelimiterFiller\");\n      return headDelimiterFiller(code3);\n    }\n    return headDelimiterNok(code3);\n  }\n  function headDelimiterFiller(code3) {\n    if (code3 === codes.dash) {\n      effects.consume(code3);\n      return headDelimiterFiller;\n    }\n    if (code3 === codes.colon) {\n      seen = true;\n      effects.exit(\"tableDelimiterFiller\");\n      effects.enter(\"tableDelimiterMarker\");\n      effects.consume(code3);\n      effects.exit(\"tableDelimiterMarker\");\n      return headDelimiterRightAlignmentAfter;\n    }\n    effects.exit(\"tableDelimiterFiller\");\n    return headDelimiterRightAlignmentAfter(code3);\n  }\n  function headDelimiterRightAlignmentAfter(code3) {\n    if (markdownSpace(code3)) {\n      return factorySpace(\n        effects,\n        headDelimiterCellAfter,\n        types.whitespace\n      )(code3);\n    }\n    return headDelimiterCellAfter(code3);\n  }\n  function headDelimiterCellAfter(code3) {\n    if (code3 === codes.verticalBar) {\n      return headDelimiterBefore(code3);\n    }\n    if (code3 === codes.eof || markdownLineEnding(code3)) {\n      if (!seen || size !== sizeB) {\n        return headDelimiterNok(code3);\n      }\n      effects.exit(\"tableDelimiterRow\");\n      effects.exit(\"tableHead\");\n      return ok2(code3);\n    }\n    return headDelimiterNok(code3);\n  }\n  function headDelimiterNok(code3) {\n    return nok(code3);\n  }\n  function bodyRowStart(code3) {\n    effects.enter(\"tableRow\");\n    return bodyRowBreak(code3);\n  }\n  function bodyRowBreak(code3) {\n    if (code3 === codes.verticalBar) {\n      effects.enter(\"tableCellDivider\");\n      effects.consume(code3);\n      effects.exit(\"tableCellDivider\");\n      return bodyRowBreak;\n    }\n    if (code3 === codes.eof || markdownLineEnding(code3)) {\n      effects.exit(\"tableRow\");\n      return ok2(code3);\n    }\n    if (markdownSpace(code3)) {\n      return factorySpace(effects, bodyRowBreak, types.whitespace)(code3);\n    }\n    effects.enter(types.data);\n    return bodyRowData(code3);\n  }\n  function bodyRowData(code3) {\n    if (code3 === codes.eof || code3 === codes.verticalBar || markdownLineEndingOrSpace(code3)) {\n      effects.exit(types.data);\n      return bodyRowBreak(code3);\n    }\n    effects.consume(code3);\n    return code3 === codes.backslash ? bodyRowEscape : bodyRowData;\n  }\n  function bodyRowEscape(code3) {\n    if (code3 === codes.backslash || code3 === codes.verticalBar) {\n      effects.consume(code3);\n      return bodyRowData;\n    }\n    return bodyRowData(code3);\n  }\n}\nfunction resolveTable(events, context) {\n  let index = -1;\n  let inFirstCellAwaitingPipe = true;\n  let rowKind = 0;\n  let lastCell = [0, 0, 0, 0];\n  let cell = [0, 0, 0, 0];\n  let afterHeadAwaitingFirstBodyRow = false;\n  let lastTableEnd = 0;\n  let currentTable;\n  let currentBody;\n  let currentCell;\n  const map3 = new EditMap();\n  while (++index < events.length) {\n    const event = events[index];\n    const token = event[1];\n    if (event[0] === \"enter\") {\n      if (token.type === \"tableHead\") {\n        afterHeadAwaitingFirstBodyRow = false;\n        if (lastTableEnd !== 0) {\n          ok(currentTable, \"there should be a table opening\");\n          flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);\n          currentBody = void 0;\n          lastTableEnd = 0;\n        }\n        currentTable = {\n          type: \"table\",\n          start: Object.assign({}, token.start),\n          // Note: correct end is set later.\n          end: Object.assign({}, token.end)\n        };\n        map3.add(index, 0, [[\"enter\", currentTable, context]]);\n      } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n        inFirstCellAwaitingPipe = true;\n        currentCell = void 0;\n        lastCell = [0, 0, 0, 0];\n        cell = [0, index + 1, 0, 0];\n        if (afterHeadAwaitingFirstBodyRow) {\n          afterHeadAwaitingFirstBodyRow = false;\n          currentBody = {\n            type: \"tableBody\",\n            start: Object.assign({}, token.start),\n            // Note: correct end is set later.\n            end: Object.assign({}, token.end)\n          };\n          map3.add(index, 0, [[\"enter\", currentBody, context]]);\n        }\n        rowKind = token.type === \"tableDelimiterRow\" ? 2 : currentBody ? 3 : 1;\n      } else if (rowKind && (token.type === types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n        inFirstCellAwaitingPipe = false;\n        if (cell[2] === 0) {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1];\n            currentCell = flushCell(\n              map3,\n              context,\n              lastCell,\n              rowKind,\n              void 0,\n              currentCell\n            );\n            lastCell = [0, 0, 0, 0];\n          }\n          cell[2] = index;\n        }\n      } else if (token.type === \"tableCellDivider\") {\n        if (inFirstCellAwaitingPipe) {\n          inFirstCellAwaitingPipe = false;\n        } else {\n          if (lastCell[1] !== 0) {\n            cell[0] = cell[1];\n            currentCell = flushCell(\n              map3,\n              context,\n              lastCell,\n              rowKind,\n              void 0,\n              currentCell\n            );\n          }\n          lastCell = cell;\n          cell = [lastCell[1], index, 0, 0];\n        }\n      }\n    } else if (token.type === \"tableHead\") {\n      afterHeadAwaitingFirstBodyRow = true;\n      lastTableEnd = index;\n    } else if (token.type === \"tableRow\" || token.type === \"tableDelimiterRow\") {\n      lastTableEnd = index;\n      if (lastCell[1] !== 0) {\n        cell[0] = cell[1];\n        currentCell = flushCell(\n          map3,\n          context,\n          lastCell,\n          rowKind,\n          index,\n          currentCell\n        );\n      } else if (cell[1] !== 0) {\n        currentCell = flushCell(map3, context, cell, rowKind, index, currentCell);\n      }\n      rowKind = 0;\n    } else if (rowKind && (token.type === types.data || token.type === \"tableDelimiterMarker\" || token.type === \"tableDelimiterFiller\")) {\n      cell[3] = index;\n    }\n  }\n  if (lastTableEnd !== 0) {\n    ok(currentTable, \"expected table opening\");\n    flushTableEnd(map3, context, lastTableEnd, currentTable, currentBody);\n  }\n  map3.consume(context.events);\n  index = -1;\n  while (++index < context.events.length) {\n    const event = context.events[index];\n    if (event[0] === \"enter\" && event[1].type === \"table\") {\n      event[1]._align = gfmTableAlign(context.events, index);\n    }\n  }\n  return events;\n}\nfunction flushCell(map3, context, range, rowKind, rowEnd, previousCell) {\n  const groupName = rowKind === 1 ? \"tableHeader\" : rowKind === 2 ? \"tableDelimiter\" : \"tableData\";\n  const valueName = \"tableContent\";\n  if (range[0] !== 0) {\n    ok(previousCell, \"expected previous cell enter\");\n    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));\n    map3.add(range[0], 0, [[\"exit\", previousCell, context]]);\n  }\n  const now = getPoint(context.events, range[1]);\n  previousCell = {\n    type: groupName,\n    start: Object.assign({}, now),\n    // Note: correct end is set later.\n    end: Object.assign({}, now)\n  };\n  map3.add(range[1], 0, [[\"enter\", previousCell, context]]);\n  if (range[2] !== 0) {\n    const relatedStart = getPoint(context.events, range[2]);\n    const relatedEnd = getPoint(context.events, range[3]);\n    const valueToken = {\n      type: valueName,\n      start: Object.assign({}, relatedStart),\n      end: Object.assign({}, relatedEnd)\n    };\n    map3.add(range[2], 0, [[\"enter\", valueToken, context]]);\n    ok(range[3] !== 0);\n    if (rowKind !== 2) {\n      const start = context.events[range[2]];\n      const end = context.events[range[3]];\n      start[1].end = Object.assign({}, end[1].end);\n      start[1].type = types.chunkText;\n      start[1].contentType = constants.contentTypeText;\n      if (range[3] > range[2] + 1) {\n        const a = range[2] + 1;\n        const b = range[3] - range[2] - 1;\n        map3.add(a, b, []);\n      }\n    }\n    map3.add(range[3] + 1, 0, [[\"exit\", valueToken, context]]);\n  }\n  if (rowEnd !== void 0) {\n    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));\n    map3.add(rowEnd, 0, [[\"exit\", previousCell, context]]);\n    previousCell = void 0;\n  }\n  return previousCell;\n}\nfunction flushTableEnd(map3, context, index, table, tableBody) {\n  const exits = [];\n  const related = getPoint(context.events, index);\n  if (tableBody) {\n    tableBody.end = Object.assign({}, related);\n    exits.push([\"exit\", tableBody, context]);\n  }\n  table.end = Object.assign({}, related);\n  exits.push([\"exit\", table, context]);\n  map3.add(index + 1, 0, exits);\n}\nfunction getPoint(events, index) {\n  const event = events[index];\n  const side = event[0] === \"enter\" ? \"start\" : \"end\";\n  return event[1][side];\n}\n\n// node_modules/micromark-extension-gfm-tagfilter/lib/index.js\nvar reFlow = /<(\\/?)(iframe|noembed|noframes|plaintext|script|style|title|textarea|xmp)(?=[\\t\\n\\f\\r />])/gi;\nvar reText = new RegExp(\"^\" + reFlow.source, \"i\");\n\n// node_modules/micromark-extension-gfm-task-list-item/dev/lib/syntax.js\nvar tasklistCheck = { name: \"tasklistCheck\", tokenize: tokenizeTasklistCheck };\nfunction gfmTaskListItem() {\n  return {\n    text: { [codes.leftSquareBracket]: tasklistCheck }\n  };\n}\nfunction tokenizeTasklistCheck(effects, ok2, nok) {\n  const self = this;\n  return open;\n  function open(code3) {\n    ok(code3 === codes.leftSquareBracket, \"expected `[`\");\n    if (\n      // Exit if theres stuff before.\n      self.previous !== codes.eof || // Exit if not in the first content that is the first child of a list\n      // item.\n      !self._gfmTasklistFirstContentOfListItem\n    ) {\n      return nok(code3);\n    }\n    effects.enter(\"taskListCheck\");\n    effects.enter(\"taskListCheckMarker\");\n    effects.consume(code3);\n    effects.exit(\"taskListCheckMarker\");\n    return inside;\n  }\n  function inside(code3) {\n    if (markdownLineEndingOrSpace(code3)) {\n      effects.enter(\"taskListCheckValueUnchecked\");\n      effects.consume(code3);\n      effects.exit(\"taskListCheckValueUnchecked\");\n      return close;\n    }\n    if (code3 === codes.uppercaseX || code3 === codes.lowercaseX) {\n      effects.enter(\"taskListCheckValueChecked\");\n      effects.consume(code3);\n      effects.exit(\"taskListCheckValueChecked\");\n      return close;\n    }\n    return nok(code3);\n  }\n  function close(code3) {\n    if (code3 === codes.rightSquareBracket) {\n      effects.enter(\"taskListCheckMarker\");\n      effects.consume(code3);\n      effects.exit(\"taskListCheckMarker\");\n      effects.exit(\"taskListCheck\");\n      return after;\n    }\n    return nok(code3);\n  }\n  function after(code3) {\n    if (markdownLineEnding(code3)) {\n      return ok2(code3);\n    }\n    if (markdownSpace(code3)) {\n      return effects.check({ tokenize: spaceThenNonSpace }, ok2, nok)(code3);\n    }\n    return nok(code3);\n  }\n}\nfunction spaceThenNonSpace(effects, ok2, nok) {\n  return factorySpace(effects, after, types.whitespace);\n  function after(code3) {\n    return code3 === codes.eof ? nok(code3) : ok2(code3);\n  }\n}\n\n// node_modules/micromark-extension-gfm/index.js\nfunction gfm(options) {\n  return combineExtensions([\n    gfmAutolinkLiteral(),\n    gfmFootnote(),\n    gfmStrikethrough(options),\n    gfmTable(),\n    gfmTaskListItem()\n  ]);\n}\n\n// node_modules/remark-gfm/lib/index.js\nvar emptyOptions = {};\nfunction remarkGfm(options) {\n  const self = (\n    /** @type {Processor<Root>} */\n    this\n  );\n  const settings = options || emptyOptions;\n  const data = self.data();\n  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);\n  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);\n  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);\n  micromarkExtensions.push(gfm(settings));\n  fromMarkdownExtensions.push(gfmFromMarkdown());\n  toMarkdownExtensions.push(gfmToMarkdown(settings));\n}\nexport {\n  remarkGfm as default\n};\n//# sourceMappingURL=remark-gfm.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.741Z",
        "time": 2.846999999746913,
        "timings": {
          "blocked": 0.9390000004461035,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.6460000013501849,
          "receive": 1.2619999979506247,
          "_blocked_queueing": 0.9040000004461035,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "lineNumber": 20
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "14750"
            },
            {
              "name": "Etag",
              "value": "W/\"399e-tAG/5dBMJIArF8MDvuJ0dnVjFlc\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 14750,
            "mimeType": "text/javascript",
            "text": "import {\n  katex\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-FV2J4HIN.js?v=2a7591ed\";\nimport {\n  longestStreak\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-Y7LV7UOF.js?v=2a7591ed\";\nimport {\n  codes,\n  constants,\n  factorySpace,\n  markdownLineEnding,\n  ok,\n  types\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-EIBGEDEJ.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/mdast-util-math/lib/index.js\nfunction mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n  function enterMathFlow(token) {\n    const code = {\n      type: \"element\",\n      tagName: \"code\",\n      properties: { className: [\"language-math\", \"math-display\"] },\n      children: []\n    };\n    this.enter(\n      {\n        type: \"math\",\n        meta: null,\n        value: \"\",\n        data: { hName: \"pre\", hChildren: [code] }\n      },\n      token\n    );\n  }\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    ok(node.type === \"math\");\n    node.meta = data;\n  }\n  function exitMathFlowFence() {\n    if (this.data.mathFlowInside) return;\n    this.buffer();\n    this.data.mathFlowInside = true;\n  }\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\");\n    const node = this.stack[this.stack.length - 1];\n    ok(node.type === \"math\");\n    this.exit(token);\n    node.value = data;\n    const code = (\n      /** @type {HastElement} */\n      node.data.hChildren[0]\n    );\n    ok(code.type === \"element\");\n    ok(code.tagName === \"code\");\n    code.children.push({ type: \"text\", value: data });\n    this.data.mathFlowInside = void 0;\n  }\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: \"inlineMath\",\n        value: \"\",\n        data: {\n          hName: \"code\",\n          hProperties: { className: [\"language-math\", \"math-inline\"] },\n          hChildren: []\n        }\n      },\n      token\n    );\n    this.buffer();\n  }\n  function exitMathText(token) {\n    const data = this.resume();\n    const node = this.stack[this.stack.length - 1];\n    ok(node.type === \"inlineMath\");\n    this.exit(token);\n    node.value = data;\n    const children = (\n      /** @type {Array<HastElementContent>} */\n      // @ts-expect-error: we defined it in `enterMathFlow`.\n      node.data.hChildren\n    );\n    children.push({ type: \"text\", value: data });\n  }\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\nfunction mathToMarkdown(options) {\n  let single = (options || {}).singleDollarTextMath;\n  if (single === null || single === void 0) {\n    single = true;\n  }\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [\n      { character: \"\\r\", inConstruct: \"mathFlowMeta\" },\n      { character: \"\\n\", inConstruct: \"mathFlowMeta\" },\n      {\n        character: \"$\",\n        after: single ? void 0 : \"\\\\$\",\n        inConstruct: \"phrasing\"\n      },\n      { character: \"$\", inConstruct: \"mathFlowMeta\" },\n      { atBreak: true, character: \"$\", after: \"\\\\$\" }\n    ],\n    handlers: { math: math2, inlineMath }\n  };\n  function math2(node, _, state, info) {\n    const raw = node.value || \"\";\n    const tracker = state.createTracker(info);\n    const sequence = \"$\".repeat(Math.max(longestStreak(raw, \"$\") + 1, 2));\n    const exit = state.enter(\"mathFlow\");\n    let value = tracker.move(sequence);\n    if (node.meta) {\n      const subexit = state.enter(\"mathFlowMeta\");\n      value += tracker.move(\n        state.safe(node.meta, {\n          after: \"\\n\",\n          before: value,\n          encode: [\"$\"],\n          ...tracker.current()\n        })\n      );\n      subexit();\n    }\n    value += tracker.move(\"\\n\");\n    if (raw) {\n      value += tracker.move(raw + \"\\n\");\n    }\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n  function inlineMath(node, _, state) {\n    let value = node.value || \"\";\n    let size = 1;\n    if (!single) size++;\n    while (new RegExp(\"(^|[^$])\" + \"\\\\$\".repeat(size) + \"([^$]|$)\").test(value)) {\n      size++;\n    }\n    const sequence = \"$\".repeat(size);\n    if (\n      // Contains non-space.\n      /[^ \\r\\n]/.test(value) && // Starts with space and ends with space.\n      (/^[ \\r\\n]/.test(value) && /[ \\r\\n]$/.test(value) || // Starts or ends with dollar.\n      /^\\$|\\$$/.test(value))\n    ) {\n      value = \" \" + value + \" \";\n    }\n    let index = -1;\n    while (++index < state.unsafe.length) {\n      const pattern = state.unsafe[index];\n      if (!pattern.atBreak) continue;\n      const expression = state.compilePattern(pattern);\n      let match;\n      while (match = expression.exec(value)) {\n        let position = match.index;\n        if (value.codePointAt(position) === 10 && value.codePointAt(position - 1) === 13) {\n          position--;\n        }\n        value = value.slice(0, position) + \" \" + value.slice(match.index + 1);\n      }\n    }\n    return sequence + value + sequence;\n  }\n  function inlineMathPeek() {\n    return \"$\";\n  }\n}\n\n// node_modules/micromark-extension-math/dev/lib/math-flow.js\nvar mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true,\n  name: \"mathFlow\"\n};\nvar nonLazyContinuation = {\n  tokenize: tokenizeNonLazyContinuation,\n  partial: true\n};\nfunction tokenizeMathFenced(effects, ok2, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n  function start(code) {\n    ok(code === codes.dollarSign, \"expected `$`\");\n    effects.enter(\"mathFlow\");\n    effects.enter(\"mathFlowFence\");\n    effects.enter(\"mathFlowFenceSequence\");\n    return sequenceOpen(code);\n  }\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    if (sizeOpen < 2) {\n      return nok(code);\n    }\n    effects.exit(\"mathFlowFenceSequence\");\n    return factorySpace(effects, metaBefore, types.whitespace)(code);\n  }\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return metaAfter(code);\n    }\n    effects.enter(\"mathFlowFenceMeta\");\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return meta(code);\n  }\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(\"mathFlowFenceMeta\");\n      return metaAfter(code);\n    }\n    if (code === codes.dollarSign) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n  function metaAfter(code) {\n    effects.exit(\"mathFlowFence\");\n    if (self.interrupt) {\n      return ok2(code);\n    }\n    return effects.attempt(\n      nonLazyContinuation,\n      beforeNonLazyContinuation,\n      after\n    )(code);\n  }\n  function beforeNonLazyContinuation(code) {\n    return effects.attempt(\n      { tokenize: tokenizeClosingFence, partial: true },\n      after,\n      contentStart\n    )(code);\n  }\n  function contentStart(code) {\n    return (initialSize ? factorySpace(\n      effects,\n      beforeContentChunk,\n      types.linePrefix,\n      initialSize + 1\n    ) : beforeContentChunk)(code);\n  }\n  function beforeContentChunk(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyContinuation,\n        beforeNonLazyContinuation,\n        after\n      )(code);\n    }\n    effects.enter(\"mathFlowValue\");\n    return contentChunk(code);\n  }\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(\"mathFlowValue\");\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n  function after(code) {\n    effects.exit(\"mathFlow\");\n    return ok2(code);\n  }\n  function tokenizeClosingFence(effects2, ok3, nok2) {\n    let size = 0;\n    ok(self.parser.constructs.disable.null, \"expected `disable.null`\");\n    return factorySpace(\n      effects2,\n      beforeSequenceClose,\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize\n    );\n    function beforeSequenceClose(code) {\n      effects2.enter(\"mathFlowFence\");\n      effects2.enter(\"mathFlowFenceSequence\");\n      return sequenceClose(code);\n    }\n    function sequenceClose(code) {\n      if (code === codes.dollarSign) {\n        size++;\n        effects2.consume(code);\n        return sequenceClose;\n      }\n      if (size < sizeOpen) {\n        return nok2(code);\n      }\n      effects2.exit(\"mathFlowFenceSequence\");\n      return factorySpace(effects2, afterSequenceClose, types.whitespace)(code);\n    }\n    function afterSequenceClose(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects2.exit(\"mathFlowFence\");\n        return ok3(code);\n      }\n      return nok2(code);\n    }\n  }\n}\nfunction tokenizeNonLazyContinuation(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code === null) {\n      return ok2(code);\n    }\n    ok(markdownLineEnding(code), \"expected eol\");\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok2(code);\n  }\n}\n\n// node_modules/micromark-extension-math/dev/lib/math-text.js\nfunction mathText(options) {\n  const options_ = options || {};\n  let single = options_.singleDollarTextMath;\n  if (single === null || single === void 0) {\n    single = true;\n  }\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous,\n    name: \"mathText\"\n  };\n  function tokenizeMathText(effects, ok2, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    let size;\n    let token;\n    return start;\n    function start(code) {\n      ok(code === codes.dollarSign, \"expected `$`\");\n      ok(previous.call(self, self.previous), \"expected correct previous\");\n      effects.enter(\"mathText\");\n      effects.enter(\"mathTextSequence\");\n      return sequenceOpen(code);\n    }\n    function sequenceOpen(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code);\n        sizeOpen++;\n        return sequenceOpen;\n      }\n      if (sizeOpen < 2 && !single) {\n        return nok(code);\n      }\n      effects.exit(\"mathTextSequence\");\n      return between(code);\n    }\n    function between(code) {\n      if (code === codes.eof) {\n        return nok(code);\n      }\n      if (code === codes.dollarSign) {\n        token = effects.enter(\"mathTextSequence\");\n        size = 0;\n        return sequenceClose(code);\n      }\n      if (code === codes.space) {\n        effects.enter(\"space\");\n        effects.consume(code);\n        effects.exit(\"space\");\n        return between;\n      }\n      if (markdownLineEnding(code)) {\n        effects.enter(types.lineEnding);\n        effects.consume(code);\n        effects.exit(types.lineEnding);\n        return between;\n      }\n      effects.enter(\"mathTextData\");\n      return data(code);\n    }\n    function data(code) {\n      if (code === codes.eof || code === codes.space || code === codes.dollarSign || markdownLineEnding(code)) {\n        effects.exit(\"mathTextData\");\n        return between(code);\n      }\n      effects.consume(code);\n      return data;\n    }\n    function sequenceClose(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code);\n        size++;\n        return sequenceClose;\n      }\n      if (size === sizeOpen) {\n        effects.exit(\"mathTextSequence\");\n        effects.exit(\"mathText\");\n        return ok2(code);\n      }\n      token.type = \"mathTextData\";\n      return data(code);\n    }\n  }\n}\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  let index;\n  let enter;\n  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === \"space\") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === \"space\")) {\n    index = headEnterIndex;\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === \"mathTextData\") {\n        events[tailExitIndex][1].type = \"mathTextPadding\";\n        events[headEnterIndex][1].type = \"mathTextPadding\";\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === void 0) {\n      if (index !== tailExitIndex && events[index][1].type !== types.lineEnding) {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === types.lineEnding) {\n      events[enter][1].type = \"mathTextData\";\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = void 0;\n    }\n  }\n  return events;\n}\nfunction previous(code) {\n  return code !== codes.dollarSign || this.events[this.events.length - 1][1].type === types.characterEscape;\n}\n\n// node_modules/micromark-extension-math/dev/lib/syntax.js\nfunction math(options) {\n  return {\n    flow: { [codes.dollarSign]: mathFlow },\n    text: { [codes.dollarSign]: mathText(options) }\n  };\n}\n\n// node_modules/micromark-extension-math/dev/lib/html.js\nvar renderToString = katex.renderToString;\n\n// node_modules/remark-math/lib/index.js\nvar emptyOptions = {};\nfunction remarkMath(options) {\n  const self = (\n    /** @type {Processor} */\n    this\n  );\n  const settings = options || emptyOptions;\n  const data = self.data();\n  const micromarkExtensions = data.micromarkExtensions || (data.micromarkExtensions = []);\n  const fromMarkdownExtensions = data.fromMarkdownExtensions || (data.fromMarkdownExtensions = []);\n  const toMarkdownExtensions = data.toMarkdownExtensions || (data.toMarkdownExtensions = []);\n  micromarkExtensions.push(math(settings));\n  fromMarkdownExtensions.push(mathFromMarkdown());\n  toMarkdownExtensions.push(mathToMarkdown(settings));\n}\nexport {\n  remarkMath as default\n};\n//# sourceMappingURL=remark-math.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.741Z",
        "time": 2.260000001115259,
        "timings": {
          "blocked": 0.9980000006230548,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.8929999992637895,
          "receive": 0.3690000012284145,
          "_blocked_queueing": 0.9690000006230548,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "lineNumber": 21
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-katex.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "24002"
            },
            {
              "name": "Etag",
              "value": "W/\"5dc2-iWAyYn3ldLaFNFyuHsijk/Hqu1I\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 24002,
            "mimeType": "text/javascript",
            "text": "import {\n  find,\n  html,\n  normalize,\n  parse,\n  parse2,\n  svg\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-JJWVCDWF.js?v=2a7591ed\";\nimport {\n  SKIP,\n  convert,\n  visitParents\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-XHSSKPCH.js?v=2a7591ed\";\nimport {\n  katex\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-FV2J4HIN.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/hast-util-parse-selector/lib/index.js\nvar search = /[#.]/g;\nfunction parseSelector(selector, defaultTagName) {\n  const value = selector || \"\";\n  const props = {};\n  let start = 0;\n  let previous;\n  let tagName;\n  while (start < value.length) {\n    search.lastIndex = start;\n    const match = search.exec(value);\n    const subvalue = value.slice(start, match ? match.index : value.length);\n    if (subvalue) {\n      if (!previous) {\n        tagName = subvalue;\n      } else if (previous === \"#\") {\n        props.id = subvalue;\n      } else if (Array.isArray(props.className)) {\n        props.className.push(subvalue);\n      } else {\n        props.className = [subvalue];\n      }\n      start += subvalue.length;\n    }\n    if (match) {\n      previous = match[0];\n      start++;\n    }\n  }\n  return {\n    type: \"element\",\n    // @ts-expect-error: tag name is parsed.\n    tagName: tagName || defaultTagName || \"div\",\n    properties: props,\n    children: []\n  };\n}\n\n// node_modules/hastscript/lib/create-h.js\nfunction createH(schema, defaultTagName, caseSensitive) {\n  const adjust = caseSensitive ? createAdjustMap(caseSensitive) : void 0;\n  function h2(selector, properties, ...children) {\n    let node;\n    if (selector === null || selector === void 0) {\n      node = { type: \"root\", children: [] };\n      const child = (\n        /** @type {Child} */\n        properties\n      );\n      children.unshift(child);\n    } else {\n      node = parseSelector(selector, defaultTagName);\n      const lower = node.tagName.toLowerCase();\n      const adjusted = adjust ? adjust.get(lower) : void 0;\n      node.tagName = adjusted || lower;\n      if (isChild(properties)) {\n        children.unshift(properties);\n      } else {\n        for (const [key, value] of Object.entries(properties)) {\n          addProperty(schema, node.properties, key, value);\n        }\n      }\n    }\n    for (const child of children) {\n      addChild(node.children, child);\n    }\n    if (node.type === \"element\" && node.tagName === \"template\") {\n      node.content = { type: \"root\", children: node.children };\n      node.children = [];\n    }\n    return node;\n  }\n  return h2;\n}\nfunction isChild(value) {\n  if (value === null || typeof value !== \"object\" || Array.isArray(value)) {\n    return true;\n  }\n  if (typeof value.type !== \"string\") return false;\n  const record = (\n    /** @type {Record<string, unknown>} */\n    value\n  );\n  const keys = Object.keys(value);\n  for (const key of keys) {\n    const value2 = record[key];\n    if (value2 && typeof value2 === \"object\") {\n      if (!Array.isArray(value2)) return true;\n      const list = (\n        /** @type {ReadonlyArray<unknown>} */\n        value2\n      );\n      for (const item of list) {\n        if (typeof item !== \"number\" && typeof item !== \"string\") {\n          return true;\n        }\n      }\n    }\n  }\n  if (\"children\" in value && Array.isArray(value.children)) {\n    return true;\n  }\n  return false;\n}\nfunction addProperty(schema, properties, key, value) {\n  const info = find(schema, key);\n  let result;\n  if (value === null || value === void 0) return;\n  if (typeof value === \"number\") {\n    if (Number.isNaN(value)) return;\n    result = value;\n  } else if (typeof value === \"boolean\") {\n    result = value;\n  } else if (typeof value === \"string\") {\n    if (info.spaceSeparated) {\n      result = parse2(value);\n    } else if (info.commaSeparated) {\n      result = parse(value);\n    } else if (info.commaOrSpaceSeparated) {\n      result = parse2(parse(value).join(\" \"));\n    } else {\n      result = parsePrimitive(info, info.property, value);\n    }\n  } else if (Array.isArray(value)) {\n    result = [...value];\n  } else {\n    result = info.property === \"style\" ? style(value) : String(value);\n  }\n  if (Array.isArray(result)) {\n    const finalResult = [];\n    for (const item of result) {\n      finalResult.push(\n        /** @type {number | string} */\n        parsePrimitive(info, info.property, item)\n      );\n    }\n    result = finalResult;\n  }\n  if (info.property === \"className\" && Array.isArray(properties.className)) {\n    result = properties.className.concat(\n      /** @type {Array<number | string> | number | string} */\n      result\n    );\n  }\n  properties[info.property] = result;\n}\nfunction addChild(nodes, value) {\n  if (value === null || value === void 0) {\n  } else if (typeof value === \"number\" || typeof value === \"string\") {\n    nodes.push({ type: \"text\", value: String(value) });\n  } else if (Array.isArray(value)) {\n    for (const child of value) {\n      addChild(nodes, child);\n    }\n  } else if (typeof value === \"object\" && \"type\" in value) {\n    if (value.type === \"root\") {\n      addChild(nodes, value.children);\n    } else {\n      nodes.push(value);\n    }\n  } else {\n    throw new Error(\"Expected node, nodes, or string, got `\" + value + \"`\");\n  }\n}\nfunction parsePrimitive(info, name, value) {\n  if (typeof value === \"string\") {\n    if (info.number && value && !Number.isNaN(Number(value))) {\n      return Number(value);\n    }\n    if ((info.boolean || info.overloadedBoolean) && (value === \"\" || normalize(value) === normalize(name))) {\n      return true;\n    }\n  }\n  return value;\n}\nfunction style(styles) {\n  const result = [];\n  for (const [key, value] of Object.entries(styles)) {\n    result.push([key, value].join(\": \"));\n  }\n  return result.join(\"; \");\n}\nfunction createAdjustMap(values) {\n  const result = /* @__PURE__ */ new Map();\n  for (const value of values) {\n    result.set(value.toLowerCase(), value);\n  }\n  return result;\n}\n\n// node_modules/hastscript/lib/svg-case-sensitive-tag-names.js\nvar svgCaseSensitiveTagNames = [\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"clipPath\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feDropShadow\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"foreignObject\",\n  \"glyphRef\",\n  \"linearGradient\",\n  \"radialGradient\",\n  \"solidColor\",\n  \"textArea\",\n  \"textPath\"\n];\n\n// node_modules/hastscript/lib/index.js\nvar h = createH(html, \"div\");\nvar s = createH(svg, \"g\", svgCaseSensitiveTagNames);\n\n// node_modules/web-namespaces/index.js\nvar webNamespaces = {\n  html: \"http://www.w3.org/1999/xhtml\",\n  mathml: \"http://www.w3.org/1998/Math/MathML\",\n  svg: \"http://www.w3.org/2000/svg\",\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\",\n  xmlns: \"http://www.w3.org/2000/xmlns/\"\n};\n\n// node_modules/hast-util-from-dom/lib/index.js\nfunction fromDom(tree, options) {\n  return transform(tree, options || {}) || { type: \"root\", children: [] };\n}\nfunction transform(node, options) {\n  const transformed = one(node, options);\n  if (transformed && options.afterTransform)\n    options.afterTransform(node, transformed);\n  return transformed;\n}\nfunction one(node, options) {\n  switch (node.nodeType) {\n    case 1: {\n      const domNode = (\n        /** @type {Element} */\n        node\n      );\n      return element(domNode, options);\n    }\n    case 3: {\n      const domNode = (\n        /** @type {Text} */\n        node\n      );\n      return text(domNode);\n    }\n    case 8: {\n      const domNode = (\n        /** @type {Comment} */\n        node\n      );\n      return comment(domNode);\n    }\n    case 9: {\n      const domNode = (\n        /** @type {Document} */\n        node\n      );\n      return root(domNode, options);\n    }\n    case 10: {\n      return doctype();\n    }\n    case 11: {\n      const domNode = (\n        /** @type {DocumentFragment} */\n        node\n      );\n      return root(domNode, options);\n    }\n    default: {\n      return void 0;\n    }\n  }\n}\nfunction root(node, options) {\n  return { type: \"root\", children: all(node, options) };\n}\nfunction doctype() {\n  return { type: \"doctype\" };\n}\nfunction text(node) {\n  return { type: \"text\", value: node.nodeValue || \"\" };\n}\nfunction comment(node) {\n  return { type: \"comment\", value: node.nodeValue || \"\" };\n}\nfunction element(node, options) {\n  const space = node.namespaceURI;\n  const x = space === webNamespaces.svg ? s : h;\n  const tagName = space === webNamespaces.html ? node.tagName.toLowerCase() : node.tagName;\n  const content = (\n    // @ts-expect-error: DOM types are wrong, content can exist.\n    space === webNamespaces.html && tagName === \"template\" ? node.content : node\n  );\n  const attributes = node.getAttributeNames();\n  const properties = {};\n  let index = -1;\n  while (++index < attributes.length) {\n    properties[attributes[index]] = node.getAttribute(attributes[index]) || \"\";\n  }\n  return x(tagName, properties, all(content, options));\n}\nfunction all(node, options) {\n  const nodes = node.childNodes;\n  const children = [];\n  let index = -1;\n  while (++index < nodes.length) {\n    const child = transform(nodes[index], options);\n    if (child !== void 0) {\n      children.push(child);\n    }\n  }\n  return children;\n}\n\n// node_modules/hast-util-from-html-isomorphic/lib/browser.js\nvar parser = new DOMParser();\nfunction fromHtmlIsomorphic(value, options) {\n  const node = (options == null ? void 0 : options.fragment) ? parseFragment(value) : parser.parseFromString(value, \"text/html\");\n  return (\n    /** @type {Root} */\n    fromDom(node)\n  );\n}\nfunction parseFragment(value) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = value;\n  return template.content;\n}\n\n// node_modules/unist-util-find-after/lib/index.js\nvar findAfter = (\n  // Note: overloads like this are needed to support optional generics.\n  /**\n   * @type {(\n   *   (<Kind extends UnistParent, Check extends Test>(parent: Kind, index: Child<Kind> | number, test: Check) => Matches<Child<Kind>, Check> | undefined) &\n   *   (<Kind extends UnistParent>(parent: Kind, index: Child<Kind> | number, test?: null | undefined) => Child<Kind> | undefined)\n   * )}\n   */\n  /**\n   * @param {UnistParent} parent\n   * @param {UnistNode | number} index\n   * @param {Test} [test]\n   * @returns {UnistNode | undefined}\n   */\n  function(parent, index, test) {\n    const is = convert(test);\n    if (!parent || !parent.type || !parent.children) {\n      throw new Error(\"Expected parent node\");\n    }\n    if (typeof index === \"number\") {\n      if (index < 0 || index === Number.POSITIVE_INFINITY) {\n        throw new Error(\"Expected positive finite number as index\");\n      }\n    } else {\n      index = parent.children.indexOf(index);\n      if (index < 0) {\n        throw new Error(\"Expected child node or index\");\n      }\n    }\n    while (++index < parent.children.length) {\n      if (is(parent.children[index], index, parent)) {\n        return parent.children[index];\n      }\n    }\n    return void 0;\n  }\n);\n\n// node_modules/hast-util-is-element/lib/index.js\nvar convertElement = (\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends TestFunction>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & Predicate<Condition, Element>) &\n   *   (<Condition extends string>(test: Condition) => (element: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element & {tagName: Condition}) &\n   *   ((test?: null | undefined) => (element?: unknown, index?: number | null | undefined, parent?: Parents | null | undefined, context?: unknown) => element is Element) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  /**\n   * @param {Test | null | undefined} [test]\n   * @returns {Check}\n   */\n  function(test) {\n    if (test === null || test === void 0) {\n      return element2;\n    }\n    if (typeof test === \"string\") {\n      return tagNameFactory(test);\n    }\n    if (typeof test === \"object\") {\n      return anyFactory(test);\n    }\n    if (typeof test === \"function\") {\n      return castFactory(test);\n    }\n    throw new Error(\"Expected function, string, or array as `test`\");\n  }\n);\nfunction anyFactory(tests) {\n  const checks = [];\n  let index = -1;\n  while (++index < tests.length) {\n    checks[index] = convertElement(tests[index]);\n  }\n  return castFactory(any);\n  function any(...parameters) {\n    let index2 = -1;\n    while (++index2 < checks.length) {\n      if (checks[index2].apply(this, parameters)) return true;\n    }\n    return false;\n  }\n}\nfunction tagNameFactory(check) {\n  return castFactory(tagName);\n  function tagName(element3) {\n    return element3.tagName === check;\n  }\n}\nfunction castFactory(testFunction) {\n  return check;\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeAnElement(value) && testFunction.call(\n        this,\n        value,\n        typeof index === \"number\" ? index : void 0,\n        parent || void 0\n      )\n    );\n  }\n}\nfunction element2(element3) {\n  return Boolean(\n    element3 && typeof element3 === \"object\" && \"type\" in element3 && element3.type === \"element\" && \"tagName\" in element3 && typeof element3.tagName === \"string\"\n  );\n}\nfunction looksLikeAnElement(value) {\n  return value !== null && typeof value === \"object\" && \"type\" in value && \"tagName\" in value;\n}\n\n// node_modules/hast-util-to-text/lib/index.js\nvar searchLineFeeds = /\\n/g;\nvar searchTabOrSpaces = /[\\t ]+/g;\nvar br = convertElement(\"br\");\nvar cell = convertElement(isCell);\nvar p = convertElement(\"p\");\nvar row = convertElement(\"tr\");\nvar notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/multipage/rendering.html#hidden-elements>\n  \"datalist\",\n  \"head\",\n  \"noembed\",\n  \"noframes\",\n  \"noscript\",\n  // Act as if we support scripting.\n  \"rp\",\n  \"script\",\n  \"style\",\n  \"template\",\n  \"title\",\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/multipage/rendering.html#flow-content-3>\n  closedDialog\n]);\nvar blockOrCaption = convertElement([\n  \"address\",\n  // Flow content\n  \"article\",\n  // Sections and headings\n  \"aside\",\n  // Sections and headings\n  \"blockquote\",\n  // Flow content\n  \"body\",\n  // Page\n  \"caption\",\n  // `table-caption`\n  \"center\",\n  // Flow content (legacy)\n  \"dd\",\n  // Lists\n  \"dialog\",\n  // Flow content\n  \"dir\",\n  // Lists (legacy)\n  \"dl\",\n  // Lists\n  \"dt\",\n  // Lists\n  \"div\",\n  // Flow content\n  \"figure\",\n  // Flow content\n  \"figcaption\",\n  // Flow content\n  \"footer\",\n  // Flow content\n  \"form,\",\n  // Flow content\n  \"h1\",\n  // Sections and headings\n  \"h2\",\n  // Sections and headings\n  \"h3\",\n  // Sections and headings\n  \"h4\",\n  // Sections and headings\n  \"h5\",\n  // Sections and headings\n  \"h6\",\n  // Sections and headings\n  \"header\",\n  // Flow content\n  \"hgroup\",\n  // Sections and headings\n  \"hr\",\n  // Flow content\n  \"html\",\n  // Page\n  \"legend\",\n  // Flow content\n  \"li\",\n  // Lists (as `display: list-item`)\n  \"listing\",\n  // Flow content (legacy)\n  \"main\",\n  // Flow content\n  \"menu\",\n  // Lists\n  \"nav\",\n  // Sections and headings\n  \"ol\",\n  // Lists\n  \"p\",\n  // Flow content\n  \"plaintext\",\n  // Flow content (legacy)\n  \"pre\",\n  // Flow content\n  \"section\",\n  // Sections and headings\n  \"ul\",\n  // Lists\n  \"xmp\"\n  // Flow content (legacy)\n]);\nfunction toText(tree, options) {\n  const options_ = options || {};\n  const children = \"children\" in tree ? tree.children : [];\n  const block = blockOrCaption(tree);\n  const whitespace = inferWhitespace(tree, {\n    whitespace: options_.whitespace || \"normal\",\n    breakBefore: false,\n    breakAfter: false\n  });\n  const results = [];\n  if (tree.type === \"text\" || tree.type === \"comment\") {\n    results.push(\n      ...collectText(tree, {\n        whitespace,\n        breakBefore: true,\n        breakAfter: true\n      })\n    );\n  }\n  let index = -1;\n  while (++index < children.length) {\n    results.push(\n      ...renderedTextCollection(\n        children[index],\n        // @ts-expect-error: `tree` is a parent if were here.\n        tree,\n        {\n          whitespace,\n          breakBefore: index ? void 0 : block,\n          breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\n        }\n      )\n    );\n  }\n  const result = [];\n  let count;\n  index = -1;\n  while (++index < results.length) {\n    const value = results[index];\n    if (typeof value === \"number\") {\n      if (count !== void 0 && value > count) count = value;\n    } else if (value) {\n      if (count !== void 0 && count > -1) {\n        result.push(\"\\n\".repeat(count) || \" \");\n      }\n      count = -1;\n      result.push(value);\n    }\n  }\n  return result.join(\"\");\n}\nfunction renderedTextCollection(node, parent, info) {\n  if (node.type === \"element\") {\n    return collectElement(node, parent, info);\n  }\n  if (node.type === \"text\") {\n    return info.whitespace === \"normal\" ? collectText(node, info) : collectPreText(node);\n  }\n  return [];\n}\nfunction collectElement(node, parent, info) {\n  const whitespace = inferWhitespace(node, info);\n  const children = node.children || [];\n  let index = -1;\n  let items = [];\n  if (notRendered(node)) {\n    return items;\n  }\n  let prefix;\n  let suffix;\n  if (br(node)) {\n    suffix = \"\\n\";\n  } else if (row(node) && // @ts-expect-error: something up with types of parents.\n  findAfter(parent, node, row)) {\n    suffix = \"\\n\";\n  } else if (p(node)) {\n    prefix = 2;\n    suffix = 2;\n  } else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  }\n  while (++index < children.length) {\n    items = items.concat(\n      renderedTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? void 0 : prefix,\n        breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    );\n  }\n  if (cell(node) && // @ts-expect-error: something up with types of parents.\n  findAfter(parent, node, cell)) {\n    items.push(\"\t\");\n  }\n  if (prefix) items.unshift(prefix);\n  if (suffix) items.push(suffix);\n  return items;\n}\nfunction collectText(node, info) {\n  const value = String(node.value);\n  const lines = [];\n  const result = [];\n  let start = 0;\n  while (start <= value.length) {\n    searchLineFeeds.lastIndex = start;\n    const match = searchLineFeeds.exec(value);\n    const end = match && \"index\" in match ? match.index : value.length;\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value.slice(start, end).replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, \"\"),\n        start === 0 ? info.breakBefore : true,\n        end === value.length ? info.breakAfter : true\n      )\n    );\n    start = end + 1;\n  }\n  let index = -1;\n  let join;\n  while (++index < lines.length) {\n    if (lines[index].charCodeAt(lines[index].length - 1) === 8203 || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 8203) {\n      result.push(lines[index]);\n      join = void 0;\n    } else if (lines[index]) {\n      if (typeof join === \"number\") result.push(join);\n      result.push(lines[index]);\n      join = 0;\n    } else if (index === 0 || index === lines.length - 1) {\n      result.push(0);\n    }\n  }\n  return result;\n}\nfunction collectPreText(node) {\n  return [String(node.value)];\n}\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  const result = [];\n  let start = 0;\n  let end;\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start;\n    const match = searchTabOrSpaces.exec(value);\n    end = match ? match.index : value.length;\n    if (!start && !end && match && !breakBefore) {\n      result.push(\"\");\n    }\n    if (start !== end) {\n      result.push(value.slice(start, end));\n    }\n    start = match ? end + match[0].length : end;\n  }\n  if (start !== end && !breakAfter) {\n    result.push(\"\");\n  }\n  return result.join(\" \");\n}\nfunction inferWhitespace(node, info) {\n  if (node.type === \"element\") {\n    const properties = node.properties || {};\n    switch (node.tagName) {\n      case \"listing\":\n      case \"plaintext\":\n      case \"xmp\": {\n        return \"pre\";\n      }\n      case \"nobr\": {\n        return \"nowrap\";\n      }\n      case \"pre\": {\n        return properties.wrap ? \"pre-wrap\" : \"pre\";\n      }\n      case \"td\":\n      case \"th\": {\n        return properties.noWrap ? \"nowrap\" : info.whitespace;\n      }\n      case \"textarea\": {\n        return \"pre-wrap\";\n      }\n      default:\n    }\n  }\n  return info.whitespace;\n}\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden);\n}\nfunction isCell(node) {\n  return node.tagName === \"td\" || node.tagName === \"th\";\n}\nfunction closedDialog(node) {\n  return node.tagName === \"dialog\" && !(node.properties || {}).open;\n}\n\n// node_modules/rehype-katex/lib/index.js\nvar emptyOptions = {};\nvar emptyClasses = [];\nfunction rehypeKatex(options) {\n  const settings = options || emptyOptions;\n  return function(tree, file) {\n    visitParents(tree, \"element\", function(element3, parents) {\n      const classes = Array.isArray(element3.properties.className) ? element3.properties.className : emptyClasses;\n      const languageMath = classes.includes(\"language-math\");\n      const mathDisplay = classes.includes(\"math-display\");\n      const mathInline = classes.includes(\"math-inline\");\n      let displayMode = mathDisplay;\n      if (!languageMath && !mathDisplay && !mathInline) {\n        return;\n      }\n      let parent = parents[parents.length - 1];\n      let scope = element3;\n      if (element3.tagName === \"code\" && languageMath && parent && parent.type === \"element\" && parent.tagName === \"pre\") {\n        scope = parent;\n        parent = parents[parents.length - 2];\n        displayMode = true;\n      }\n      if (!parent) return;\n      const value = toText(scope, { whitespace: \"pre\" });\n      let result;\n      try {\n        result = katex.renderToString(value, {\n          ...settings,\n          displayMode,\n          throwOnError: true\n        });\n      } catch (error) {\n        const cause = (\n          /** @type {Error} */\n          error\n        );\n        const ruleId = cause.name.toLowerCase();\n        file.message(\"Could not render math with KaTeX\", {\n          ancestors: [...parents, element3],\n          cause,\n          place: element3.position,\n          ruleId,\n          source: \"rehype-katex\"\n        });\n        try {\n          result = katex.renderToString(value, {\n            ...settings,\n            displayMode,\n            strict: \"ignore\",\n            throwOnError: false\n          });\n        } catch {\n          result = [\n            {\n              type: \"element\",\n              tagName: \"span\",\n              properties: {\n                className: [\"katex-error\"],\n                style: \"color:\" + (settings.errorColor || \"#cc0000\"),\n                title: String(error)\n              },\n              children: [{ type: \"text\", value }]\n            }\n          ];\n        }\n      }\n      if (typeof result === \"string\") {\n        const root2 = fromHtmlIsomorphic(result, { fragment: true });\n        result = /** @type {Array<ElementContent>} */\n        root2.children;\n      }\n      const index = parent.children.indexOf(scope);\n      parent.children.splice(index, 1, ...result);\n      return SKIP;\n    });\n  };\n}\nexport {\n  rehypeKatex as default\n};\n//# sourceMappingURL=rehype-katex.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.741Z",
        "time": 2.53800000064075,
        "timings": {
          "blocked": 1.0160000030787195,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.9180000004512258,
          "receive": 0.6039999971108045,
          "_blocked_queueing": 0.9870000030787196,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "lineNumber": 22
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-sanitize.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "13030"
            },
            {
              "name": "Etag",
              "value": "W/\"32e6-1zdETvD0U3IrOf/8Au3dZbvUM5E\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 13030,
            "mimeType": "text/javascript",
            "text": "import {\n  esm_default,\n  position\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-WA7BIZIN.js?v=2a7591ed\";\nimport \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/hast-util-sanitize/lib/schema.js\nvar aria = [\"ariaDescribedBy\", \"ariaLabel\", \"ariaLabelledBy\"];\nvar defaultSchema = {\n  ancestors: {\n    tbody: [\"table\"],\n    td: [\"table\"],\n    th: [\"table\"],\n    thead: [\"table\"],\n    tfoot: [\"table\"],\n    tr: [\"table\"]\n  },\n  attributes: {\n    a: [\n      ...aria,\n      // Note: these 3 are used by GFM footnotes, they do work on all links.\n      \"dataFootnoteBackref\",\n      \"dataFootnoteRef\",\n      [\"className\", \"data-footnote-backref\"],\n      \"href\"\n    ],\n    blockquote: [\"cite\"],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `code` as HTML in markdown, they adds it some other way.\n    // We cant do that, so we have to allow it.\n    code: [[\"className\", /^language-./]],\n    del: [\"cite\"],\n    div: [\"itemScope\", \"itemType\"],\n    dl: [...aria],\n    // Note: this is used by GFM footnotes.\n    h2: [[\"className\", \"sr-only\"]],\n    img: [...aria, \"longDesc\", \"src\"],\n    // Note: `input` is not normally allowed by GH, when manually writing\n    // it in markdown, they add it from tasklists some other way.\n    // We cant do that, so we have to allow it.\n    input: [\n      [\"disabled\", true],\n      [\"type\", \"checkbox\"]\n    ],\n    ins: [\"cite\"],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `li` as HTML in markdown, they adds it some other way.\n    // We cant do that, so we have to allow it.\n    li: [[\"className\", \"task-list-item\"]],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `ol` as HTML in markdown, they adds it some other way.\n    // We cant do that, so we have to allow it.\n    ol: [...aria, [\"className\", \"contains-task-list\"]],\n    q: [\"cite\"],\n    section: [\"dataFootnotes\", [\"className\", \"footnotes\"]],\n    source: [\"srcSet\"],\n    summary: [...aria],\n    table: [...aria],\n    // Note: this class is not normally allowed by GH, when manually writing\n    // `ol` as HTML in markdown, they adds it some other way.\n    // We cant do that, so we have to allow it.\n    ul: [...aria, [\"className\", \"contains-task-list\"]],\n    \"*\": [\n      \"abbr\",\n      \"accept\",\n      \"acceptCharset\",\n      \"accessKey\",\n      \"action\",\n      \"align\",\n      \"alt\",\n      \"axis\",\n      \"border\",\n      \"cellPadding\",\n      \"cellSpacing\",\n      \"char\",\n      \"charOff\",\n      \"charSet\",\n      \"checked\",\n      \"clear\",\n      \"colSpan\",\n      \"color\",\n      \"cols\",\n      \"compact\",\n      \"coords\",\n      \"dateTime\",\n      \"dir\",\n      // Note: `disabled` is technically allowed on all elements by GH.\n      // But it is useless on everything except `input`.\n      // Because `input`s are normally not allowed, but we allow them for\n      // checkboxes due to tasklists, we allow `disabled` only there.\n      \"encType\",\n      \"frame\",\n      \"hSpace\",\n      \"headers\",\n      \"height\",\n      \"hrefLang\",\n      \"htmlFor\",\n      \"id\",\n      \"isMap\",\n      \"itemProp\",\n      \"label\",\n      \"lang\",\n      \"maxLength\",\n      \"media\",\n      \"method\",\n      \"multiple\",\n      \"name\",\n      \"noHref\",\n      \"noShade\",\n      \"noWrap\",\n      \"open\",\n      \"prompt\",\n      \"readOnly\",\n      \"rev\",\n      \"rowSpan\",\n      \"rows\",\n      \"rules\",\n      \"scope\",\n      \"selected\",\n      \"shape\",\n      \"size\",\n      \"span\",\n      \"start\",\n      \"summary\",\n      \"tabIndex\",\n      \"title\",\n      \"useMap\",\n      \"vAlign\",\n      \"value\",\n      \"width\"\n    ]\n  },\n  clobber: [\"ariaDescribedBy\", \"ariaLabelledBy\", \"id\", \"name\"],\n  clobberPrefix: \"user-content-\",\n  protocols: {\n    cite: [\"http\", \"https\"],\n    href: [\"http\", \"https\", \"irc\", \"ircs\", \"mailto\", \"xmpp\"],\n    longDesc: [\"http\", \"https\"],\n    src: [\"http\", \"https\"]\n  },\n  required: {\n    input: { disabled: true, type: \"checkbox\" }\n  },\n  strip: [\"script\"],\n  tagNames: [\n    \"a\",\n    \"b\",\n    \"blockquote\",\n    \"br\",\n    \"code\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"hr\",\n    \"i\",\n    \"img\",\n    // Note: `input` is not normally allowed by GH, when manually writing\n    // it in markdown, they add it from tasklists some other way.\n    // We cant do that, so we have to allow it.\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"li\",\n    \"ol\",\n    \"p\",\n    \"picture\",\n    \"pre\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"section\",\n    \"source\",\n    \"span\",\n    \"strike\",\n    \"strong\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"tr\",\n    \"tt\",\n    \"ul\",\n    \"var\"\n  ]\n};\n\n// node_modules/hast-util-sanitize/lib/index.js\nvar own = {}.hasOwnProperty;\nfunction sanitize(node, options) {\n  let result = { type: \"root\", children: [] };\n  const state = {\n    schema: options ? { ...defaultSchema, ...options } : defaultSchema,\n    stack: []\n  };\n  const replace = transform(state, node);\n  if (replace) {\n    if (Array.isArray(replace)) {\n      if (replace.length === 1) {\n        result = replace[0];\n      } else {\n        result.children = replace;\n      }\n    } else {\n      result = replace;\n    }\n  }\n  return result;\n}\nfunction transform(state, node) {\n  if (node && typeof node === \"object\") {\n    const unsafe = (\n      /** @type {Record<string, Readonly<unknown>>} */\n      node\n    );\n    const type = typeof unsafe.type === \"string\" ? unsafe.type : \"\";\n    switch (type) {\n      case \"comment\": {\n        return comment(state, unsafe);\n      }\n      case \"doctype\": {\n        return doctype(state, unsafe);\n      }\n      case \"element\": {\n        return element(state, unsafe);\n      }\n      case \"root\": {\n        return root(state, unsafe);\n      }\n      case \"text\": {\n        return text(state, unsafe);\n      }\n      default:\n    }\n  }\n}\nfunction comment(state, unsafe) {\n  if (state.schema.allowComments) {\n    const result = typeof unsafe.value === \"string\" ? unsafe.value : \"\";\n    const index = result.indexOf(\"-->\");\n    const value = index < 0 ? result : result.slice(0, index);\n    const node = { type: \"comment\", value };\n    patch(node, unsafe);\n    return node;\n  }\n}\nfunction doctype(state, unsafe) {\n  if (state.schema.allowDoctypes) {\n    const node = { type: \"doctype\" };\n    patch(node, unsafe);\n    return node;\n  }\n}\nfunction element(state, unsafe) {\n  const name = typeof unsafe.tagName === \"string\" ? unsafe.tagName : \"\";\n  state.stack.push(name);\n  const content = (\n    /** @type {Array<ElementContent>} */\n    children(state, unsafe.children)\n  );\n  const properties_ = properties(state, unsafe.properties);\n  state.stack.pop();\n  let safeElement = false;\n  if (name && name !== \"*\" && (!state.schema.tagNames || state.schema.tagNames.includes(name))) {\n    safeElement = true;\n    if (state.schema.ancestors && own.call(state.schema.ancestors, name)) {\n      const ancestors = state.schema.ancestors[name];\n      let index = -1;\n      safeElement = false;\n      while (++index < ancestors.length) {\n        if (state.stack.includes(ancestors[index])) {\n          safeElement = true;\n        }\n      }\n    }\n  }\n  if (!safeElement) {\n    return state.schema.strip && !state.schema.strip.includes(name) ? content : void 0;\n  }\n  const node = {\n    type: \"element\",\n    tagName: name,\n    properties: properties_,\n    children: content\n  };\n  patch(node, unsafe);\n  return node;\n}\nfunction root(state, unsafe) {\n  const content = (\n    /** @type {Array<RootContent>} */\n    children(state, unsafe.children)\n  );\n  const node = { type: \"root\", children: content };\n  patch(node, unsafe);\n  return node;\n}\nfunction text(_, unsafe) {\n  const value = typeof unsafe.value === \"string\" ? unsafe.value : \"\";\n  const node = { type: \"text\", value };\n  patch(node, unsafe);\n  return node;\n}\nfunction children(state, children2) {\n  const results = [];\n  if (Array.isArray(children2)) {\n    const childrenUnknown = (\n      /** @type {Array<Readonly<unknown>>} */\n      children2\n    );\n    let index = -1;\n    while (++index < childrenUnknown.length) {\n      const value = transform(state, childrenUnknown[index]);\n      if (value) {\n        if (Array.isArray(value)) {\n          results.push(...value);\n        } else {\n          results.push(value);\n        }\n      }\n    }\n  }\n  return results;\n}\nfunction properties(state, properties2) {\n  const tagName = state.stack[state.stack.length - 1];\n  const attributes = state.schema.attributes;\n  const required = state.schema.required;\n  const specific = attributes && own.call(attributes, tagName) ? attributes[tagName] : void 0;\n  const defaults = attributes && own.call(attributes, \"*\") ? attributes[\"*\"] : void 0;\n  const properties_ = (\n    /** @type {Readonly<Record<string, Readonly<unknown>>>} */\n    properties2 && typeof properties2 === \"object\" ? properties2 : {}\n  );\n  const result = {};\n  let key;\n  for (key in properties_) {\n    if (own.call(properties_, key)) {\n      const unsafe = properties_[key];\n      let safe = propertyValue(\n        state,\n        findDefinition(specific, key),\n        key,\n        unsafe\n      );\n      if (safe === null || safe === void 0) {\n        safe = propertyValue(state, findDefinition(defaults, key), key, unsafe);\n      }\n      if (safe !== null && safe !== void 0) {\n        result[key] = safe;\n      }\n    }\n  }\n  if (required && own.call(required, tagName)) {\n    const properties3 = required[tagName];\n    for (key in properties3) {\n      if (own.call(properties3, key) && !own.call(result, key)) {\n        result[key] = properties3[key];\n      }\n    }\n  }\n  return result;\n}\nfunction propertyValue(state, definition, key, value) {\n  return definition ? Array.isArray(value) ? propertyValueMany(state, definition, key, value) : propertyValuePrimitive(state, definition, key, value) : void 0;\n}\nfunction propertyValueMany(state, definition, key, values) {\n  let index = -1;\n  const result = [];\n  while (++index < values.length) {\n    const value = propertyValuePrimitive(state, definition, key, values[index]);\n    if (typeof value === \"number\" || typeof value === \"string\") {\n      result.push(value);\n    }\n  }\n  return result;\n}\nfunction propertyValuePrimitive(state, definition, key, value) {\n  if (typeof value !== \"boolean\" && typeof value !== \"number\" && typeof value !== \"string\") {\n    return;\n  }\n  if (!safeProtocol(state, key, value)) {\n    return;\n  }\n  if (typeof definition === \"object\" && definition.length > 1) {\n    let ok = false;\n    let index = 0;\n    while (++index < definition.length) {\n      const allowed = definition[index];\n      if (allowed && typeof allowed === \"object\" && \"flags\" in allowed) {\n        if (allowed.test(String(value))) {\n          ok = true;\n          break;\n        }\n      } else if (allowed === value) {\n        ok = true;\n        break;\n      }\n    }\n    if (!ok) return;\n  }\n  return state.schema.clobber && state.schema.clobberPrefix && state.schema.clobber.includes(key) ? state.schema.clobberPrefix + value : value;\n}\nfunction safeProtocol(state, key, value) {\n  const protocols = state.schema.protocols && own.call(state.schema.protocols, key) ? state.schema.protocols[key] : void 0;\n  if (!protocols || protocols.length === 0) {\n    return true;\n  }\n  const url = String(value);\n  const colon = url.indexOf(\":\");\n  const questionMark = url.indexOf(\"?\");\n  const numberSign = url.indexOf(\"#\");\n  const slash = url.indexOf(\"/\");\n  if (colon < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.\n  slash > -1 && colon > slash || questionMark > -1 && colon > questionMark || numberSign > -1 && colon > numberSign) {\n    return true;\n  }\n  let index = -1;\n  while (++index < protocols.length) {\n    const protocol = protocols[index];\n    if (colon === protocol.length && url.slice(0, protocol.length) === protocol) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction patch(node, unsafe) {\n  const cleanPosition = position(\n    // @ts-expect-error: looks like a node.\n    unsafe\n  );\n  if (unsafe.data) {\n    node.data = esm_default(unsafe.data);\n  }\n  if (cleanPosition) node.position = cleanPosition;\n}\nfunction findDefinition(definitions, key) {\n  let dataDefault;\n  let index = -1;\n  if (definitions) {\n    while (++index < definitions.length) {\n      const entry = definitions[index];\n      const name = typeof entry === \"string\" ? entry : entry[0];\n      if (name === key) {\n        return entry;\n      }\n      if (name === \"data*\") dataDefault = entry;\n    }\n  }\n  if (key.length > 4 && key.slice(0, 4).toLowerCase() === \"data\") {\n    return dataDefault;\n  }\n}\n\n// node_modules/rehype-sanitize/lib/index.js\nfunction rehypeSanitize(options) {\n  return function(tree) {\n    const result = (\n      /** @type {Root} */\n      sanitize(tree, options)\n    );\n    return result;\n  };\n}\nexport {\n  rehypeSanitize as default,\n  defaultSchema\n};\n//# sourceMappingURL=rehype-sanitize.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.741Z",
        "time": 2.563000001828186,
        "timings": {
          "blocked": 1.0790000022400636,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.9390000006230548,
          "receive": 0.5449999989650678,
          "_blocked_queueing": 1.0490000022400636,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx",
          "lineNumber": 23
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/katex.min.css",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"69c5-t8Ku7LartiTRyxb0RXdaFjSQ2Tg\""
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/components/SimpleMarkdownRenderer.tsx"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "script"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 603,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 27077,
            "mimeType": "text/javascript",
            "text": "import { createHotContext as __vite__createHotContext } from \"/@vite/client\";import.meta.hot = __vite__createHotContext(\"/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/katex.min.css\");import { updateStyle as __vite__updateStyle, removeStyle as __vite__removeStyle } from \"/@vite/client\"\nconst __vite__id = \"/home/jano/DEV_WSL/LLM/node_modules/katex/dist/katex.min.css\"\nconst __vite__css = \"@font-face{font-family:KaTeX_AMS;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_AMS-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_AMS-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_AMS-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:700;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Caligraphic-Bold.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Caligraphic-Bold.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Caligraphic-Bold.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Caligraphic;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Caligraphic-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Caligraphic-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Caligraphic-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:700;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Fraktur-Bold.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Fraktur-Bold.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Fraktur-Bold.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Fraktur;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Fraktur-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Fraktur-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Fraktur-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:700;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Bold.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Bold.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Bold.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:700;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-BoldItalic.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-BoldItalic.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-BoldItalic.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Main;font-style:italic;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Italic.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Italic.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Italic.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Main;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Main-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:700;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Math-BoldItalic.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Math-BoldItalic.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Math-BoldItalic.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Math;font-style:italic;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Math-Italic.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Math-Italic.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Math-Italic.ttf) format(\\\"truetype\\\")}@font-face{font-family:\\\"KaTeX_SansSerif\\\";font-style:normal;font-weight:700;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Bold.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Bold.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Bold.ttf) format(\\\"truetype\\\")}@font-face{font-family:\\\"KaTeX_SansSerif\\\";font-style:italic;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Italic.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Italic.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Italic.ttf) format(\\\"truetype\\\")}@font-face{font-family:\\\"KaTeX_SansSerif\\\";font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_SansSerif-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Script;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Script-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Script-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Script-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Size1;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size1-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size1-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size1-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Size2;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size2-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size2-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size2-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Size3;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size3-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size3-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size3-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Size4;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size4-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size4-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Size4-Regular.ttf) format(\\\"truetype\\\")}@font-face{font-family:KaTeX_Typewriter;font-style:normal;font-weight:400;src:url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Typewriter-Regular.woff2) format(\\\"woff2\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Typewriter-Regular.woff) format(\\\"woff\\\"),url(/@fs/home/jano/DEV_WSL/LLM/node_modules/katex/dist/fonts/KaTeX_Typewriter-Regular.ttf) format(\\\"truetype\\\")}.katex{font:normal 1.21em KaTeX_Main,Times New Roman,serif;line-height:1.2;text-indent:0;text-rendering:auto}.katex *{-ms-high-contrast-adjust:none!important;border-color:currentColor}.katex .katex-version:after{content:\\\"0.16.22\\\"}.katex .katex-mathml{clip:rect(1px,1px,1px,1px);border:0;height:1px;overflow:hidden;padding:0;position:absolute;width:1px}.katex .katex-html>.newline{display:block}.katex .base{position:relative;white-space:nowrap;width:-webkit-min-content;width:-moz-min-content;width:min-content}.katex .base,.katex .strut{display:inline-block}.katex .textbf{font-weight:700}.katex .textit{font-style:italic}.katex .textrm{font-family:KaTeX_Main}.katex .textsf{font-family:KaTeX_SansSerif}.katex .texttt{font-family:KaTeX_Typewriter}.katex .mathnormal{font-family:KaTeX_Math;font-style:italic}.katex .mathit{font-family:KaTeX_Main;font-style:italic}.katex .mathrm{font-style:normal}.katex .mathbf{font-family:KaTeX_Main;font-weight:700}.katex .boldsymbol{font-family:KaTeX_Math;font-style:italic;font-weight:700}.katex .amsrm,.katex .mathbb,.katex .textbb{font-family:KaTeX_AMS}.katex .mathcal{font-family:KaTeX_Caligraphic}.katex .mathfrak,.katex .textfrak{font-family:KaTeX_Fraktur}.katex .mathboldfrak,.katex .textboldfrak{font-family:KaTeX_Fraktur;font-weight:700}.katex .mathtt{font-family:KaTeX_Typewriter}.katex .mathscr,.katex .textscr{font-family:KaTeX_Script}.katex .mathsf,.katex .textsf{font-family:KaTeX_SansSerif}.katex .mathboldsf,.katex .textboldsf{font-family:KaTeX_SansSerif;font-weight:700}.katex .mathitsf,.katex .mathsfit,.katex .textitsf{font-family:KaTeX_SansSerif;font-style:italic}.katex .mainrm{font-family:KaTeX_Main;font-style:normal}.katex .vlist-t{border-collapse:collapse;display:inline-table;table-layout:fixed}.katex .vlist-r{display:table-row}.katex .vlist{display:table-cell;position:relative;vertical-align:bottom}.katex .vlist>span{display:block;height:0;position:relative}.katex .vlist>span>span{display:inline-block}.katex .vlist>span>.pstrut{overflow:hidden;width:0}.katex .vlist-t2{margin-right:-2px}.katex .vlist-s{display:table-cell;font-size:1px;min-width:2px;vertical-align:bottom;width:2px}.katex .vbox{align-items:baseline;display:inline-flex;flex-direction:column}.katex .hbox{width:100%}.katex .hbox,.katex .thinbox{display:inline-flex;flex-direction:row}.katex .thinbox{max-width:0;width:0}.katex .msupsub{text-align:left}.katex .mfrac>span>span{text-align:center}.katex .mfrac .frac-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline,.katex .hline,.katex .mfrac .frac-line,.katex .overline .overline-line,.katex .rule,.katex .underline .underline-line{min-height:1px}.katex .mspace{display:inline-block}.katex .clap,.katex .llap,.katex .rlap{position:relative;width:0}.katex .clap>.inner,.katex .llap>.inner,.katex .rlap>.inner{position:absolute}.katex .clap>.fix,.katex .llap>.fix,.katex .rlap>.fix{display:inline-block}.katex .llap>.inner{right:0}.katex .clap>.inner,.katex .rlap>.inner{left:0}.katex .clap>.inner>span{margin-left:-50%;margin-right:50%}.katex .rule{border:0 solid;display:inline-block;position:relative}.katex .hline,.katex .overline .overline-line,.katex .underline .underline-line{border-bottom-style:solid;display:inline-block;width:100%}.katex .hdashline{border-bottom-style:dashed;display:inline-block;width:100%}.katex .sqrt>.root{margin-left:.2777777778em;margin-right:-.5555555556em}.katex .fontsize-ensurer.reset-size1.size1,.katex .sizing.reset-size1.size1{font-size:1em}.katex .fontsize-ensurer.reset-size1.size2,.katex .sizing.reset-size1.size2{font-size:1.2em}.katex .fontsize-ensurer.reset-size1.size3,.katex .sizing.reset-size1.size3{font-size:1.4em}.katex .fontsize-ensurer.reset-size1.size4,.katex .sizing.reset-size1.size4{font-size:1.6em}.katex .fontsize-ensurer.reset-size1.size5,.katex .sizing.reset-size1.size5{font-size:1.8em}.katex .fontsize-ensurer.reset-size1.size6,.katex .sizing.reset-size1.size6{font-size:2em}.katex .fontsize-ensurer.reset-size1.size7,.katex .sizing.reset-size1.size7{font-size:2.4em}.katex .fontsize-ensurer.reset-size1.size8,.katex .sizing.reset-size1.size8{font-size:2.88em}.katex .fontsize-ensurer.reset-size1.size9,.katex .sizing.reset-size1.size9{font-size:3.456em}.katex .fontsize-ensurer.reset-size1.size10,.katex .sizing.reset-size1.size10{font-size:4.148em}.katex .fontsize-ensurer.reset-size1.size11,.katex .sizing.reset-size1.size11{font-size:4.976em}.katex .fontsize-ensurer.reset-size2.size1,.katex .sizing.reset-size2.size1{font-size:.8333333333em}.katex .fontsize-ensurer.reset-size2.size2,.katex .sizing.reset-size2.size2{font-size:1em}.katex .fontsize-ensurer.reset-size2.size3,.katex .sizing.reset-size2.size3{font-size:1.1666666667em}.katex .fontsize-ensurer.reset-size2.size4,.katex .sizing.reset-size2.size4{font-size:1.3333333333em}.katex .fontsize-ensurer.reset-size2.size5,.katex .sizing.reset-size2.size5{font-size:1.5em}.katex .fontsize-ensurer.reset-size2.size6,.katex .sizing.reset-size2.size6{font-size:1.6666666667em}.katex .fontsize-ensurer.reset-size2.size7,.katex .sizing.reset-size2.size7{font-size:2em}.katex .fontsize-ensurer.reset-size2.size8,.katex .sizing.reset-size2.size8{font-size:2.4em}.katex .fontsize-ensurer.reset-size2.size9,.katex .sizing.reset-size2.size9{font-size:2.88em}.katex .fontsize-ensurer.reset-size2.size10,.katex .sizing.reset-size2.size10{font-size:3.4566666667em}.katex .fontsize-ensurer.reset-size2.size11,.katex .sizing.reset-size2.size11{font-size:4.1466666667em}.katex .fontsize-ensurer.reset-size3.size1,.katex .sizing.reset-size3.size1{font-size:.7142857143em}.katex .fontsize-ensurer.reset-size3.size2,.katex .sizing.reset-size3.size2{font-size:.8571428571em}.katex .fontsize-ensurer.reset-size3.size3,.katex .sizing.reset-size3.size3{font-size:1em}.katex .fontsize-ensurer.reset-size3.size4,.katex .sizing.reset-size3.size4{font-size:1.1428571429em}.katex .fontsize-ensurer.reset-size3.size5,.katex .sizing.reset-size3.size5{font-size:1.2857142857em}.katex .fontsize-ensurer.reset-size3.size6,.katex .sizing.reset-size3.size6{font-size:1.4285714286em}.katex .fontsize-ensurer.reset-size3.size7,.katex .sizing.reset-size3.size7{font-size:1.7142857143em}.katex .fontsize-ensurer.reset-size3.size8,.katex .sizing.reset-size3.size8{font-size:2.0571428571em}.katex .fontsize-ensurer.reset-size3.size9,.katex .sizing.reset-size3.size9{font-size:2.4685714286em}.katex .fontsize-ensurer.reset-size3.size10,.katex .sizing.reset-size3.size10{font-size:2.9628571429em}.katex .fontsize-ensurer.reset-size3.size11,.katex .sizing.reset-size3.size11{font-size:3.5542857143em}.katex .fontsize-ensurer.reset-size4.size1,.katex .sizing.reset-size4.size1{font-size:.625em}.katex .fontsize-ensurer.reset-size4.size2,.katex .sizing.reset-size4.size2{font-size:.75em}.katex .fontsize-ensurer.reset-size4.size3,.katex .sizing.reset-size4.size3{font-size:.875em}.katex .fontsize-ensurer.reset-size4.size4,.katex .sizing.reset-size4.size4{font-size:1em}.katex .fontsize-ensurer.reset-size4.size5,.katex .sizing.reset-size4.size5{font-size:1.125em}.katex .fontsize-ensurer.reset-size4.size6,.katex .sizing.reset-size4.size6{font-size:1.25em}.katex .fontsize-ensurer.reset-size4.size7,.katex .sizing.reset-size4.size7{font-size:1.5em}.katex .fontsize-ensurer.reset-size4.size8,.katex .sizing.reset-size4.size8{font-size:1.8em}.katex .fontsize-ensurer.reset-size4.size9,.katex .sizing.reset-size4.size9{font-size:2.16em}.katex .fontsize-ensurer.reset-size4.size10,.katex .sizing.reset-size4.size10{font-size:2.5925em}.katex .fontsize-ensurer.reset-size4.size11,.katex .sizing.reset-size4.size11{font-size:3.11em}.katex .fontsize-ensurer.reset-size5.size1,.katex .sizing.reset-size5.size1{font-size:.5555555556em}.katex .fontsize-ensurer.reset-size5.size2,.katex .sizing.reset-size5.size2{font-size:.6666666667em}.katex .fontsize-ensurer.reset-size5.size3,.katex .sizing.reset-size5.size3{font-size:.7777777778em}.katex .fontsize-ensurer.reset-size5.size4,.katex .sizing.reset-size5.size4{font-size:.8888888889em}.katex .fontsize-ensurer.reset-size5.size5,.katex .sizing.reset-size5.size5{font-size:1em}.katex .fontsize-ensurer.reset-size5.size6,.katex .sizing.reset-size5.size6{font-size:1.1111111111em}.katex .fontsize-ensurer.reset-size5.size7,.katex .sizing.reset-size5.size7{font-size:1.3333333333em}.katex .fontsize-ensurer.reset-size5.size8,.katex .sizing.reset-size5.size8{font-size:1.6em}.katex .fontsize-ensurer.reset-size5.size9,.katex .sizing.reset-size5.size9{font-size:1.92em}.katex .fontsize-ensurer.reset-size5.size10,.katex .sizing.reset-size5.size10{font-size:2.3044444444em}.katex .fontsize-ensurer.reset-size5.size11,.katex .sizing.reset-size5.size11{font-size:2.7644444444em}.katex .fontsize-ensurer.reset-size6.size1,.katex .sizing.reset-size6.size1{font-size:.5em}.katex .fontsize-ensurer.reset-size6.size2,.katex .sizing.reset-size6.size2{font-size:.6em}.katex .fontsize-ensurer.reset-size6.size3,.katex .sizing.reset-size6.size3{font-size:.7em}.katex .fontsize-ensurer.reset-size6.size4,.katex .sizing.reset-size6.size4{font-size:.8em}.katex .fontsize-ensurer.reset-size6.size5,.katex .sizing.reset-size6.size5{font-size:.9em}.katex .fontsize-ensurer.reset-size6.size6,.katex .sizing.reset-size6.size6{font-size:1em}.katex .fontsize-ensurer.reset-size6.size7,.katex .sizing.reset-size6.size7{font-size:1.2em}.katex .fontsize-ensurer.reset-size6.size8,.katex .sizing.reset-size6.size8{font-size:1.44em}.katex .fontsize-ensurer.reset-size6.size9,.katex .sizing.reset-size6.size9{font-size:1.728em}.katex .fontsize-ensurer.reset-size6.size10,.katex .sizing.reset-size6.size10{font-size:2.074em}.katex .fontsize-ensurer.reset-size6.size11,.katex .sizing.reset-size6.size11{font-size:2.488em}.katex .fontsize-ensurer.reset-size7.size1,.katex .sizing.reset-size7.size1{font-size:.4166666667em}.katex .fontsize-ensurer.reset-size7.size2,.katex .sizing.reset-size7.size2{font-size:.5em}.katex .fontsize-ensurer.reset-size7.size3,.katex .sizing.reset-size7.size3{font-size:.5833333333em}.katex .fontsize-ensurer.reset-size7.size4,.katex .sizing.reset-size7.size4{font-size:.6666666667em}.katex .fontsize-ensurer.reset-size7.size5,.katex .sizing.reset-size7.size5{font-size:.75em}.katex .fontsize-ensurer.reset-size7.size6,.katex .sizing.reset-size7.size6{font-size:.8333333333em}.katex .fontsize-ensurer.reset-size7.size7,.katex .sizing.reset-size7.size7{font-size:1em}.katex .fontsize-ensurer.reset-size7.size8,.katex .sizing.reset-size7.size8{font-size:1.2em}.katex .fontsize-ensurer.reset-size7.size9,.katex .sizing.reset-size7.size9{font-size:1.44em}.katex .fontsize-ensurer.reset-size7.size10,.katex .sizing.reset-size7.size10{font-size:1.7283333333em}.katex .fontsize-ensurer.reset-size7.size11,.katex .sizing.reset-size7.size11{font-size:2.0733333333em}.katex .fontsize-ensurer.reset-size8.size1,.katex .sizing.reset-size8.size1{font-size:.3472222222em}.katex .fontsize-ensurer.reset-size8.size2,.katex .sizing.reset-size8.size2{font-size:.4166666667em}.katex .fontsize-ensurer.reset-size8.size3,.katex .sizing.reset-size8.size3{font-size:.4861111111em}.katex .fontsize-ensurer.reset-size8.size4,.katex .sizing.reset-size8.size4{font-size:.5555555556em}.katex .fontsize-ensurer.reset-size8.size5,.katex .sizing.reset-size8.size5{font-size:.625em}.katex .fontsize-ensurer.reset-size8.size6,.katex .sizing.reset-size8.size6{font-size:.6944444444em}.katex .fontsize-ensurer.reset-size8.size7,.katex .sizing.reset-size8.size7{font-size:.8333333333em}.katex .fontsize-ensurer.reset-size8.size8,.katex .sizing.reset-size8.size8{font-size:1em}.katex .fontsize-ensurer.reset-size8.size9,.katex .sizing.reset-size8.size9{font-size:1.2em}.katex .fontsize-ensurer.reset-size8.size10,.katex .sizing.reset-size8.size10{font-size:1.4402777778em}.katex .fontsize-ensurer.reset-size8.size11,.katex .sizing.reset-size8.size11{font-size:1.7277777778em}.katex .fontsize-ensurer.reset-size9.size1,.katex .sizing.reset-size9.size1{font-size:.2893518519em}.katex .fontsize-ensurer.reset-size9.size2,.katex .sizing.reset-size9.size2{font-size:.3472222222em}.katex .fontsize-ensurer.reset-size9.size3,.katex .sizing.reset-size9.size3{font-size:.4050925926em}.katex .fontsize-ensurer.reset-size9.size4,.katex .sizing.reset-size9.size4{font-size:.462962963em}.katex .fontsize-ensurer.reset-size9.size5,.katex .sizing.reset-size9.size5{font-size:.5208333333em}.katex .fontsize-ensurer.reset-size9.size6,.katex .sizing.reset-size9.size6{font-size:.5787037037em}.katex .fontsize-ensurer.reset-size9.size7,.katex .sizing.reset-size9.size7{font-size:.6944444444em}.katex .fontsize-ensurer.reset-size9.size8,.katex .sizing.reset-size9.size8{font-size:.8333333333em}.katex .fontsize-ensurer.reset-size9.size9,.katex .sizing.reset-size9.size9{font-size:1em}.katex .fontsize-ensurer.reset-size9.size10,.katex .sizing.reset-size9.size10{font-size:1.2002314815em}.katex .fontsize-ensurer.reset-size9.size11,.katex .sizing.reset-size9.size11{font-size:1.4398148148em}.katex .fontsize-ensurer.reset-size10.size1,.katex .sizing.reset-size10.size1{font-size:.2410800386em}.katex .fontsize-ensurer.reset-size10.size2,.katex .sizing.reset-size10.size2{font-size:.2892960463em}.katex .fontsize-ensurer.reset-size10.size3,.katex .sizing.reset-size10.size3{font-size:.337512054em}.katex .fontsize-ensurer.reset-size10.size4,.katex .sizing.reset-size10.size4{font-size:.3857280617em}.katex .fontsize-ensurer.reset-size10.size5,.katex .sizing.reset-size10.size5{font-size:.4339440694em}.katex .fontsize-ensurer.reset-size10.size6,.katex .sizing.reset-size10.size6{font-size:.4821600771em}.katex .fontsize-ensurer.reset-size10.size7,.katex .sizing.reset-size10.size7{font-size:.5785920926em}.katex .fontsize-ensurer.reset-size10.size8,.katex .sizing.reset-size10.size8{font-size:.6943105111em}.katex .fontsize-ensurer.reset-size10.size9,.katex .sizing.reset-size10.size9{font-size:.8331726133em}.katex .fontsize-ensurer.reset-size10.size10,.katex .sizing.reset-size10.size10{font-size:1em}.katex .fontsize-ensurer.reset-size10.size11,.katex .sizing.reset-size10.size11{font-size:1.1996142719em}.katex .fontsize-ensurer.reset-size11.size1,.katex .sizing.reset-size11.size1{font-size:.2009646302em}.katex .fontsize-ensurer.reset-size11.size2,.katex .sizing.reset-size11.size2{font-size:.2411575563em}.katex .fontsize-ensurer.reset-size11.size3,.katex .sizing.reset-size11.size3{font-size:.2813504823em}.katex .fontsize-ensurer.reset-size11.size4,.katex .sizing.reset-size11.size4{font-size:.3215434084em}.katex .fontsize-ensurer.reset-size11.size5,.katex .sizing.reset-size11.size5{font-size:.3617363344em}.katex .fontsize-ensurer.reset-size11.size6,.katex .sizing.reset-size11.size6{font-size:.4019292605em}.katex .fontsize-ensurer.reset-size11.size7,.katex .sizing.reset-size11.size7{font-size:.4823151125em}.katex .fontsize-ensurer.reset-size11.size8,.katex .sizing.reset-size11.size8{font-size:.578778135em}.katex .fontsize-ensurer.reset-size11.size9,.katex .sizing.reset-size11.size9{font-size:.6945337621em}.katex .fontsize-ensurer.reset-size11.size10,.katex .sizing.reset-size11.size10{font-size:.8336012862em}.katex .fontsize-ensurer.reset-size11.size11,.katex .sizing.reset-size11.size11{font-size:1em}.katex .delimsizing.size1{font-family:KaTeX_Size1}.katex .delimsizing.size2{font-family:KaTeX_Size2}.katex .delimsizing.size3{font-family:KaTeX_Size3}.katex .delimsizing.size4{font-family:KaTeX_Size4}.katex .delimsizing.mult .delim-size1>span{font-family:KaTeX_Size1}.katex .delimsizing.mult .delim-size4>span{font-family:KaTeX_Size4}.katex .nulldelimiter{display:inline-block;width:.12em}.katex .delimcenter,.katex .op-symbol{position:relative}.katex .op-symbol.small-op{font-family:KaTeX_Size1}.katex .op-symbol.large-op{font-family:KaTeX_Size2}.katex .accent>.vlist-t,.katex .op-limits>.vlist-t{text-align:center}.katex .accent .accent-body{position:relative}.katex .accent .accent-body:not(.accent-full){width:0}.katex .overlay{display:block}.katex .mtable .vertical-separator{display:inline-block;min-width:1px}.katex .mtable .arraycolsep{display:inline-block}.katex .mtable .col-align-c>.vlist-t{text-align:center}.katex .mtable .col-align-l>.vlist-t{text-align:left}.katex .mtable .col-align-r>.vlist-t{text-align:right}.katex .svg-align{text-align:left}.katex svg{fill:currentColor;stroke:currentColor;fill-rule:nonzero;fill-opacity:1;stroke-width:1;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0;stroke-opacity:1;display:block;height:inherit;position:absolute;width:100%}.katex svg path{stroke:none}.katex img{border-style:none;max-height:none;max-width:none;min-height:0;min-width:0}.katex .stretchy{display:block;overflow:hidden;position:relative;width:100%}.katex .stretchy:after,.katex .stretchy:before{content:\\\"\\\"}.katex .hide-tail{overflow:hidden;position:relative;width:100%}.katex .halfarrow-left{left:0;overflow:hidden;position:absolute;width:50.2%}.katex .halfarrow-right{overflow:hidden;position:absolute;right:0;width:50.2%}.katex .brace-left{left:0;overflow:hidden;position:absolute;width:25.1%}.katex .brace-center{left:25%;overflow:hidden;position:absolute;width:50%}.katex .brace-right{overflow:hidden;position:absolute;right:0;width:25.1%}.katex .x-arrow-pad{padding:0 .5em}.katex .cd-arrow-pad{padding:0 .55556em 0 .27778em}.katex .mover,.katex .munder,.katex .x-arrow{text-align:center}.katex .boxpad{padding:0 .3em}.katex .fbox,.katex .fcolorbox{border:.04em solid;box-sizing:border-box}.katex .cancel-pad{padding:0 .2em}.katex .cancel-lap{margin-left:-.2em;margin-right:-.2em}.katex .sout{border-bottom-style:solid;border-bottom-width:.08em}.katex .angl{border-right:.049em solid;border-top:.049em solid;box-sizing:border-box;margin-right:.03889em}.katex .anglpad{padding:0 .03889em}.katex .eqn-num:before{content:\\\"(\\\" counter(katexEqnNo) \\\")\\\";counter-increment:katexEqnNo}.katex .mml-eqn-num:before{content:\\\"(\\\" counter(mmlEqnNo) \\\")\\\";counter-increment:mmlEqnNo}.katex .mtr-glue{width:50%}.katex .cd-vert-arrow{display:inline-block;position:relative}.katex .cd-label-left{display:inline-block;position:absolute;right:calc(50% + .3em);text-align:left}.katex .cd-label-right{display:inline-block;left:calc(50% + .3em);position:absolute;text-align:right}.katex-display{display:block;margin:1em 0;text-align:center}.katex-display>.katex{display:block;text-align:center;white-space:nowrap}.katex-display>.katex>.katex-html{display:block;position:relative}.katex-display>.katex>.katex-html>.tag{position:absolute;right:0}.katex-display.leqno>.katex>.katex-html>.tag{left:0;right:auto}.katex-display.fleqn>.katex{padding-left:2em;text-align:left}body{counter-reset:katexEqnNo mmlEqnNo}\\n\"\n__vite__updateStyle(__vite__id, __vite__css)\nimport.meta.hot.accept()\nimport.meta.hot.prune(() => __vite__removeStyle(__vite__id))"
          },
          "redirectURL": "",
          "headersSize": 179,
          "bodySize": 0,
          "_transferSize": 179,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.741Z",
        "time": 4.561000001558568,
        "timings": {
          "blocked": 2.1530000022400637,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.17499999999999982,
          "wait": 1.8039999996058178,
          "receive": 0.428999999712687,
          "_blocked_queueing": 1.0490000022400636,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed",
          "lineNumber": 2
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-FV2J4HIN.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "489001"
            },
            {
              "name": "Etag",
              "value": "W/\"77629-gteTO0+JI1R1MnoQ2wrybnaQ8no\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 489001,
            "mimeType": "text/javascript",
            "text": "Ly8gbm9kZV9tb2R1bGVzL2thdGV4L2Rpc3Qva2F0ZXgubWpzCnZhciBTb3VyY2VMb2NhdGlvbiA9IGNsYXNzIF9Tb3VyY2VMb2NhdGlvbiB7CiAgLy8gVGhlICsgcHJlZml4IGluZGljYXRlcyB0aGF0IHRoZXNlIGZpZWxkcyBhcmVuJ3Qgd3JpdGVhYmxlCiAgLy8gTGV4ZXIgaG9sZGluZyB0aGUgaW5wdXQgc3RyaW5nLgogIC8vIFN0YXJ0IG9mZnNldCwgemVyby1iYXNlZCBpbmNsdXNpdmUuCiAgLy8gRW5kIG9mZnNldCwgemVyby1iYXNlZCBleGNsdXNpdmUuCiAgY29uc3RydWN0b3IobGV4ZXIsIHN0YXJ0LCBlbmQpIHsKICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7CiAgICB0aGlzLnN0YXJ0ID0gdm9pZCAwOwogICAgdGhpcy5lbmQgPSB2b2lkIDA7CiAgICB0aGlzLmxleGVyID0gbGV4ZXI7CiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7CiAgICB0aGlzLmVuZCA9IGVuZDsKICB9CiAgLyoqCiAgICogTWVyZ2VzIHR3byBgU291cmNlTG9jYXRpb25gcyBmcm9tIGxvY2F0aW9uIHByb3ZpZGVycywgZ2l2ZW4gdGhleSBhcmUKICAgKiBwcm92aWRlZCBpbiBvcmRlciBvZiBhcHBlYXJhbmNlLgogICAqIC0gUmV0dXJucyB0aGUgZmlyc3Qgb25lJ3MgbG9jYXRpb24gaWYgb25seSB0aGUgZmlyc3QgaXMgcHJvdmlkZWQuCiAgICogLSBSZXR1cm5zIGEgbWVyZ2VkIHJhbmdlIG9mIHRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgaWYgYm90aCBhcmUgcHJvdmlkZWQKICAgKiAgIGFuZCB0aGVpciBsZXhlcnMgbWF0Y2guCiAgICogLSBPdGhlcndpc2UsIHJldHVybnMgbnVsbC4KICAgKi8KICBzdGF0aWMgcmFuZ2UoZmlyc3QsIHNlY29uZCkgewogICAgaWYgKCFzZWNvbmQpIHsKICAgICAgcmV0dXJuIGZpcnN0ICYmIGZpcnN0LmxvYzsKICAgIH0gZWxzZSBpZiAoIWZpcnN0IHx8ICFmaXJzdC5sb2MgfHwgIXNlY29uZC5sb2MgfHwgZmlyc3QubG9jLmxleGVyICE9PSBzZWNvbmQubG9jLmxleGVyKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIG5ldyBfU291cmNlTG9jYXRpb24oZmlyc3QubG9jLmxleGVyLCBmaXJzdC5sb2Muc3RhcnQsIHNlY29uZC5sb2MuZW5kKTsKICAgIH0KICB9Cn07CnZhciBUb2tlbiA9IGNsYXNzIF9Ub2tlbiB7CiAgLy8gZG9uJ3QgZXhwYW5kIHRoZSB0b2tlbgogIC8vIHVzZWQgaW4gXG5vZXhwYW5kCiAgY29uc3RydWN0b3IodGV4dDIsIGxvYykgewogICAgdGhpcy50ZXh0ID0gdm9pZCAwOwogICAgdGhpcy5sb2MgPSB2b2lkIDA7CiAgICB0aGlzLm5vZXhwYW5kID0gdm9pZCAwOwogICAgdGhpcy50cmVhdEFzUmVsYXggPSB2b2lkIDA7CiAgICB0aGlzLnRleHQgPSB0ZXh0MjsKICAgIHRoaXMubG9jID0gbG9jOwogIH0KICAvKioKICAgKiBHaXZlbiBhIHBhaXIgb2YgdG9rZW5zICh0aGlzIGFuZCBlbmRUb2tlbiksIGNvbXB1dGUgYSBgVG9rZW5gIGVuY29tcGFzc2luZwogICAqIHRoZSB3aG9sZSBpbnB1dCByYW5nZSBlbmNsb3NlZCBieSB0aGVzZSB0d28uCiAgICovCiAgcmFuZ2UoZW5kVG9rZW4sIHRleHQyKSB7CiAgICByZXR1cm4gbmV3IF9Ub2tlbih0ZXh0MiwgU291cmNlTG9jYXRpb24ucmFuZ2UodGhpcywgZW5kVG9rZW4pKTsKICB9Cn07CnZhciBQYXJzZUVycm9yID0gY2xhc3MgX1BhcnNlRXJyb3IgewogIC8vIEVycm9yIHN0YXJ0IHBvc2l0aW9uIGJhc2VkIG9uIHBhc3NlZC1pbiBUb2tlbiBvciBQYXJzZU5vZGUuCiAgLy8gTGVuZ3RoIG9mIGFmZmVjdGVkIHRleHQgYmFzZWQgb24gcGFzc2VkLWluIFRva2VuIG9yIFBhcnNlTm9kZS4KICAvLyBUaGUgdW5kZXJseWluZyBlcnJvciBtZXNzYWdlIHdpdGhvdXQgYW55IGNvbnRleHQgYWRkZWQuCiAgY29uc3RydWN0b3IobWVzc2FnZSwgdG9rZW4pIHsKICAgIHRoaXMubmFtZSA9IHZvaWQgMDsKICAgIHRoaXMucG9zaXRpb24gPSB2b2lkIDA7CiAgICB0aGlzLmxlbmd0aCA9IHZvaWQgMDsKICAgIHRoaXMucmF3TWVzc2FnZSA9IHZvaWQgMDsKICAgIHZhciBlcnJvciA9ICJLYVRlWCBwYXJzZSBlcnJvcjogIiArIG1lc3NhZ2U7CiAgICB2YXIgc3RhcnQ7CiAgICB2YXIgZW5kOwogICAgdmFyIGxvYyA9IHRva2VuICYmIHRva2VuLmxvYzsKICAgIGlmIChsb2MgJiYgbG9jLnN0YXJ0IDw9IGxvYy5lbmQpIHsKICAgICAgdmFyIGlucHV0ID0gbG9jLmxleGVyLmlucHV0OwogICAgICBzdGFydCA9IGxvYy5zdGFydDsKICAgICAgZW5kID0gbG9jLmVuZDsKICAgICAgaWYgKHN0YXJ0ID09PSBpbnB1dC5sZW5ndGgpIHsKICAgICAgICBlcnJvciArPSAiIGF0IGVuZCBvZiBpbnB1dDogIjsKICAgICAgfSBlbHNlIHsKICAgICAgICBlcnJvciArPSAiIGF0IHBvc2l0aW9uICIgKyAoc3RhcnQgKyAxKSArICI6ICI7CiAgICAgIH0KICAgICAgdmFyIHVuZGVybGluZWQgPSBpbnB1dC5zbGljZShzdGFydCwgZW5kKS5yZXBsYWNlKC9bXl0vZywgIiQmzLIiKTsKICAgICAgdmFyIGxlZnQ7CiAgICAgIGlmIChzdGFydCA+IDE1KSB7CiAgICAgICAgbGVmdCA9ICLigKYiICsgaW5wdXQuc2xpY2Uoc3RhcnQgLSAxNSwgc3RhcnQpOwogICAgICB9IGVsc2UgewogICAgICAgIGxlZnQgPSBpbnB1dC5zbGljZSgwLCBzdGFydCk7CiAgICAgIH0KICAgICAgdmFyIHJpZ2h0OwogICAgICBpZiAoZW5kICsgMTUgPCBpbnB1dC5sZW5ndGgpIHsKICAgICAgICByaWdodCA9IGlucHV0LnNsaWNlKGVuZCwgZW5kICsgMTUpICsgIuKApiI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmlnaHQgPSBpbnB1dC5zbGljZShlbmQpOwogICAgICB9CiAgICAgIGVycm9yICs9IGxlZnQgKyB1bmRlcmxpbmVkICsgcmlnaHQ7CiAgICB9CiAgICB2YXIgc2VsZiA9IG5ldyBFcnJvcihlcnJvcik7CiAgICBzZWxmLm5hbWUgPSAiUGFyc2VFcnJvciI7CiAgICBzZWxmLl9fcHJvdG9fXyA9IF9QYXJzZUVycm9yLnByb3RvdHlwZTsKICAgIHNlbGYucG9zaXRpb24gPSBzdGFydDsKICAgIGlmIChzdGFydCAhPSBudWxsICYmIGVuZCAhPSBudWxsKSB7CiAgICAgIHNlbGYubGVuZ3RoID0gZW5kIC0gc3RhcnQ7CiAgICB9CiAgICBzZWxmLnJhd01lc3NhZ2UgPSBtZXNzYWdlOwogICAgcmV0dXJuIHNlbGY7CiAgfQp9OwpQYXJzZUVycm9yLnByb3RvdHlwZS5fX3Byb3RvX18gPSBFcnJvci5wcm90b3R5cGU7CnZhciBjb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zMihsaXN0LCBlbGVtKSB7CiAgcmV0dXJuIGxpc3QuaW5kZXhPZihlbGVtKSAhPT0gLTE7Cn07CnZhciBkZWZsdCA9IGZ1bmN0aW9uIGRlZmx0MihzZXR0aW5nLCBkZWZhdWx0SWZVbmRlZmluZWQpIHsKICByZXR1cm4gc2V0dGluZyA9PT0gdm9pZCAwID8gZGVmYXVsdElmVW5kZWZpbmVkIDogc2V0dGluZzsKfTsKdmFyIHVwcGVyY2FzZSA9IC8oW0EtWl0pL2c7CnZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiBoeXBoZW5hdGUyKHN0cikgewogIHJldHVybiBzdHIucmVwbGFjZSh1cHBlcmNhc2UsICItJDEiKS50b0xvd2VyQ2FzZSgpOwp9Owp2YXIgRVNDQVBFX0xPT0tVUCA9IHsKICAiJiI6ICImYW1wOyIsCiAgIj4iOiAiJmd0OyIsCiAgIjwiOiAiJmx0OyIsCiAgJyInOiAiJnF1b3Q7IiwKICAiJyI6ICImI3gyNzsiCn07CnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PCInXS9nOwpmdW5jdGlvbiBlc2NhcGUodGV4dDIpIHsKICByZXR1cm4gU3RyaW5nKHRleHQyKS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG1hdGNoKSA9PiBFU0NBUEVfTE9PS1VQW21hdGNoXSk7Cn0KdmFyIGdldEJhc2VFbGVtID0gZnVuY3Rpb24gZ2V0QmFzZUVsZW0yKGdyb3VwKSB7CiAgaWYgKGdyb3VwLnR5cGUgPT09ICJvcmRncm91cCIpIHsKICAgIGlmIChncm91cC5ib2R5Lmxlbmd0aCA9PT0gMSkgewogICAgICByZXR1cm4gZ2V0QmFzZUVsZW0yKGdyb3VwLmJvZHlbMF0pOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGdyb3VwOwogICAgfQogIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gImNvbG9yIikgewogICAgaWYgKGdyb3VwLmJvZHkubGVuZ3RoID09PSAxKSB7CiAgICAgIHJldHVybiBnZXRCYXNlRWxlbTIoZ3JvdXAuYm9keVswXSk7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gZ3JvdXA7CiAgICB9CiAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSAiZm9udCIpIHsKICAgIHJldHVybiBnZXRCYXNlRWxlbTIoZ3JvdXAuYm9keSk7CiAgfSBlbHNlIHsKICAgIHJldHVybiBncm91cDsKICB9Cn07CnZhciBpc0NoYXJhY3RlckJveCA9IGZ1bmN0aW9uIGlzQ2hhcmFjdGVyQm94Mihncm91cCkgewogIHZhciBiYXNlRWxlbSA9IGdldEJhc2VFbGVtKGdyb3VwKTsKICByZXR1cm4gYmFzZUVsZW0udHlwZSA9PT0gIm1hdGhvcmQiIHx8IGJhc2VFbGVtLnR5cGUgPT09ICJ0ZXh0b3JkIiB8fCBiYXNlRWxlbS50eXBlID09PSAiYXRvbSI7Cn07CnZhciBhc3NlcnQgPSBmdW5jdGlvbiBhc3NlcnQyKHZhbHVlKSB7CiAgaWYgKCF2YWx1ZSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCBub24tbnVsbCwgYnV0IGdvdCAiICsgU3RyaW5nKHZhbHVlKSk7CiAgfQogIHJldHVybiB2YWx1ZTsKfTsKdmFyIHByb3RvY29sRnJvbVVybCA9IGZ1bmN0aW9uIHByb3RvY29sRnJvbVVybDIodXJsKSB7CiAgdmFyIHByb3RvY29sID0gL15bXHgwMC1ceDIwXSooW15cXC8jP10qPykoOnwmIzAqNTh8JiN4MCozYXwmY29sb24pL2kuZXhlYyh1cmwpOwogIGlmICghcHJvdG9jb2wpIHsKICAgIHJldHVybiAiX3JlbGF0aXZlIjsKICB9CiAgaWYgKHByb3RvY29sWzJdICE9PSAiOiIpIHsKICAgIHJldHVybiBudWxsOwogIH0KICBpZiAoIS9eW2EtekEtWl1bYS16QS1aMC05K1wtLl0qJC8udGVzdChwcm90b2NvbFsxXSkpIHsKICAgIHJldHVybiBudWxsOwogIH0KICByZXR1cm4gcHJvdG9jb2xbMV0udG9Mb3dlckNhc2UoKTsKfTsKdmFyIHV0aWxzID0gewogIGNvbnRhaW5zLAogIGRlZmx0LAogIGVzY2FwZSwKICBoeXBoZW5hdGUsCiAgZ2V0QmFzZUVsZW0sCiAgaXNDaGFyYWN0ZXJCb3gsCiAgcHJvdG9jb2xGcm9tVXJsCn07CnZhciBTRVRUSU5HU19TQ0hFTUEgPSB7CiAgZGlzcGxheU1vZGU6IHsKICAgIHR5cGU6ICJib29sZWFuIiwKICAgIGRlc2NyaXB0aW9uOiAiUmVuZGVyIG1hdGggaW4gZGlzcGxheSBtb2RlLCB3aGljaCBwdXRzIHRoZSBtYXRoIGluIGRpc3BsYXkgc3R5bGUgKHNvIFxcaW50IGFuZCBcXHN1bSBhcmUgbGFyZ2UsIGZvciBleGFtcGxlKSwgYW5kIGNlbnRlcnMgdGhlIG1hdGggb24gdGhlIHBhZ2Ugb24gaXRzIG93biBsaW5lLiIsCiAgICBjbGk6ICItZCwgLS1kaXNwbGF5LW1vZGUiCiAgfSwKICBvdXRwdXQ6IHsKICAgIHR5cGU6IHsKICAgICAgZW51bTogWyJodG1sQW5kTWF0aG1sIiwgImh0bWwiLCAibWF0aG1sIl0KICAgIH0sCiAgICBkZXNjcmlwdGlvbjogIkRldGVybWluZXMgdGhlIG1hcmt1cCBsYW5ndWFnZSBvZiB0aGUgb3V0cHV0LiIsCiAgICBjbGk6ICItRiwgLS1mb3JtYXQgPHR5cGU+IgogIH0sCiAgbGVxbm86IHsKICAgIHR5cGU6ICJib29sZWFuIiwKICAgIGRlc2NyaXB0aW9uOiAiUmVuZGVyIGRpc3BsYXkgbWF0aCBpbiBsZXFubyBzdHlsZSAobGVmdC1qdXN0aWZpZWQgdGFncykuIgogIH0sCiAgZmxlcW46IHsKICAgIHR5cGU6ICJib29sZWFuIiwKICAgIGRlc2NyaXB0aW9uOiAiUmVuZGVyIGRpc3BsYXkgbWF0aCBmbHVzaCBsZWZ0LiIKICB9LAogIHRocm93T25FcnJvcjogewogICAgdHlwZTogImJvb2xlYW4iLAogICAgZGVmYXVsdDogdHJ1ZSwKICAgIGNsaTogIi10LCAtLW5vLXRocm93LW9uLWVycm9yIiwKICAgIGNsaURlc2NyaXB0aW9uOiAiUmVuZGVyIGVycm9ycyAoaW4gdGhlIGNvbG9yIGdpdmVuIGJ5IC0tZXJyb3ItY29sb3IpIGluc3RlYWQgb2YgdGhyb3dpbmcgYSBQYXJzZUVycm9yIGV4Y2VwdGlvbiB3aGVuIGVuY291bnRlcmluZyBhbiBlcnJvci4iCiAgfSwKICBlcnJvckNvbG9yOiB7CiAgICB0eXBlOiAic3RyaW5nIiwKICAgIGRlZmF1bHQ6ICIjY2MwMDAwIiwKICAgIGNsaTogIi1jLCAtLWVycm9yLWNvbG9yIDxjb2xvcj4iLAogICAgY2xpRGVzY3JpcHRpb246ICJBIGNvbG9yIHN0cmluZyBnaXZlbiBpbiB0aGUgZm9ybWF0ICdyZ2InIG9yICdycmdnYmInIChubyAjKS4gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyB0aGUgY29sb3Igb2YgZXJyb3JzIHJlbmRlcmVkIGJ5IHRoZSAtdCBvcHRpb24uIiwKICAgIGNsaVByb2Nlc3NvcjogKGNvbG9yKSA9PiAiIyIgKyBjb2xvcgogIH0sCiAgbWFjcm9zOiB7CiAgICB0eXBlOiAib2JqZWN0IiwKICAgIGNsaTogIi1tLCAtLW1hY3JvIDxkZWY+IiwKICAgIGNsaURlc2NyaXB0aW9uOiAiRGVmaW5lIGN1c3RvbSBtYWNybyBvZiB0aGUgZm9ybSAnXFxmb286ZXhwYW5zaW9uJyAodXNlIG11bHRpcGxlIC1tIGFyZ3VtZW50cyBmb3IgbXVsdGlwbGUgbWFjcm9zKS4iLAogICAgY2xpRGVmYXVsdDogW10sCiAgICBjbGlQcm9jZXNzb3I6IChkZWYsIGRlZnMpID0+IHsKICAgICAgZGVmcy5wdXNoKGRlZik7CiAgICAgIHJldHVybiBkZWZzOwogICAgfQogIH0sCiAgbWluUnVsZVRoaWNrbmVzczogewogICAgdHlwZTogIm51bWJlciIsCiAgICBkZXNjcmlwdGlvbjogIlNwZWNpZmllcyBhIG1pbmltdW0gdGhpY2tuZXNzLCBpbiBlbXMsIGZvciBmcmFjdGlvbiBsaW5lcywgYFxcc3FydGAgdG9wIGxpbmVzLCBge2FycmF5fWAgdmVydGljYWwgbGluZXMsIGBcXGhsaW5lYCwgYFxcaGRhc2hsaW5lYCwgYFxcdW5kZXJsaW5lYCwgYFxcb3ZlcmxpbmVgLCBhbmQgdGhlIGJvcmRlcnMgb2YgYFxcZmJveGAsIGBcXGJveGVkYCwgYW5kIGBcXGZjb2xvcmJveGAuIiwKICAgIHByb2Nlc3NvcjogKHQpID0+IE1hdGgubWF4KDAsIHQpLAogICAgY2xpOiAiLS1taW4tcnVsZS10aGlja25lc3MgPHNpemU+IiwKICAgIGNsaVByb2Nlc3NvcjogcGFyc2VGbG9hdAogIH0sCiAgY29sb3JJc1RleHRDb2xvcjogewogICAgdHlwZTogImJvb2xlYW4iLAogICAgZGVzY3JpcHRpb246ICJNYWtlcyBcXGNvbG9yIGJlaGF2ZSBsaWtlIExhVGVYJ3MgMi1hcmd1bWVudCBcXHRleHRjb2xvciwgaW5zdGVhZCBvZiBMYVRlWCdzIG9uZS1hcmd1bWVudCBcXGNvbG9yIG1vZGUgY2hhbmdlLiIsCiAgICBjbGk6ICItYiwgLS1jb2xvci1pcy10ZXh0LWNvbG9yIgogIH0sCiAgc3RyaWN0OiB7CiAgICB0eXBlOiBbewogICAgICBlbnVtOiBbIndhcm4iLCAiaWdub3JlIiwgImVycm9yIl0KICAgIH0sICJib29sZWFuIiwgImZ1bmN0aW9uIl0sCiAgICBkZXNjcmlwdGlvbjogIlR1cm4gb24gc3RyaWN0IC8gTGFUZVggZmFpdGhmdWxuZXNzIG1vZGUsIHdoaWNoIHRocm93cyBhbiBlcnJvciBpZiB0aGUgaW5wdXQgdXNlcyBmZWF0dXJlcyB0aGF0IGFyZSBub3Qgc3VwcG9ydGVkIGJ5IExhVGVYLiIsCiAgICBjbGk6ICItUywgLS1zdHJpY3QiLAogICAgY2xpRGVmYXVsdDogZmFsc2UKICB9LAogIHRydXN0OiB7CiAgICB0eXBlOiBbImJvb2xlYW4iLCAiZnVuY3Rpb24iXSwKICAgIGRlc2NyaXB0aW9uOiAiVHJ1c3QgdGhlIGlucHV0LCBlbmFibGluZyBhbGwgSFRNTCBmZWF0dXJlcyBzdWNoIGFzIFxcdXJsLiIsCiAgICBjbGk6ICItVCwgLS10cnVzdCIKICB9LAogIG1heFNpemU6IHsKICAgIHR5cGU6ICJudW1iZXIiLAogICAgZGVmYXVsdDogSW5maW5pdHksCiAgICBkZXNjcmlwdGlvbjogIklmIG5vbi16ZXJvLCBhbGwgdXNlci1zcGVjaWZpZWQgc2l6ZXMsIGUuZy4gaW4gXFxydWxlezUwMGVtfXs1MDBlbX0sIHdpbGwgYmUgY2FwcGVkIHRvIG1heFNpemUgZW1zLiBPdGhlcndpc2UsIGVsZW1lbnRzIGFuZCBzcGFjZXMgY2FuIGJlIGFyYml0cmFyaWx5IGxhcmdlIiwKICAgIHByb2Nlc3NvcjogKHMpID0+IE1hdGgubWF4KDAsIHMpLAogICAgY2xpOiAiLXMsIC0tbWF4LXNpemUgPG4+IiwKICAgIGNsaVByb2Nlc3NvcjogcGFyc2VJbnQKICB9LAogIG1heEV4cGFuZDogewogICAgdHlwZTogIm51bWJlciIsCiAgICBkZWZhdWx0OiAxZTMsCiAgICBkZXNjcmlwdGlvbjogIkxpbWl0IHRoZSBudW1iZXIgb2YgbWFjcm8gZXhwYW5zaW9ucyB0byB0aGUgc3BlY2lmaWVkIG51bWJlciwgdG8gcHJldmVudCBlLmcuIGluZmluaXRlIG1hY3JvIGxvb3BzLiBJZiBzZXQgdG8gSW5maW5pdHksIHRoZSBtYWNybyBleHBhbmRlciB3aWxsIHRyeSB0byBmdWxseSBleHBhbmQgYXMgaW4gTGFUZVguIiwKICAgIHByb2Nlc3NvcjogKG4pID0+IE1hdGgubWF4KDAsIG4pLAogICAgY2xpOiAiLWUsIC0tbWF4LWV4cGFuZCA8bj4iLAogICAgY2xpUHJvY2Vzc29yOiAobikgPT4gbiA9PT0gIkluZmluaXR5IiA/IEluZmluaXR5IDogcGFyc2VJbnQobikKICB9LAogIGdsb2JhbEdyb3VwOiB7CiAgICB0eXBlOiAiYm9vbGVhbiIsCiAgICBjbGk6IGZhbHNlCiAgfQp9OwpmdW5jdGlvbiBnZXREZWZhdWx0VmFsdWUoc2NoZW1hKSB7CiAgaWYgKHNjaGVtYS5kZWZhdWx0KSB7CiAgICByZXR1cm4gc2NoZW1hLmRlZmF1bHQ7CiAgfQogIHZhciB0eXBlID0gc2NoZW1hLnR5cGU7CiAgdmFyIGRlZmF1bHRUeXBlID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGVbMF0gOiB0eXBlOwogIGlmICh0eXBlb2YgZGVmYXVsdFR5cGUgIT09ICJzdHJpbmciKSB7CiAgICByZXR1cm4gZGVmYXVsdFR5cGUuZW51bVswXTsKICB9CiAgc3dpdGNoIChkZWZhdWx0VHlwZSkgewogICAgY2FzZSAiYm9vbGVhbiI6CiAgICAgIHJldHVybiBmYWxzZTsKICAgIGNhc2UgInN0cmluZyI6CiAgICAgIHJldHVybiAiIjsKICAgIGNhc2UgIm51bWJlciI6CiAgICAgIHJldHVybiAwOwogICAgY2FzZSAib2JqZWN0IjoKICAgICAgcmV0dXJuIHt9OwogIH0KfQp2YXIgU2V0dGluZ3MgPSBjbGFzcyB7CiAgY29uc3RydWN0b3Iob3B0aW9ucykgewogICAgdGhpcy5kaXNwbGF5TW9kZSA9IHZvaWQgMDsKICAgIHRoaXMub3V0cHV0ID0gdm9pZCAwOwogICAgdGhpcy5sZXFubyA9IHZvaWQgMDsKICAgIHRoaXMuZmxlcW4gPSB2b2lkIDA7CiAgICB0aGlzLnRocm93T25FcnJvciA9IHZvaWQgMDsKICAgIHRoaXMuZXJyb3JDb2xvciA9IHZvaWQgMDsKICAgIHRoaXMubWFjcm9zID0gdm9pZCAwOwogICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gdm9pZCAwOwogICAgdGhpcy5jb2xvcklzVGV4dENvbG9yID0gdm9pZCAwOwogICAgdGhpcy5zdHJpY3QgPSB2b2lkIDA7CiAgICB0aGlzLnRydXN0ID0gdm9pZCAwOwogICAgdGhpcy5tYXhTaXplID0gdm9pZCAwOwogICAgdGhpcy5tYXhFeHBhbmQgPSB2b2lkIDA7CiAgICB0aGlzLmdsb2JhbEdyb3VwID0gdm9pZCAwOwogICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICBmb3IgKHZhciBwcm9wIGluIFNFVFRJTkdTX1NDSEVNQSkgewogICAgICBpZiAoU0VUVElOR1NfU0NIRU1BLmhhc093blByb3BlcnR5KHByb3ApKSB7CiAgICAgICAgdmFyIHNjaGVtYSA9IFNFVFRJTkdTX1NDSEVNQVtwcm9wXTsKICAgICAgICB0aGlzW3Byb3BdID0gb3B0aW9uc1twcm9wXSAhPT0gdm9pZCAwID8gc2NoZW1hLnByb2Nlc3NvciA/IHNjaGVtYS5wcm9jZXNzb3Iob3B0aW9uc1twcm9wXSkgOiBvcHRpb25zW3Byb3BdIDogZ2V0RGVmYXVsdFZhbHVlKHNjaGVtYSk7CiAgICAgIH0KICAgIH0KICB9CiAgLyoqCiAgICogUmVwb3J0IG5vbnN0cmljdCAobm9uLUxhVGVYLWNvbXBhdGlibGUpIGlucHV0LgogICAqIENhbiBzYWZlbHkgbm90IGJlIGNhbGxlZCBpZiBgdGhpcy5zdHJpY3RgIGlzIGZhbHNlIGluIEphdmFTY3JpcHQuCiAgICovCiAgcmVwb3J0Tm9uc3RyaWN0KGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7CiAgICB2YXIgc3RyaWN0ID0gdGhpcy5zdHJpY3Q7CiAgICBpZiAodHlwZW9mIHN0cmljdCA9PT0gImZ1bmN0aW9uIikgewogICAgICBzdHJpY3QgPSBzdHJpY3QoZXJyb3JDb2RlLCBlcnJvck1zZywgdG9rZW4pOwogICAgfQogICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSAiaWdub3JlIikgewogICAgICByZXR1cm47CiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09ICJlcnJvciIpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkxhVGVYLWluY29tcGF0aWJsZSBpbnB1dCBhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvICdlcnJvcic6ICIgKyAoZXJyb3JNc2cgKyAiIFsiICsgZXJyb3JDb2RlICsgIl0iKSwgdG9rZW4pOwogICAgfSBlbHNlIGlmIChzdHJpY3QgPT09ICJ3YXJuIikgewogICAgICB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgY29uc29sZS53YXJuKCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAnd2Fybic6ICIgKyAoZXJyb3JNc2cgKyAiIFsiICsgZXJyb3JDb2RlICsgIl0iKSk7CiAgICB9IGVsc2UgewogICAgICB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgY29uc29sZS53YXJuKCJMYVRlWC1pbmNvbXBhdGlibGUgaW5wdXQgYW5kIHN0cmljdCBtb2RlIGlzIHNldCB0byAiICsgKCJ1bnJlY29nbml6ZWQgJyIgKyBzdHJpY3QgKyAiJzogIiArIGVycm9yTXNnICsgIiBbIiArIGVycm9yQ29kZSArICJdIikpOwogICAgfQogIH0KICAvKioKICAgKiBDaGVjayB3aGV0aGVyIHRvIGFwcGx5IHN0cmljdCAoTGFUZVgtYWRoZXJpbmcpIGJlaGF2aW9yIGZvciB1bnVzdWFsCiAgICogaW5wdXQgKGxpa2UgYFxcYCkuICBVbmxpa2UgYG5vbnN0cmljdGAsIHdpbGwgbm90IHRocm93IGFuIGVycm9yOwogICAqIGluc3RlYWQsICJlcnJvciIgdHJhbnNsYXRlcyB0byBhIHJldHVybiB2YWx1ZSBvZiBgdHJ1ZWAsIHdoaWxlICJpZ25vcmUiCiAgICogdHJhbnNsYXRlcyB0byBhIHJldHVybiB2YWx1ZSBvZiBgZmFsc2VgLiAgTWF5IHN0aWxsIHByaW50IGEgd2FybmluZzoKICAgKiAid2FybiIgcHJpbnRzIGEgd2FybmluZyBhbmQgcmV0dXJucyBgZmFsc2VgLgogICAqIFRoaXMgaXMgZm9yIHRoZSBzZWNvbmQgY2F0ZWdvcnkgb2YgYGVycm9yQ29kZWBzIGxpc3RlZCBpbiB0aGUgUkVBRE1FLgogICAqLwogIHVzZVN0cmljdEJlaGF2aW9yKGVycm9yQ29kZSwgZXJyb3JNc2csIHRva2VuKSB7CiAgICB2YXIgc3RyaWN0ID0gdGhpcy5zdHJpY3Q7CiAgICBpZiAodHlwZW9mIHN0cmljdCA9PT0gImZ1bmN0aW9uIikgewogICAgICB0cnkgewogICAgICAgIHN0cmljdCA9IHN0cmljdChlcnJvckNvZGUsIGVycm9yTXNnLCB0b2tlbik7CiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7CiAgICAgICAgc3RyaWN0ID0gImVycm9yIjsKICAgICAgfQogICAgfQogICAgaWYgKCFzdHJpY3QgfHwgc3RyaWN0ID09PSAiaWdub3JlIikgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gdHJ1ZSB8fCBzdHJpY3QgPT09ICJlcnJvciIpIHsKICAgICAgcmV0dXJuIHRydWU7CiAgICB9IGVsc2UgaWYgKHN0cmljdCA9PT0gIndhcm4iKSB7CiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAidW5kZWZpbmVkIiAmJiBjb25zb2xlLndhcm4oIkxhVGVYLWluY29tcGF0aWJsZSBpbnB1dCBhbmQgc3RyaWN0IG1vZGUgaXMgc2V0IHRvICd3YXJuJzogIiArIChlcnJvck1zZyArICIgWyIgKyBlcnJvckNvZGUgKyAiXSIpKTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfSBlbHNlIHsKICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICJ1bmRlZmluZWQiICYmIGNvbnNvbGUud2FybigiTGFUZVgtaW5jb21wYXRpYmxlIGlucHV0IGFuZCBzdHJpY3QgbW9kZSBpcyBzZXQgdG8gIiArICgidW5yZWNvZ25pemVkICciICsgc3RyaWN0ICsgIic6ICIgKyBlcnJvck1zZyArICIgWyIgKyBlcnJvckNvZGUgKyAiXSIpKTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0KICAvKioKICAgKiBDaGVjayB3aGV0aGVyIHRvIHRlc3QgcG90ZW50aWFsbHkgZGFuZ2Vyb3VzIGlucHV0LCBhbmQgcmV0dXJuCiAgICogYHRydWVgICh0cnVzdGVkKSBvciBgZmFsc2VgICh1bnRydXN0ZWQpLiAgVGhlIHNvbGUgYXJndW1lbnQgYGNvbnRleHRgCiAgICogc2hvdWxkIGJlIGFuIG9iamVjdCB3aXRoIGBjb21tYW5kYCBmaWVsZCBzcGVjaWZ5aW5nIHRoZSByZWxldmFudCBMYVRlWAogICAqIGNvbW1hbmQgKGFzIGEgc3RyaW5nIHN0YXJ0aW5nIHdpdGggYFxgKSwgYW5kIGFueSBvdGhlciBhcmd1bWVudHMsIGV0Yy4KICAgKiBJZiBgY29udGV4dGAgaGFzIGEgYHVybGAgZmllbGQsIGEgYHByb3RvY29sYCBmaWVsZCB3aWxsIGF1dG9tYXRpY2FsbHkKICAgKiBnZXQgYWRkZWQgYnkgdGhpcyBmdW5jdGlvbiAoY2hhbmdpbmcgdGhlIHNwZWNpZmllZCBvYmplY3QpLgogICAqLwogIGlzVHJ1c3RlZChjb250ZXh0KSB7CiAgICBpZiAoY29udGV4dC51cmwgJiYgIWNvbnRleHQucHJvdG9jb2wpIHsKICAgICAgdmFyIHByb3RvY29sID0gdXRpbHMucHJvdG9jb2xGcm9tVXJsKGNvbnRleHQudXJsKTsKICAgICAgaWYgKHByb3RvY29sID09IG51bGwpIHsKICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgIH0KICAgICAgY29udGV4dC5wcm90b2NvbCA9IHByb3RvY29sOwogICAgfQogICAgdmFyIHRydXN0ID0gdHlwZW9mIHRoaXMudHJ1c3QgPT09ICJmdW5jdGlvbiIgPyB0aGlzLnRydXN0KGNvbnRleHQpIDogdGhpcy50cnVzdDsKICAgIHJldHVybiBCb29sZWFuKHRydXN0KTsKICB9Cn07CnZhciBTdHlsZSA9IGNsYXNzIHsKICBjb25zdHJ1Y3RvcihpZCwgc2l6ZSwgY3JhbXBlZCkgewogICAgdGhpcy5pZCA9IHZvaWQgMDsKICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDsKICAgIHRoaXMuY3JhbXBlZCA9IHZvaWQgMDsKICAgIHRoaXMuaWQgPSBpZDsKICAgIHRoaXMuc2l6ZSA9IHNpemU7CiAgICB0aGlzLmNyYW1wZWQgPSBjcmFtcGVkOwogIH0KICAvKioKICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgc3VwZXJzY3JpcHQgZ2l2ZW4gYSBiYXNlIGluIHRoZSBjdXJyZW50IHN0eWxlLgogICAqLwogIHN1cCgpIHsKICAgIHJldHVybiBzdHlsZXNbc3VwW3RoaXMuaWRdXTsKICB9CiAgLyoqCiAgICogR2V0IHRoZSBzdHlsZSBvZiBhIHN1YnNjcmlwdCBnaXZlbiBhIGJhc2UgaW4gdGhlIGN1cnJlbnQgc3R5bGUuCiAgICovCiAgc3ViKCkgewogICAgcmV0dXJuIHN0eWxlc1tzdWJbdGhpcy5pZF1dOwogIH0KICAvKioKICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gbnVtZXJhdG9yIGdpdmVuIHRoZSBmcmFjdGlvbiBpbiB0aGUgY3VycmVudAogICAqIHN0eWxlLgogICAqLwogIGZyYWNOdW0oKSB7CiAgICByZXR1cm4gc3R5bGVzW2ZyYWNOdW1bdGhpcy5pZF1dOwogIH0KICAvKioKICAgKiBHZXQgdGhlIHN0eWxlIG9mIGEgZnJhY3Rpb24gZGVub21pbmF0b3IgZ2l2ZW4gdGhlIGZyYWN0aW9uIGluIHRoZSBjdXJyZW50CiAgICogc3R5bGUuCiAgICovCiAgZnJhY0RlbigpIHsKICAgIHJldHVybiBzdHlsZXNbZnJhY0Rlblt0aGlzLmlkXV07CiAgfQogIC8qKgogICAqIEdldCB0aGUgY3JhbXBlZCB2ZXJzaW9uIG9mIGEgc3R5bGUgKGluIHBhcnRpY3VsYXIsIGNyYW1waW5nIGEgY3JhbXBlZCBzdHlsZQogICAqIGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHlsZSkuCiAgICovCiAgY3JhbXAoKSB7CiAgICByZXR1cm4gc3R5bGVzW2NyYW1wW3RoaXMuaWRdXTsKICB9CiAgLyoqCiAgICogR2V0IGEgdGV4dCBvciBkaXNwbGF5IHZlcnNpb24gb2YgdGhpcyBzdHlsZS4KICAgKi8KICB0ZXh0KCkgewogICAgcmV0dXJuIHN0eWxlc1t0ZXh0JDFbdGhpcy5pZF1dOwogIH0KICAvKioKICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGlzIHN0eWxlIGlzIHRpZ2h0bHkgc3BhY2VkIChzY3JpcHRzdHlsZS9zY3JpcHRzY3JpcHRzdHlsZSkKICAgKi8KICBpc1RpZ2h0KCkgewogICAgcmV0dXJuIHRoaXMuc2l6ZSA+PSAyOwogIH0KfTsKdmFyIEQgPSAwOwp2YXIgRGMgPSAxOwp2YXIgVCA9IDI7CnZhciBUYyA9IDM7CnZhciBTID0gNDsKdmFyIFNjID0gNTsKdmFyIFNTID0gNjsKdmFyIFNTYyA9IDc7CnZhciBzdHlsZXMgPSBbbmV3IFN0eWxlKEQsIDAsIGZhbHNlKSwgbmV3IFN0eWxlKERjLCAwLCB0cnVlKSwgbmV3IFN0eWxlKFQsIDEsIGZhbHNlKSwgbmV3IFN0eWxlKFRjLCAxLCB0cnVlKSwgbmV3IFN0eWxlKFMsIDIsIGZhbHNlKSwgbmV3IFN0eWxlKFNjLCAyLCB0cnVlKSwgbmV3IFN0eWxlKFNTLCAzLCBmYWxzZSksIG5ldyBTdHlsZShTU2MsIDMsIHRydWUpXTsKdmFyIHN1cCA9IFtTLCBTYywgUywgU2MsIFNTLCBTU2MsIFNTLCBTU2NdOwp2YXIgc3ViID0gW1NjLCBTYywgU2MsIFNjLCBTU2MsIFNTYywgU1NjLCBTU2NdOwp2YXIgZnJhY051bSA9IFtULCBUYywgUywgU2MsIFNTLCBTU2MsIFNTLCBTU2NdOwp2YXIgZnJhY0RlbiA9IFtUYywgVGMsIFNjLCBTYywgU1NjLCBTU2MsIFNTYywgU1NjXTsKdmFyIGNyYW1wID0gW0RjLCBEYywgVGMsIFRjLCBTYywgU2MsIFNTYywgU1NjXTsKdmFyIHRleHQkMSA9IFtELCBEYywgVCwgVGMsIFQsIFRjLCBULCBUY107CnZhciBTdHlsZSQxID0gewogIERJU1BMQVk6IHN0eWxlc1tEXSwKICBURVhUOiBzdHlsZXNbVF0sCiAgU0NSSVBUOiBzdHlsZXNbU10sCiAgU0NSSVBUU0NSSVBUOiBzdHlsZXNbU1NdCn07CnZhciBzY3JpcHREYXRhID0gW3sKICAvLyBMYXRpbiBjaGFyYWN0ZXJzIGJleW9uZCB0aGUgTGF0aW4tMSBjaGFyYWN0ZXJzIHdlIGhhdmUgbWV0cmljcyBmb3IuCiAgLy8gTmVlZGVkIGZvciBDemVjaCwgSHVuZ2FyaWFuIGFuZCBUdXJraXNoIHRleHQsIGZvciBleGFtcGxlLgogIG5hbWU6ICJsYXRpbiIsCiAgYmxvY2tzOiBbCiAgICBbMjU2LCA1OTFdLAogICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBhbmQgTGF0aW4gRXh0ZW5kZWQtQgogICAgWzc2OCwgODc5XQogICAgLy8gQ29tYmluaW5nIERpYWNyaXRpY2FsIG1hcmtzCiAgXQp9LCB7CiAgLy8gVGhlIEN5cmlsbGljIHNjcmlwdCB1c2VkIGJ5IFJ1c3NpYW4gYW5kIHJlbGF0ZWQgbGFuZ3VhZ2VzLgogIC8vIEEgQ3lyaWxsaWMgc3Vic2V0IHVzZWQgdG8gYmUgc3VwcG9ydGVkIGFzIGV4cGxpY2l0bHkgZGVmaW5lZAogIC8vIHN5bWJvbHMgaW4gc3ltYm9scy5qcwogIG5hbWU6ICJjeXJpbGxpYyIsCiAgYmxvY2tzOiBbWzEwMjQsIDEyNzldXQp9LCB7CiAgLy8gQXJtZW5pYW4KICBuYW1lOiAiYXJtZW5pYW4iLAogIGJsb2NrczogW1sxMzI4LCAxNDIzXV0KfSwgewogIC8vIFRoZSBCcmFobWljIHNjcmlwdHMgb2YgU291dGggYW5kIFNvdXRoZWFzdCBBc2lhCiAgLy8gRGV2YW5hZ2FyaSAoMDkwMOKAkzA5N0YpCiAgLy8gQmVuZ2FsaSAoMDk4MOKAkzA5RkYpCiAgLy8gR3VybXVraGkgKDBBMDDigJMwQTdGKQogIC8vIEd1amFyYXRpICgwQTgw4oCTMEFGRikKICAvLyBPcml5YSAoMEIwMOKAkzBCN0YpCiAgLy8gVGFtaWwgKDBCODDigJMwQkZGKQogIC8vIFRlbHVndSAoMEMwMOKAkzBDN0YpCiAgLy8gS2FubmFkYSAoMEM4MOKAkzBDRkYpCiAgLy8gTWFsYXlhbGFtICgwRDAw4oCTMEQ3RikKICAvLyBTaW5oYWxhICgwRDgw4oCTMERGRikKICAvLyBUaGFpICgwRTAw4oCTMEU3RikKICAvLyBMYW8gKDBFODDigJMwRUZGKQogIC8vIFRpYmV0YW4gKDBGMDDigJMwRkZGKQogIC8vIE15YW5tYXIgKDEwMDDigJMxMDlGKQogIG5hbWU6ICJicmFobWljIiwKICBibG9ja3M6IFtbMjMwNCwgNDI1NV1dCn0sIHsKICBuYW1lOiAiZ2VvcmdpYW4iLAogIGJsb2NrczogW1s0MjU2LCA0MzUxXV0KfSwgewogIC8vIENoaW5lc2UgYW5kIEphcGFuZXNlLgogIC8vIFRoZSAiayIgaW4gY2prIGlzIGZvciBLb3JlYW4sIGJ1dCB3ZSd2ZSBzZXBhcmF0ZWQgS29yZWFuIG91dAogIG5hbWU6ICJjamsiLAogIGJsb2NrczogWwogICAgWzEyMjg4LCAxMjU0M10sCiAgICAvLyBDSksgc3ltYm9scyBhbmQgcHVuY3R1YXRpb24sIEhpcmFnYW5hLCBLYXRha2FuYQogICAgWzE5OTY4LCA0MDg3OV0sCiAgICAvLyBDSksgaWRlb2dyYW1zCiAgICBbNjUyODAsIDY1Mzc2XQogICAgLy8gRnVsbHdpZHRoIHB1bmN0dWF0aW9uCiAgICAvLyBUT0RPOiBhZGQgaGFsZndpZHRoIEthdGFrYW5hIGFuZCBSb21hbmppIGdseXBocwogIF0KfSwgewogIC8vIEtvcmVhbgogIG5hbWU6ICJoYW5ndWwiLAogIGJsb2NrczogW1s0NDAzMiwgNTUyMTVdXQp9XTsKZnVuY3Rpb24gc2NyaXB0RnJvbUNvZGVwb2ludChjb2RlcG9pbnQpIHsKICBmb3IgKHZhciBpID0gMDsgaSA8IHNjcmlwdERhdGEubGVuZ3RoOyBpKyspIHsKICAgIHZhciBzY3JpcHQgPSBzY3JpcHREYXRhW2ldOwogICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHNjcmlwdC5ibG9ja3MubGVuZ3RoOyBfaSsrKSB7CiAgICAgIHZhciBibG9jayA9IHNjcmlwdC5ibG9ja3NbX2ldOwogICAgICBpZiAoY29kZXBvaW50ID49IGJsb2NrWzBdICYmIGNvZGVwb2ludCA8PSBibG9ja1sxXSkgewogICAgICAgIHJldHVybiBzY3JpcHQubmFtZTsKICAgICAgfQogICAgfQogIH0KICByZXR1cm4gbnVsbDsKfQp2YXIgYWxsQmxvY2tzID0gW107CnNjcmlwdERhdGEuZm9yRWFjaCgocykgPT4gcy5ibG9ja3MuZm9yRWFjaCgoYikgPT4gYWxsQmxvY2tzLnB1c2goLi4uYikpKTsKZnVuY3Rpb24gc3VwcG9ydGVkQ29kZXBvaW50KGNvZGVwb2ludCkgewogIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsQmxvY2tzLmxlbmd0aDsgaSArPSAyKSB7CiAgICBpZiAoY29kZXBvaW50ID49IGFsbEJsb2Nrc1tpXSAmJiBjb2RlcG9pbnQgPD0gYWxsQmxvY2tzW2kgKyAxXSkgewogICAgICByZXR1cm4gdHJ1ZTsKICAgIH0KICB9CiAgcmV0dXJuIGZhbHNlOwp9CnZhciBoTGluZVBhZCA9IDgwOwp2YXIgc3FydE1haW4gPSBmdW5jdGlvbiBzcXJ0TWFpbjIoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQyKSB7CiAgcmV0dXJuICJNOTUsIiArICg2MjIgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQyKSArICJcbmMtMi43LDAsLTcuMTcsLTIuNywtMTMuNSwtOGMtNS44LC01LjMsLTkuNSwtMTAsLTkuNSwtMTRcbmMwLC0yLDAuMywtMy4zLDEsLTRjMS4zLC0yLjcsMjMuODMsLTIwLjcsNjcuNSwtNTRcbmM0NC4yLC0zMy4zLDY1LjgsLTUwLjMsNjYuNSwtNTFjMS4zLC0xLjMsMywtMiw1LC0yYzQuNywwLDguNywzLjMsMTIsMTBcbnMxNzMsMzc4LDE3MywzNzhjMC43LDAsMzUuMywtNzEsMTA0LC0yMTNjNjguNywtMTQyLDEzNy41LC0yODUsMjA2LjUsLTQyOVxuYzY5LC0xNDQsMTA0LjUsLTIxNy43LDEwNi41LC0yMjFcbmwiICsgZXh0cmFWaW5jdWx1bSAvIDIuMDc1ICsgIiAtIiArIGV4dHJhVmluY3VsdW0gKyAiXG5jNS4zLC05LjMsMTIsLTE0LDIwLC0xNFxuSDQwMDAwMHYiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyAiSDg0NS4yNzI0XG5zLTIyNS4yNzIsNDY3LC0yMjUuMjcyLDQ2N3MtMjM1LDQ4NiwtMjM1LDQ4NmMtMi43LDQuNywtOSw3LC0xOSw3XG5jLTYsMCwtMTAsLTEsLTEyLC0zcy0xOTQsLTQyMiwtMTk0LC00MjJzLTY1LDQ3LC02NSw0N3pcbk0iICsgKDgzNCArIGV4dHJhVmluY3VsdW0pICsgIiAiICsgaExpbmVQYWQyICsgImg0MDAwMDB2IiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgImgtNDAwMDAweiI7Cn07CnZhciBzcXJ0U2l6ZTEgPSBmdW5jdGlvbiBzcXJ0U2l6ZTEyKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkMikgewogIHJldHVybiAiTTI2MywiICsgKDYwMSArIGV4dHJhVmluY3VsdW0gKyBoTGluZVBhZDIpICsgImMwLjcsMCwxOCwzOS43LDUyLDExOVxuYzM0LDc5LjMsNjguMTY3LDE1OC43LDEwMi41LDIzOGMzNC4zLDc5LjMsNTEuOCwxMTkuMyw1Mi41LDEyMFxuYzM0MCwtNzA0LjcsNTEwLjcsLTEwNjAuMyw1MTIsLTEwNjdcbmwiICsgZXh0cmFWaW5jdWx1bSAvIDIuMDg0ICsgIiAtIiArIGV4dHJhVmluY3VsdW0gKyAiXG5jNC43LC03LjMsMTEsLTExLDE5LC0xMVxuSDQwMDAwdiIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArICJIMTAxMi4zXG5zLTI3MS4zLDU2NywtMjcxLjMsNTY3Yy0zOC43LDgwLjcsLTg0LDE3NSwtMTM2LDI4M2MtNTIsMTA4LC04OS4xNjcsMTg1LjMsLTExMS41LDIzMlxuYy0yMi4zLDQ2LjcsLTMzLjgsNzAuMywtMzQuNSw3MWMtNC43LDQuNywtMTIuMyw3LC0yMyw3cy0xMiwtMSwtMTIsLTFcbnMtMTA5LC0yNTMsLTEwOSwtMjUzYy03Mi43LC0xNjgsLTEwOS4zLC0yNTIsLTExMCwtMjUyYy0xMC43LDgsLTIyLDE2LjcsLTM0LDI2XG5jLTIyLDE3LjMsLTMzLjMsMjYsLTM0LDI2cy0yNiwtMjYsLTI2LC0yNnM3NiwtNTksNzYsLTU5czc2LC02MCw3NiwtNjB6XG5NIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyAiICIgKyBoTGluZVBhZDIgKyAiaDQwMDAwMHYiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyAiaC00MDAwMDB6IjsKfTsKdmFyIHNxcnRTaXplMiA9IGZ1bmN0aW9uIHNxcnRTaXplMjIoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQyKSB7CiAgcmV0dXJuICJNOTgzICIgKyAoMTAgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQyKSArICJcbmwiICsgZXh0cmFWaW5jdWx1bSAvIDMuMTMgKyAiIC0iICsgZXh0cmFWaW5jdWx1bSArICJcbmM0LC02LjcsMTAsLTEwLDE4LC0xMCBINDAwMDAwdiIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArICJcbkgxMDEzLjFzLTgzLjQsMjY4LC0yNjQuMSw4NDBjLTE4MC43LDU3MiwtMjc3LDg3Ni4zLC0yODksOTEzYy00LjcsNC43LC0xMi43LDcsLTI0LDdcbnMtMTIsMCwtMTIsMGMtMS4zLC0zLjMsLTMuNywtMTEuNywtNywtMjVjLTM1LjMsLTEyNS4zLC0xMDYuNywtMzczLjMsLTIxNCwtNzQ0XG5jLTEwLDEyLC0yMSwyNSwtMzMsMzlzLTMyLDM5LC0zMiwzOWMtNiwtNS4zLC0xNSwtMTQsLTI3LC0yNnMyNSwtMzAsMjUsLTMwXG5jMjYuNywtMzIuNyw1MiwtNjMsNzYsLTkxczUyLC02MCw1MiwtNjBzMjA4LDcyMiwyMDgsNzIyXG5jNTYsLTE3NS4zLDEyNi4zLC0zOTcuMywyMTEsLTY2NmM4NC43LC0yNjguNywxNTMuOCwtNDg4LjIsMjA3LjUsLTY1OC41XG5jNTMuNywtMTcwLjMsODQuNSwtMjY2LjgsOTIuNSwtMjg5LjV6XG5NIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyAiICIgKyBoTGluZVBhZDIgKyAiaDQwMDAwMHYiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyAiaC00MDAwMDB6IjsKfTsKdmFyIHNxcnRTaXplMyA9IGZ1bmN0aW9uIHNxcnRTaXplMzIoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQyKSB7CiAgcmV0dXJuICJNNDI0LCIgKyAoMjM5OCArIGV4dHJhVmluY3VsdW0gKyBoTGluZVBhZDIpICsgIlxuYy0xLjMsLTAuNywtMzguNSwtMTcyLC0xMTEuNSwtNTE0Yy03MywtMzQyLC0xMDkuOCwtNTEzLjMsLTExMC41LC01MTRcbmMwLC0yLC0xMC43LDE0LjMsLTMyLDQ5Yy00LjcsNy4zLC05LjgsMTUuNywtMTUuNSwyNWMtNS43LDkuMywtOS44LDE2LC0xMi41LDIwXG5zLTUsNywtNSw3Yy00LC0zLjMsLTguMywtNy43LC0xMywtMTNzLTEzLC0xMywtMTMsLTEzczc2LC0xMjIsNzYsLTEyMnM3NywtMTIxLDc3LC0xMjFcbnMyMDksOTY4LDIwOSw5NjhjMCwtMiw4NC43LC0zNjEuNywyNTQsLTEwNzljMTY5LjMsLTcxNy4zLDI1NC43LC0xMDc3LjcsMjU2LC0xMDgxXG5sIiArIGV4dHJhVmluY3VsdW0gLyA0LjIyMyArICIgLSIgKyBleHRyYVZpbmN1bHVtICsgImM0LC02LjcsMTAsLTEwLDE4LC0xMCBINDAwMDAwXG52IiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgIkgxMDE0LjZcbnMtODcuMywzNzguNywtMjcyLjYsMTE2NmMtMTg1LjMsNzg3LjMsLTI3OS4zLDExODIuMywtMjgyLDExODVcbmMtMiw2LC0xMCw5LC0yNCw5XG5jLTgsMCwtMTIsLTAuNywtMTIsLTJ6IE0iICsgKDEwMDEgKyBleHRyYVZpbmN1bHVtKSArICIgIiArIGhMaW5lUGFkMiArICJcbmg0MDAwMDB2IiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgImgtNDAwMDAweiI7Cn07CnZhciBzcXJ0U2l6ZTQgPSBmdW5jdGlvbiBzcXJ0U2l6ZTQyKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkMikgewogIHJldHVybiAiTTQ3MywiICsgKDI3MTMgKyBleHRyYVZpbmN1bHVtICsgaExpbmVQYWQyKSArICJcbmMzMzkuMywtMTc5OS4zLDUwOS4zLC0yNzAwLDUxMCwtMjcwMiBsIiArIGV4dHJhVmluY3VsdW0gLyA1LjI5OCArICIgLSIgKyBleHRyYVZpbmN1bHVtICsgIlxuYzMuMywtNy4zLDkuMywtMTEsMTgsLTExIEg0MDAwMDB2IiArICg0MCArIGV4dHJhVmluY3VsdW0pICsgIkgxMDE3LjdcbnMtOTAuNSw0NzgsLTI3Ni4yLDE0NjZjLTE4NS43LDk4OCwtMjc5LjUsMTQ4MywtMjgxLjUsMTQ4NWMtMiw2LC0xMCw5LC0yNCw5XG5jLTgsMCwtMTIsLTAuNywtMTIsLTJjMCwtMS4zLC01LjMsLTMyLC0xNiwtOTJjLTUwLjcsLTI5My4zLC0xMTkuNywtNjkzLjMsLTIwNywtMTIwMFxuYzAsLTEuMywtNS4zLDguNywtMTYsMzBjLTEwLjcsMjEuMywtMjEuMyw0Mi43LC0zMiw2NHMtMTYsMzMsLTE2LDMzcy0yNiwtMjYsLTI2LC0yNlxuczc2LC0xNTMsNzYsLTE1M3M3NywtMTUxLDc3LC0xNTFjMC43LDAuNywzNS43LDIwMiwxMDUsNjA0YzY3LjMsNDAwLjcsMTAyLDYwMi43LDEwNCxcbjYwNnpNIiArICgxMDAxICsgZXh0cmFWaW5jdWx1bSkgKyAiICIgKyBoTGluZVBhZDIgKyAiaDQwMDAwMHYiICsgKDQwICsgZXh0cmFWaW5jdWx1bSkgKyAiSDEwMTcuN3oiOwp9Owp2YXIgcGhhc2VQYXRoID0gZnVuY3Rpb24gcGhhc2VQYXRoMih5KSB7CiAgdmFyIHggPSB5IC8gMjsKICByZXR1cm4gIk00MDAwMDAgIiArIHkgKyAiIEgwIEwiICsgeCArICIgMCBsNjUgNDUgTDE0NSAiICsgKHkgLSA4MCkgKyAiIEg0MDAwMDB6IjsKfTsKdmFyIHNxcnRUYWxsID0gZnVuY3Rpb24gc3FydFRhbGwyKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkMiwgdmlld0JveEhlaWdodCkgewogIHZhciB2ZXJ0U2VnbWVudCA9IHZpZXdCb3hIZWlnaHQgLSA1NCAtIGhMaW5lUGFkMiAtIGV4dHJhVmluY3VsdW07CiAgcmV0dXJuICJNNzAyICIgKyAoZXh0cmFWaW5jdWx1bSArIGhMaW5lUGFkMikgKyAiSDQwMDAwMCIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArICJcbkg3NDJ2IiArIHZlcnRTZWdtZW50ICsgImwtNCA0LTQgNGMtLjY2Ny43IC0yIDEuNS00IDIuNXMtNC4xNjcgMS44MzMtNi41IDIuNS01LjUgMS05LjUgMVxuaC0xMmwtMjgtODRjLTE2LjY2Ny01Mi05Ni42NjcgLTI5NC4zMzMtMjQwLTcyN2wtMjEyIC02NDMgLTg1IDE3MFxuYy00LTMuMzMzLTguMzMzLTcuNjY3LTEzIC0xM2wtMTMtMTNsNzctMTU1IDc3LTE1NmM2NiAxOTkuMzMzIDEzOSA0MTkuNjY3XG4yMTkgNjYxIGwyMTggNjYxek03MDIgIiArIGhMaW5lUGFkMiArICJINDAwMDAwdiIgKyAoNDAgKyBleHRyYVZpbmN1bHVtKSArICJINzQyeiI7Cn07CnZhciBzcXJ0UGF0aCA9IGZ1bmN0aW9uIHNxcnRQYXRoMihzaXplLCBleHRyYVZpbmN1bHVtLCB2aWV3Qm94SGVpZ2h0KSB7CiAgZXh0cmFWaW5jdWx1bSA9IDFlMyAqIGV4dHJhVmluY3VsdW07CiAgdmFyIHBhdGgyID0gIiI7CiAgc3dpdGNoIChzaXplKSB7CiAgICBjYXNlICJzcXJ0TWFpbiI6CiAgICAgIHBhdGgyID0gc3FydE1haW4oZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpOwogICAgICBicmVhazsKICAgIGNhc2UgInNxcnRTaXplMSI6CiAgICAgIHBhdGgyID0gc3FydFNpemUxKGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJzcXJ0U2l6ZTIiOgogICAgICBwYXRoMiA9IHNxcnRTaXplMihleHRyYVZpbmN1bHVtLCBoTGluZVBhZCk7CiAgICAgIGJyZWFrOwogICAgY2FzZSAic3FydFNpemUzIjoKICAgICAgcGF0aDIgPSBzcXJ0U2l6ZTMoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQpOwogICAgICBicmVhazsKICAgIGNhc2UgInNxcnRTaXplNCI6CiAgICAgIHBhdGgyID0gc3FydFNpemU0KGV4dHJhVmluY3VsdW0sIGhMaW5lUGFkKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJzcXJ0VGFsbCI6CiAgICAgIHBhdGgyID0gc3FydFRhbGwoZXh0cmFWaW5jdWx1bSwgaExpbmVQYWQsIHZpZXdCb3hIZWlnaHQpOwogIH0KICByZXR1cm4gcGF0aDI7Cn07CnZhciBpbm5lclBhdGggPSBmdW5jdGlvbiBpbm5lclBhdGgyKG5hbWUsIGhlaWdodCkgewogIHN3aXRjaCAobmFtZSkgewogICAgY2FzZSAi4o6cIjoKICAgICAgcmV0dXJuICJNMjkxIDAgSDQxNyBWIiArIGhlaWdodCArICIgSDI5MXogTTI5MSAwIEg0MTcgViIgKyBoZWlnaHQgKyAiIEgyOTF6IjsKICAgIGNhc2UgIuKIoyI6CiAgICAgIHJldHVybiAiTTE0NSAwIEgxODggViIgKyBoZWlnaHQgKyAiIEgxNDV6IE0xNDUgMCBIMTg4IFYiICsgaGVpZ2h0ICsgIiBIMTQ1eiI7CiAgICBjYXNlICLiiKUiOgogICAgICByZXR1cm4gIk0xNDUgMCBIMTg4IFYiICsgaGVpZ2h0ICsgIiBIMTQ1eiBNMTQ1IDAgSDE4OCBWIiArIGhlaWdodCArICIgSDE0NXoiICsgKCJNMzY3IDAgSDQxMCBWIiArIGhlaWdodCArICIgSDM2N3ogTTM2NyAwIEg0MTAgViIgKyBoZWlnaHQgKyAiIEgzNjd6Iik7CiAgICBjYXNlICLijp8iOgogICAgICByZXR1cm4gIk00NTcgMCBINTgzIFYiICsgaGVpZ2h0ICsgIiBINDU3eiBNNDU3IDAgSDU4MyBWIiArIGhlaWdodCArICIgSDQ1N3oiOwogICAgY2FzZSAi4o6iIjoKICAgICAgcmV0dXJuICJNMzE5IDAgSDQwMyBWIiArIGhlaWdodCArICIgSDMxOXogTTMxOSAwIEg0MDMgViIgKyBoZWlnaHQgKyAiIEgzMTl6IjsKICAgIGNhc2UgIuKOpSI6CiAgICAgIHJldHVybiAiTTI2MyAwIEgzNDcgViIgKyBoZWlnaHQgKyAiIEgyNjN6IE0yNjMgMCBIMzQ3IFYiICsgaGVpZ2h0ICsgIiBIMjYzeiI7CiAgICBjYXNlICLijqoiOgogICAgICByZXR1cm4gIk0zODQgMCBINTA0IFYiICsgaGVpZ2h0ICsgIiBIMzg0eiBNMzg0IDAgSDUwNCBWIiArIGhlaWdodCArICIgSDM4NHoiOwogICAgY2FzZSAi4o+QIjoKICAgICAgcmV0dXJuICJNMzEyIDAgSDM1NSBWIiArIGhlaWdodCArICIgSDMxMnogTTMxMiAwIEgzNTUgViIgKyBoZWlnaHQgKyAiIEgzMTJ6IjsKICAgIGNhc2UgIuKAliI6CiAgICAgIHJldHVybiAiTTI1NyAwIEgzMDAgViIgKyBoZWlnaHQgKyAiIEgyNTd6IE0yNTcgMCBIMzAwIFYiICsgaGVpZ2h0ICsgIiBIMjU3eiIgKyAoIk00NzggMCBINTIxIFYiICsgaGVpZ2h0ICsgIiBINDc4eiBNNDc4IDAgSDUyMSBWIiArIGhlaWdodCArICIgSDQ3OHoiKTsKICAgIGRlZmF1bHQ6CiAgICAgIHJldHVybiAiIjsKICB9Cn07CnZhciBwYXRoID0gewogIC8vIFRoZSBkb3VibGVsZWZ0YXJyb3cgZ2VvbWV0cnkgaXMgZnJvbSBnbHlwaCBVKzIxRDAgaW4gdGhlIGZvbnQgS2FUZVggTWFpbgogIGRvdWJsZWxlZnRhcnJvdzogIk0yNjIgMTU3XG5sMTAtMTBjMzQtMzYgNjIuNy03NyA4Ni0xMjMgMy4zLTggNS0xMy4zIDUtMTYgMC01LjMtNi43LTgtMjAtOC03LjNcbiAwLTEyLjIuNS0xNC41IDEuNS0yLjMgMS00LjggNC41LTcuNSAxMC41LTQ5LjMgOTcuMy0xMjEuNyAxNjkuMy0yMTcgMjE2LTI4XG4gMTQtNTcuMyAyNS04OCAzMy02LjcgMi0xMSAzLjgtMTMgNS41LTIgMS43LTMgNC4yLTMgNy41czEgNS44IDMgNy41XG5jMiAxLjcgNi4zIDMuNSAxMyA1LjUgNjggMTcuMyAxMjguMiA0Ny44IDE4MC41IDkxLjUgNTIuMyA0My43IDkzLjggOTYuMiAxMjQuNVxuIDE1Ny41IDkuMyA4IDE1LjMgMTIuMyAxOCAxM2g2YzEyLS43IDE4LTQgMTgtMTAgMC0yLTEuNy03LTUtMTUtMjMuMy00Ni01Mi04N1xuLTg2LTEyM2wtMTAtMTBoMzk5NzM4di00MEgyMThjMzI4IDAgMCAwIDAgMGwtMTAtOGMtMjYuNy0yMC02NS43LTQzLTExNy02OSAyLjdcbi0yIDYtMy43IDEwLTUgMzYuNy0xNiA3Mi4zLTM3LjMgMTA3LTY0bDEwLThoMzk5Nzgydi00MHpcbm04IDB2NDBoMzk5NzMwdi00MHptMCAxOTR2NDBoMzk5NzMwdi00MHoiLAogIC8vIGRvdWJsZXJpZ2h0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxRDIgaW4gZm9udCBLYVRlWCBNYWluCiAgZG91YmxlcmlnaHRhcnJvdzogIk0zOTk3MzggMzkybFxuLTEwIDEwYy0zNCAzNi02Mi43IDc3LTg2IDEyMy0zLjMgOC01IDEzLjMtNSAxNiAwIDUuMyA2LjcgOCAyMCA4IDcuMyAwIDEyLjItLjVcbiAxNC41LTEuNSAyLjMtMSA0LjgtNC41IDcuNS0xMC41IDQ5LjMtOTcuMyAxMjEuNy0xNjkuMyAyMTctMjE2IDI4LTE0IDU3LjMtMjUgODhcbi0zMyA2LjctMiAxMS0zLjggMTMtNS41IDItMS43IDMtNC4yIDMtNy41cy0xLTUuOC0zLTcuNWMtMi0xLjctNi4zLTMuNS0xMy01LjUtNjhcbi0xNy4zLTEyOC4yLTQ3LjgtMTgwLjUtOTEuNS01Mi4zLTQzLjctOTMuOC05Ni4yLTEyNC41LTE1Ny41LTkuMy04LTE1LjMtMTIuMy0xOFxuLTEzaC02Yy0xMiAuNy0xOCA0LTE4IDEwIDAgMiAxLjcgNyA1IDE1IDIzLjMgNDYgNTIgODcgODYgMTIzbDEwIDEwSDB2NDBoMzk5NzgyXG5jLTMyOCAwIDAgMCAwIDBsMTAgOGMyNi43IDIwIDY1LjcgNDMgMTE3IDY5LTIuNyAyLTYgMy43LTEwIDUtMzYuNyAxNi03Mi4zIDM3LjNcbi0xMDcgNjRsLTEwIDhIMHY0MHpNMCAxNTd2NDBoMzk5NzMwdi00MHptMCAxOTR2NDBoMzk5NzMwdi00MHoiLAogIC8vIGxlZnRhcnJvdyBpcyBmcm9tIGdseXBoIFUrMjE5MCBpbiBmb250IEthVGVYIE1haW4KICBsZWZ0YXJyb3c6ICJNNDAwMDAwIDI0MUgxMTBsMy0zYzY4LjctNTIuNyAxMTMuNy0xMjBcbiAxMzUtMjAyIDQtMTQuNyA2LTIzIDYtMjUgMC03LjMtNy0xMS0yMS0xMS04IDAtMTMuMi44LTE1LjUgMi41LTIuMyAxLjctNC4yIDUuOFxuLTUuNSAxMi41LTEuMyA0LjctMi43IDEwLjMtNCAxNy0xMiA0OC43LTM0LjggOTItNjguNSAxMzBTNjUuMyAyMjguMyAxOCAyNDdcbmMtMTAgNC0xNiA3LjctMTggMTEgMCA4LjcgNiAxNC4zIDE4IDE3IDQ3LjMgMTguNyA4Ny44IDQ3IDEyMS41IDg1UzE5NiA0NDEuMyAyMDhcbiA0OTBjLjcgMiAxLjMgNSAyIDlzMS4yIDYuNyAxLjUgOGMuMyAxLjMgMSAzLjMgMiA2czIuMiA0LjUgMy41IDUuNWMxLjMgMSAzLjNcbiAxLjggNiAyLjVzNiAxIDEwIDFjMTQgMCAyMS0zLjcgMjEtMTEgMC0yLTItMTAuMy02LTI1LTIwLTc5LjMtNjUtMTQ2LjctMTM1LTIwMlxuIGwtMy0zaDM5OTg5MHpNMTAwIDI0MXY0MGgzOTk5MDB2LTQweiIsCiAgLy8gb3ZlcmJyYWNlIGlzIGZyb20gZ2x5cGhzIFUrMjNBOS8yM0E4LzIzQTcgaW4gZm9udCBLYVRlWF9TaXplNC1SZWd1bGFyCiAgbGVmdGJyYWNlOiAiTTYgNTQ4bC02LTZ2LTM1bDYtMTFjNTYtMTA0IDEzNS4zLTE4MS4zIDIzOC0yMzIgNTcuMy0yOC43IDExN1xuLTQ1IDE3OS01MGgzOTk1Nzd2MTIwSDQwM2MtNDMuMyA3LTgxIDE1LTExMyAyNi0xMDAuNyAzMy0xNzkuNyA5MS0yMzcgMTc0LTIuN1xuIDUtNiA5LTEwIDEzLS43IDEtNy4zIDEtMjAgMUg2eiIsCiAgbGVmdGJyYWNldW5kZXI6ICJNMCA2bDYtNmgxN2MxMi42ODggMCAxOS4zMTMuMyAyMCAxIDQgNCA3LjMxMyA4LjMgMTAgMTNcbiAzNS4zMTMgNTEuMyA4MC44MTMgOTMuOCAxMzYuNSAxMjcuNSA1NS42ODggMzMuNyAxMTcuMTg4IDU1LjggMTg0LjUgNjYuNS42ODhcbiAwIDIgLjMgNCAxIDE4LjY4OCAyLjcgNzYgNC4zIDE3MiA1aDM5OTQ1MHYxMjBINDI5bC02LTFjLTEyNC42ODgtOC0yMzUtNjEuN1xuLTMzMS0xNjFDNjAuNjg3IDEzOC43IDMyLjMxMiA5OS4zIDcgNTRMMCA0MVY2eiIsCiAgLy8gb3Zlcmdyb3VwIGlzIGZyb20gdGhlIE1uU3ltYm9sIHBhY2thZ2UgKHB1YmxpYyBkb21haW4pCiAgbGVmdGdyb3VwOiAiTTQwMDAwMCA4MFxuSDQzNUM2NCA4MCAxNjguMyAyMjkuNCAyMSAyNjBjLTUuOSAxLjItMTggMC0xOCAwLTIgMC0zLTEtMy0zdi0zOEM3NiA2MSAyNTcgMFxuIDQzNSAwaDM5OTU2NXoiLAogIGxlZnRncm91cHVuZGVyOiAiTTQwMDAwMCAyNjJcbkg0MzVDNjQgMjYyIDE2OC4zIDExMi42IDIxIDgyYy01LjktMS4yLTE4IDAtMTggMC0yIDAtMyAxLTMgM3YzOGM3NiAxNTggMjU3IDIxOVxuIDQzNSAyMTloMzk5NTY1eiIsCiAgLy8gSGFycG9vbnMgYXJlIGZyb20gZ2x5cGggVSsyMUJEIGluIGZvbnQgS2FUZVggTWFpbgogIGxlZnRoYXJwb29uOiAiTTAgMjY3Yy43IDUuMyAzIDEwIDcgMTRoMzk5OTkzdi00MEg5M2MzLjNcbi0zLjMgMTAuMi05LjUgMjAuNS0xOC41czE3LjgtMTUuOCAyMi41LTIwLjVjNTAuNy01MiA4OC0xMTAuMyAxMTItMTc1IDQtMTEuMyA1XG4tMTguMyAzLTIxLTEuMy00LTcuMy02LTE4LTYtOCAwLTEzIC43LTE1IDJzLTQuNyA2LjctOCAxNmMtNDIgOTguNy0xMDcuMyAxNzQuN1xuLTE5NiAyMjgtNi43IDQuNy0xMC43IDgtMTIgMTAtMS4zIDItMiA1LjctMiAxMXptMTAwLTI2djQwaDM5OTkwMHYtNDB6IiwKICBsZWZ0aGFycG9vbnBsdXM6ICJNMCAyNjdjLjcgNS4zIDMgMTAgNyAxNGgzOTk5OTN2LTQwSDkzYzMuMy0zLjMgMTAuMi05LjVcbiAyMC41LTE4LjVzMTcuOC0xNS44IDIyLjUtMjAuNWM1MC43LTUyIDg4LTExMC4zIDExMi0xNzUgNC0xMS4zIDUtMTguMyAzLTIxLTEuM1xuLTQtNy4zLTYtMTgtNi04IDAtMTMgLjctMTUgMnMtNC43IDYuNy04IDE2Yy00MiA5OC43LTEwNy4zIDE3NC43LTE5NiAyMjgtNi43IDQuN1xuLTEwLjcgOC0xMiAxMC0xLjMgMi0yIDUuNy0yIDExem0xMDAtMjZ2NDBoMzk5OTAwdi00MHpNMCA0MzV2NDBoNDAwMDAwdi00MHpcbm0wIDB2NDBoNDAwMDAwdi00MHoiLAogIGxlZnRoYXJwb29uZG93bjogIk03IDI0MWMtNCA0LTYuMzMzIDguNjY3LTcgMTQgMCA1LjMzMy42NjcgOSAyIDExczUuMzMzXG4gNS4zMzMgMTIgMTBjOTAuNjY3IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMzMyAxMC42NjcgNi4zMzMgMTYuMzMzIDkgMTcgMiAuNjY3IDVcbiAxIDkgMWg1YzEwLjY2NyAwIDE2LjY2Ny0yIDE4LTYgMi0yLjY2NyAxLTkuNjY3LTMtMjEtMzItODcuMzMzLTgyLjY2Ny0xNTcuNjY3XG4tMTUyLTIxMWwtMy0zaDM5OTkwN3YtNDB6TTkzIDI4MSBINDAwMDAwIHYtNDBMNyAyNDF6IiwKICBsZWZ0aGFycG9vbmRvd25wbHVzOiAiTTcgNDM1Yy00IDQtNi4zIDguNy03IDE0IDAgNS4zLjcgOSAyIDExczUuMyA1LjMgMTJcbiAxMGM5MC43IDU0IDE1NiAxMzAgMTk2IDIyOCAzLjMgMTAuNyA2LjMgMTYuMyA5IDE3IDIgLjcgNSAxIDkgMWg1YzEwLjcgMCAxNi43XG4tMiAxOC02IDItMi43IDEtOS43LTMtMjEtMzItODcuMy04Mi43LTE1Ny43LTE1Mi0yMTFsLTMtM2gzOTk5MDd2LTQwSDd6bTkzIDBcbnY0MGgzOTk5MDB2LTQwek0wIDI0MXY0MGgzOTk5MDB2LTQwem0wIDB2NDBoMzk5OTAwdi00MHoiLAogIC8vIGhvb2sgaXMgZnJvbSBnbHlwaCBVKzIxQTkgaW4gZm9udCBLYVRlWCBNYWluCiAgbGVmdGhvb2s6ICJNNDAwMDAwIDI4MSBIMTAzcy0zMy0xMS4yLTYxLTMzLjVTMCAxOTcuMyAwIDE2NHMxNC4yLTYxLjIgNDIuNVxuLTgzLjVDNzAuOCA1OC4yIDEwNCA0NyAxNDIgNDcgYzE2LjcgMCAyNSA2LjcgMjUgMjAgMCAxMi04LjcgMTguNy0yNiAyMC00MCAzLjNcbi02OC43IDE1LjctODYgMzctMTAgMTItMTUgMjUuMy0xNSA0MCAwIDIyLjcgOS44IDQwLjcgMjkuNSA1NCAxOS43IDEzLjMgNDMuNSAyMVxuIDcxLjUgMjNoMzk5ODU5ek0xMDMgMjgxdi00MGgzOTk4OTd2NDB6IiwKICBsZWZ0bGluZXNlZ21lbnQ6ICJNNDAgMjgxIFY0MjggSDAgVjk0IEg0MCBWMjQxIEg0MDAwMDAgdjQwelxuTTQwIDI4MSBWNDI4IEgwIFY5NCBINDAgVjI0MSBINDAwMDAwIHY0MHoiLAogIGxlZnRtYXBzdG86ICJNNDAgMjgxIFY0NDhIMFY3NEg0MFYyNDFINDAwMDAwdjQwelxuTTQwIDI4MSBWNDQ4SDBWNzRINDBWMjQxSDQwMDAwMHY0MHoiLAogIC8vIHRvZnJvbSBpcyBmcm9tIGdseXBoIFUrMjFDNCBpbiBmb250IEthVGVYIEFNUyBSZWd1bGFyCiAgbGVmdFRvRnJvbTogIk0wIDE0N2g0MDAwMDB2NDBIMHptMCAyMTRjNjggNDAgMTE1LjcgOTUuNyAxNDMgMTY3aDIyYzE1LjMgMCAyM1xuLS4zIDIzLTEgMC0xLjMtNS4zLTEzLjctMTYtMzctMTgtMzUuMy00MS4zLTY5LTcwLTEwMWwtNy04aDM5OTkwNXYtNDBIOTVsNy04XG5jMjguNy0zMiA1Mi02NS43IDcwLTEwMSAxMC43LTIzLjMgMTYtMzUuNyAxNi0zNyAwLS43LTcuNy0xLTIzLTFoLTIyQzExNS43IDI2NS4zXG4gNjggMzIxIDAgMzYxem0wLTE3NHYtNDBoMzk5OTAwdjQwem0xMDAgMTU0djQwaDM5OTkwMHYtNDB6IiwKICBsb25nZXF1YWw6ICJNMCA1MCBoNDAwMDAwIHY0MEgweiBtMCAxOTRoNDAwMDB2NDBIMHpcbk0wIDUwIGg0MDAwMDAgdjQwSDB6IG0wIDE5NGg0MDAwMHY0MEgweiIsCiAgbWlkYnJhY2U6ICJNMjAwNDI4IDMzNFxuYy0xMDAuNy04LjMtMTk1LjMtNDQtMjgwLTEwOC01NS4zLTQyLTEwMS43LTkzLTEzOS0xNTNsLTktMTRjLTIuNyA0LTUuNyA4LjctOSAxNFxuLTUzLjMgODYuNy0xMjMuNyAxNTMtMjExIDE5OS02Ni43IDM2LTEzNy4zIDU2LjMtMjEyIDYySDBWMjE0aDE5OTU2OGMxNzguMy0xMS43XG4gMzExLjctNzguMyA0MDMtMjAxIDYtOCA5LjctMTIgMTEtMTIgLjctLjcgNi43LTEgMTgtMXMxNy4zLjMgMTggMWMxLjMgMCA1IDQgMTFcbiAxMiA0NC43IDU5LjMgMTAxLjMgMTA2LjMgMTcwIDE0MXMxNDUuMyA1NC4zIDIyOSA2MGgxOTk1NzJ2MTIweiIsCiAgbWlkYnJhY2V1bmRlcjogIk0xOTk1NzIgMjE0XG5jMTAwLjcgOC4zIDE5NS4zIDQ0IDI4MCAxMDggNTUuMyA0MiAxMDEuNyA5MyAxMzkgMTUzbDkgMTRjMi43LTQgNS43LTguNyA5LTE0XG4gNTMuMy04Ni43IDEyMy43LTE1MyAyMTEtMTk5IDY2LjctMzYgMTM3LjMtNTYuMyAyMTItNjJoMTk5NTY4djEyMEgyMDA0MzJjLTE3OC4zXG4gMTEuNy0zMTEuNyA3OC4zLTQwMyAyMDEtNiA4LTkuNyAxMi0xMSAxMi0uNy43LTYuNyAxLTE4IDFzLTE3LjMtLjMtMTgtMWMtMS4zIDBcbi01LTQtMTEtMTItNDQuNy01OS4zLTEwMS4zLTEwNi4zLTE3MC0xNDFzLTE0NS4zLTU0LjMtMjI5LTYwSDBWMjE0eiIsCiAgb2lpbnRTaXplMTogIk01MTIuNiA3MS42YzI3Mi42IDAgMzIwLjMgMTA2LjggMzIwLjMgMTc4LjIgMCA3MC44LTQ3LjcgMTc3LjZcbi0zMjAuMyAxNzcuNlMxOTMuMSAzMjAuNiAxOTMuMSAyNDkuOGMwLTcxLjQgNDYuOS0xNzguMiAzMTkuNS0xNzguMnpcbm0zNjguMSAxNzguMmMwLTg2LjQtNjAuOS0yMTUuNC0zNjguMS0yMTUuNC0zMDYuNCAwLTM2Ny4zIDEyOS0zNjcuMyAyMTUuNCAwIDg1LjhcbjYwLjkgMjE0LjggMzY3LjMgMjE0LjggMzA3LjIgMCAzNjguMS0xMjkgMzY4LjEtMjE0Ljh6IiwKICBvaWludFNpemUyOiAiTTc1Ny44IDEwMC4xYzM4NC43IDAgNDUxLjEgMTM3LjYgNDUxLjEgMjMwIDAgOTEuMy02Ni40IDIyOC44XG4tNDUxLjEgMjI4LjgtMzg2LjMgMC00NTIuNy0xMzcuNS00NTIuNy0yMjguOCAwLTkyLjQgNjYuNC0yMzAgNDUyLjctMjMwelxubTUwMi40IDIzMGMwLTExMS4yLTgyLjQtMjc3LjItNTAyLjQtMjc3LjJzLTUwNCAxNjYtNTA0IDI3Ny4yXG5jMCAxMTAgODQgMjc2IDUwNCAyNzZzNTAyLjQtMTY2IDUwMi40LTI3NnoiLAogIG9paWludFNpemUxOiAiTTY4MS40IDcxLjZjNDA4LjkgMCA0ODAuNSAxMDYuOCA0ODAuNSAxNzguMiAwIDcwLjgtNzEuNiAxNzcuNlxuLTQ4MC41IDE3Ny42UzIwMi4xIDMyMC42IDIwMi4xIDI0OS44YzAtNzEuNCA3MC41LTE3OC4yIDQ3OS4zLTE3OC4yelxubTUyNS44IDE3OC4yYzAtODYuNC04Ni44LTIxNS40LTUyNS43LTIxNS40LTQzNy45IDAtNTI0LjcgMTI5LTUyNC43IDIxNS40IDBcbjg1LjggODYuOCAyMTQuOCA1MjQuNyAyMTQuOCA0MzguOSAwIDUyNS43LTEyOSA1MjUuNy0yMTQuOHoiLAogIG9paWludFNpemUyOiAiTTEwMjEuMiA1M2M2MDMuNiAwIDcwNy44IDE2NS44IDcwNy44IDI3Ny4yIDAgMTEwLTEwNC4yIDI3NS44XG4tNzA3LjggMjc1LjgtNjA2IDAtNzEwLjItMTY1LjgtNzEwLjItMjc1LjhDMzExIDIxOC44IDQxNS4yIDUzIDEwMjEuMiA1M3pcbm03NzAuNCAyNzcuMWMwLTEzMS4yLTEyNi40LTMyNy42LTc3MC41LTMyNy42UzI0OC40IDE5OC45IDI0OC40IDMzMC4xXG5jMCAxMzAgMTI4LjggMzI2LjQgNzcyLjcgMzI2LjRzNzcwLjUtMTk2LjQgNzcwLjUtMzI2LjR6IiwKICByaWdodGFycm93OiAiTTAgMjQxdjQwaDM5OTg5MWMtNDcuMyAzNS4zLTg0IDc4LTExMCAxMjhcbi0xNi43IDMyLTI3LjcgNjMuNy0zMyA5NSAwIDEuMy0uMiAyLjctLjUgNC0uMyAxLjMtLjUgMi4zLS41IDMgMCA3LjMgNi43IDExIDIwXG4gMTEgOCAwIDEzLjItLjggMTUuNS0yLjUgMi4zLTEuNyA0LjItNS41IDUuNS0xMS41IDItMTMuMyA1LjctMjcgMTEtNDEgMTQuNy00NC43XG4gMzktODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODVcbi00MC41LTExOS03NS41cy01OC4zLTc0LjgtNzMtMTE5LjVjLTQuNy0xNC04LjMtMjcuMy0xMS00MC0xLjMtNi43LTMuMi0xMC44LTUuNVxuLTEyLjUtMi4zLTEuNy03LjUtMi41LTE1LjUtMi41LTE0IDAtMjEgMy43LTIxIDExIDAgMiAyIDEwLjMgNiAyNSAyMC43IDgzLjMgNjdcbiAxNTEuNyAxMzkgMjA1em0wIDB2NDBoMzk5OTAwdi00MHoiLAogIHJpZ2h0YnJhY2U6ICJNNDAwMDAwIDU0Mmxcbi02IDZoLTE3Yy0xMi43IDAtMTkuMy0uMy0yMC0xLTQtNC03LjMtOC4zLTEwLTEzLTM1LjMtNTEuMy04MC44LTkzLjgtMTM2LjUtMTI3LjVcbnMtMTE3LjItNTUuOC0xODQuNS02Ni41Yy0uNyAwLTItLjMtNC0xLTE4LjctMi43LTc2LTQuMy0xNzItNUgwVjIxNGgzOTk1NzFsNiAxXG5jMTI0LjcgOCAyMzUgNjEuNyAzMzEgMTYxIDMxLjMgMzMuMyA1OS43IDcyLjcgODUgMTE4bDcgMTN2MzV6IiwKICByaWdodGJyYWNldW5kZXI6ICJNMzk5OTk0IDBsNiA2djM1bC02IDExYy01NiAxMDQtMTM1LjMgMTgxLjMtMjM4IDIzMi01Ny4zXG4gMjguNy0xMTcgNDUtMTc5IDUwSC0zMDBWMjE0aDM5OTg5N2M0My4zLTcgODEtMTUgMTEzLTI2IDEwMC43LTMzIDE3OS43LTkxIDIzN1xuLTE3NCAyLjctNSA2LTkgMTAtMTMgLjctMSA3LjMtMSAyMC0xaDE3eiIsCiAgcmlnaHRncm91cDogIk0wIDgwaDM5OTU2NWMzNzEgMCAyNjYuNyAxNDkuNCA0MTQgMTgwIDUuOSAxLjIgMTggMCAxOCAwIDIgMFxuIDMtMSAzLTN2LTM4Yy03Ni0xNTgtMjU3LTIxOS00MzUtMjE5SDB6IiwKICByaWdodGdyb3VwdW5kZXI6ICJNMCAyNjJoMzk5NTY1YzM3MSAwIDI2Ni43LTE0OS40IDQxNC0xODAgNS45LTEuMiAxOCAwIDE4XG4gMCAyIDAgMyAxIDMgM3YzOGMtNzYgMTU4LTI1NyAyMTktNDM1IDIxOUgweiIsCiAgcmlnaHRoYXJwb29uOiAiTTAgMjQxdjQwaDM5OTk5M2M0LjctNC43IDctOS4zIDctMTQgMC05LjNcbi0zLjctMTUuMy0xMS0xOC05Mi43LTU2LjctMTU5LTEzMy43LTE5OS0yMzEtMy4zLTkuMy02LTE0LjctOC0xNi0yLTEuMy03LTItMTUtMlxuLTEwLjcgMC0xNi43IDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OFxuIDY5LjIgOTIgOTQuNXptMCAwdjQwaDM5OTkwMHYtNDB6IiwKICByaWdodGhhcnBvb25wbHVzOiAiTTAgMjQxdjQwaDM5OTk5M2M0LjctNC43IDctOS4zIDctMTQgMC05LjMtMy43LTE1LjMtMTFcbi0xOC05Mi43LTU2LjctMTU5LTEzMy43LTE5OS0yMzEtMy4zLTkuMy02LTE0LjctOC0xNi0yLTEuMy03LTItMTUtMi0xMC43IDAtMTYuN1xuIDItMTggNi0yIDIuNy0xIDkuNyAzIDIxIDE1LjMgNDIgMzYuNyA4MS44IDY0IDExOS41IDI3LjMgMzcuNyA1OCA2OS4yIDkyIDk0LjV6XG5tMCAwdjQwaDM5OTkwMHYtNDB6IG0xMDAgMTk0djQwaDM5OTkwMHYtNDB6bTAgMHY0MGgzOTk5MDB2LTQweiIsCiAgcmlnaHRoYXJwb29uZG93bjogIk0zOTk3NDcgNTExYzAgNy4zIDYuNyAxMSAyMCAxMSA4IDAgMTMtLjggMTUtMi41czQuNy02LjhcbiA4LTE1LjVjNDAtOTQgOTkuMy0xNjYuMyAxNzgtMjE3IDEzLjMtOCAyMC4zLTEyLjMgMjEtMTMgNS4zLTMuMyA4LjUtNS44IDkuNVxuLTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zLTY0LjcgNTctOTIgOTVcbi0yNy4zIDM4LTQ4LjcgNzcuNy02NCAxMTktMy4zIDguNy01IDE0LTUgMTZ6TTAgMjQxdjQwaDM5OTkwMHYtNDB6IiwKICByaWdodGhhcnBvb25kb3ducGx1czogIk0zOTk3NDcgNzA1YzAgNy4zIDYuNyAxMSAyMCAxMSA4IDAgMTMtLjhcbiAxNS0yLjVzNC43LTYuOCA4LTE1LjVjNDAtOTQgOTkuMy0xNjYuMyAxNzgtMjE3IDEzLjMtOCAyMC4zLTEyLjMgMjEtMTMgNS4zLTMuM1xuIDguNS01LjggOS41LTcuNSAxLTEuNyAxLjUtNS4yIDEuNS0xMC41cy0yLjMtMTAuMy03LTE1SDB2NDBoMzk5OTA4Yy0zNCAyNS4zXG4tNjQuNyA1Ny05MiA5NS0yNy4zIDM4LTQ4LjcgNzcuNy02NCAxMTktMy4zIDguNy01IDE0LTUgMTZ6TTAgNDM1djQwaDM5OTkwMHYtNDB6XG5tMC0xOTR2NDBoNDAwMDAwdi00MHptMCAwdjQwaDQwMDAwMHYtNDB6IiwKICByaWdodGhvb2s6ICJNMzk5ODU5IDI0MWMtNzY0IDAgMCAwIDAgMCA0MC0zLjMgNjguNy0xNS43IDg2LTM3IDEwLTEyIDE1LTI1LjNcbiAxNS00MCAwLTIyLjctOS44LTQwLjctMjkuNS01NC0xOS43LTEzLjMtNDMuNS0yMS03MS41LTIzLTE3LjMtMS4zLTI2LTgtMjYtMjAgMFxuLTEzLjMgOC43LTIwIDI2LTIwIDM4IDAgNzEgMTEuMiA5OSAzMy41IDAgMCA3IDUuNiAyMSAxNi43IDE0IDExLjIgMjEgMzMuNSAyMVxuIDY2LjhzLTE0IDYxLjItNDIgODMuNWMtMjggMjIuMy02MSAzMy41LTk5IDMzLjVMMCAyNDF6IE0wIDI4MXYtNDBoMzk5ODU5djQweiIsCiAgcmlnaHRsaW5lc2VnbWVudDogIk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHpcbk0zOTk5NjAgMjQxIFY5NCBoNDAgVjQyOCBoLTQwIFYyODEgSDAgdi00MHoiLAogIHJpZ2h0VG9Gcm9tOiAiTTQwMDAwMCAxNjdjLTcwLjctNDItMTE4LTk3LjctMTQyLTE2N2gtMjNjLTE1LjMgMC0yMyAuMy0yM1xuIDEgMCAxLjMgNS4zIDEzLjcgMTYgMzcgMTggMzUuMyA0MS4zIDY5IDcwIDEwMWw3IDhIMHY0MGgzOTk5MDVsLTcgOGMtMjguNyAzMlxuLTUyIDY1LjctNzAgMTAxLTEwLjcgMjMuMy0xNiAzNS43LTE2IDM3IDAgLjcgNy43IDEgMjMgMWgyM2MyNC02OS4zIDcxLjMtMTI1IDE0MlxuLTE2N3ogTTEwMCAxNDd2NDBoMzk5OTAwdi00MHpNMCAzNDF2NDBoMzk5OTAwdi00MHoiLAogIC8vIHR3b2hlYWRsZWZ0YXJyb3cgaXMgZnJvbSBnbHlwaCBVKzIxOUUgaW4gZm9udCBLYVRlWCBBTVMgUmVndWxhcgogIHR3b2hlYWRsZWZ0YXJyb3c6ICJNMCAxNjdjNjggNDBcbiAxMTUuNyA5NS43IDE0MyAxNjdoMjJjMTUuMyAwIDIzLS4zIDIzLTEgMC0xLjMtNS4zLTEzLjctMTYtMzctMTgtMzUuMy00MS4zLTY5XG4tNzAtMTAxbC03LThoMTI1bDkgN2M1MC43IDM5LjMgODUgODYgMTAzIDE0MGg0NmMwLTQuNy02LjMtMTguNy0xOS00Mi0xOC0zNS4zXG4tNDAtNjcuMy02Ni05NmwtOS05aDM5OTcxNnYtNDBIMjg0bDktOWMyNi0yOC43IDQ4LTYwLjcgNjYtOTYgMTIuNy0yMy4zMzMgMTlcbi0zNy4zMzMgMTktNDJoLTQ2Yy0xOCA1NC01Mi4zIDEwMC43LTEwMyAxNDBsLTkgN0g5NWw3LThjMjguNy0zMiA1Mi02NS43IDcwLTEwMVxuIDEwLjctMjMuMzMzIDE2LTM1LjcgMTYtMzcgMC0uNy03LjctMS0yMy0xaC0yMkMxMTUuNyA3MS4zIDY4IDEyNyAwIDE2N3oiLAogIHR3b2hlYWRyaWdodGFycm93OiAiTTQwMDAwMCAxNjdcbmMtNjgtNDAtMTE1LjctOTUuNy0xNDMtMTY3aC0yMmMtMTUuMyAwLTIzIC4zLTIzIDEgMCAxLjMgNS4zIDEzLjcgMTYgMzcgMTggMzUuM1xuIDQxLjMgNjkgNzAgMTAxbDcgOGgtMTI1bC05LTdjLTUwLjctMzkuMy04NS04Ni0xMDMtMTQwaC00NmMwIDQuNyA2LjMgMTguNyAxOSA0MlxuIDE4IDM1LjMgNDAgNjcuMyA2NiA5Nmw5IDlIMHY0MGgzOTk3MTZsLTkgOWMtMjYgMjguNy00OCA2MC43LTY2IDk2LTEyLjcgMjMuMzMzXG4tMTkgMzcuMzMzLTE5IDQyaDQ2YzE4LTU0IDUyLjMtMTAwLjcgMTAzLTE0MGw5LTdoMTI1bC03IDhjLTI4LjcgMzItNTIgNjUuNy03MFxuIDEwMS0xMC43IDIzLjMzMy0xNiAzNS43LTE2IDM3IDAgLjcgNy43IDEgMjMgMWgyMmMyNy4zLTcxLjMgNzUtMTI3IDE0My0xNjd6IiwKICAvLyB0aWxkZTEgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIGEgZ2x5cGggZnJvbSB0aGUgTW5TeW1ib2wgcGFja2FnZQogIHRpbGRlMTogIk0yMDAgNTUuNTM4Yy03NyAwLTE2OCA3My45NTMtMTc3IDczLjk1My0zIDAtN1xuLTIuMTc1LTktNS40MzdMMiA5N2MtMS0yLTItNC0yLTYgMC00IDItNyA1LTlsMjAtMTJDMTE2IDEyIDE3MSAwIDIwNyAwYzg2IDBcbiAxMTQgNjggMTkxIDY4IDc4IDAgMTY4LTY4IDE3Ny02OCA0IDAgNyAyIDkgNWwxMiAxOWMxIDIuMTc1IDIgNC4zNSAyIDYuNTI1IDBcbiA0LjM1LTIgNy42MTMtNSA5Ljc4OGwtMTkgMTMuMDVjLTkyIDYzLjA3Ny0xMTYuOTM3IDc1LjMwOC0xODMgNzYuMTI4XG4tNjguMjY3Ljg0Ny0xMTMtNzMuOTUyLTE5MS03My45NTJ6IiwKICAvLyBkaXR0byB0aWxkZTIsIHRpbGRlMywgJiB0aWxkZTQKICB0aWxkZTI6ICJNMzQ0IDU1LjI2NmMtMTQyIDAtMzAwLjYzOCA4MS4zMTYtMzExLjUgODYuNDE4XG4tOC4wMSAzLjc2Mi0yMi41IDEwLjkxLTIzLjUgNS41NjJMMSAxMjBjLTEtMi0xLTMtMS00IDAtNSAzLTkgOC0xMGwxOC40LTlDMTYwLjlcbiAzMS45IDI4MyAwIDM1OCAwYzE0OCAwIDE4OCAxMjIgMzMxIDEyMnMzMTQtOTcgMzI2LTk3YzQgMCA4IDIgMTAgN2w3IDIxLjExNFxuYzEgMi4xNCAxIDMuMjEgMSA0LjI4IDAgNS4zNDctMyA5LjYyNi03IDEwLjY5NmwtMjIuMyAxMi42MjJDODUyLjYgMTU4LjM3MiA3NTFcbiAxODEuNDc2IDY3NiAxODEuNDc2Yy0xNDkgMC0xODktMTI2LjIxLTMzMi0xMjYuMjF6IiwKICB0aWxkZTM6ICJNNzg2IDU5QzQ1NyA1OSAzMiAxNzUuMjQyIDEzIDE3NS4yNDJjLTYgMC0xMC0zLjQ1N1xuLTExLTEwLjM3TC4xNSAxMzhjLTEtNyAzLTEyIDEwLTEzbDE5LjItNi40QzM3OC40IDQwLjcgNjM0LjMgMCA4MDQuMyAwYzMzNyAwXG4gNDExLjggMTU3IDc0Ni44IDE1NyAzMjggMCA3NTQtMTEyIDc3My0xMTIgNSAwIDEwIDMgMTEgOWwxIDE0LjA3NWMxIDguMDY2LS42OTdcbiAxNi41OTUtNi42OTcgMTcuNDkybC0yMS4wNTIgNy4zMWMtMzY3LjkgOTguMTQ2LTYwOS4xNSAxMjIuNjk2LTc3OC4xNSAxMjIuNjk2XG4gLTMzOCAwLTQwOS0xNTYuNTczLTc0NC0xNTYuNTczeiIsCiAgdGlsZGU0OiAiTTc4NiA1OEM0NTcgNTggMzIgMTc3LjQ4NyAxMyAxNzcuNDg3Yy02IDAtMTAtMy4zNDVcbi0xMS0xMC4wMzVMLjE1IDE0M2MtMS03IDMtMTIgMTAtMTNsMjItNi43QzM4MS4yIDM1IDYzNy4xNSAwIDgwNy4xNSAwYzMzNyAwIDQwOVxuIDE3NyA3NDQgMTc3IDMyOCAwIDc1NC0xMjcgNzczLTEyNyA1IDAgMTAgMyAxMSA5bDEgMTQuNzk0YzEgNy44MDUtMyAxMy4zOC05XG4gMTQuNDk1bC0yMC43IDUuNTc0Yy0zNjYuODUgOTkuNzktNjA3LjMgMTM5LjM3Mi03NzYuMyAxMzkuMzcyLTMzOCAwLTQwOVxuIC0xNzUuMjM2LTc0NC0xNzUuMjM2eiIsCiAgLy8gdmVjIGlzIGZyb20gZ2x5cGggVSsyMEQ3IGluIGZvbnQgS2FUZVggTWFpbgogIHZlYzogIk0zNzcgMjBjMC01LjMzMyAxLjgzMy0xMCA1LjUtMTRTMzkxIDAgMzk3IDBjNC42NjcgMCA4LjY2NyAxLjY2NyAxMiA1XG4zLjMzMyAyLjY2NyA2LjY2NyA5IDEwIDE5IDYuNjY3IDI0LjY2NyAyMC4zMzMgNDMuNjY3IDQxIDU3IDcuMzMzIDQuNjY3IDExXG4xMC42NjcgMTEgMTggMCA2LTEgMTAtMyAxMnMtNi42NjcgNS0xNCA5Yy0yOC42NjcgMTQuNjY3LTUzLjY2NyAzNS42NjctNzUgNjNcbi0xLjMzMyAxLjMzMy0zLjE2NyAzLjUtNS41IDYuNXMtNCA0LjgzMy01IDUuNWMtMSAuNjY3LTIuNSAxLjMzMy00LjUgMnMtNC4zMzMgMVxuLTcgMWMtNC42NjcgMC05LjE2Ny0xLjgzMy0xMy41LTUuNVMzMzcgMTg0IDMzNyAxNzhjMC0xMi42NjcgMTUuNjY3LTMyLjMzMyA0Ny01OVxuSDIxM2wtMTcxLTFjLTguNjY3LTYtMTMtMTIuMzMzLTEzLTE5IDAtNC42NjcgNC4zMzMtMTEuMzMzIDEzLTIwaDM1OVxuYy0xNi0yNS4zMzMtMjQtNDUtMjQtNTl6IiwKICAvLyB3aWRlaGF0MSBpcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgYSBnbHlwaCBmcm9tIHRoZSBNblN5bWJvbCBwYWNrYWdlCiAgd2lkZWhhdDE6ICJNNTI5IDBoNWw1MTkgMTE1YzUgMSA5IDUgOSAxMCAwIDEtMSAyLTEgM2wtNCAyMlxuYy0xIDUtNSA5LTExIDloLTJMNTMyIDY3IDE5IDE1OWgtMmMtNSAwLTktNC0xMS05bC01LTIyYy0xLTYgMi0xMiA4LTEzeiIsCiAgLy8gZGl0dG8gd2lkZWhhdDIsIHdpZGVoYXQzLCAmIHdpZGVoYXQ0CiAgd2lkZWhhdDI6ICJNMTE4MSAwaDJsMTE3MSAxNzZjNiAwIDEwIDUgMTAgMTFsLTIgMjNjLTEgNi01IDEwXG4tMTEgMTBoLTFMMTE4MiA2NyAxNSAyMjBoLTFjLTYgMC0xMC00LTExLTEwbC0yLTIzYy0xLTYgNC0xMSAxMC0xMXoiLAogIHdpZGVoYXQzOiAiTTExODEgMGgybDExNzEgMjM2YzYgMCAxMCA1IDEwIDExbC0yIDIzYy0xIDYtNSAxMFxuLTExIDEwaC0xTDExODIgNjcgMTUgMjgwaC0xYy02IDAtMTAtNC0xMS0xMGwtMi0yM2MtMS02IDQtMTEgMTAtMTF6IiwKICB3aWRlaGF0NDogIk0xMTgxIDBoMmwxMTcxIDI5NmM2IDAgMTAgNSAxMCAxMWwtMiAyM2MtMSA2LTUgMTBcbi0xMSAxMGgtMUwxMTgyIDY3IDE1IDM0MGgtMWMtNiAwLTEwLTQtMTEtMTBsLTItMjNjLTEtNiA0LTExIDEwLTExeiIsCiAgLy8gd2lkZWNoZWNrIHBhdGhzIGFyZSBhbGwgaW52ZXJ0ZWQgdmVyc2lvbnMgb2Ygd2lkZWhhdAogIHdpZGVjaGVjazE6ICJNNTI5LDE1OWg1bDUxOSwtMTE1YzUsLTEsOSwtNSw5LC0xMGMwLC0xLC0xLC0yLC0xLC0zbC00LC0yMmMtMSxcbi01LC01LC05LC0xMSwtOWgtMmwtNTEyLDkybC01MTMsLTkyaC0yYy01LDAsLTksNCwtMTEsOWwtNSwyMmMtMSw2LDIsMTIsOCwxM3oiLAogIHdpZGVjaGVjazI6ICJNMTE4MSwyMjBoMmwxMTcxLC0xNzZjNiwwLDEwLC01LDEwLC0xMWwtMiwtMjNjLTEsLTYsLTUsLTEwLFxuLTExLC0xMGgtMWwtMTE2OCwxNTNsLTExNjcsLTE1M2gtMWMtNiwwLC0xMCw0LC0xMSwxMGwtMiwyM2MtMSw2LDQsMTEsMTAsMTF6IiwKICB3aWRlY2hlY2szOiAiTTExODEsMjgwaDJsMTE3MSwtMjM2YzYsMCwxMCwtNSwxMCwtMTFsLTIsLTIzYy0xLC02LC01LC0xMCxcbi0xMSwtMTBoLTFsLTExNjgsMjEzbC0xMTY3LC0yMTNoLTFjLTYsMCwtMTAsNCwtMTEsMTBsLTIsMjNjLTEsNiw0LDExLDEwLDExeiIsCiAgd2lkZWNoZWNrNDogIk0xMTgxLDM0MGgybDExNzEsLTI5NmM2LDAsMTAsLTUsMTAsLTExbC0yLC0yM2MtMSwtNiwtNSwtMTAsXG4tMTEsLTEwaC0xbC0xMTY4LDI3M2wtMTE2NywtMjczaC0xYy02LDAsLTEwLDQsLTExLDEwbC0yLDIzYy0xLDYsNCwxMSwxMCwxMXoiLAogIC8vIFRoZSBuZXh0IHRlbiBwYXRocyBzdXBwb3J0IHJlYWN0aW9uIGFycm93cyBmcm9tIHRoZSBtaGNoZW0gcGFja2FnZS4KICAvLyBBcnJvd3MgZm9yIFxjZXs8LS0+fSBhcmUgb2Zmc2V0IGZyb20geEF4aXMgYnkgMC4yMmV4LCBwZXIgbWhjaGVtIGluIExhVGVYCiAgLy8gYmFyYWJvdmVsZWZ0YXJyb3cgaXMgbW9zdGx5IGZyb20gZ2x5cGggVSsyMTkwIGluIGZvbnQgS2FUZVggTWFpbgogIGJhcmFib3ZlbGVmdGFycm93OiAiTTQwMDAwMCA2MjBoLTM5OTg5MGwzIC0zYzY4LjcgLTUyLjcgMTEzLjcgLTEyMCAxMzUgLTIwMlxuYzQgLTE0LjcgNiAtMjMgNiAtMjVjMCAtNy4zIC03IC0xMSAtMjEgLTExYy04IDAgLTEzLjIgMC44IC0xNS41IDIuNVxuYy0yLjMgMS43IC00LjIgNS44IC01LjUgMTIuNWMtMS4zIDQuNyAtMi43IDEwLjMgLTQgMTdjLTEyIDQ4LjcgLTM0LjggOTIgLTY4LjUgMTMwXG5zLTc0LjIgNjYuMyAtMTIxLjUgODVjLTEwIDQgLTE2IDcuNyAtMTggMTFjMCA4LjcgNiAxNC4zIDE4IDE3YzQ3LjMgMTguNyA4Ny44IDQ3XG4xMjEuNSA4NXM1Ni41IDgxLjMgNjguNSAxMzBjMC43IDIgMS4zIDUgMiA5czEuMiA2LjcgMS41IDhjMC4zIDEuMyAxIDMuMyAyIDZcbnMyLjIgNC41IDMuNSA1LjVjMS4zIDEgMy4zIDEuOCA2IDIuNXM2IDEgMTAgMWMxNCAwIDIxIC0zLjcgMjEgLTExXG5jMCAtMiAtMiAtMTAuMyAtNiAtMjVjLTIwIC03OS4zIC02NSAtMTQ2LjcgLTEzNSAtMjAybC0zIC0zaDM5OTg5MHpcbk0xMDAgNjIwdjQwaDM5OTkwMHYtNDB6IE0wIDI0MXY0MGgzOTk5MDB2LTQwek0wIDI0MXY0MGgzOTk5MDB2LTQweiIsCiAgLy8gcmlnaHRhcnJvd2Fib3ZlYmFyIGlzIG1vc3RseSBmcm9tIGdseXBoIFUrMjE5MiwgS2FUZVggTWFpbgogIHJpZ2h0YXJyb3dhYm92ZWJhcjogIk0wIDI0MXY0MGgzOTk4OTFjLTQ3LjMgMzUuMy04NCA3OC0xMTAgMTI4LTE2LjcgMzJcbi0yNy43IDYzLjctMzMgOTUgMCAxLjMtLjIgMi43LS41IDQtLjMgMS4zLS41IDIuMy0uNSAzIDAgNy4zIDYuNyAxMSAyMCAxMSA4IDBcbjEzLjItLjggMTUuNS0yLjUgMi4zLTEuNyA0LjItNS41IDUuNS0xMS41IDItMTMuMyA1LjctMjcgMTEtNDEgMTQuNy00NC43IDM5XG4tODQuNSA3My0xMTkuNXM3My43LTYwLjIgMTE5LTc1LjVjNi0yIDktNS43IDktMTFzLTMtOS05LTExYy00NS4zLTE1LjMtODUtNDAuNVxuLTExOS03NS41cy01OC4zLTc0LjgtNzMtMTE5LjVjLTQuNy0xNC04LjMtMjcuMy0xMS00MC0xLjMtNi43LTMuMi0xMC44LTUuNVxuLTEyLjUtMi4zLTEuNy03LjUtMi41LTE1LjUtMi41LTE0IDAtMjEgMy43LTIxIDExIDAgMiAyIDEwLjMgNiAyNSAyMC43IDgzLjMgNjdcbjE1MS43IDEzOSAyMDV6bTk2IDM3OWgzOTk4OTR2NDBIMHptMCAwaDM5OTkwNHY0MEgweiIsCiAgLy8gVGhlIHNob3J0IGxlZnQgaGFycG9vbiBoYXMgMC41ZW0gKGkuZS4gNTAwIHVuaXRzKSBrZXJuIG9uIHRoZSBsZWZ0IGVuZC4KICAvLyBSZWYgZnJvbSBtaGNoZW0uc3R5OiBccmxhcHtccmFpc2Vib3h7LS4yMmV4fXskXGtlcm4wLjVlbQogIGJhcmFib3Zlc2hvcnRsZWZ0aGFycG9vbjogIk01MDcsNDM1Yy00LDQsLTYuMyw4LjcsLTcsMTRjMCw1LjMsMC43LDksMiwxMVxuYzEuMywyLDUuMyw1LjMsMTIsMTBjOTAuNyw1NCwxNTYsMTMwLDE5NiwyMjhjMy4zLDEwLjcsNi4zLDE2LjMsOSwxN1xuYzIsMC43LDUsMSw5LDFjMCwwLDUsMCw1LDBjMTAuNywwLDE2LjcsLTIsMTgsLTZjMiwtMi43LDEsLTkuNywtMywtMjFcbmMtMzIsLTg3LjMsLTgyLjcsLTE1Ny43LC0xNTIsLTIxMWMwLDAsLTMsLTMsLTMsLTNsMzk5MzUxLDBsMCwtNDBcbmMtMzk4NTcwLDAsLTM5OTQzNywwLC0zOTk0MzcsMHogTTU5MyA0MzUgdjQwIEgzOTk1MDAgdi00MHpcbk0wIDI4MSB2LTQwIEgzOTk5MDggdjQweiBNMCAyODEgdi00MCBIMzk5OTA4IHY0MHoiLAogIHJpZ2h0aGFycG9vbmFib3Zlc2hvcnRiYXI6ICJNMCwyNDEgbDAsNDBjMzk5MTI2LDAsMzk5OTkzLDAsMzk5OTkzLDBcbmM0LjcsLTQuNyw3LC05LjMsNywtMTRjMCwtOS4zLC0zLjcsLTE1LjMsLTExLC0xOGMtOTIuNywtNTYuNywtMTU5LC0xMzMuNywtMTk5LFxuLTIzMWMtMy4zLC05LjMsLTYsLTE0LjcsLTgsLTE2Yy0yLC0xLjMsLTcsLTIsLTE1LC0yYy0xMC43LDAsLTE2LjcsMiwtMTgsNlxuYy0yLDIuNywtMSw5LjcsMywyMWMxNS4zLDQyLDM2LjcsODEuOCw2NCwxMTkuNWMyNy4zLDM3LjcsNTgsNjkuMiw5Miw5NC41elxuTTAgMjQxIHY0MCBIMzk5OTA4IHYtNDB6IE0wIDQ3NSB2LTQwIEgzOTk1MDAgdjQweiBNMCA0NzUgdi00MCBIMzk5NTAwIHY0MHoiLAogIHNob3J0YmFyYWJvdmVsZWZ0aGFycG9vbjogIk03LDQzNWMtNCw0LC02LjMsOC43LC03LDE0YzAsNS4zLDAuNyw5LDIsMTFcbmMxLjMsMiw1LjMsNS4zLDEyLDEwYzkwLjcsNTQsMTU2LDEzMCwxOTYsMjI4YzMuMywxMC43LDYuMywxNi4zLDksMTdjMiwwLjcsNSwxLDksXG4xYzAsMCw1LDAsNSwwYzEwLjcsMCwxNi43LC0yLDE4LC02YzIsLTIuNywxLC05LjcsLTMsLTIxYy0zMiwtODcuMywtODIuNywtMTU3LjcsXG4tMTUyLC0yMTFjMCwwLC0zLC0zLC0zLC0zbDM5OTkwNywwbDAsLTQwYy0zOTkxMjYsMCwtMzk5OTkzLDAsLTM5OTk5MywwelxuTTkzIDQzNSB2NDAgSDQwMDAwMCB2LTQweiBNNTAwIDI0MSB2NDAgSDQwMDAwMCB2LTQweiBNNTAwIDI0MSB2NDAgSDQwMDAwMCB2LTQweiIsCiAgc2hvcnRyaWdodGhhcnBvb25hYm92ZWJhcjogIk01MywyNDFsMCw0MGMzOTg1NzAsMCwzOTk0MzcsMCwzOTk0MzcsMFxuYzQuNywtNC43LDcsLTkuMyw3LC0xNGMwLC05LjMsLTMuNywtMTUuMywtMTEsLTE4Yy05Mi43LC01Ni43LC0xNTksLTEzMy43LC0xOTksXG4tMjMxYy0zLjMsLTkuMywtNiwtMTQuNywtOCwtMTZjLTIsLTEuMywtNywtMiwtMTUsLTJjLTEwLjcsMCwtMTYuNywyLC0xOCw2XG5jLTIsMi43LC0xLDkuNywzLDIxYzE1LjMsNDIsMzYuNyw4MS44LDY0LDExOS41YzI3LjMsMzcuNyw1OCw2OS4yLDkyLDk0LjV6XG5NNTAwIDI0MSB2NDAgSDM5OTQwOCB2LTQweiBNNTAwIDQzNSB2NDAgSDQwMDAwMCB2LTQweiIKfTsKdmFyIHRhbGxEZWxpbSA9IGZ1bmN0aW9uIHRhbGxEZWxpbTIobGFiZWwsIG1pZEhlaWdodCkgewogIHN3aXRjaCAobGFiZWwpIHsKICAgIGNhc2UgImxicmFjayI6CiAgICAgIHJldHVybiAiTTQwMyAxNzU5IFY4NCBINjY2IFYwIEgzMTkgVjE3NTkgdiIgKyBtaWRIZWlnaHQgKyAiIHYxNzU5IGgzNDcgdi04NFxuSDQwM3ogTTQwMyAxNzU5IFYwIEgzMTkgVjE3NTkgdiIgKyBtaWRIZWlnaHQgKyAiIHYxNzU5IGg4NHoiOwogICAgY2FzZSAicmJyYWNrIjoKICAgICAgcmV0dXJuICJNMzQ3IDE3NTkgVjAgSDAgVjg0IEgyNjMgVjE3NTkgdiIgKyBtaWRIZWlnaHQgKyAiIHYxNzU5IEgwIHY4NCBIMzQ3elxuTTM0NyAxNzU5IFYwIEgyNjMgVjE3NTkgdiIgKyBtaWRIZWlnaHQgKyAiIHYxNzU5IGg4NHoiOwogICAgY2FzZSAidmVydCI6CiAgICAgIHJldHVybiAiTTE0NSAxNSB2NTg1IHYiICsgbWlkSGVpZ2h0ICsgIiB2NTg1IGMyLjY2NywxMCw5LjY2NywxNSwyMSwxNVxuYzEwLDAsMTYuNjY3LC01LDIwLC0xNSB2LTU4NSB2IiArIC1taWRIZWlnaHQgKyAiIHYtNTg1IGMtMi42NjcsLTEwLC05LjY2NywtMTUsLTIxLC0xNVxuYy0xMCwwLC0xNi42NjcsNSwtMjAsMTV6IE0xODggMTUgSDE0NSB2NTg1IHYiICsgbWlkSGVpZ2h0ICsgIiB2NTg1IGg0M3oiOwogICAgY2FzZSAiZG91YmxldmVydCI6CiAgICAgIHJldHVybiAiTTE0NSAxNSB2NTg1IHYiICsgbWlkSGVpZ2h0ICsgIiB2NTg1IGMyLjY2NywxMCw5LjY2NywxNSwyMSwxNVxuYzEwLDAsMTYuNjY3LC01LDIwLC0xNSB2LTU4NSB2IiArIC1taWRIZWlnaHQgKyAiIHYtNTg1IGMtMi42NjcsLTEwLC05LjY2NywtMTUsLTIxLC0xNVxuYy0xMCwwLC0xNi42NjcsNSwtMjAsMTV6IE0xODggMTUgSDE0NSB2NTg1IHYiICsgbWlkSGVpZ2h0ICsgIiB2NTg1IGg0M3pcbk0zNjcgMTUgdjU4NSB2IiArIG1pZEhlaWdodCArICIgdjU4NSBjMi42NjcsMTAsOS42NjcsMTUsMjEsMTVcbmMxMCwwLDE2LjY2NywtNSwyMCwtMTUgdi01ODUgdiIgKyAtbWlkSGVpZ2h0ICsgIiB2LTU4NSBjLTIuNjY3LC0xMCwtOS42NjcsLTE1LC0yMSwtMTVcbmMtMTAsMCwtMTYuNjY3LDUsLTIwLDE1eiBNNDEwIDE1IEgzNjcgdjU4NSB2IiArIG1pZEhlaWdodCArICIgdjU4NSBoNDN6IjsKICAgIGNhc2UgImxmbG9vciI6CiAgICAgIHJldHVybiAiTTMxOSA2MDIgVjAgSDQwMyBWNjAyIHYiICsgbWlkSGVpZ2h0ICsgIiB2MTcxNSBoMjYzIHY4NCBIMzE5elxuTU0zMTkgNjAyIFYwIEg0MDMgVjYwMiB2IiArIG1pZEhlaWdodCArICIgdjE3MTUgSDMxOXoiOwogICAgY2FzZSAicmZsb29yIjoKICAgICAgcmV0dXJuICJNMzE5IDYwMiBWMCBINDAzIFY2MDIgdiIgKyBtaWRIZWlnaHQgKyAiIHYxNzk5IEgwIHYtODQgSDMxOXpcbk1NMzE5IDYwMiBWMCBINDAzIFY2MDIgdiIgKyBtaWRIZWlnaHQgKyAiIHYxNzE1IEgzMTl6IjsKICAgIGNhc2UgImxjZWlsIjoKICAgICAgcmV0dXJuICJNNDAzIDE3NTkgVjg0IEg2NjYgVjAgSDMxOSBWMTc1OSB2IiArIG1pZEhlaWdodCArICIgdjYwMiBoODR6XG5NNDAzIDE3NTkgVjAgSDMxOSBWMTc1OSB2IiArIG1pZEhlaWdodCArICIgdjYwMiBoODR6IjsKICAgIGNhc2UgInJjZWlsIjoKICAgICAgcmV0dXJuICJNMzQ3IDE3NTkgVjAgSDAgVjg0IEgyNjMgVjE3NTkgdiIgKyBtaWRIZWlnaHQgKyAiIHY2MDIgaDg0elxuTTM0NyAxNzU5IFYwIGgtODQgVjE3NTkgdiIgKyBtaWRIZWlnaHQgKyAiIHY2MDIgaDg0eiI7CiAgICBjYXNlICJscGFyZW4iOgogICAgICByZXR1cm4gIk04NjMsOWMwLC0yLC0yLC01LC02LC05YzAsMCwtMTcsMCwtMTcsMGMtMTIuNywwLC0xOS4zLDAuMywtMjAsMVxuYy01LjMsNS4zLC0xMC4zLDExLC0xNSwxN2MtMjQyLjcsMjk0LjcsLTM5NS4zLDY4MiwtNDU4LDExNjJjLTIxLjMsMTYzLjMsLTMzLjMsMzQ5LFxuLTM2LDU1NyBsMCwiICsgKG1pZEhlaWdodCArIDg0KSArICJjMC4yLDYsMCwyNiwwLDYwYzIsMTU5LjMsMTAsMzEwLjcsMjQsNDU0YzUzLjMsNTI4LDIxMCxcbjk0OS43LDQ3MCwxMjY1YzQuNyw2LDkuNywxMS43LDE1LDE3YzAuNywwLjcsNywxLDE5LDFjMCwwLDE4LDAsMTgsMGM0LC00LDYsLTcsNiwtOVxuYzAsLTIuNywtMy4zLC04LjcsLTEwLC0xOGMtMTM1LjMsLTE5Mi43LC0yMzUuNSwtNDE0LjMsLTMwMC41LC02NjVjLTY1LC0yNTAuNywtMTAyLjUsXG4tNTQ0LjcsLTExMi41LC04ODJjLTIsLTEwNCwtMywtMTY3LC0zLC0xODlcbmwwLC0iICsgKG1pZEhlaWdodCArIDkyKSArICJjMCwtMTYyLjcsNS43LC0zMTQsMTcsLTQ1NGMyMC43LC0yNzIsNjMuNywtNTEzLDEyOSwtNzIzYzY1LjMsXG4tMjEwLDE1NS4zLC0zOTYuMywyNzAsLTU1OWM2LjcsLTkuMywxMCwtMTUuMywxMCwtMTh6IjsKICAgIGNhc2UgInJwYXJlbiI6CiAgICAgIHJldHVybiAiTTc2LDBjLTE2LjcsMCwtMjUsMywtMjUsOWMwLDIsMiw2LjMsNiwxM2MyMS4zLDI4LjcsNDIuMyw2MC4zLFxuNjMsOTVjOTYuNywxNTYuNywxNzIuOCwzMzIuNSwyMjguNSw1MjcuNWM1NS43LDE5NSw5Mi44LDQxNi41LDExMS41LDY2NC41XG5jMTEuMywxMzkuMywxNywyOTAuNywxNyw0NTRjMCwyOCwxLjcsNDMsMy4zLDQ1bDAsIiArIChtaWRIZWlnaHQgKyA5KSArICJcbmMtMyw0LC0zLjMsMTYuNywtMy4zLDM4YzAsMTYyLC01LjcsMzEzLjcsLTE3LDQ1NWMtMTguNywyNDgsLTU1LjgsNDY5LjMsLTExMS41LDY2NFxuYy01NS43LDE5NC43LC0xMzEuOCwzNzAuMywtMjI4LjUsNTI3Yy0yMC43LDM0LjcsLTQxLjcsNjYuMywtNjMsOTVjLTIsMy4zLC00LDcsLTYsMTFcbmMwLDcuMyw1LjcsMTEsMTcsMTFjMCwwLDExLDAsMTEsMGM5LjMsMCwxNC4zLC0wLjMsMTUsLTFjNS4zLC01LjMsMTAuMywtMTEsMTUsLTE3XG5jMjQyLjcsLTI5NC43LDM5NS4zLC02ODEuNyw0NTgsLTExNjFjMjEuMywtMTY0LjcsMzMuMywtMzUwLjcsMzYsLTU1OFxubDAsLSIgKyAobWlkSGVpZ2h0ICsgMTQ0KSArICJjLTIsLTE1OS4zLC0xMCwtMzEwLjcsLTI0LC00NTRjLTUzLjMsLTUyOCwtMjEwLC05NDkuNyxcbi00NzAsLTEyNjVjLTQuNywtNiwtOS43LC0xMS43LC0xNSwtMTdjLTAuNywtMC43LC02LjcsLTEsLTE4LC0xeiI7CiAgICBkZWZhdWx0OgogICAgICB0aHJvdyBuZXcgRXJyb3IoIlVua25vd24gc3RyZXRjaHkgZGVsaW1pdGVyLiIpOwogIH0KfTsKdmFyIERvY3VtZW50RnJhZ21lbnQgPSBjbGFzcyB7CiAgLy8gSHRtbERvbU5vZGUKICAvLyBOZXZlciB1c2VkOyBuZWVkZWQgZm9yIHNhdGlzZnlpbmcgaW50ZXJmYWNlLgogIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7CiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwOwogICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwOwogICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7CiAgICB0aGlzLmRlcHRoID0gdm9pZCAwOwogICAgdGhpcy5tYXhGb250U2l6ZSA9IHZvaWQgMDsKICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7CiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47CiAgICB0aGlzLmNsYXNzZXMgPSBbXTsKICAgIHRoaXMuaGVpZ2h0ID0gMDsKICAgIHRoaXMuZGVwdGggPSAwOwogICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7CiAgICB0aGlzLnN0eWxlID0ge307CiAgfQogIGhhc0NsYXNzKGNsYXNzTmFtZSkgewogICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTsKICB9CiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gYSBub2RlLiAqLwogIHRvTm9kZSgpIHsKICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICAgIGZyYWcuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7CiAgICB9CiAgICByZXR1cm4gZnJhZzsKICB9CiAgLyoqIENvbnZlcnQgdGhlIGZyYWdtZW50IGludG8gSFRNTCBtYXJrdXAuICovCiAgdG9NYXJrdXAoKSB7CiAgICB2YXIgbWFya3VwID0gIiI7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTsKICAgIH0KICAgIHJldHVybiBtYXJrdXA7CiAgfQogIC8qKgogICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQuIEFwcGxpZXMgdG8KICAgKiBNYXRoRG9tTm9kZSdzIG9ubHkuCiAgICovCiAgdG9UZXh0KCkgewogICAgdmFyIHRvVGV4dCA9IChjaGlsZCkgPT4gY2hpbGQudG9UZXh0KCk7CiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAodG9UZXh0KS5qb2luKCIiKTsKICB9Cn07CnZhciBmb250TWV0cmljc0RhdGEgPSB7CiAgIkFNUy1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjY1IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLAogICAgIjY2IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLAogICAgIjY3IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLAogICAgIjY4IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLAogICAgIjY5IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjY2NjddLAogICAgIjcwIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLAogICAgIjcxIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLAogICAgIjcyIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzc3NzhdLAogICAgIjczIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuMzg4ODldLAogICAgIjc0IjogWzAuMTY2NjcsIDAuNjg4ODksIDAsIDAsIDAuNV0sCiAgICAiNzUiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNzYiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sCiAgICAiNzciOiBbMCwgMC42ODg4OSwgMCwgMCwgMC45NDQ0NV0sCiAgICAiNzgiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sCiAgICAiNzkiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODAiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sCiAgICAiODEiOiBbMC4xNjY2NywgMC42ODg4OSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODIiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sCiAgICAiODMiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sCiAgICAiODQiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sCiAgICAiODUiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sCiAgICAiODYiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sCiAgICAiODciOiBbMCwgMC42ODg4OSwgMCwgMCwgMV0sCiAgICAiODgiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sCiAgICAiODkiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC43MjIyMl0sCiAgICAiOTAiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sCiAgICAiMTA3IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLAogICAgIjE2MCI6IFswLCAwLCAwLCAwLCAwLjI1XSwKICAgICIxNjUiOiBbMCwgMC42NzUsIDAuMDI1LCAwLCAwLjc1XSwKICAgICIxNzQiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMCwgMC45NDY2Nl0sCiAgICAiMjQwIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNTU1NTZdLAogICAgIjI5NSI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSwKICAgICI3MTAiOiBbMCwgMC44MjUsIDAsIDAsIDIuMzMzMzRdLAogICAgIjczMiI6IFswLCAwLjksIDAsIDAsIDIuMzMzMzRdLAogICAgIjc3MCI6IFswLCAwLjgyNSwgMCwgMCwgMi4zMzMzNF0sCiAgICAiNzcxIjogWzAsIDAuOSwgMCwgMCwgMi4zMzMzNF0sCiAgICAiOTg5IjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjEwMDgiOiBbMCwgMC40MzA1NiwgMC4wNDAyOCwgMCwgMC42NjY2N10sCiAgICAiODI0NSI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjI3NV0sCiAgICAiODQ2MyI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSwKICAgICI4NDg3IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLAogICAgIjg0OTgiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sCiAgICAiODUwMiI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4NTAzIjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNDQ0NDVdLAogICAgIjg1MDQiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42NjY2N10sCiAgICAiODUxMyI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjYzODg5XSwKICAgICI4NTkyIjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjVdLAogICAgIjg1OTQiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sCiAgICAiODYwMiI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMV0sCiAgICAiODYwMyI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMV0sCiAgICAiODYwNiI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxXSwKICAgICI4NjA4IjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDFdLAogICAgIjg2MTAiOiBbMC4wMTM1NCwgMC41MjIzOSwgMCwgMCwgMS4xMTExMV0sCiAgICAiODYxMSI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxLjExMTExXSwKICAgICI4NjE5IjogWzAsIDAuNTQ5ODYsIDAsIDAsIDFdLAogICAgIjg2MjAiOiBbMCwgMC41NDk4NiwgMCwgMCwgMV0sCiAgICAiODYyMSI6IFstMC4xMzMxMywgMC4zNzc4OCwgMCwgMCwgMS4zODg4OV0sCiAgICAiODYyMiI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMV0sCiAgICAiODYyNCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLAogICAgIjg2MjUiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSwKICAgICI4NjMwIjogWzAsIDAuNDMwNTYsIDAsIDAsIDFdLAogICAgIjg2MzEiOiBbMCwgMC40MzA1NiwgMCwgMCwgMV0sCiAgICAiODYzNCI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NjM1IjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg2MzgiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sCiAgICAiODYzOSI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjQxNjY3XSwKICAgICI4NjQyIjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNDE2NjddLAogICAgIjg2NDMiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC40MTY2N10sCiAgICAiODY0NCI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAxXSwKICAgICI4NjQ2IjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDFdLAogICAgIjg2NDciOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMV0sCiAgICAiODY0OCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjgzMzM0XSwKICAgICI4NjQ5IjogWzAuMTgwOCwgMC42NzUsIDAsIDAsIDFdLAogICAgIjg2NTAiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sCiAgICAiODY1MSI6IFswLjAxMzU0LCAwLjUyMjM5LCAwLCAwLCAxXSwKICAgICI4NjUyIjogWzAuMDEzNTQsIDAuNTIyMzksIDAsIDAsIDFdLAogICAgIjg2NTMiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NTQiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NTUiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NjYiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMV0sCiAgICAiODY2NyI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAxXSwKICAgICI4NjY5IjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAxXSwKICAgICI4NjcyIjogWy0wLjA2NCwgMC40MzcsIDAsIDAsIDEuMzM0XSwKICAgICI4Njc0IjogWy0wLjA2NCwgMC40MzcsIDAsIDAsIDEuMzM0XSwKICAgICI4NzA1IjogWzAsIDAuODI1LCAwLCAwLCAwLjVdLAogICAgIjg3MDgiOiBbMCwgMC42ODg4OSwgMCwgMCwgMC41NTU1Nl0sCiAgICAiODcwOSI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzE3IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDI5MTddLAogICAgIjg3MjIiOiBbLTAuMDM1OTgsIDAuNDY0MDIsIDAsIDAsIDAuNV0sCiAgICAiODcyNCI6IFswLjA4MTk4LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzI2IjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3MzMiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODczNiI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjcyMjIyXSwKICAgICI4NzM3IjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLAogICAgIjg3MzgiOiBbMC4wMzUxNywgMC41MjIzOSwgMCwgMCwgMC43MjIyMl0sCiAgICAiODczOSI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjIyMjIyXSwKICAgICI4NzQwIjogWzAuMjUxNDIsIDAuNzQxMTEsIDAsIDAsIDAuMjc3NzhdLAogICAgIjg3NDEiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4zODg4OV0sCiAgICAiODc0MiI6IFswLjI1MTQyLCAwLjc0MTExLCAwLCAwLCAwLjVdLAogICAgIjg3NTYiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sCiAgICAiODc1NyI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4NzY0IjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzY1IjogWy0wLjEzMzEzLCAwLjM3Nzg4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzY5IjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzcwIjogWy0wLjAzNjI1LCAwLjQ2Mzc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4Nzc0IjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3NzYiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3NzgiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODc4MiI6IFswLjA2MDYyLCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzgzIjogWzAuMDYwNjIsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3ODUiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODc4NiI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4Nzg3IjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3OTAiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODc5MSI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4Nzk2IjogWzAuMDgxOTgsIDAuOTE2NjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MDYiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgwNyI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODA4IjogWzAuMjUxNDIsIDAuNzU3MjYsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MDkiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgxMiI6IFswLjI1NTgzLCAwLjc1NTgzLCAwLCAwLCAwLjVdLAogICAgIjg4MTQiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgxNSI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODE2IjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MTciOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgxOCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODE5IjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MjIiOiBbMC4xODA4LCAwLjY3NSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgyMyI6IFswLjE4MDgsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODI4IjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MjkiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgzMCI6IFswLjIyOTU4LCAwLjcyOTU4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODMxIjogWzAuMjI5NTgsIDAuNzI5NTgsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MzIiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgzMyI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODQwIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4NDEiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg0MiI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODQzIjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4NDciOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg0OCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODU4IjogWzAuMDgxOTgsIDAuNTgxOTgsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4NTkiOiBbMC4wODE5OCwgMC41ODE5OCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg2MSI6IFswLjA4MTk4LCAwLjU4MTk4LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODYyIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODYzIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODY0IjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODY1IjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODcyIjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjExMTFdLAogICAgIjg4NzMiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sCiAgICAiODg3NCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjg4ODg5XSwKICAgICI4ODc2IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNjExMTFdLAogICAgIjg4NzciOiBbMCwgMC42ODg4OSwgMCwgMCwgMC42MTExMV0sCiAgICAiODg3OCI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjcyMjIyXSwKICAgICI4ODc5IjogWzAsIDAuNjg4ODksIDAsIDAsIDAuNzIyMjJdLAogICAgIjg4ODIiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg4MyI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODg0IjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4ODUiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg4OCI6IFswLCAwLjU0OTg2LCAwLCAwLCAxLjExMTExXSwKICAgICI4ODkwIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTU1NTZdLAogICAgIjg4OTEiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC42MTExMV0sCiAgICAiODg5MiI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjYxMTExXSwKICAgICI4OTAxIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuMjc3NzhdLAogICAgIjg5MDMiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODkwNSI6IFswLjA4MTY3LCAwLjU4MTY3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTA2IjogWzAuMDgxNjcsIDAuNTgxNjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MDciOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODkwOCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTA5IjogWy0wLjAzNTk4LCAwLjQ2NDAyLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTEwIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzYwNDJdLAogICAgIjg5MTEiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43NjA0Ml0sCiAgICAiODkxMiI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTEzIjogWzAuMDM1MTcsIDAuNTQ5ODYsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MTQiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC42NjY2N10sCiAgICAiODkxNSI6IFswLCAwLjU0OTg2LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4OTE2IjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLAogICAgIjg5MTgiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MTkiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MjAiOiBbMC4wMzUxNywgMC41NDk4NiwgMCwgMCwgMS4zMzMzNF0sCiAgICAiODkyMSI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAxLjMzMzM0XSwKICAgICI4OTIyIjogWzAuMzg1NjksIDAuODg1NjksIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MjMiOiBbMC4zODU2OSwgMC44ODU2OSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODkyNiI6IFswLjEzNjY3LCAwLjYzNjY3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTI3IjogWzAuMTM2NjcsIDAuNjM2NjcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MjgiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODkyOSI6IFswLjMwMjc0LCAwLjc5MzgzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTM0IjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MzUiOiBbMC4yMzIyMiwgMC43NDExMSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODkzNiI6IFswLjIzMjIyLCAwLjc0MTExLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTM3IjogWzAuMjMyMjIsIDAuNzQxMTEsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5MzgiOiBbMC4yMDU3NiwgMC43MDU3NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODkzOSI6IFswLjIwNTc2LCAwLjcwNTc2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTQwIjogWzAuMzAyNzQsIDAuNzkzODMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg5NDEiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODk5NCI6IFswLjE5NDQ0LCAwLjY5MjI0LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4OTk1IjogWzAuMTk0NDQsIDAuNjkyMjQsIDAsIDAsIDAuNzc3NzhdLAogICAgIjk0MTYiOiBbMC4xNTU1OSwgMC42OTIyNCwgMCwgMCwgMC45MDIyMl0sCiAgICAiOTQ4NCI6IFswLCAwLjY5MjI0LCAwLCAwLCAwLjVdLAogICAgIjk0ODgiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC41XSwKICAgICI5NDkyIjogWzAsIDAuMzc3ODgsIDAsIDAsIDAuNV0sCiAgICAiOTQ5NiI6IFswLCAwLjM3Nzg4LCAwLCAwLCAwLjVdLAogICAgIjk1ODUiOiBbMC4xOTQ0NCwgMC42ODg4OSwgMCwgMCwgMC44ODg4OV0sCiAgICAiOTU4NiI6IFswLjE5NDQ0LCAwLjc0MTExLCAwLCAwLCAwLjg4ODg5XSwKICAgICI5NjMyIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5NjMzIjogWzAsIDAuNjc1LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5NjUwIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLAogICAgIjk2NTEiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sCiAgICAiOTY1NCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5NjYwIjogWzAsIDAuNTQ5ODYsIDAsIDAsIDAuNzIyMjJdLAogICAgIjk2NjEiOiBbMCwgMC41NDk4NiwgMCwgMCwgMC43MjIyMl0sCiAgICAiOTY2NCI6IFswLjAzNTE3LCAwLjU0OTg2LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5Njc0IjogWzAuMTExMTEsIDAuNjkyMjQsIDAsIDAsIDAuNjY2NjddLAogICAgIjk3MzMiOiBbMC4xOTQ0NCwgMC42OTIyNCwgMCwgMCwgMC45NDQ0NV0sCiAgICAiMTAwMDMiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sCiAgICAiMTAwMTYiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC44MzMzNF0sCiAgICAiMTA3MzEiOiBbMC4xMTExMSwgMC42OTIyNCwgMCwgMCwgMC42NjY2N10sCiAgICAiMTA4NDYiOiBbMC4xOTQ0NCwgMC43NTU4MywgMCwgMCwgMC42MTExMV0sCiAgICAiMTA4NzciOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4NzgiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4ODUiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4ODYiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4ODciOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4ODgiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4ODkiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4OTAiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4OTEiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA4OTIiOiBbMC40ODI1NiwgMC45ODI1NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MDEiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MDIiOiBbMC4xMzY2NywgMC42MzY2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MzMiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MzQiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MzUiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MzYiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MzciOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MzgiOiBbMC4yNjE2NywgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5NDkiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5NTAiOiBbMC4yNTU4MywgMC43NTU4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5NTUiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5NTYiOiBbMC4yODQ4MSwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNTAiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4yMjIyMl0sCiAgICAiNTczNTEiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC4zODg4OV0sCiAgICAiNTczNTIiOiBbMC4wODE2NywgMC41ODE2NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNTMiOiBbMCwgMC40MzA1NiwgMC4wNDAyOCwgMCwgMC42NjY2N10sCiAgICAiNTczNTYiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNTciOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNTgiOiBbMC40MTk1MSwgMC45MTk1MSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNTkiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNjAiOiBbMC4zMDI3NCwgMC43OTM4MywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNjEiOiBbMC40MTk1MSwgMC45MTk1MSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNjYiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNjciOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNjgiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNjkiOiBbMC4yNTE0MiwgMC43NTcyNiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNzAiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNzEiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0KICB9LAogICJDYWxpZ3JhcGhpYy1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjY1IjogWzAsIDAuNjgzMzMsIDAsIDAuMTk0NDUsIDAuNzk4NDddLAogICAgIjY2IjogWzAsIDAuNjgzMzMsIDAuMDMwNDEsIDAuMTM4ODksIDAuNjU2ODFdLAogICAgIjY3IjogWzAsIDAuNjgzMzMsIDAuMDU4MzQsIDAuMTM4ODksIDAuNTI2NTNdLAogICAgIjY4IjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNzcxMzldLAogICAgIjY5IjogWzAsIDAuNjgzMzMsIDAuMDg5NDQsIDAuMTExMTEsIDAuNTI3NzhdLAogICAgIjcwIjogWzAsIDAuNjgzMzMsIDAuMDk5MzEsIDAuMTExMTEsIDAuNzE4NzVdLAogICAgIjcxIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAuMDU5MywgMC4xMTExMSwgMC41OTQ4N10sCiAgICAiNzIiOiBbMCwgMC42ODMzMywgOTY1ZS01LCAwLjExMTExLCAwLjg0NDUyXSwKICAgICI3MyI6IFswLCAwLjY4MzMzLCAwLjA3MzgyLCAwLCAwLjU0NDUyXSwKICAgICI3NCI6IFswLjA5NzIyLCAwLjY4MzMzLCAwLjE4NDcyLCAwLjE2NjY3LCAwLjY3Nzc4XSwKICAgICI3NSI6IFswLCAwLjY4MzMzLCAwLjAxNDQ1LCAwLjA1NTU2LCAwLjc2MTk1XSwKICAgICI3NiI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAwLjY4OTcyXSwKICAgICI3NyI6IFswLCAwLjY4MzMzLCAwLCAwLjEzODg5LCAxLjIwMDldLAogICAgIjc4IjogWzAsIDAuNjgzMzMsIDAuMTQ3MzYsIDAuMDgzMzQsIDAuODIwNDldLAogICAgIjc5IjogWzAsIDAuNjgzMzMsIDAuMDI3NzgsIDAuMTExMTEsIDAuNzk2MTFdLAogICAgIjgwIjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuNjk1NTZdLAogICAgIjgxIjogWzAuMDk3MjIsIDAuNjgzMzMsIDAsIDAuMTExMTEsIDAuODE2NjddLAogICAgIjgyIjogWzAsIDAuNjgzMzMsIDAsIDAuMDgzMzQsIDAuODQ3NV0sCiAgICAiODMiOiBbMCwgMC42ODMzMywgMC4wNzUsIDAuMTM4ODksIDAuNjA1NTZdLAogICAgIjg0IjogWzAsIDAuNjgzMzMsIDAuMjU0MTcsIDAsIDAuNTQ0NjRdLAogICAgIjg1IjogWzAsIDAuNjgzMzMsIDAuMDk5MzEsIDAuMDgzMzQsIDAuNjI1ODNdLAogICAgIjg2IjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAsIDAuNjEyNzhdLAogICAgIjg3IjogWzAsIDAuNjgzMzMsIDAuMDgyMjIsIDAuMDgzMzQsIDAuOTg3NzhdLAogICAgIjg4IjogWzAsIDAuNjgzMzMsIDAuMTQ2NDMsIDAuMTM4ODksIDAuNzEzM10sCiAgICAiODkiOiBbMC4wOTcyMiwgMC42ODMzMywgMC4wODIyMiwgMC4wODMzNCwgMC42NjgzNF0sCiAgICAiOTAiOiBbMCwgMC42ODMzMywgMC4wNzk0NCwgMC4xMzg4OSwgMC43MjQ3M10sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdCiAgfSwKICAiRnJha3R1ci1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjMzIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjk1NzRdLAogICAgIjM0IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLAogICAgIjM4IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzM3ODZdLAogICAgIjM5IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjEyMDFdLAogICAgIjQwIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMzg4NjVdLAogICAgIjQxIjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuMzg4NjVdLAogICAgIjQyIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuMjc3NjRdLAogICAgIjQzIjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDAsIDAuNzU2MjNdLAogICAgIjQ0IjogWzAsIDAuMTA4MDMsIDAsIDAsIDAuMjc3NjRdLAogICAgIjQ1IjogWzAuMDgzMTksIDAuNTgyODMsIDAsIDAsIDAuNzU2MjNdLAogICAgIjQ2IjogWzAsIDAuMTA4MDMsIDAsIDAsIDAuMjc3NjRdLAogICAgIjQ3IjogWzAuMjQ5ODIsIDAuNzQ5NDcsIDAsIDAsIDAuNTAxODFdLAogICAgIjQ4IjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjQ5IjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjUwIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjUxIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjUyIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjUzIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjU0IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTAxODFdLAogICAgIjU1IjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjU2IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNTAxODFdLAogICAgIjU3IjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAxODFdLAogICAgIjU4IjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuMjE2MDZdLAogICAgIjU5IjogWzAuMTI2MDQsIDAuNDc1MzQsIDAsIDAsIDAuMjE2MDZdLAogICAgIjYxIjogWy0wLjEzMDk5LCAwLjM2ODY2LCAwLCAwLCAwLjc1NjIzXSwKICAgICI2MyI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjM2MjQ1XSwKICAgICI2NSI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjcxNzZdLAogICAgIjY2IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODgzOTddLAogICAgIjY3IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjEyNTRdLAogICAgIjY4IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuODMxNThdLAogICAgIjY5IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNjYyNzhdLAogICAgIjcwIjogWzAuMTI2MDQsIDAuNjkxNDEsIDAsIDAsIDAuNjExMTldLAogICAgIjcxIjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuNzg1MzldLAogICAgIjcyIjogWzAuMDYzMDIsIDAuNjkxNDEsIDAsIDAsIDAuNzIwM10sCiAgICAiNzMiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41NTQ0OF0sCiAgICAiNzQiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC41NTIzMV0sCiAgICAiNzUiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42Njg0NV0sCiAgICAiNzYiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NjYwMl0sCiAgICAiNzciOiBbMCwgMC42OTE0MSwgMCwgMCwgMS4wNDk1M10sCiAgICAiNzgiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzIxMl0sCiAgICAiNzkiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MjY5OV0sCiAgICAiODAiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC44Mjc1M10sCiAgICAiODEiOiBbMC4wMzc4MSwgMC42OTE0MSwgMCwgMCwgMC44MjY5OV0sCiAgICAiODIiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MjgwN10sCiAgICAiODMiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44Mjg2MV0sCiAgICAiODQiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42Njg5OV0sCiAgICAiODUiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC42NDU3Nl0sCiAgICAiODYiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC44MzEzMV0sCiAgICAiODciOiBbMCwgMC42OTE0MSwgMCwgMCwgMS4wNDYwMl0sCiAgICAiODgiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC43MTkyMl0sCiAgICAiODkiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC44MzI5M10sCiAgICAiOTAiOiBbMC4xMjYwNCwgMC42OTE0MSwgMCwgMCwgMC42MDIwMV0sCiAgICAiOTEiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4yNzc2NF0sCiAgICAiOTMiOiBbMC4yNDk4MiwgMC43NDk0NywgMCwgMCwgMC4yNzc2NF0sCiAgICAiOTQiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC40OTk2NV0sCiAgICAiOTciOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDA0Nl0sCiAgICAiOTgiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC41MTMxNV0sCiAgICAiOTkiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC4zODk0Nl0sCiAgICAiMTAwIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk4NTddLAogICAgIjEwMSI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQwMDUzXSwKICAgICIxMDIiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMjYyNl0sCiAgICAiMTAzIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNTAzN10sCiAgICAiMTA0IjogWzAuMTg5MDYsIDAuNjkxNDEsIDAsIDAsIDAuNTIxMjZdLAogICAgIjEwNSI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI3ODk5XSwKICAgICIxMDYiOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4yODA4OF0sCiAgICAiMTA3IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMzg5NDZdLAogICAgIjEwOCI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjI3OTUzXSwKICAgICIxMDkiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC43NjY3Nl0sCiAgICAiMTEwIjogWzAsIDAuNDc1MzQsIDAsIDAsIDAuNTI2NjZdLAogICAgIjExMSI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjQ4ODg1XSwKICAgICIxMTIiOiBbMC4xODkwNiwgMC41MjM5NiwgMCwgMCwgMC41MDA0Nl0sCiAgICAiMTEzIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNDg5MTJdLAogICAgIjExNCI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjM4OTE5XSwKICAgICIxMTUiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC40NDI2Nl0sCiAgICAiMTE2IjogWzAsIDAuNjIxMTksIDAsIDAsIDAuMzMzMDFdLAogICAgIjExNyI6IFswLCAwLjQ3NTM0LCAwLCAwLCAwLjUxNzJdLAogICAgIjExOCI6IFswLCAwLjUyMzk2LCAwLCAwLCAwLjUxMThdLAogICAgIjExOSI6IFswLCAwLjUyMzk2LCAwLCAwLCAwLjc3MzUxXSwKICAgICIxMjAiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC4zODg2NV0sCiAgICAiMTIxIjogWzAuMTg5MDYsIDAuNDc1MzQsIDAsIDAsIDAuNDk4ODRdLAogICAgIjEyMiI6IFswLjE4OTA2LCAwLjQ3NTM0LCAwLCAwLCAwLjM5MDU0XSwKICAgICIxNjAiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiODIxNiI6IFswLCAwLjY5MTQxLCAwLCAwLCAwLjIxNDcxXSwKICAgICI4MjE3IjogWzAsIDAuNjkxNDEsIDAsIDAsIDAuMjE0NzFdLAogICAgIjU4MTEyIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk3NDldLAogICAgIjU4MTEzIjogWzAsIDAuNjIxMTksIDAsIDAsIDAuNDk4M10sCiAgICAiNTgxMTQiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMzMyOF0sCiAgICAiNTgxMTUiOiBbMC4xODkwNiwgMC42OTE0MSwgMCwgMCwgMC4zMjkyM10sCiAgICAiNTgxMTYiOiBbMC4xODkwNiwgMC40NzUzNCwgMCwgMCwgMC41MDM0M10sCiAgICAiNTgxMTciOiBbMCwgMC42OTE0MSwgMCwgMCwgMC4zMzMwMV0sCiAgICAiNTgxMTgiOiBbMCwgMC42MjExOSwgMCwgMCwgMC4zMzQwOV0sCiAgICAiNTgxMTkiOiBbMCwgMC40NzUzNCwgMCwgMCwgMC41MDA3M10KICB9LAogICJNYWluLUJvbGQiOiB7CiAgICAiMzIiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiMzMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNV0sCiAgICAiMzQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDI3OF0sCiAgICAiMzUiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45NTgzM10sCiAgICAiMzYiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NzVdLAogICAgIjM3IjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuOTU4MzNdLAogICAgIjM4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLAogICAgIjM5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLAogICAgIjQwIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLAogICAgIjQxIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLAogICAgIjQyIjogWzAsIDAuNzUsIDAsIDAsIDAuNTc1XSwKICAgICI0MyI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI0NCI6IFswLjE5NDQ0LCAwLjE1NTU2LCAwLCAwLCAwLjMxOTQ0XSwKICAgICI0NSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM4MzMzXSwKICAgICI0NiI6IFswLCAwLjE1NTU2LCAwLCAwLCAwLjMxOTQ0XSwKICAgICI0NyI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjU3NV0sCiAgICAiNDgiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjQ5IjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI1MCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNTEiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjUyIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI1MyI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNTQiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjU1IjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI1NiI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNTciOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjU4IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLAogICAgIjU5IjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuMzE5NDRdLAogICAgIjYwIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLAogICAgIjYxIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI2MiI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI2MyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU0MzA1XSwKICAgICI2NCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI2NSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2OTQ0XSwKICAgICI2NiI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgxODA1XSwKICAgICI2NyI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSwKICAgICI2OCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg4MTk0XSwKICAgICI2OSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjc1NTU1XSwKICAgICI3MCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjcyMzYxXSwKICAgICI3MSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjkwNDE2XSwKICAgICI3MiI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLAogICAgIjczIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNDM2MTFdLAogICAgIjc0IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNTk0NDRdLAogICAgIjc1IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTAxMzhdLAogICAgIjc2IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjkxNjZdLAogICAgIjc3IjogWzAsIDAuNjg2MTEsIDAsIDAsIDEuMDkxNjZdLAogICAgIjc4IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOV0sCiAgICAiNzkiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjM4OF0sCiAgICAiODAiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43ODYxMV0sCiAgICAiODEiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMCwgMC44NjM4OF0sCiAgICAiODIiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44NjI1XSwKICAgICI4MyI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjYzODg5XSwKICAgICI4NCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjhdLAogICAgIjg1IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODg0NzJdLAogICAgIjg2IjogWzAsIDAuNjg2MTEsIDAuMDE1OTcsIDAsIDAuODY5NDRdLAogICAgIjg3IjogWzAsIDAuNjg2MTEsIDAuMDE1OTcsIDAsIDEuMTg4ODhdLAogICAgIjg4IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLAogICAgIjg5IjogWzAsIDAuNjg2MTEsIDAuMDI4NzUsIDAsIDAuODY5NDRdLAogICAgIjkwIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzAyNzddLAogICAgIjkxIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzE5NDRdLAogICAgIjkyIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSwKICAgICI5MyI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSwKICAgICI5NCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiOTUiOiBbMC4zMSwgMC4xMzQ0NCwgMC4wMzE5NCwgMCwgMC41NzVdLAogICAgIjk3IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTU5MDJdLAogICAgIjk4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLAogICAgIjk5IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTExMTFdLAogICAgIjEwMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSwKICAgICIxMDEiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41MjcwOF0sCiAgICAiMTAyIjogWzAsIDAuNjk0NDQsIDAuMTA5MDMsIDAsIDAuMzUxMzldLAogICAgIjEwMyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjU3NV0sCiAgICAiMTA0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLAogICAgIjEwNSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSwKICAgICIxMDYiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zNTEzOV0sCiAgICAiMTA3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjA2OTRdLAogICAgIjEwOCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSwKICAgICIxMDkiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC45NTgzM10sCiAgICAiMTEwIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLAogICAgIjExMSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiMTEyIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjM4ODldLAogICAgIjExMyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYwNjk0XSwKICAgICIxMTQiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NzM2MV0sCiAgICAiMTE1IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDUzNjFdLAogICAgIjExNiI6IFswLCAwLjYzNDkyLCAwLCAwLCAwLjQ0NzIyXSwKICAgICIxMTciOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Mzg4OV0sCiAgICAiMTE4IjogWzAsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNjA2OTRdLAogICAgIjExOSI6IFswLCAwLjQ0NDQ0LCAwLjAxNTk3LCAwLCAwLjgzMDU1XSwKICAgICIxMjAiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42MDY5NF0sCiAgICAiMTIxIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDE1OTcsIDAsIDAuNjA2OTRdLAogICAgIjEyMiI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMTExXSwKICAgICIxMjMiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLAogICAgIjEyNCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSwKICAgICIxMjUiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLAogICAgIjEyNiI6IFswLjM1LCAwLjM0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjE2MyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg2ODUzXSwKICAgICIxNjgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjE3MiI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2NjY2XSwKICAgICIxNzYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44Njk0NF0sCiAgICAiMTc3IjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLAogICAgIjE4NCI6IFswLjE3MDE0LCAwLCAwLCAwLCAwLjUxMTExXSwKICAgICIxOTgiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4wNDE2Nl0sCiAgICAiMjE1IjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLAogICAgIjIxNiI6IFswLjA0ODYxLCAwLjczNDcyLCAwLCAwLCAwLjg5NDQ0XSwKICAgICIyMjMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41OTcyMl0sCiAgICAiMjMwIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODMwNTVdLAogICAgIjI0NyI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSwKICAgICIyNDgiOiBbMC4wOTcyMiwgMC41NDE2NywgMCwgMCwgMC41NzVdLAogICAgIjMwNSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjMxOTQ0XSwKICAgICIzMzgiOiBbMCwgMC42ODYxMSwgMCwgMCwgMS4xNjk0NF0sCiAgICAiMzM5IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuODk0NDRdLAogICAgIjU2NyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjM1MTM5XSwKICAgICI3MTAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjcxMSI6IFswLCAwLjYzMTk0LCAwLCAwLCAwLjU3NV0sCiAgICAiNzEzIjogWzAsIDAuNTk2MTEsIDAsIDAsIDAuNTc1XSwKICAgICI3MTQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjcxNSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNzI4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI3MjkiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sCiAgICAiNzMwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODY5NDRdLAogICAgIjczMiI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNzMzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI5MTUiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC42OTE2Nl0sCiAgICAiOTE2IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuOTU4MzNdLAogICAgIjkyMCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI5MjMiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MDU1NV0sCiAgICAiOTI2IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNzY2NjZdLAogICAgIjkyOCI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLAogICAgIjkzMSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjgzMDU1XSwKICAgICI5MzMiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44OTQ0NF0sCiAgICAiOTM0IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODMwNTVdLAogICAgIjkzNiI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI5MzciOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44MzA1NV0sCiAgICAiODIxMSI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAwLjU3NV0sCiAgICAiODIxMiI6IFswLCAwLjQ0NDQ0LCAwLjAzMTk0LCAwLCAxLjE0OTk5XSwKICAgICI4MjE2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzE5NDRdLAogICAgIjgyMTciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NF0sCiAgICAiODIyMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYwMjc4XSwKICAgICI4MjIxIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjAyNzhdLAogICAgIjgyMjQiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41MTExMV0sCiAgICAiODIyNSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjUxMTExXSwKICAgICI4MjQyIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMzQ0NDRdLAogICAgIjg0MDciOiBbMCwgMC43MjQ0NCwgMC4xNTQ4NiwgMCwgMC41NzVdLAogICAgIjg0NjMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sCiAgICAiODQ2NSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSwKICAgICI4NDY3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDczNjFdLAogICAgIjg0NzIiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43NDAyN10sCiAgICAiODQ3NiI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMDU1XSwKICAgICI4NTAxIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLAogICAgIjg1OTIiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg1OTMiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjg1OTQiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg1OTUiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjg1OTYiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg1OTciOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLAogICAgIjg1OTgiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODU5OSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxLjE0OTk5XSwKICAgICI4NjAwIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg2MDEiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODYzNiI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODYzNyI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODY0MCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODY0MSI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODY1NiI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODY1NyI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSwKICAgICI4NjU4IjogWy0wLjEwODg5LCAwLjM5MTExLCAwLCAwLCAxLjE0OTk5XSwKICAgICI4NjU5IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzddLAogICAgIjg2NjAiOiBbLTAuMTA4ODksIDAuMzkxMTEsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg2NjEiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC43MDI3N10sCiAgICAiODcwNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSwKICAgICI4NzA2IjogWzAsIDAuNjk0NDQsIDAuMDYzODksIDAsIDAuNjI4NDddLAogICAgIjg3MDciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Mzg4OV0sCiAgICAiODcwOSI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjU3NV0sCiAgICAiODcxMSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSwKICAgICI4NzEyIjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuNzY2NjZdLAogICAgIjg3MTUiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC43NjY2Nl0sCiAgICAiODcyMiI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4NzIzIjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLAogICAgIjg3MjUiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLAogICAgIjg3MjYiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NzVdLAogICAgIjg3MjciOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSwKICAgICI4NzI4IjogWy0wLjAyNjM5LCAwLjQ3MzYxLCAwLCAwLCAwLjU3NV0sCiAgICAiODcyOSI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLAogICAgIjg3MzAiOiBbMC4xOCwgMC44MiwgMCwgMCwgMC45NTgzM10sCiAgICAiODczMyI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4NzM0IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg3MzYiOiBbMCwgMC42OTIyNCwgMCwgMCwgMC43MjIyMl0sCiAgICAiODczOSI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjMxOTQ0XSwKICAgICI4NzQxIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTc1XSwKICAgICI4NzQzIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLAogICAgIjg3NDQiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sCiAgICAiODc0NSI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjc2NjY2XSwKICAgICI4NzQ2IjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLAogICAgIjg3NDciOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMjc3OCwgMCwgMC41Njg3NV0sCiAgICAiODc2NCI6IFstMC4xMDg4OSwgMC4zOTExMSwgMCwgMCwgMC44OTQ0NF0sCiAgICAiODc2OCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjMxOTQ0XSwKICAgICI4NzcxIjogWzIyMmUtNSwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sCiAgICAiODc3MyI6IFswLjAyNywgMC42MzgsIDAsIDAsIDAuODk0XSwKICAgICI4Nzc2IjogWzAuMDI0NDQsIDAuNTI0NDQsIDAsIDAsIDAuODk0NDRdLAogICAgIjg3ODEiOiBbMjIyZS01LCAwLjUwMjIyLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODAxIjogWzIyMmUtNSwgMC41MDIyMiwgMCwgMCwgMC44OTQ0NF0sCiAgICAiODgwNCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODA1IjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLAogICAgIjg4MTAiOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMS4xNDk5OV0sCiAgICAiODgxMSI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAxLjE0OTk5XSwKICAgICI4ODI2IjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLAogICAgIjg4MjciOiBbMC4wODU1NiwgMC41ODU1NiwgMCwgMCwgMC44OTQ0NF0sCiAgICAiODgzNCI6IFswLjA4NTU2LCAwLjU4NTU2LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODM1IjogWzAuMDg1NTYsIDAuNTg1NTYsIDAsIDAsIDAuODk0NDRdLAogICAgIjg4MzgiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sCiAgICAiODgzOSI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODQ2IjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLAogICAgIjg4NDkiOiBbMC4xOTY2NywgMC42OTY2NywgMCwgMCwgMC44OTQ0NF0sCiAgICAiODg1MCI6IFswLjE5NjY3LCAwLjY5NjY3LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODUxIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNzY2NjZdLAogICAgIjg4NTIiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC43NjY2Nl0sCiAgICAiODg1MyI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODU0IjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLAogICAgIjg4NTUiOiBbMC4xMzMzMywgMC42MzMzMywgMCwgMCwgMC44OTQ0NF0sCiAgICAiODg1NiI6IFswLjEzMzMzLCAwLjYzMzMzLCAwLCAwLCAwLjg5NDQ0XSwKICAgICI4ODU3IjogWzAuMTMzMzMsIDAuNjMzMzMsIDAsIDAsIDAuODk0NDRdLAogICAgIjg4NjYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MDI3N10sCiAgICAiODg2NyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwMjc3XSwKICAgICI4ODY4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLAogICAgIjg4NjkiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sCiAgICAiODkwMCI6IFstMC4wMjYzOSwgMC40NzM2MSwgMCwgMCwgMC41NzVdLAogICAgIjg5MDEiOiBbLTAuMDI2MzksIDAuNDczNjEsIDAsIDAsIDAuMzE5NDRdLAogICAgIjg5MDIiOiBbLTAuMDI3NzgsIDAuNDcyMjIsIDAsIDAsIDAuNTc1XSwKICAgICI4OTY4IjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLAogICAgIjg5NjkiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41MTExMV0sCiAgICAiODk3MCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjUxMTExXSwKICAgICI4OTcxIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNTExMTFdLAogICAgIjg5OTQiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLAogICAgIjg5OTUiOiBbLTAuMTM4ODksIDAuMzYxMTEsIDAsIDAsIDEuMTQ5OTldLAogICAgIjk2NTEiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sCiAgICAiOTY1NyI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLAogICAgIjk2NjEiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4wMjIyMl0sCiAgICAiOTY2NyI6IFstMC4wMjc3OCwgMC40NzIyMiwgMCwgMCwgMC41NzVdLAogICAgIjk3MTEiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMS4xNDk5OV0sCiAgICAiOTgyNCI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI5ODI1IjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuODk0NDRdLAogICAgIjk4MjYiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC44OTQ0NF0sCiAgICAiOTgyNyI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjg5NDQ0XSwKICAgICI5ODM3IjogWzAsIDAuNzUsIDAsIDAsIDAuNDQ3MjJdLAogICAgIjk4MzgiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC40NDcyMl0sCiAgICAiOTgzOSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NzIyXSwKICAgICIxMDIxNiI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSwKICAgICIxMDIxNyI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NzIyXSwKICAgICIxMDgxNSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjldLAogICAgIjEwOTI3IjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLAogICAgIjEwOTI4IjogWzAuMTk2NjcsIDAuNjk2NjcsIDAsIDAsIDAuODk0NDRdLAogICAgIjU3Mzc2IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDBdCiAgfSwKICAiTWFpbi1Cb2xkSXRhbGljIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjMzIjogWzAsIDAuNjk0NDQsIDAuMTE0MTcsIDAsIDAuMzg2MTFdLAogICAgIjM0IjogWzAsIDAuNjk0NDQsIDAuMDc5MzksIDAsIDAuNjIwNTVdLAogICAgIjM1IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDY4MzMsIDAsIDAuOTQ0NDRdLAogICAgIjM3IjogWzAuMDU1NTYsIDAuNzUsIDAuMTI4NjEsIDAsIDAuOTQ0NDRdLAogICAgIjM4IjogWzAsIDAuNjk0NDQsIDAuMDg1MjgsIDAsIDAuODg1NTVdLAogICAgIjM5IjogWzAsIDAuNjk0NDQsIDAuMTI5NDUsIDAsIDAuMzU1NTVdLAogICAgIjQwIjogWzAuMjUsIDAuNzUsIDAuMTU4MDYsIDAsIDAuNDczMzNdLAogICAgIjQxIjogWzAuMjUsIDAuNzUsIDAuMDMzMDYsIDAsIDAuNDczMzNdLAogICAgIjQyIjogWzAsIDAuNzUsIDAuMTQzMzMsIDAsIDAuNTkxMTFdLAogICAgIjQzIjogWzAuMTAzMzMsIDAuNjAzMzMsIDAuMDMzMDYsIDAsIDAuODg1NTVdLAogICAgIjQ0IjogWzAuMTk0NDQsIDAuMTQ3MjIsIDAsIDAsIDAuMzU1NTVdLAogICAgIjQ1IjogWzAsIDAuNDQ0NDQsIDAuMDI2MTEsIDAsIDAuNDE0NDRdLAogICAgIjQ2IjogWzAsIDAuMTQ3MjIsIDAsIDAsIDAuMzU1NTVdLAogICAgIjQ3IjogWzAuMjUsIDAuNzUsIDAuMTU4MDYsIDAsIDAuNTkxMTFdLAogICAgIjQ4IjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjQ5IjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjUwIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjUxIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjUyIjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjUzIjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjU0IjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjU1IjogWzAuMTk0NDQsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjU2IjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjU3IjogWzAsIDAuNjQ0NDQsIDAuMTMxNjcsIDAsIDAuNTkxMTFdLAogICAgIjU4IjogWzAsIDAuNDQ0NDQsIDAuMDY2OTUsIDAsIDAuMzU1NTVdLAogICAgIjU5IjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDY2OTUsIDAsIDAuMzU1NTVdLAogICAgIjYxIjogWy0wLjEwODg5LCAwLjM5MTExLCAwLjA2ODMzLCAwLCAwLjg4NTU1XSwKICAgICI2MyI6IFswLCAwLjY5NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSwKICAgICI2NCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA4LCAwLCAwLjg4NTU1XSwKICAgICI2NSI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjg2NTU1XSwKICAgICI2NiI6IFswLCAwLjY4NjExLCAwLjA5OTIsIDAsIDAuODE2NjZdLAogICAgIjY3IjogWzAsIDAuNjg2MTEsIDAuMTQyMDgsIDAsIDAuODI2NjZdLAogICAgIjY4IjogWzAsIDAuNjg2MTEsIDAuMDkwNjIsIDAsIDAuODc1NTVdLAogICAgIjY5IjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDAuNzU2NjZdLAogICAgIjcwIjogWzAsIDAuNjg2MTEsIDAuMTI5MDMsIDAsIDAuNzI3MjJdLAogICAgIjcxIjogWzAsIDAuNjg2MTEsIDAuMDczNDcsIDAsIDAuODk1MjddLAogICAgIjcyIjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sCiAgICAiNzMiOiBbMCwgMC42ODYxMSwgMC4xNTY4MSwgMCwgMC40NzE2Nl0sCiAgICAiNzQiOiBbMCwgMC42ODYxMSwgMC4xNDUsIDAsIDAuNjEwNTVdLAogICAgIjc1IjogWzAsIDAuNjg2MTEsIDAuMTQyMDgsIDAsIDAuODk0OTldLAogICAgIjc2IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuNjk3NzddLAogICAgIjc3IjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDEuMDcyNzddLAogICAgIjc4IjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODk2MV0sCiAgICAiNzkiOiBbMCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44NTQ5OV0sCiAgICAiODAiOiBbMCwgMC42ODYxMSwgMC4wOTkyLCAwLCAwLjc4NzIxXSwKICAgICI4MSI6IFswLjE5NDQ0LCAwLjY4NjExLCAwLjA5MDYyLCAwLCAwLjg1NDk5XSwKICAgICI4MiI6IFswLCAwLjY4NjExLCAwLjAyNTU5LCAwLCAwLjg1OTQ0XSwKICAgICI4MyI6IFswLCAwLjY4NjExLCAwLjExMjY0LCAwLCAwLjY0OTk5XSwKICAgICI4NCI6IFswLCAwLjY4NjExLCAwLjEyOTAzLCAwLCAwLjc5NjFdLAogICAgIjg1IjogWzAsIDAuNjg2MTEsIDAuMTcyMDgsIDAsIDAuODgwODNdLAogICAgIjg2IjogWzAsIDAuNjg2MTEsIDAuMTg2MjUsIDAsIDAuODY1NTVdLAogICAgIjg3IjogWzAsIDAuNjg2MTEsIDAuMTg2MjUsIDAsIDEuMTU5OTldLAogICAgIjg4IjogWzAsIDAuNjg2MTEsIDAuMTU2ODEsIDAsIDAuODY1NTVdLAogICAgIjg5IjogWzAsIDAuNjg2MTEsIDAuMTk4MDMsIDAsIDAuODY1NTVdLAogICAgIjkwIjogWzAsIDAuNjg2MTEsIDAuMTQyMDgsIDAsIDAuNzA4ODhdLAogICAgIjkxIjogWzAuMjUsIDAuNzUsIDAuMTg3NSwgMCwgMC4zNTYxMV0sCiAgICAiOTMiOiBbMC4yNSwgMC43NSwgMC4wOTk3MiwgMCwgMC4zNTYxMV0sCiAgICAiOTQiOiBbMCwgMC42OTQ0NCwgMC4wNjcwOSwgMCwgMC41OTExMV0sCiAgICAiOTUiOiBbMC4zMSwgMC4xMzQ0NCwgMC4wOTgxMSwgMCwgMC41OTExMV0sCiAgICAiOTciOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC41OTExMV0sCiAgICAiOTgiOiBbMCwgMC42OTQ0NCwgMC4wNzg2MSwgMCwgMC41MzIyMl0sCiAgICAiOTkiOiBbMCwgMC40NDQ0NCwgMC4wNTIyMiwgMCwgMC41MzIyMl0sCiAgICAiMTAwIjogWzAsIDAuNjk0NDQsIDAuMTA4NjEsIDAsIDAuNTkxMTFdLAogICAgIjEwMSI6IFswLCAwLjQ0NDQ0LCAwLjA4NSwgMCwgMC41MzIyMl0sCiAgICAiMTAyIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMjE3NzgsIDAsIDAuNF0sCiAgICAiMTAzIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMTA1LCAwLCAwLjUzMjIyXSwKICAgICIxMDQiOiBbMCwgMC42OTQ0NCwgMC4wOTQyNiwgMCwgMC41OTExMV0sCiAgICAiMTA1IjogWzAsIDAuNjkzMjYsIDAuMTEzODcsIDAsIDAuMzU1NTVdLAogICAgIjEwNiI6IFswLjE5NDQ0LCAwLjY5MzI2LCAwLjE2NzIsIDAsIDAuMzU1NTVdLAogICAgIjEwNyI6IFswLCAwLjY5NDQ0LCAwLjExMTExLCAwLCAwLjUzMjIyXSwKICAgICIxMDgiOiBbMCwgMC42OTQ0NCwgMC4xMDg2MSwgMCwgMC4yOTY2Nl0sCiAgICAiMTA5IjogWzAsIDAuNDQ0NDQsIDAuMDk0MjYsIDAsIDAuOTQ0NDRdLAogICAgIjExMCI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjY0OTk5XSwKICAgICIxMTEiOiBbMCwgMC40NDQ0NCwgMC4wNzg2MSwgMCwgMC41OTExMV0sCiAgICAiMTEyIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDc4NjEsIDAsIDAuNTkxMTFdLAogICAgIjExMyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwNSwgMCwgMC41MzIyMl0sCiAgICAiMTE0IjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNTAxNjddLAogICAgIjExNSI6IFswLCAwLjQ0NDQ0LCAwLjA4MTY3LCAwLCAwLjQ4Njk0XSwKICAgICIxMTYiOiBbMCwgMC42MzQ5MiwgMC4wOTYzOSwgMCwgMC4zODVdLAogICAgIjExNyI6IFswLCAwLjQ0NDQ0LCAwLjA5NDI2LCAwLCAwLjYyMDU1XSwKICAgICIxMTgiOiBbMCwgMC40NDQ0NCwgMC4xMTExMSwgMCwgMC41MzIyMl0sCiAgICAiMTE5IjogWzAsIDAuNDQ0NDQsIDAuMTExMTEsIDAsIDAuNzY3NzddLAogICAgIjEyMCI6IFswLCAwLjQ0NDQ0LCAwLjEyNTgzLCAwLCAwLjU2MDU1XSwKICAgICIxMjEiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDUsIDAsIDAuNTYxNjZdLAogICAgIjEyMiI6IFswLCAwLjQ0NDQ0LCAwLjEzODg5LCAwLCAwLjQ5MDU1XSwKICAgICIxMjYiOiBbMC4zNSwgMC4zNDQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjE2OCI6IFswLCAwLjY5NDQ0LCAwLjExNDczLCAwLCAwLjU5MTExXSwKICAgICIxNzYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45NDg4OF0sCiAgICAiMTg0IjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNTMyMjJdLAogICAgIjE5OCI6IFswLCAwLjY4NjExLCAwLjExNDMxLCAwLCAxLjAyMjc3XSwKICAgICIyMTYiOiBbMC4wNDg2MSwgMC43MzQ3MiwgMC4wOTA2MiwgMCwgMC44ODU1NV0sCiAgICAiMjIzIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDk3MzYsIDAsIDAuNjY1XSwKICAgICIyMzAiOiBbMCwgMC40NDQ0NCwgMC4wODUsIDAsIDAuODI2NjZdLAogICAgIjI0OCI6IFswLjA5NzIyLCAwLjU0MTY3LCAwLjA5NDU4LCAwLCAwLjU5MTExXSwKICAgICIzMDUiOiBbMCwgMC40NDQ0NCwgMC4wOTQyNiwgMCwgMC4zNTU1NV0sCiAgICAiMzM4IjogWzAsIDAuNjg2MTEsIDAuMTE0MzEsIDAsIDEuMTQwNTRdLAogICAgIjMzOSI6IFswLCAwLjQ0NDQ0LCAwLjA4NSwgMCwgMC44MjY2Nl0sCiAgICAiNTY3IjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQ2MTEsIDAsIDAuMzg1XSwKICAgICI3MTAiOiBbMCwgMC42OTQ0NCwgMC4wNjcwOSwgMCwgMC41OTExMV0sCiAgICAiNzExIjogWzAsIDAuNjMxOTQsIDAuMDgyNzEsIDAsIDAuNTkxMTFdLAogICAgIjcxMyI6IFswLCAwLjU5NDQ0LCAwLjEwNDQ0LCAwLCAwLjU5MTExXSwKICAgICI3MTQiOiBbMCwgMC42OTQ0NCwgMC4wODUyOCwgMCwgMC41OTExMV0sCiAgICAiNzE1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTkxMTFdLAogICAgIjcyOCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjU5MTExXSwKICAgICI3MjkiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sCiAgICAiNzMwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTQ4ODhdLAogICAgIjczMiI6IFswLCAwLjY5NDQ0LCAwLjExNDcyLCAwLCAwLjU5MTExXSwKICAgICI3MzMiOiBbMCwgMC42OTQ0NCwgMC4xMTQ3MiwgMCwgMC41OTExMV0sCiAgICAiOTE1IjogWzAsIDAuNjg2MTEsIDAuMTI5MDMsIDAsIDAuNjk3NzddLAogICAgIjkxNiI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk0NDQ0XSwKICAgICI5MjAiOiBbMCwgMC42ODYxMSwgMC4wOTA2MiwgMCwgMC44ODU1NV0sCiAgICAiOTIzIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODA2NjZdLAogICAgIjkyNiI6IFswLCAwLjY4NjExLCAwLjE1MDkyLCAwLCAwLjc2Nzc3XSwKICAgICI5MjgiOiBbMCwgMC42ODYxMSwgMC4xNzIwOCwgMCwgMC44OTYxXSwKICAgICI5MzEiOiBbMCwgMC42ODYxMSwgMC4xMTQzMSwgMCwgMC44MjY2Nl0sCiAgICAiOTMzIjogWzAsIDAuNjg2MTEsIDAuMTA3NzgsIDAsIDAuODg1NTVdLAogICAgIjkzNCI6IFswLCAwLjY4NjExLCAwLjA1NjMyLCAwLCAwLjgyNjY2XSwKICAgICI5MzYiOiBbMCwgMC42ODYxMSwgMC4xMDc3OCwgMCwgMC44ODU1NV0sCiAgICAiOTM3IjogWzAsIDAuNjg2MTEsIDAuMDk5MiwgMCwgMC44MjY2Nl0sCiAgICAiODIxMSI6IFswLCAwLjQ0NDQ0LCAwLjA5ODExLCAwLCAwLjU5MTExXSwKICAgICI4MjEyIjogWzAsIDAuNDQ0NDQsIDAuMDk4MTEsIDAsIDEuMTgyMjFdLAogICAgIjgyMTYiOiBbMCwgMC42OTQ0NCwgMC4xMjk0NSwgMCwgMC4zNTU1NV0sCiAgICAiODIxNyI6IFswLCAwLjY5NDQ0LCAwLjEyOTQ1LCAwLCAwLjM1NTU1XSwKICAgICI4MjIwIjogWzAsIDAuNjk0NDQsIDAuMTY3NzIsIDAsIDAuNjIwNTVdLAogICAgIjgyMjEiOiBbMCwgMC42OTQ0NCwgMC4wNzkzOSwgMCwgMC42MjA1NV0KICB9LAogICJNYWluLUl0YWxpYyI6IHsKICAgICIzMiI6IFswLCAwLCAwLCAwLCAwLjI1XSwKICAgICIzMyI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSwKICAgICIzNCI6IFswLCAwLjY5NDQ0LCAwLjA2OTYxLCAwLCAwLjUxNDQ0XSwKICAgICIzNSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA2NjE2LCAwLCAwLjgxNzc3XSwKICAgICIzNyI6IFswLjA1NTU2LCAwLjc1LCAwLjEzNjM5LCAwLCAwLjgxNzc3XSwKICAgICIzOCI6IFswLCAwLjY5NDQ0LCAwLjA5Njk0LCAwLCAwLjc2NjY2XSwKICAgICIzOSI6IFswLCAwLjY5NDQ0LCAwLjEyNDE3LCAwLCAwLjMwNjY3XSwKICAgICI0MCI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwLCAwLjQwODg5XSwKICAgICI0MSI6IFswLjI1LCAwLjc1LCAwLjAzNjk0LCAwLCAwLjQwODg5XSwKICAgICI0MiI6IFswLCAwLjc1LCAwLjE0OTE3LCAwLCAwLjUxMTExXSwKICAgICI0MyI6IFswLjA1NjY3LCAwLjU2MTY3LCAwLjAzNjk0LCAwLCAwLjc2NjY2XSwKICAgICI0NCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjMwNjY3XSwKICAgICI0NSI6IFswLCAwLjQzMDU2LCAwLjAyODI2LCAwLCAwLjM1Nzc4XSwKICAgICI0NiI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjMwNjY3XSwKICAgICI0NyI6IFswLjI1LCAwLjc1LCAwLjE2MTk0LCAwLCAwLjUxMTExXSwKICAgICI0OCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI0OSI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1MCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1MSI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1MiI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1MyI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1NCI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1NSI6IFswLjE5NDQ0LCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1NiI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1NyI6IFswLCAwLjY0NDQ0LCAwLjEzNTU2LCAwLCAwLjUxMTExXSwKICAgICI1OCI6IFswLCAwLjQzMDU2LCAwLjA1ODIsIDAsIDAuMzA2NjddLAogICAgIjU5IjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDU4MiwgMCwgMC4zMDY2N10sCiAgICAiNjEiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAuMDY2MTYsIDAsIDAuNzY2NjZdLAogICAgIjYzIjogWzAsIDAuNjk0NDQsIDAuMTIyNSwgMCwgMC41MTExMV0sCiAgICAiNjQiOiBbMCwgMC42OTQ0NCwgMC4wOTU5NywgMCwgMC43NjY2Nl0sCiAgICAiNjUiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NDMzM10sCiAgICAiNjYiOiBbMCwgMC42ODMzMywgMC4xMDI1NywgMCwgMC43MDM4OV0sCiAgICAiNjciOiBbMCwgMC42ODMzMywgMC4xNDUyOCwgMCwgMC43MTU1NV0sCiAgICAiNjgiOiBbMCwgMC42ODMzMywgMC4wOTQwMywgMCwgMC43NTVdLAogICAgIjY5IjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuNjc4MzNdLAogICAgIjcwIjogWzAsIDAuNjgzMzMsIDAuMTMzMDUsIDAsIDAuNjUyNzddLAogICAgIjcxIjogWzAsIDAuNjgzMzMsIDAuMDg3MjIsIDAsIDAuNzczNjFdLAogICAgIjcyIjogWzAsIDAuNjgzMzMsIDAuMTYzODksIDAsIDAuNzQzMzNdLAogICAgIjczIjogWzAsIDAuNjgzMzMsIDAuMTU4MDYsIDAsIDAuMzg1NTVdLAogICAgIjc0IjogWzAsIDAuNjgzMzMsIDAuMTQwMjgsIDAsIDAuNTI1XSwKICAgICI3NSI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjc2ODg4XSwKICAgICI3NiI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYyNzIyXSwKICAgICI3NyI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjg5NjY2XSwKICAgICI3OCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSwKICAgICI3OSI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSwKICAgICI4MCI6IFswLCAwLjY4MzMzLCAwLjEwMjU3LCAwLCAwLjY3ODMzXSwKICAgICI4MSI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSwKICAgICI4MiI6IFswLCAwLjY4MzMzLCAwLjAzODY4LCAwLCAwLjcyOTQ0XSwKICAgICI4MyI6IFswLCAwLjY4MzMzLCAwLjExOTcyLCAwLCAwLjU2MjIyXSwKICAgICI4NCI6IFswLCAwLjY4MzMzLCAwLjEzMzA1LCAwLCAwLjcxNTU1XSwKICAgICI4NSI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSwKICAgICI4NiI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwLCAwLjc0MzMzXSwKICAgICI4NyI6IFswLCAwLjY4MzMzLCAwLjE4MzYxLCAwLCAwLjk5ODg4XSwKICAgICI4OCI6IFswLCAwLjY4MzMzLCAwLjE1ODA2LCAwLCAwLjc0MzMzXSwKICAgICI4OSI6IFswLCAwLjY4MzMzLCAwLjE5MzgzLCAwLCAwLjc0MzMzXSwKICAgICI5MCI6IFswLCAwLjY4MzMzLCAwLjE0NTI4LCAwLCAwLjYxMzMzXSwKICAgICI5MSI6IFswLjI1LCAwLjc1LCAwLjE4NzUsIDAsIDAuMzA2NjddLAogICAgIjkzIjogWzAuMjUsIDAuNzUsIDAuMTA1MjgsIDAsIDAuMzA2NjddLAogICAgIjk0IjogWzAsIDAuNjk0NDQsIDAuMDY2NDYsIDAsIDAuNTExMTFdLAogICAgIjk1IjogWzAuMzEsIDAuMTIwNTYsIDAuMDkyMDgsIDAsIDAuNTExMTFdLAogICAgIjk3IjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuNTExMTFdLAogICAgIjk4IjogWzAsIDAuNjk0NDQsIDAuMDYzMTIsIDAsIDAuNDZdLAogICAgIjk5IjogWzAsIDAuNDMwNTYsIDAuMDU2NTMsIDAsIDAuNDZdLAogICAgIjEwMCI6IFswLCAwLjY5NDQ0LCAwLjEwMzMzLCAwLCAwLjUxMTExXSwKICAgICIxMDEiOiBbMCwgMC40MzA1NiwgMC4wNzUxNCwgMCwgMC40Nl0sCiAgICAiMTAyIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMjExOTQsIDAsIDAuMzA2NjddLAogICAgIjEwMyI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ2XSwKICAgICIxMDQiOiBbMCwgMC42OTQ0NCwgMC4wNzY3MSwgMCwgMC41MTExMV0sCiAgICAiMTA1IjogWzAsIDAuNjU1MzYsIDAuMTAxOSwgMCwgMC4zMDY2N10sCiAgICAiMTA2IjogWzAuMTk0NDQsIDAuNjU1MzYsIDAuMTQ0NjcsIDAsIDAuMzA2NjddLAogICAgIjEwNyI6IFswLCAwLjY5NDQ0LCAwLjEwNzY0LCAwLCAwLjQ2XSwKICAgICIxMDgiOiBbMCwgMC42OTQ0NCwgMC4xMDMzMywgMCwgMC4yNTU1NV0sCiAgICAiMTA5IjogWzAsIDAuNDMwNTYsIDAuMDc2NzEsIDAsIDAuODE3NzddLAogICAgIjExMCI6IFswLCAwLjQzMDU2LCAwLjA3NjcxLCAwLCAwLjU2MjIyXSwKICAgICIxMTEiOiBbMCwgMC40MzA1NiwgMC4wNjMxMiwgMCwgMC41MTExMV0sCiAgICAiMTEyIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDYzMTIsIDAsIDAuNTExMTFdLAogICAgIjExMyI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjA4ODQ3LCAwLCAwLjQ2XSwKICAgICIxMTQiOiBbMCwgMC40MzA1NiwgMC4xMDc2NCwgMCwgMC40MjE2Nl0sCiAgICAiMTE1IjogWzAsIDAuNDMwNTYsIDAuMDgyMDgsIDAsIDAuNDA4ODldLAogICAgIjExNiI6IFswLCAwLjYxNTA4LCAwLjA5NDg2LCAwLCAwLjMzMjIyXSwKICAgICIxMTciOiBbMCwgMC40MzA1NiwgMC4wNzY3MSwgMCwgMC41MzY2Nl0sCiAgICAiMTE4IjogWzAsIDAuNDMwNTYsIDAuMTA3NjQsIDAsIDAuNDZdLAogICAgIjExOSI6IFswLCAwLjQzMDU2LCAwLjEwNzY0LCAwLCAwLjY2NDQ0XSwKICAgICIxMjAiOiBbMCwgMC40MzA1NiwgMC4xMjA0MiwgMCwgMC40NjM4OV0sCiAgICAiMTIxIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDg4NDcsIDAsIDAuNDg1NTVdLAogICAgIjEyMiI6IFswLCAwLjQzMDU2LCAwLjEyMjkyLCAwLCAwLjQwODg5XSwKICAgICIxMjYiOiBbMC4zNSwgMC4zMTc4NiwgMC4xMTU4NSwgMCwgMC41MTExMV0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjE2OCI6IFswLCAwLjY2Nzg2LCAwLjEwNDc0LCAwLCAwLjUxMTExXSwKICAgICIxNzYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzEyOV0sCiAgICAiMTg0IjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDZdLAogICAgIjE5OCI6IFswLCAwLjY4MzMzLCAwLjEyMDI4LCAwLCAwLjg4Mjc3XSwKICAgICIyMTYiOiBbMC4wNDg2MSwgMC43MzE5NCwgMC4wOTQwMywgMCwgMC43NjY2Nl0sCiAgICAiMjIzIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMTA1MTQsIDAsIDAuNTM2NjZdLAogICAgIjIzMCI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjcxNTU1XSwKICAgICIyNDgiOiBbMC4wOTcyMiwgMC41Mjc3OCwgMC4wOTE5NCwgMCwgMC41MTExMV0sCiAgICAiMzM4IjogWzAsIDAuNjgzMzMsIDAuMTIwMjgsIDAsIDAuOTg0OTldLAogICAgIjMzOSI6IFswLCAwLjQzMDU2LCAwLjA3NTE0LCAwLCAwLjcxNTU1XSwKICAgICI3MTAiOiBbMCwgMC42OTQ0NCwgMC4wNjY0NiwgMCwgMC41MTExMV0sCiAgICAiNzExIjogWzAsIDAuNjI4NDcsIDAuMDgyOTUsIDAsIDAuNTExMTFdLAogICAgIjcxMyI6IFswLCAwLjU2MTY3LCAwLjEwMzMzLCAwLCAwLjUxMTExXSwKICAgICI3MTQiOiBbMCwgMC42OTQ0NCwgMC4wOTY5NCwgMCwgMC41MTExMV0sCiAgICAiNzE1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTExMTFdLAogICAgIjcyOCI6IFswLCAwLjY5NDQ0LCAwLjEwODA2LCAwLCAwLjUxMTExXSwKICAgICI3MjkiOiBbMCwgMC42Njc4NiwgMC4xMTc1MiwgMCwgMC4zMDY2N10sCiAgICAiNzMwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMxMjldLAogICAgIjczMiI6IFswLCAwLjY2Nzg2LCAwLjExNTg1LCAwLCAwLjUxMTExXSwKICAgICI3MzMiOiBbMCwgMC42OTQ0NCwgMC4xMjI1LCAwLCAwLjUxMTExXSwKICAgICI5MTUiOiBbMCwgMC42ODMzMywgMC4xMzMwNSwgMCwgMC42MjcyMl0sCiAgICAiOTE2IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuODE3NzddLAogICAgIjkyMCI6IFswLCAwLjY4MzMzLCAwLjA5NDAzLCAwLCAwLjc2NjY2XSwKICAgICI5MjMiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42OTIyMl0sCiAgICAiOTI2IjogWzAsIDAuNjgzMzMsIDAuMTUyOTQsIDAsIDAuNjY0NDRdLAogICAgIjkyOCI6IFswLCAwLjY4MzMzLCAwLjE2Mzg5LCAwLCAwLjc0MzMzXSwKICAgICI5MzEiOiBbMCwgMC42ODMzMywgMC4xMjAyOCwgMCwgMC43MTU1NV0sCiAgICAiOTMzIjogWzAsIDAuNjgzMzMsIDAuMTExMTEsIDAsIDAuNzY2NjZdLAogICAgIjkzNCI6IFswLCAwLjY4MzMzLCAwLjA1OTg2LCAwLCAwLjcxNTU1XSwKICAgICI5MzYiOiBbMCwgMC42ODMzMywgMC4xMTExMSwgMCwgMC43NjY2Nl0sCiAgICAiOTM3IjogWzAsIDAuNjgzMzMsIDAuMTAyNTcsIDAsIDAuNzE1NTVdLAogICAgIjgyMTEiOiBbMCwgMC40MzA1NiwgMC4wOTIwOCwgMCwgMC41MTExMV0sCiAgICAiODIxMiI6IFswLCAwLjQzMDU2LCAwLjA5MjA4LCAwLCAxLjAyMjIyXSwKICAgICI4MjE2IjogWzAsIDAuNjk0NDQsIDAuMTI0MTcsIDAsIDAuMzA2NjddLAogICAgIjgyMTciOiBbMCwgMC42OTQ0NCwgMC4xMjQxNywgMCwgMC4zMDY2N10sCiAgICAiODIyMCI6IFswLCAwLjY5NDQ0LCAwLjE2ODUsIDAsIDAuNTE0NDRdLAogICAgIjgyMjEiOiBbMCwgMC42OTQ0NCwgMC4wNjk2MSwgMCwgMC41MTQ0NF0sCiAgICAiODQ2MyI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XQogIH0sCiAgIk1haW4tUmVndWxhciI6IHsKICAgICIzMiI6IFswLCAwLCAwLCAwLCAwLjI1XSwKICAgICIzMyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSwKICAgICIzNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjM1IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLAogICAgIjM2IjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuNV0sCiAgICAiMzciOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC44MzMzNF0sCiAgICAiMzgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiMzkiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sCiAgICAiNDAiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sCiAgICAiNDEiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sCiAgICAiNDIiOiBbMCwgMC43NSwgMCwgMCwgMC41XSwKICAgICI0MyI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI0NCI6IFswLjE5NDQ0LCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI0NSI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjMzMzMzXSwKICAgICI0NiI6IFswLCAwLjEwNTU2LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI0NyI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLAogICAgIjQ4IjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sCiAgICAiNDkiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSwKICAgICI1MCI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLAogICAgIjUxIjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sCiAgICAiNTIiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSwKICAgICI1MyI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLAogICAgIjU0IjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sCiAgICAiNTUiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41XSwKICAgICI1NiI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLAogICAgIjU3IjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sCiAgICAiNTgiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sCiAgICAiNTkiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC4yNzc3OF0sCiAgICAiNjAiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNzc3NzhdLAogICAgIjYxIjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI2MiI6IFswLjAzOTEsIDAuNTM5MSwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNjMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40NzIyMl0sCiAgICAiNjQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNjUiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sCiAgICAiNjYiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MDgzNF0sCiAgICAiNjciOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sCiAgICAiNjgiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NjM4OV0sCiAgICAiNjkiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42ODA1Nl0sCiAgICAiNzAiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NTI3OF0sCiAgICAiNzEiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43ODQ3Ml0sCiAgICAiNzIiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sCiAgICAiNzMiOiBbMCwgMC42ODMzMywgMCwgMCwgMC4zNjExMV0sCiAgICAiNzQiOiBbMCwgMC42ODMzMywgMCwgMCwgMC41MTM4OV0sCiAgICAiNzUiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNzYiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42MjVdLAogICAgIjc3IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuOTE2NjddLAogICAgIjc4IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLAogICAgIjc5IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjgwIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjgwNTZdLAogICAgIjgxIjogWzAuMTk0NDQsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjgyIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzM2MTFdLAogICAgIjgzIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNTU1NTZdLAogICAgIjg0IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLAogICAgIjg1IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLAogICAgIjg2IjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDAuNzVdLAogICAgIjg3IjogWzAsIDAuNjgzMzMsIDAuMDEzODksIDAsIDEuMDI3NzhdLAogICAgIjg4IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLAogICAgIjg5IjogWzAsIDAuNjgzMzMsIDAuMDI1LCAwLCAwLjc1XSwKICAgICI5MCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjYxMTExXSwKICAgICI5MSI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI5MiI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLAogICAgIjkzIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMjc3NzhdLAogICAgIjk0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiOTUiOiBbMC4zMSwgMC4xMjA1NiwgMC4wMjc3OCwgMCwgMC41XSwKICAgICI5NyI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLAogICAgIjk4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLAogICAgIjk5IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjEwMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSwKICAgICIxMDEiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC40NDQ0NV0sCiAgICAiMTAyIjogWzAsIDAuNjk0NDQsIDAuMDc3NzgsIDAsIDAuMzA1NTZdLAogICAgIjEwMyI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLjAxMzg5LCAwLCAwLjVdLAogICAgIjEwNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1NTU2XSwKICAgICIxMDUiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC4yNzc3OF0sCiAgICAiMTA2IjogWzAuMTk0NDQsIDAuNjY3ODYsIDAsIDAsIDAuMzA1NTZdLAogICAgIjEwNyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNzc4XSwKICAgICIxMDgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sCiAgICAiMTA5IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuODMzMzRdLAogICAgIjExMCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSwKICAgICIxMTEiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSwKICAgICIxMTIiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41NTU1Nl0sCiAgICAiMTEzIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNTI3NzhdLAogICAgIjExNCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjM5MTY3XSwKICAgICIxMTUiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC4zOTQ0NV0sCiAgICAiMTE2IjogWzAsIDAuNjE1MDgsIDAsIDAsIDAuMzg4ODldLAogICAgIjExNyI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjU1NTU2XSwKICAgICIxMTgiOiBbMCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sCiAgICAiMTE5IjogWzAsIDAuNDMwNTYsIDAuMDEzODksIDAsIDAuNzIyMjJdLAogICAgIjEyMCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNzc4XSwKICAgICIxMjEiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMTM4OSwgMCwgMC41Mjc3OF0sCiAgICAiMTIyIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjEyMyI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLAogICAgIjEyNCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjI3Nzc4XSwKICAgICIxMjUiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41XSwKICAgICIxMjYiOiBbMC4zNSwgMC4zMTc4NiwgMCwgMCwgMC41XSwKICAgICIxNjAiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiMTYzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzY5MDldLAogICAgIjE2NyI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSwKICAgICIxNjgiOiBbMCwgMC42Njc4NiwgMCwgMCwgMC41XSwKICAgICIxNzIiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC42NjY2N10sCiAgICAiMTc2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzVdLAogICAgIjE3NyI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICIxODIiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sCiAgICAiMTg0IjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjE5OCI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjkwMjc4XSwKICAgICIyMTUiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMjE2IjogWzAuMDQ4NjEsIDAuNzMxOTQsIDAsIDAsIDAuNzc3NzhdLAogICAgIjIyMyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjIzMCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjcyMjIyXSwKICAgICIyNDciOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMjQ4IjogWzAuMDk3MjIsIDAuNTI3NzgsIDAsIDAsIDAuNV0sCiAgICAiMzA1IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuMjc3NzhdLAogICAgIjMzOCI6IFswLCAwLjY4MzMzLCAwLCAwLCAxLjAxMzg5XSwKICAgICIzMzkiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTY3IjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuMzA1NTZdLAogICAgIjcxMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjcxMSI6IFswLCAwLjYyODQ3LCAwLCAwLCAwLjVdLAogICAgIjcxMyI6IFswLCAwLjU2Nzc4LCAwLCAwLCAwLjVdLAogICAgIjcxNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjcxNSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjcyOCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjcyOSI6IFswLCAwLjY2Nzg2LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI3MzAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43NV0sCiAgICAiNzMyIjogWzAsIDAuNjY3ODYsIDAsIDAsIDAuNV0sCiAgICAiNzMzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiOTE1IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNjI1XSwKICAgICI5MTYiOiBbMCwgMC42ODMzMywgMCwgMCwgMC44MzMzNF0sCiAgICAiOTIwIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjkyMyI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjY5NDQ1XSwKICAgICI5MjYiOiBbMCwgMC42ODMzMywgMCwgMCwgMC42NjY2N10sCiAgICAiOTI4IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzVdLAogICAgIjkzMSI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjcyMjIyXSwKICAgICI5MzMiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiOTM0IjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuNzIyMjJdLAogICAgIjkzNiI6IFswLCAwLjY4MzMzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5MzciOiBbMCwgMC42ODMzMywgMCwgMCwgMC43MjIyMl0sCiAgICAiODIxMSI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLCAwLjVdLAogICAgIjgyMTIiOiBbMCwgMC40MzA1NiwgMC4wMjc3OCwgMCwgMV0sCiAgICAiODIxNiI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI4MjE3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLAogICAgIjgyMjAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSwKICAgICI4MjIxIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiODIyNCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjQ0NDQ1XSwKICAgICI4MjI1IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjgyMzAiOiBbMCwgMC4xMjMsIDAsIDAsIDEuMTcyXSwKICAgICI4MjQyIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuMjc1XSwKICAgICI4NDA3IjogWzAsIDAuNzE0NDQsIDAuMTUzODIsIDAsIDAuNV0sCiAgICAiODQ2MyI6IFswLCAwLjY4ODg5LCAwLCAwLCAwLjU0MDI4XSwKICAgICI4NDY1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLAogICAgIjg0NjciOiBbMCwgMC42OTQ0NCwgMCwgMC4xMTExMSwgMC40MTY2N10sCiAgICAiODQ3MiI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjExMTExLCAwLjYzNjQ2XSwKICAgICI4NDc2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLAogICAgIjg1MDEiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sCiAgICAiODU5MiI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMV0sCiAgICAiODU5MyI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjg1OTQiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg1OTUiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC41XSwKICAgICI4NTk2IjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxXSwKICAgICI4NTk3IjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sCiAgICAiODU5OCI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxXSwKICAgICI4NTk5IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDFdLAogICAgIjg2MDAiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMV0sCiAgICAiODYwMSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAxXSwKICAgICI4NjE0IjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMV0sCiAgICAiODYxNyI6IFswLjAxMSwgMC41MTEsIDAsIDAsIDEuMTI2XSwKICAgICI4NjE4IjogWzAuMDExLCAwLjUxMSwgMCwgMCwgMS4xMjZdLAogICAgIjg2MzYiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2MzciOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NDAiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NDEiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NTIiOiBbMC4wMTEsIDAuNjcxLCAwLCAwLCAxXSwKICAgICI4NjU2IjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAxXSwKICAgICI4NjU3IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLAogICAgIjg2NTgiOiBbLTAuMTMzMTMsIDAuMzY2ODcsIDAsIDAsIDFdLAogICAgIjg2NTkiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sCiAgICAiODY2MCI6IFstMC4xMzMxMywgMC4zNjY4NywgMCwgMCwgMV0sCiAgICAiODY2MSI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjYxMTExXSwKICAgICI4NzA0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLAogICAgIjg3MDYiOiBbMCwgMC42OTQ0NCwgMC4wNTU1NiwgMC4wODMzNCwgMC41MzA5XSwKICAgICI4NzA3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU1NTZdLAogICAgIjg3MDkiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41XSwKICAgICI4NzExIjogWzAsIDAuNjgzMzMsIDAsIDAsIDAuODMzMzRdLAogICAgIjg3MTIiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNjY2NjddLAogICAgIjg3MTUiOiBbMC4wMzkxLCAwLjUzOTEsIDAsIDAsIDAuNjY2NjddLAogICAgIjg3MjIiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODcyMyI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzI1IjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sCiAgICAiODcyNiI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLAogICAgIjg3MjciOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sCiAgICAiODcyOCI6IFstMC4wNTU1NSwgMC40NDQ0NSwgMCwgMCwgMC41XSwKICAgICI4NzI5IjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjVdLAogICAgIjg3MzAiOiBbMC4yLCAwLjgsIDAsIDAsIDAuODMzMzRdLAogICAgIjg3MzMiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC43Nzc3OF0sCiAgICAiODczNCI6IFswLCAwLjQzMDU2LCAwLCAwLCAxXSwKICAgICI4NzM2IjogWzAsIDAuNjkyMjQsIDAsIDAsIDAuNzIyMjJdLAogICAgIjg3MzkiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yNzc3OF0sCiAgICAiODc0MSI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjVdLAogICAgIjg3NDMiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sCiAgICAiODc0NCI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4NzQ1IjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLAogICAgIjg3NDYiOiBbMCwgMC41NTU1NiwgMCwgMCwgMC42NjY2N10sCiAgICAiODc0NyI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMTExLCAwLCAwLjQxNjY3XSwKICAgICI4NzY0IjogWy0wLjEzMzEzLCAwLjM2Njg3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzY4IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLAogICAgIjg3NzEiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3NzMiOiBbLTAuMDIyLCAwLjU4OSwgMCwgMCwgMC43NzhdLAogICAgIjg3NzYiOiBbLTAuMDE2ODgsIDAuNDgzMTIsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3ODEiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg3ODQiOiBbLTAuMTMzLCAwLjY3MywgMCwgMCwgMC43NzhdLAogICAgIjg4MDEiOiBbLTAuMDM2MjUsIDAuNDYzNzUsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MDQiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODgwNSI6IFswLjEzNTk3LCAwLjYzNTk3LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODEwIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxXSwKICAgICI4ODExIjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAxXSwKICAgICI4ODI2IjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODI3IjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODM0IjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODM1IjogWzAuMDM5MSwgMC41MzkxLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODM4IjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4MzkiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg0NiI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4ODQ5IjogWzAuMTM1OTcsIDAuNjM1OTcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4NTAiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg1MSI6IFswLCAwLjU1NTU2LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4ODUyIjogWzAsIDAuNTU1NTYsIDAsIDAsIDAuNjY2NjddLAogICAgIjg4NTMiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg1NCI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODU1IjogWzAuMDgzMzMsIDAuNTgzMzMsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4NTYiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiODg1NyI6IFswLjA4MzMzLCAwLjU4MzMzLCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODY2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLAogICAgIjg4NjciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sCiAgICAiODg2OCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4ODY5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg4NzIiOiBbMC4yNDksIDAuNzUsIDAsIDAsIDAuODY3XSwKICAgICI4OTAwIjogWy0wLjA1NTU1LCAwLjQ0NDQ1LCAwLCAwLCAwLjVdLAogICAgIjg5MDEiOiBbLTAuMDU1NTUsIDAuNDQ0NDUsIDAsIDAsIDAuMjc3NzhdLAogICAgIjg5MDIiOiBbLTAuMDM0NzIsIDAuNDY1MjgsIDAsIDAsIDAuNV0sCiAgICAiODkwNCI6IFs1ZS0zLCAwLjUwNSwgMCwgMCwgMC45XSwKICAgICI4OTQyIjogWzAuMDMsIDAuOTAzLCAwLCAwLCAwLjI3OF0sCiAgICAiODk0MyI6IFstMC4xOSwgMC4zMTMsIDAsIDAsIDEuMTcyXSwKICAgICI4OTQ1IjogWy0wLjEsIDAuODIzLCAwLCAwLCAxLjI4Ml0sCiAgICAiODk2OCI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSwKICAgICI4OTY5IjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjg5NzAiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40NDQ0NV0sCiAgICAiODk3MSI6IFswLjI1LCAwLjc1LCAwLCAwLCAwLjQ0NDQ1XSwKICAgICI4OTk0IjogWy0wLjE0MjM2LCAwLjM1NzY0LCAwLCAwLCAxXSwKICAgICI4OTk1IjogWy0wLjE0MjM2LCAwLjM1NzY0LCAwLCAwLCAxXSwKICAgICI5MTM2IjogWzAuMjQ0LCAwLjc0NCwgMCwgMCwgMC40MTJdLAogICAgIjkxMzciOiBbMC4yNDQsIDAuNzQ1LCAwLCAwLCAwLjQxMl0sCiAgICAiOTY1MSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjg4ODg5XSwKICAgICI5NjU3IjogWy0wLjAzNDcyLCAwLjQ2NTI4LCAwLCAwLCAwLjVdLAogICAgIjk2NjEiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC44ODg4OV0sCiAgICAiOTY2NyI6IFstMC4wMzQ3MiwgMC40NjUyOCwgMCwgMCwgMC41XSwKICAgICI5NzExIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDFdLAogICAgIjk4MjQiOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiOTgyNSI6IFswLjEyOTYzLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5ODI2IjogWzAuMTI5NjMsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLAogICAgIjk4MjciOiBbMC4xMjk2MywgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiOTgzNyI6IFswLCAwLjc1LCAwLCAwLCAwLjM4ODg5XSwKICAgICI5ODM4IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuMzg4ODldLAogICAgIjk4MzkiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC4zODg4OV0sCiAgICAiMTAyMTYiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sCiAgICAiMTAyMTciOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zODg4OV0sCiAgICAiMTAyMjIiOiBbMC4yNDQsIDAuNzQ0LCAwLCAwLCAwLjQxMl0sCiAgICAiMTAyMjMiOiBbMC4yNDQsIDAuNzQ1LCAwLCAwLCAwLjQxMl0sCiAgICAiMTAyMjkiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjYwOV0sCiAgICAiMTAyMzAiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjYzOF0sCiAgICAiMTAyMzEiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjg1OV0sCiAgICAiMTAyMzIiOiBbMC4wMjQsIDAuNTI1LCAwLCAwLCAxLjYwOV0sCiAgICAiMTAyMzMiOiBbMC4wMjQsIDAuNTI1LCAwLCAwLCAxLjYzOF0sCiAgICAiMTAyMzQiOiBbMC4wMjQsIDAuNTI1LCAwLCAwLCAxLjg1OF0sCiAgICAiMTAyMzYiOiBbMC4wMTEsIDAuNTExLCAwLCAwLCAxLjYzOF0sCiAgICAiMTA4MTUiOiBbMCwgMC42ODMzMywgMCwgMCwgMC43NV0sCiAgICAiMTA5MjciOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiMTA5MjgiOiBbMC4xMzU5NywgMC42MzU5NywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNTczNzYiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMF0KICB9LAogICJNYXRoLUJvbGRJdGFsaWMiOiB7CiAgICAiMzIiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiNDgiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjQ5IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI1MCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNTEiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjUyIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI1MyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNTQiOiBbMCwgMC42NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjU1IjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTc1XSwKICAgICI1NiI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjU3NV0sCiAgICAiNTciOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41NzVdLAogICAgIjY1IjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODY5NDRdLAogICAgIjY2IjogWzAsIDAuNjg2MTEsIDAuMDQ4MzUsIDAsIDAuODY2NF0sCiAgICAiNjciOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC44MTY5NF0sCiAgICAiNjgiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC45MzgxMl0sCiAgICAiNjkiOiBbMCwgMC42ODYxMSwgMC4wNTQ1MSwgMCwgMC44MTAwN10sCiAgICAiNzAiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC42ODg4OV0sCiAgICAiNzEiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC44ODY3M10sCiAgICAiNzIiOiBbMCwgMC42ODYxMSwgMC4wODIyOSwgMCwgMC45ODIyOV0sCiAgICAiNzMiOiBbMCwgMC42ODYxMSwgMC4wNzc3OCwgMCwgMC41MTExMV0sCiAgICAiNzQiOiBbMCwgMC42ODYxMSwgMC4xMDA2OSwgMCwgMC42MzEyNV0sCiAgICAiNzUiOiBbMCwgMC42ODYxMSwgMC4wNjk3OSwgMCwgMC45NzExOF0sCiAgICAiNzYiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NTU1NV0sCiAgICAiNzciOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMS4xNDIwMV0sCiAgICAiNzgiOiBbMCwgMC42ODYxMSwgMC4xMTQyNCwgMCwgMC45NTAzNF0sCiAgICAiNzkiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC44MzY2Nl0sCiAgICAiODAiOiBbMCwgMC42ODYxMSwgMC4xNTk3MiwgMCwgMC43MjMwOV0sCiAgICAiODEiOiBbMC4xOTQ0NCwgMC42ODYxMSwgMCwgMCwgMC44Njg2MV0sCiAgICAiODIiOiBbMCwgMC42ODYxMSwgNDIxZS01LCAwLCAwLjg3MjM1XSwKICAgICI4MyI6IFswLCAwLjY4NjExLCAwLjA1MzgyLCAwLCAwLjY5MjcxXSwKICAgICI4NCI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjYzNjYzXSwKICAgICI4NSI6IFswLCAwLjY4NjExLCAwLjExNDI0LCAwLCAwLjgwMDI3XSwKICAgICI4NiI6IFswLCAwLjY4NjExLCAwLjI1NTU1LCAwLCAwLjY3Nzc4XSwKICAgICI4NyI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAxLjA5MzA1XSwKICAgICI4OCI6IFswLCAwLjY4NjExLCAwLjA3Nzc4LCAwLCAwLjk0NzIyXSwKICAgICI4OSI6IFswLCAwLjY4NjExLCAwLjI1NTU1LCAwLCAwLjY3NDU4XSwKICAgICI5MCI6IFswLCAwLjY4NjExLCAwLjA2OTc5LCAwLCAwLjc3MjU3XSwKICAgICI5NyI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjYzMjg3XSwKICAgICI5OCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUyMDgzXSwKICAgICI5OSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxMzQyXSwKICAgICIxMDAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MDk3Ml0sCiAgICAiMTAxIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTUzNjFdLAogICAgIjEwMiI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjExMDQyLCAwLCAwLjU2ODA2XSwKICAgICIxMDMiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NDQ5XSwKICAgICIxMDQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42Njc1OV0sCiAgICAiMTA1IjogWzAsIDAuNjkzMjYsIDAsIDAsIDAuNDA0OF0sCiAgICAiMTA2IjogWzAuMTk0NDQsIDAuNjkzMjYsIDAuMDYyMiwgMCwgMC40NzA4M10sCiAgICAiMTA3IjogWzAsIDAuNjk0NDQsIDAuMDE4NTIsIDAsIDAuNjAzN10sCiAgICAiMTA4IjogWzAsIDAuNjk0NDQsIDg4ZS00LCAwLCAwLjM0ODE1XSwKICAgICIxMDkiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMS4wMzI0XSwKICAgICIxMTAiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC43MTI5Nl0sCiAgICAiMTExIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTg0NzJdLAogICAgIjExMiI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjYwMDkyXSwKICAgICIxMTMiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC41NDIxM10sCiAgICAiMTE0IjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuNTI4N10sCiAgICAiMTE1IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNTMxMjVdLAogICAgIjExNiI6IFswLCAwLjYzNDkyLCAwLCAwLCAwLjQxNTI4XSwKICAgICIxMTciOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42ODEwMl0sCiAgICAiMTE4IjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTY2NjZdLAogICAgIjExOSI6IFswLCAwLjQ0NDQ0LCAwLjAyNzc4LCAwLCAwLjgzMTQ4XSwKICAgICIxMjAiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42NTkwM10sCiAgICAiMTIxIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNTkwMjhdLAogICAgIjEyMiI6IFswLCAwLjQ0NDQ0LCAwLjA0MjEzLCAwLCAwLjU1NTA5XSwKICAgICIxNjAiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiOTE1IjogWzAsIDAuNjg2MTEsIDAuMTU5NzIsIDAsIDAuNjU2OTRdLAogICAgIjkxNiI6IFswLCAwLjY4NjExLCAwLCAwLCAwLjk1ODMzXSwKICAgICI5MjAiOiBbMCwgMC42ODYxMSwgMC4wMzE5NCwgMCwgMC44NjcyMl0sCiAgICAiOTIzIjogWzAsIDAuNjg2MTEsIDAsIDAsIDAuODA1NTVdLAogICAgIjkyNiI6IFswLCAwLjY4NjExLCAwLjA3NDU4LCAwLCAwLjg0MTI1XSwKICAgICI5MjgiOiBbMCwgMC42ODYxMSwgMC4wODIyOSwgMCwgMC45ODIyOV0sCiAgICAiOTMxIjogWzAsIDAuNjg2MTEsIDAuMDU0NTEsIDAsIDAuODg1MDddLAogICAgIjkzMyI6IFswLCAwLjY4NjExLCAwLjE1OTcyLCAwLCAwLjY3MDgzXSwKICAgICI5MzQiOiBbMCwgMC42ODYxMSwgMCwgMCwgMC43NjY2Nl0sCiAgICAiOTM2IjogWzAsIDAuNjg2MTEsIDAuMTE2NTMsIDAsIDAuNzE0MDJdLAogICAgIjkzNyI6IFswLCAwLjY4NjExLCAwLjA0ODM1LCAwLCAwLjg3ODldLAogICAgIjk0NSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjc2MDY0XSwKICAgICI5NDYiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzQwMywgMCwgMC42NTk3Ml0sCiAgICAiOTQ3IjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDYzODksIDAsIDAuNTkwMDNdLAogICAgIjk0OCI6IFswLCAwLjY5NDQ0LCAwLjAzODE5LCAwLCAwLjUyMjIyXSwKICAgICI5NDkiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41Mjg4Ml0sCiAgICAiOTUwIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDYyMTUsIDAsIDAuNTA4MzNdLAogICAgIjk1MSI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjZdLAogICAgIjk1MiI6IFswLCAwLjY5NDQ0LCAwLjAzMTk0LCAwLCAwLjU2MThdLAogICAgIjk1MyI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQxMjA0XSwKICAgICI5NTQiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC42Njc1OV0sCiAgICAiOTU1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjcwODNdLAogICAgIjk1NiI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjcwNzg3XSwKICAgICI5NTciOiBbMCwgMC40NDQ0NCwgMC4wNjg5OCwgMCwgMC41NzY4NV0sCiAgICAiOTU4IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDMwMjEsIDAsIDAuNTA4MzNdLAogICAgIjk1OSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjU4NDcyXSwKICAgICI5NjAiOiBbMCwgMC40NDQ0NCwgMC4wMzcwNCwgMCwgMC42ODI0MV0sCiAgICAiOTYxIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjExOF0sCiAgICAiOTYyIjogWzAuMDk3MjIsIDAuNDQ0NDQsIDAuMDc5MTcsIDAsIDAuNDIzNjFdLAogICAgIjk2MyI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjY4NTg4XSwKICAgICI5NjQiOiBbMCwgMC40NDQ0NCwgMC4xMzQ3MiwgMCwgMC41MjA4M10sCiAgICAiOTY1IjogWzAsIDAuNDQ0NDQsIDAuMDM3MDQsIDAsIDAuNjMwNTVdLAogICAgIjk2NiI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjc0NzIyXSwKICAgICI5NjciOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC43MTgwNV0sCiAgICAiOTY4IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDM3MDQsIDAsIDAuNzU4MzNdLAogICAgIjk2OSI6IFswLCAwLjQ0NDQ0LCAwLjAzNzA0LCAwLCAwLjcxNzgyXSwKICAgICI5NzciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42OTE1NV0sCiAgICAiOTgxIjogWzAuMTk0NDQsIDAuNjk0NDQsIDAsIDAsIDAuNzEyNV0sCiAgICAiOTgyIjogWzAsIDAuNDQ0NDQsIDAuMDMxOTQsIDAsIDAuOTc1XSwKICAgICIxMDA5IjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNjExOF0sCiAgICAiMTAxMyI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ4MzMzXSwKICAgICI1NzY0OSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjM5MzUyXSwKICAgICI1NzkxMSI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLCAwLCAwLjQzODg5XQogIH0sCiAgIk1hdGgtSXRhbGljIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjQ4IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNV0sCiAgICAiNDkiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41XSwKICAgICI1MCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjVdLAogICAgIjUxIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sCiAgICAiNTIiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSwKICAgICI1MyI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLCAwLjVdLAogICAgIjU0IjogWzAsIDAuNjQ0NDQsIDAsIDAsIDAuNV0sCiAgICAiNTUiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMCwgMC41XSwKICAgICI1NiI6IFswLCAwLjY0NDQ0LCAwLCAwLCAwLjVdLAogICAgIjU3IjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAsIDAuNV0sCiAgICAiNjUiOiBbMCwgMC42ODMzMywgMCwgMC4xMzg4OSwgMC43NV0sCiAgICAiNjYiOiBbMCwgMC42ODMzMywgMC4wNTAxNywgMC4wODMzNCwgMC43NTg1MV0sCiAgICAiNjciOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC43MTQ3Ml0sCiAgICAiNjgiOiBbMCwgMC42ODMzMywgMC4wMjc3OCwgMC4wNTU1NiwgMC44Mjc5Ml0sCiAgICAiNjkiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC43MzgyXSwKICAgICI3MCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjY0MzA2XSwKICAgICI3MSI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjc4NjI1XSwKICAgICI3MiI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2LCAwLjgzMTI1XSwKICAgICI3MyI6IFswLCAwLjY4MzMzLCAwLjA3ODQ3LCAwLjExMTExLCAwLjQzOTU4XSwKICAgICI3NCI6IFswLCAwLjY4MzMzLCAwLjA5NjE4LCAwLjE2NjY3LCAwLjU1NDUxXSwKICAgICI3NSI6IFswLCAwLjY4MzMzLCAwLjA3MTUzLCAwLjA1NTU2LCAwLjg0OTMxXSwKICAgICI3NiI6IFswLCAwLjY4MzMzLCAwLCAwLjAyNzc4LCAwLjY4MDU2XSwKICAgICI3NyI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0LCAwLjk3MDE0XSwKICAgICI3OCI6IFswLCAwLjY4MzMzLCAwLjEwOTAzLCAwLjA4MzM0LCAwLjgwMzQ3XSwKICAgICI3OSI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc2Mjc4XSwKICAgICI4MCI6IFswLCAwLjY4MzMzLCAwLjEzODg5LCAwLjA4MzM0LCAwLjY0MjAxXSwKICAgICI4MSI6IFswLjE5NDQ0LCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjc5MDU2XSwKICAgICI4MiI6IFswLCAwLjY4MzMzLCA3NzNlLTUsIDAuMDgzMzQsIDAuNzU5MjldLAogICAgIjgzIjogWzAsIDAuNjgzMzMsIDAuMDU3NjQsIDAuMDgzMzQsIDAuNjEzMl0sCiAgICAiODQiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC41ODQzOF0sCiAgICAiODUiOiBbMCwgMC42ODMzMywgMC4xMDkwMywgMC4wMjc3OCwgMC42ODI3OF0sCiAgICAiODYiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODMzM10sCiAgICAiODciOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMCwgMC45NDQ0NV0sCiAgICAiODgiOiBbMCwgMC42ODMzMywgMC4wNzg0NywgMC4wODMzNCwgMC44Mjg0N10sCiAgICAiODkiOiBbMCwgMC42ODMzMywgMC4yMjIyMiwgMCwgMC41ODA1Nl0sCiAgICAiOTAiOiBbMCwgMC42ODMzMywgMC4wNzE1MywgMC4wODMzNCwgMC42ODI2NF0sCiAgICAiOTciOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41Mjg1OV0sCiAgICAiOTgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC40MjkxN10sCiAgICAiOTkiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40MzI3Nl0sCiAgICAiMTAwIjogWzAsIDAuNjk0NDQsIDAsIDAuMTY2NjcsIDAuNTIwNDldLAogICAgIjEwMSI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ2NTYzXSwKICAgICIxMDIiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4xMDc2NCwgMC4xNjY2NywgMC40ODk1OV0sCiAgICAiMTAzIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDI3NzgsIDAuNDc2OTddLAogICAgIjEwNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU3NjE2XSwKICAgICIxMDUiOiBbMCwgMC42NTk1MiwgMCwgMCwgMC4zNDQ1MV0sCiAgICAiMTA2IjogWzAuMTk0NDQsIDAuNjU5NTIsIDAuMDU3MjQsIDAsIDAuNDExODFdLAogICAgIjEwNyI6IFswLCAwLjY5NDQ0LCAwLjAzMTQ4LCAwLCAwLjUyMDZdLAogICAgIjEwOCI6IFswLCAwLjY5NDQ0LCAwLjAxOTY4LCAwLjA4MzM0LCAwLjI5ODM4XSwKICAgICIxMDkiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC44NzgwMV0sCiAgICAiMTEwIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNjAwMjNdLAogICAgIjExMSI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQ4NDcyXSwKICAgICIxMTIiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MDMxM10sCiAgICAiMTEzIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAuMDM1ODgsIDAuMDgzMzQsIDAuNDQ2NDFdLAogICAgIjExNCI6IFswLCAwLjQzMDU2LCAwLjAyNzc4LCAwLjA1NTU2LCAwLjQ1MTE2XSwKICAgICIxMTUiOiBbMCwgMC40MzA1NiwgMCwgMC4wNTU1NiwgMC40Njg3NV0sCiAgICAiMTE2IjogWzAsIDAuNjE1MDgsIDAsIDAuMDgzMzQsIDAuMzYxMTFdLAogICAgIjExNyI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MjQ2XSwKICAgICIxMTgiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC40ODQ3Ml0sCiAgICAiMTE5IjogWzAsIDAuNDMwNTYsIDAuMDI2OTEsIDAuMDgzMzQsIDAuNzE1OTJdLAogICAgIjEyMCI6IFswLCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjU3MTUzXSwKICAgICIxMjEiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTAyOF0sCiAgICAiMTIyIjogWzAsIDAuNDMwNTYsIDAuMDQzOTgsIDAuMDU1NTYsIDAuNDY1MDVdLAogICAgIjE2MCI6IFswLCAwLCAwLCAwLCAwLjI1XSwKICAgICI5MTUiOiBbMCwgMC42ODMzMywgMC4xMzg4OSwgMC4wODMzNCwgMC42MTUyOF0sCiAgICAiOTE2IjogWzAsIDAuNjgzMzMsIDAsIDAuMTY2NjcsIDAuODMzMzRdLAogICAgIjkyMCI6IFswLCAwLjY4MzMzLCAwLjAyNzc4LCAwLjA4MzM0LCAwLjc2Mjc4XSwKICAgICI5MjMiOiBbMCwgMC42ODMzMywgMCwgMC4xNjY2NywgMC42OTQ0NV0sCiAgICAiOTI2IjogWzAsIDAuNjgzMzMsIDAuMDc1NjksIDAuMDgzMzQsIDAuNzQyMzZdLAogICAgIjkyOCI6IFswLCAwLjY4MzMzLCAwLjA4MTI1LCAwLjA1NTU2LCAwLjgzMTI1XSwKICAgICI5MzEiOiBbMCwgMC42ODMzMywgMC4wNTc2NCwgMC4wODMzNCwgMC43Nzk4Nl0sCiAgICAiOTMzIjogWzAsIDAuNjgzMzMsIDAuMTM4ODksIDAuMDU1NTYsIDAuNTgzMzNdLAogICAgIjkzNCI6IFswLCAwLjY4MzMzLCAwLCAwLjA4MzM0LCAwLjY2NjY3XSwKICAgICI5MzYiOiBbMCwgMC42ODMzMywgMC4xMSwgMC4wNTU1NiwgMC42MTIyMl0sCiAgICAiOTM3IjogWzAsIDAuNjgzMzMsIDAuMDUwMTcsIDAuMDgzMzQsIDAuNzcyNF0sCiAgICAiOTQ1IjogWzAsIDAuNDMwNTYsIDM3ZS00LCAwLjAyNzc4LCAwLjYzOTddLAogICAgIjk0NiI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA1Mjc4LCAwLjA4MzM0LCAwLjU2NTYzXSwKICAgICI5NDciOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wNTU1NiwgMCwgMC41MTc3M10sCiAgICAiOTQ4IjogWzAsIDAuNjk0NDQsIDAuMDM3ODUsIDAuMDU1NTYsIDAuNDQ0NDRdLAogICAgIjk0OSI6IFswLCAwLjQzMDU2LCAwLCAwLjA4MzM0LCAwLjQ2NjMyXSwKICAgICI5NTAiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wNzM3OCwgMC4wODMzNCwgMC40Mzc1XSwKICAgICI5NTEiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wNTU1NiwgMC40OTY1M10sCiAgICAiOTUyIjogWzAsIDAuNjk0NDQsIDAuMDI3NzgsIDAuMDgzMzQsIDAuNDY5NDRdLAogICAgIjk1MyI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjM1Mzk0XSwKICAgICI5NTQiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41NzYxNl0sCiAgICAiOTU1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgzMzRdLAogICAgIjk1NiI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjAyNzc4LCAwLjYwMjU1XSwKICAgICI5NTciOiBbMCwgMC40MzA1NiwgMC4wNjM2NiwgMC4wMjc3OCwgMC40OTM5OF0sCiAgICAiOTU4IjogWzAuMTk0NDQsIDAuNjk0NDQsIDAuMDQ2MDEsIDAuMTExMTEsIDAuNDM3NV0sCiAgICAiOTU5IjogWzAsIDAuNDMwNTYsIDAsIDAuMDU1NTYsIDAuNDg0NzJdLAogICAgIjk2MCI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MDAzXSwKICAgICI5NjEiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sCiAgICAiOTYyIjogWzAuMDk3MjIsIDAuNDMwNTYsIDAuMDc5ODYsIDAuMDgzMzQsIDAuMzYyODVdLAogICAgIjk2MyI6IFswLCAwLjQzMDU2LCAwLjAzNTg4LCAwLCAwLjU3MTQxXSwKICAgICI5NjQiOiBbMCwgMC40MzA1NiwgMC4xMTMyLCAwLjAyNzc4LCAwLjQzNzE1XSwKICAgICI5NjUiOiBbMCwgMC40MzA1NiwgMC4wMzU4OCwgMC4wMjc3OCwgMC41NDAyOF0sCiAgICAiOTY2IjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuNjU0MTddLAogICAgIjk2NyI6IFswLjE5NDQ0LCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjYyNTY5XSwKICAgICI5NjgiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMC4wMzU4OCwgMC4xMTExMSwgMC42NTEzOV0sCiAgICAiOTY5IjogWzAsIDAuNDMwNTYsIDAuMDM1ODgsIDAsIDAuNjIyNDVdLAogICAgIjk3NyI6IFswLCAwLjY5NDQ0LCAwLCAwLjA4MzM0LCAwLjU5MTQ0XSwKICAgICI5ODEiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMC4wODMzNCwgMC41OTU4M10sCiAgICAiOTgyIjogWzAsIDAuNDMwNTYsIDAuMDI3NzgsIDAsIDAuODI4MTNdLAogICAgIjEwMDkiOiBbMC4xOTQ0NCwgMC40MzA1NiwgMCwgMC4wODMzNCwgMC41MTcwMl0sCiAgICAiMTAxMyI6IFswLCAwLjQzMDU2LCAwLCAwLjA1NTU2LCAwLjQwNTldLAogICAgIjU3NjQ5IjogWzAsIDAuNDMwNTYsIDAsIDAuMDI3NzgsIDAuMzIyNDZdLAogICAgIjU3OTExIjogWzAuMTk0NDQsIDAuNDMwNTYsIDAsIDAuMDgzMzQsIDAuMzg0MDNdCiAgfSwKICAiU2Fuc1NlcmlmLUJvbGQiOiB7CiAgICAiMzIiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiMzMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zNjY2N10sCiAgICAiMzQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0sCiAgICAiMzUiOiBbMC4xOTQ0NCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sCiAgICAiMzYiOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMC41NV0sCiAgICAiMzciOiBbMC4wNTU1NiwgMC43NSwgMCwgMCwgMS4wMjkxMl0sCiAgICAiMzgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44MzA1Nl0sCiAgICAiMzkiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sCiAgICAiNDAiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sCiAgICAiNDEiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC40Mjc3OF0sCiAgICAiNDIiOiBbMCwgMC43NSwgMCwgMCwgMC41NV0sCiAgICAiNDMiOiBbMC4xMTY2NywgMC42MTY2NywgMCwgMCwgMC44NTU1Nl0sCiAgICAiNDQiOiBbMC4xMDU1NiwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sCiAgICAiNDUiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zNjY2N10sCiAgICAiNDYiOiBbMCwgMC4xMzA1NiwgMCwgMCwgMC4zMDU1Nl0sCiAgICAiNDciOiBbMC4yNSwgMC43NSwgMCwgMCwgMC41NV0sCiAgICAiNDgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNDkiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTEiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTIiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTUiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNTgiOiBbMCwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sCiAgICAiNTkiOiBbMC4xMDU1NiwgMC40NTgzMywgMCwgMCwgMC4zMDU1Nl0sCiAgICAiNjEiOiBbLTAuMDkzNzUsIDAuNDA2MjUsIDAsIDAsIDAuODU1NTZdLAogICAgIjYzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLAogICAgIjY0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjY1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjY2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjY3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLAogICAgIjY4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjY5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjQxNjddLAogICAgIjcwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLAogICAgIjcxIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjcyIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjczIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzMwNTZdLAogICAgIjc0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE5NDVdLAogICAgIjc1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLAogICAgIjc2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTgwNTZdLAogICAgIjc3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuOTc3NzhdLAogICAgIjc4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjc5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjgwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLAogICAgIjgxIjogWzAuMTA1NTYsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjgyIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzAyNzhdLAogICAgIjgzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLAogICAgIjg0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjg1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzYzODldLAogICAgIjg2IjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDAuNzMzMzRdLAogICAgIjg3IjogWzAsIDAuNjk0NDQsIDAuMDE1MjgsIDAsIDEuMDM4ODldLAogICAgIjg4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjg5IjogWzAsIDAuNjk0NDQsIDAuMDI3NSwgMCwgMC43MzMzNF0sCiAgICAiOTAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NzIyM10sCiAgICAiOTEiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sCiAgICAiOTMiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4zNDMwNl0sCiAgICAiOTQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiOTUiOiBbMC4zNSwgMC4xMDgzMywgMC4wMzA1NiwgMCwgMC41NV0sCiAgICAiOTciOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MjVdLAogICAgIjk4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTYxMTFdLAogICAgIjk5IjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNDg4ODldLAogICAgIjEwMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU2MTExXSwKICAgICIxMDEiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41MTExMV0sCiAgICAiMTAyIjogWzAsIDAuNjk0NDQsIDAuMDc2MzksIDAsIDAuMzM2MTFdLAogICAgIjEwMyI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjU1XSwKICAgICIxMDQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NjExMV0sCiAgICAiMTA1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLAogICAgIjEwNiI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjI4NjExXSwKICAgICIxMDciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41MzA1Nl0sCiAgICAiMTA4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjU1NTZdLAogICAgIjEwOSI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjg2NjY3XSwKICAgICIxMTAiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sCiAgICAiMTExIjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTVdLAogICAgIjExMiI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjU2MTExXSwKICAgICIxMTMiOiBbMC4xOTQ0NCwgMC40NTgzMywgMCwgMCwgMC41NjExMV0sCiAgICAiMTE0IjogWzAsIDAuNDU4MzMsIDAuMDE1MjgsIDAsIDAuMzcyMjJdLAogICAgIjExNSI6IFswLCAwLjQ1ODMzLCAwLCAwLCAwLjQyMTY3XSwKICAgICIxMTYiOiBbMCwgMC41ODkyOSwgMCwgMCwgMC40MDQxN10sCiAgICAiMTE3IjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuNTYxMTFdLAogICAgIjExOCI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjVdLAogICAgIjExOSI6IFswLCAwLjQ1ODMzLCAwLjAxNTI4LCAwLCAwLjc0NDQ1XSwKICAgICIxMjAiOiBbMCwgMC40NTgzMywgMCwgMCwgMC41XSwKICAgICIxMjEiOiBbMC4xOTQ0NCwgMC40NTgzMywgMC4wMTUyOCwgMCwgMC41XSwKICAgICIxMjIiOiBbMCwgMC40NTgzMywgMCwgMCwgMC40NzYzOV0sCiAgICAiMTI2IjogWzAuMzUsIDAuMzQ0NDQsIDAsIDAsIDAuNTVdLAogICAgIjE2MCI6IFswLCAwLCAwLCAwLCAwLjI1XSwKICAgICIxNjgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiMTc2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzMzMzRdLAogICAgIjE4MCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU1XSwKICAgICIxODQiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40ODg4OV0sCiAgICAiMzA1IjogWzAsIDAuNDU4MzMsIDAsIDAsIDAuMjU1NTZdLAogICAgIjU2NyI6IFswLjE5NDQ0LCAwLjQ1ODMzLCAwLCAwLCAwLjI4NjExXSwKICAgICI3MTAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNzExIjogWzAsIDAuNjM1NDIsIDAsIDAsIDAuNTVdLAogICAgIjcxMyI6IFswLCAwLjYzNzc4LCAwLCAwLCAwLjU1XSwKICAgICI3MjgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNzI5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMzA1NTZdLAogICAgIjczMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczMzM0XSwKICAgICI3MzIiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NV0sCiAgICAiNzMzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTVdLAogICAgIjkxNSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjU4MDU2XSwKICAgICI5MTYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC45MTY2N10sCiAgICAiOTIwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODU1NTZdLAogICAgIjkyMyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY3MjIzXSwKICAgICI5MjYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MzMzNF0sCiAgICAiOTI4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjkzMSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc5NDQ1XSwKICAgICI5MzMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC44NTU1Nl0sCiAgICAiOTM0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjkzNiI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjg1NTU2XSwKICAgICI5MzciOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43OTQ0NV0sCiAgICAiODIxMSI6IFswLCAwLjQ1ODMzLCAwLjAzMDU2LCAwLCAwLjU1XSwKICAgICI4MjEyIjogWzAsIDAuNDU4MzMsIDAuMDMwNTYsIDAsIDEuMTAwMDFdLAogICAgIjgyMTYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMDU1Nl0sCiAgICAiODIxNyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjMwNTU2XSwKICAgICI4MjIwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTU4MzRdLAogICAgIjgyMjEiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTgzNF0KICB9LAogICJTYW5zU2VyaWYtSXRhbGljIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjMzIjogWzAsIDAuNjk0NDQsIDAuMDU3MzMsIDAsIDAuMzE5NDVdLAogICAgIjM0IjogWzAsIDAuNjk0NDQsIDMxNmUtNSwgMCwgMC41XSwKICAgICIzNSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLjA1MDg3LCAwLCAwLjgzMzM0XSwKICAgICIzNiI6IFswLjA1NTU2LCAwLjc1LCAwLjExMTU2LCAwLCAwLjVdLAogICAgIjM3IjogWzAuMDU1NTYsIDAuNzUsIDAuMDMxMjYsIDAsIDAuODMzMzRdLAogICAgIjM4IjogWzAsIDAuNjk0NDQsIDAuMDMwNTgsIDAsIDAuNzU4MzRdLAogICAgIjM5IjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLAogICAgIjQwIjogWzAuMjUsIDAuNzUsIDAuMTMxNjQsIDAsIDAuMzg4ODldLAogICAgIjQxIjogWzAuMjUsIDAuNzUsIDAuMDI1MzYsIDAsIDAuMzg4ODldLAogICAgIjQyIjogWzAsIDAuNzUsIDAuMTE3NzUsIDAsIDAuNV0sCiAgICAiNDMiOiBbMC4wODMzMywgMC41ODMzMywgMC4wMjUzNiwgMCwgMC43Nzc3OF0sCiAgICAiNDQiOiBbMC4xMjUsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLAogICAgIjQ1IjogWzAsIDAuNDQ0NDQsIDAuMDE5NDYsIDAsIDAuMzMzMzNdLAogICAgIjQ2IjogWzAsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLAogICAgIjQ3IjogWzAuMjUsIDAuNzUsIDAuMTMxNjQsIDAsIDAuNV0sCiAgICAiNDgiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSwKICAgICI0OSI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLAogICAgIjUwIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sCiAgICAiNTEiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSwKICAgICI1MiI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLAogICAgIjUzIjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sCiAgICAiNTQiOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSwKICAgICI1NSI6IFswLCAwLjY1NTU2LCAwLjExMTU2LCAwLCAwLjVdLAogICAgIjU2IjogWzAsIDAuNjU1NTYsIDAuMTExNTYsIDAsIDAuNV0sCiAgICAiNTciOiBbMCwgMC42NTU1NiwgMC4xMTE1NiwgMCwgMC41XSwKICAgICI1OCI6IFswLCAwLjQ0NDQ0LCAwLjAyNTAyLCAwLCAwLjI3Nzc4XSwKICAgICI1OSI6IFswLjEyNSwgMC40NDQ0NCwgMC4wMjUwMiwgMCwgMC4yNzc3OF0sCiAgICAiNjEiOiBbLTAuMTMsIDAuMzcsIDAuMDUwODcsIDAsIDAuNzc3NzhdLAogICAgIjYzIjogWzAsIDAuNjk0NDQsIDAuMTE4MDksIDAsIDAuNDcyMjJdLAogICAgIjY0IjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNjY2NjddLAogICAgIjY1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLAogICAgIjY2IjogWzAsIDAuNjk0NDQsIDAuMDgyOTMsIDAsIDAuNjY2NjddLAogICAgIjY3IjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjM4ODldLAogICAgIjY4IjogWzAsIDAuNjk0NDQsIDAuMDc1NTUsIDAsIDAuNzIyMjNdLAogICAgIjY5IjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNTk3MjJdLAogICAgIjcwIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNTY5NDVdLAogICAgIjcxIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjY2NjddLAogICAgIjcyIjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNzA4MzRdLAogICAgIjczIjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuMjc3NzhdLAogICAgIjc0IjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuNDcyMjJdLAogICAgIjc1IjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNjk0NDVdLAogICAgIjc2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLAogICAgIjc3IjogWzAsIDAuNjk0NDQsIDAuMDgwOTQsIDAsIDAuODc1XSwKICAgICI3OCI6IFswLCAwLjY5NDQ0LCAwLjA4MDk0LCAwLCAwLjcwODM0XSwKICAgICI3OSI6IFswLCAwLjY5NDQ0LCAwLjA3NTU1LCAwLCAwLjczNjExXSwKICAgICI4MCI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjYzODg5XSwKICAgICI4MSI6IFswLjEyNSwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43MzYxMV0sCiAgICAiODIiOiBbMCwgMC42OTQ0NCwgMC4wODI5MywgMCwgMC42NDU4NF0sCiAgICAiODMiOiBbMCwgMC42OTQ0NCwgMC4wOTIwNSwgMCwgMC41NTU1Nl0sCiAgICAiODQiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC42ODA1Nl0sCiAgICAiODUiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC42ODc1XSwKICAgICI4NiI6IFswLCAwLjY5NDQ0LCAwLjE2MTUsIDAsIDAuNjY2NjddLAogICAgIjg3IjogWzAsIDAuNjk0NDQsIDAuMTYxNSwgMCwgMC45NDQ0NV0sCiAgICAiODgiOiBbMCwgMC42OTQ0NCwgMC4xMzM3MiwgMCwgMC42NjY2N10sCiAgICAiODkiOiBbMCwgMC42OTQ0NCwgMC4xNzI2MSwgMCwgMC42NjY2N10sCiAgICAiOTAiOiBbMCwgMC42OTQ0NCwgMC4xMTk4MywgMCwgMC42MTExMV0sCiAgICAiOTEiOiBbMC4yNSwgMC43NSwgMC4xNTk0MiwgMCwgMC4yODg4OV0sCiAgICAiOTMiOiBbMC4yNSwgMC43NSwgMC4wODcxOSwgMCwgMC4yODg4OV0sCiAgICAiOTQiOiBbMCwgMC42OTQ0NCwgMC4wNzk5LCAwLCAwLjVdLAogICAgIjk1IjogWzAuMzUsIDAuMDk0NDQsIDAuMDg2MTYsIDAsIDAuNV0sCiAgICAiOTciOiBbMCwgMC40NDQ0NCwgOTgxZS01LCAwLCAwLjQ4MDU2XSwKICAgICI5OCI6IFswLCAwLjY5NDQ0LCAwLjAzMDU3LCAwLCAwLjUxNjY3XSwKICAgICI5OSI6IFswLCAwLjQ0NDQ0LCAwLjA4MzM2LCAwLCAwLjQ0NDQ1XSwKICAgICIxMDAiOiBbMCwgMC42OTQ0NCwgMC4wOTQ4MywgMCwgMC41MTY2N10sCiAgICAiMTAxIjogWzAsIDAuNDQ0NDQsIDAuMDY3NzgsIDAsIDAuNDQ0NDVdLAogICAgIjEwMiI6IFswLCAwLjY5NDQ0LCAwLjIxNzA1LCAwLCAwLjMwNTU2XSwKICAgICIxMDMiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC41XSwKICAgICIxMDQiOiBbMCwgMC42OTQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sCiAgICAiMTA1IjogWzAsIDAuNjc5MzcsIDAuMDk3MTgsIDAsIDAuMjM4ODldLAogICAgIjEwNiI6IFswLjE5NDQ0LCAwLjY3OTM3LCAwLjA5MTYyLCAwLCAwLjI2NjY3XSwKICAgICIxMDciOiBbMCwgMC42OTQ0NCwgMC4wODMzNiwgMCwgMC40ODg4OV0sCiAgICAiMTA4IjogWzAsIDAuNjk0NDQsIDAuMDk0ODMsIDAsIDAuMjM4ODldLAogICAgIjEwOSI6IFswLCAwLjQ0NDQ0LCAwLjAxNzc4LCAwLCAwLjc5NDQ1XSwKICAgICIxMTAiOiBbMCwgMC40NDQ0NCwgMC4wMTc3OCwgMCwgMC41MTY2N10sCiAgICAiMTExIjogWzAsIDAuNDQ0NDQsIDAuMDY2MTMsIDAsIDAuNV0sCiAgICAiMTEyIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDM4OSwgMCwgMC41MTY2N10sCiAgICAiMTEzIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLAogICAgIjExNCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjM0MTY3XSwKICAgICIxMTUiOiBbMCwgMC40NDQ0NCwgMC4wNzc4LCAwLCAwLjM4MzMzXSwKICAgICIxMTYiOiBbMCwgMC41NzE0MywgMC4wNzIyNSwgMCwgMC4zNjExMV0sCiAgICAiMTE3IjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuNTE2NjddLAogICAgIjExOCI6IFswLCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSwKICAgICIxMTkiOiBbMCwgMC40NDQ0NCwgMC4xMDgzNiwgMCwgMC42ODMzNF0sCiAgICAiMTIwIjogWzAsIDAuNDQ0NDQsIDAuMDkxNjksIDAsIDAuNDYxMTFdLAogICAgIjEyMSI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjEwODM2LCAwLCAwLjQ2MTExXSwKICAgICIxMjIiOiBbMCwgMC40NDQ0NCwgMC4wODc1MiwgMCwgMC40MzQ3Ml0sCiAgICAiMTI2IjogWzAuMzUsIDAuMzI2NTksIDAuMDg4MjYsIDAsIDAuNV0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjE2OCI6IFswLCAwLjY3OTM3LCAwLjA2Mzg1LCAwLCAwLjVdLAogICAgIjE3NiI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNzUyXSwKICAgICIxODQiOiBbMC4xNzAxNCwgMCwgMCwgMCwgMC40NDQ0NV0sCiAgICAiMzA1IjogWzAsIDAuNDQ0NDQsIDAuMDQxNjksIDAsIDAuMjM4ODldLAogICAgIjU2NyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjA0MTY5LCAwLCAwLjI2NjY3XSwKICAgICI3MTAiOiBbMCwgMC42OTQ0NCwgMC4wNzk5LCAwLCAwLjVdLAogICAgIjcxMSI6IFswLCAwLjYzMTk0LCAwLjA4NDMyLCAwLCAwLjVdLAogICAgIjcxMyI6IFswLCAwLjYwODg5LCAwLjA4Nzc2LCAwLCAwLjVdLAogICAgIjcxNCI6IFswLCAwLjY5NDQ0LCAwLjA5MjA1LCAwLCAwLjVdLAogICAgIjcxNSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdLAogICAgIjcyOCI6IFswLCAwLjY5NDQ0LCAwLjA5NDgzLCAwLCAwLjVdLAogICAgIjcyOSI6IFswLCAwLjY3OTM3LCAwLjA3Nzc0LCAwLCAwLjI3Nzc4XSwKICAgICI3MzAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Mzc1Ml0sCiAgICAiNzMyIjogWzAsIDAuNjc2NTksIDAuMDg4MjYsIDAsIDAuNV0sCiAgICAiNzMzIjogWzAsIDAuNjk0NDQsIDAuMDkyMDUsIDAsIDAuNV0sCiAgICAiOTE1IjogWzAsIDAuNjk0NDQsIDAuMTMzNzIsIDAsIDAuNTQxNjddLAogICAgIjkxNiI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSwKICAgICI5MjAiOiBbMCwgMC42OTQ0NCwgMC4wNzU1NSwgMCwgMC43Nzc3OF0sCiAgICAiOTIzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjExMTFdLAogICAgIjkyNiI6IFswLCAwLjY5NDQ0LCAwLjEyODE2LCAwLCAwLjY2NjY3XSwKICAgICI5MjgiOiBbMCwgMC42OTQ0NCwgMC4wODA5NCwgMCwgMC43MDgzNF0sCiAgICAiOTMxIjogWzAsIDAuNjk0NDQsIDAuMTE5ODMsIDAsIDAuNzIyMjJdLAogICAgIjkzMyI6IFswLCAwLjY5NDQ0LCAwLjA5MDMxLCAwLCAwLjc3Nzc4XSwKICAgICI5MzQiOiBbMCwgMC42OTQ0NCwgMC4wNDYwMywgMCwgMC43MjIyMl0sCiAgICAiOTM2IjogWzAsIDAuNjk0NDQsIDAuMDkwMzEsIDAsIDAuNzc3NzhdLAogICAgIjkzNyI6IFswLCAwLjY5NDQ0LCAwLjA4MjkzLCAwLCAwLjcyMjIyXSwKICAgICI4MjExIjogWzAsIDAuNDQ0NDQsIDAuMDg2MTYsIDAsIDAuNV0sCiAgICAiODIxMiI6IFswLCAwLjQ0NDQ0LCAwLjA4NjE2LCAwLCAxXSwKICAgICI4MjE2IjogWzAsIDAuNjk0NDQsIDAuMDc4MTYsIDAsIDAuMjc3NzhdLAogICAgIjgyMTciOiBbMCwgMC42OTQ0NCwgMC4wNzgxNiwgMCwgMC4yNzc3OF0sCiAgICAiODIyMCI6IFswLCAwLjY5NDQ0LCAwLjE0MjA1LCAwLCAwLjVdLAogICAgIjgyMjEiOiBbMCwgMC42OTQ0NCwgMzE2ZS01LCAwLCAwLjVdCiAgfSwKICAiU2Fuc1NlcmlmLVJlZ3VsYXIiOiB7CiAgICAiMzIiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiMzMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4zMTk0NV0sCiAgICAiMzQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSwKICAgICIzNSI6IFswLjE5NDQ0LCAwLjY5NDQ0LCAwLCAwLCAwLjgzMzM0XSwKICAgICIzNiI6IFswLjA1NTU2LCAwLjc1LCAwLCAwLCAwLjVdLAogICAgIjM3IjogWzAuMDU1NTYsIDAuNzUsIDAsIDAsIDAuODMzMzRdLAogICAgIjM4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzU4MzRdLAogICAgIjM5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLAogICAgIjQwIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLAogICAgIjQxIjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuMzg4ODldLAogICAgIjQyIjogWzAsIDAuNzUsIDAsIDAsIDAuNV0sCiAgICAiNDMiOiBbMC4wODMzMywgMC41ODMzMywgMCwgMCwgMC43Nzc3OF0sCiAgICAiNDQiOiBbMC4xMjUsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLAogICAgIjQ1IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuMzMzMzNdLAogICAgIjQ2IjogWzAsIDAuMDgzMzMsIDAsIDAsIDAuMjc3NzhdLAogICAgIjQ3IjogWzAuMjUsIDAuNzUsIDAsIDAsIDAuNV0sCiAgICAiNDgiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSwKICAgICI0OSI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLAogICAgIjUwIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sCiAgICAiNTEiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSwKICAgICI1MiI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLAogICAgIjUzIjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sCiAgICAiNTQiOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSwKICAgICI1NSI6IFswLCAwLjY1NTU2LCAwLCAwLCAwLjVdLAogICAgIjU2IjogWzAsIDAuNjU1NTYsIDAsIDAsIDAuNV0sCiAgICAiNTciOiBbMCwgMC42NTU1NiwgMCwgMCwgMC41XSwKICAgICI1OCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI1OSI6IFswLjEyNSwgMC40NDQ0NCwgMCwgMCwgMC4yNzc3OF0sCiAgICAiNjEiOiBbLTAuMTMsIDAuMzcsIDAsIDAsIDAuNzc3NzhdLAogICAgIjYzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLAogICAgIjY0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLAogICAgIjY1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLAogICAgIjY2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLAogICAgIjY3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjM4ODldLAogICAgIjY4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjNdLAogICAgIjY5IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTk3MjJdLAogICAgIjcwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTY5NDVdLAogICAgIjcxIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLAogICAgIjcyIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzA4MzRdLAogICAgIjczIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuMjc3NzhdLAogICAgIjc0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNDcyMjJdLAogICAgIjc1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjk0NDVdLAogICAgIjc2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTQxNjddLAogICAgIjc3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODc1XSwKICAgICI3OCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSwKICAgICI3OSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjczNjExXSwKICAgICI4MCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjYzODg5XSwKICAgICI4MSI6IFswLjEyNSwgMC42OTQ0NCwgMCwgMCwgMC43MzYxMV0sCiAgICAiODIiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NDU4NF0sCiAgICAiODMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NTU1Nl0sCiAgICAiODQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42ODA1Nl0sCiAgICAiODUiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42ODc1XSwKICAgICI4NiI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwLCAwLjY2NjY3XSwKICAgICI4NyI6IFswLCAwLjY5NDQ0LCAwLjAxMzg5LCAwLCAwLjk0NDQ1XSwKICAgICI4OCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4OSI6IFswLCAwLjY5NDQ0LCAwLjAyNSwgMCwgMC42NjY2N10sCiAgICAiOTAiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sCiAgICAiOTEiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yODg4OV0sCiAgICAiOTMiOiBbMC4yNSwgMC43NSwgMCwgMCwgMC4yODg4OV0sCiAgICAiOTQiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSwKICAgICI5NSI6IFswLjM1LCAwLjA5NDQ0LCAwLjAyNzc4LCAwLCAwLjVdLAogICAgIjk3IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDgwNTZdLAogICAgIjk4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNTE2NjddLAogICAgIjk5IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjEwMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSwKICAgICIxMDEiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC40NDQ0NV0sCiAgICAiMTAyIjogWzAsIDAuNjk0NDQsIDAuMDY5NDQsIDAsIDAuMzA1NTZdLAogICAgIjEwMyI6IFswLjE5NDQ0LCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjVdLAogICAgIjEwNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjUxNjY3XSwKICAgICIxMDUiOiBbMCwgMC42NzkzNywgMCwgMCwgMC4yMzg4OV0sCiAgICAiMTA2IjogWzAuMTk0NDQsIDAuNjc5MzcsIDAsIDAsIDAuMjY2NjddLAogICAgIjEwNyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjQ4ODg5XSwKICAgICIxMDgiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yMzg4OV0sCiAgICAiMTA5IjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNzk0NDVdLAogICAgIjExMCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSwKICAgICIxMTEiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC41XSwKICAgICIxMTIiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC41MTY2N10sCiAgICAiMTEzIjogWzAuMTk0NDQsIDAuNDQ0NDQsIDAsIDAsIDAuNTE2NjddLAogICAgIjExNCI6IFswLCAwLjQ0NDQ0LCAwLjAxMzg5LCAwLCAwLjM0MTY3XSwKICAgICIxMTUiOiBbMCwgMC40NDQ0NCwgMCwgMCwgMC4zODMzM10sCiAgICAiMTE2IjogWzAsIDAuNTcxNDMsIDAsIDAsIDAuMzYxMTFdLAogICAgIjExNyI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjUxNjY3XSwKICAgICIxMTgiOiBbMCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC40NjExMV0sCiAgICAiMTE5IjogWzAsIDAuNDQ0NDQsIDAuMDEzODksIDAsIDAuNjgzMzRdLAogICAgIjEyMCI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjQ2MTExXSwKICAgICIxMjEiOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMC4wMTM4OSwgMCwgMC40NjExMV0sCiAgICAiMTIyIjogWzAsIDAuNDQ0NDQsIDAsIDAsIDAuNDM0NzJdLAogICAgIjEyNiI6IFswLjM1LCAwLjMyNjU5LCAwLCAwLCAwLjVdLAogICAgIjE2MCI6IFswLCAwLCAwLCAwLCAwLjI1XSwKICAgICIxNjgiOiBbMCwgMC42NzkzNywgMCwgMCwgMC41XSwKICAgICIxNzYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42NjY2N10sCiAgICAiMTg0IjogWzAuMTcwMTQsIDAsIDAsIDAsIDAuNDQ0NDVdLAogICAgIjMwNSI6IFswLCAwLjQ0NDQ0LCAwLCAwLCAwLjIzODg5XSwKICAgICI1NjciOiBbMC4xOTQ0NCwgMC40NDQ0NCwgMCwgMCwgMC4yNjY2N10sCiAgICAiNzEwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiNzExIjogWzAsIDAuNjMxOTQsIDAsIDAsIDAuNV0sCiAgICAiNzEzIjogWzAsIDAuNjA4ODksIDAsIDAsIDAuNV0sCiAgICAiNzE0IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiNzE1IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiNzI4IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiNzI5IjogWzAsIDAuNjc5MzcsIDAsIDAsIDAuMjc3NzhdLAogICAgIjczMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjY2NjY3XSwKICAgICI3MzIiOiBbMCwgMC42NzY1OSwgMCwgMCwgMC41XSwKICAgICI3MzMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41XSwKICAgICI5MTUiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC41NDE2N10sCiAgICAiOTE2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuODMzMzRdLAogICAgIjkyMCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI5MjMiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC42MTExMV0sCiAgICAiOTI2IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNjY2NjddLAogICAgIjkyOCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcwODM0XSwKICAgICI5MzEiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43MjIyMl0sCiAgICAiOTMzIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzc3NzhdLAogICAgIjkzNCI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjcyMjIyXSwKICAgICI5MzYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC43Nzc3OF0sCiAgICAiOTM3IjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNzIyMjJdLAogICAgIjgyMTEiOiBbMCwgMC40NDQ0NCwgMC4wMjc3OCwgMCwgMC41XSwKICAgICI4MjEyIjogWzAsIDAuNDQ0NDQsIDAuMDI3NzgsIDAsIDFdLAogICAgIjgyMTYiOiBbMCwgMC42OTQ0NCwgMCwgMCwgMC4yNzc3OF0sCiAgICAiODIxNyI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjI3Nzc4XSwKICAgICI4MjIwIjogWzAsIDAuNjk0NDQsIDAsIDAsIDAuNV0sCiAgICAiODIyMSI6IFswLCAwLjY5NDQ0LCAwLCAwLCAwLjVdCiAgfSwKICAiU2NyaXB0LVJlZ3VsYXIiOiB7CiAgICAiMzIiOiBbMCwgMCwgMCwgMCwgMC4yNV0sCiAgICAiNjUiOiBbMCwgMC43LCAwLjIyOTI1LCAwLCAwLjgwMjUzXSwKICAgICI2NiI6IFswLCAwLjcsIDAuMDQwODcsIDAsIDAuOTA3NTddLAogICAgIjY3IjogWzAsIDAuNywgMC4xNjg5LCAwLCAwLjY2NjE5XSwKICAgICI2OCI6IFswLCAwLjcsIDAuMDkzNzEsIDAsIDAuNzc0NDNdLAogICAgIjY5IjogWzAsIDAuNywgMC4xODU4MywgMCwgMC41NjE2Ml0sCiAgICAiNzAiOiBbMCwgMC43LCAwLjEzNjM0LCAwLCAwLjg5NTQ0XSwKICAgICI3MSI6IFswLCAwLjcsIDAuMTczMjIsIDAsIDAuNjA5NjFdLAogICAgIjcyIjogWzAsIDAuNywgMC4yOTY5NCwgMCwgMC45NjkxOV0sCiAgICAiNzMiOiBbMCwgMC43LCAwLjE5MTg5LCAwLCAwLjgwOTA3XSwKICAgICI3NCI6IFswLjI3Nzc4LCAwLjcsIDAuMTkxODksIDAsIDEuMDUxNTldLAogICAgIjc1IjogWzAsIDAuNywgMC4zMTI1OSwgMCwgMC45MTM2NF0sCiAgICAiNzYiOiBbMCwgMC43LCAwLjE5MTg5LCAwLCAwLjg3MzczXSwKICAgICI3NyI6IFswLCAwLjcsIDAuMTU5ODEsIDAsIDEuMDgwMzFdLAogICAgIjc4IjogWzAsIDAuNywgMC4zNTI1LCAwLCAwLjkwMTVdLAogICAgIjc5IjogWzAsIDAuNywgMC4wODA3OCwgMCwgMC43Mzc4N10sCiAgICAiODAiOiBbMCwgMC43LCAwLjA4MDc4LCAwLCAxLjAxMjYyXSwKICAgICI4MSI6IFswLCAwLjcsIDAuMDMzMDUsIDAsIDAuODgyODJdLAogICAgIjgyIjogWzAsIDAuNywgMC4wNjI1OSwgMCwgMC44NV0sCiAgICAiODMiOiBbMCwgMC43LCAwLjE5MTg5LCAwLCAwLjg2NzY3XSwKICAgICI4NCI6IFswLCAwLjcsIDAuMjkwODcsIDAsIDAuNzQ2OTddLAogICAgIjg1IjogWzAsIDAuNywgMC4yNTgxNSwgMCwgMC43OTk5Nl0sCiAgICAiODYiOiBbMCwgMC43LCAwLjI3NTIzLCAwLCAwLjYyMjA0XSwKICAgICI4NyI6IFswLCAwLjcsIDAuMjc1MjMsIDAsIDAuODA1MzJdLAogICAgIjg4IjogWzAsIDAuNywgMC4yNjAwNiwgMCwgMC45NDQ0NV0sCiAgICAiODkiOiBbMCwgMC43LCAwLjI5MzksIDAsIDAuNzA5NjFdLAogICAgIjkwIjogWzAsIDAuNywgMC4yNDAzNywgMCwgMC44MjEyXSwKICAgICIxNjAiOiBbMCwgMCwgMCwgMCwgMC4yNV0KICB9LAogICJTaXplMS1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjQwIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDU4MzRdLAogICAgIjQxIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDU4MzRdLAogICAgIjQ3IjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTc3NzhdLAogICAgIjkxIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDE2NjddLAogICAgIjkyIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNTc3NzhdLAogICAgIjkzIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDE2NjddLAogICAgIjEyMyI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjU4MzM0XSwKICAgICIxMjUiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC41ODMzNF0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjcxMCI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSwKICAgICI3MzIiOiBbMCwgMC43MjIyMiwgMCwgMCwgMC41NTU1Nl0sCiAgICAiNzcwIjogWzAsIDAuNzIyMjIsIDAsIDAsIDAuNTU1NTZdLAogICAgIjc3MSI6IFswLCAwLjcyMjIyLCAwLCAwLCAwLjU1NTU2XSwKICAgICI4MjE0IjogWy05OWUtNSwgMC42MDEsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg1OTMiOiBbMWUtNSwgMC42LCAwLCAwLCAwLjY2NjY3XSwKICAgICI4NTk1IjogWzFlLTUsIDAuNiwgMCwgMCwgMC42NjY2N10sCiAgICAiODY1NyI6IFsxZS01LCAwLjYsIDAsIDAsIDAuNzc3NzhdLAogICAgIjg2NTkiOiBbMWUtNSwgMC42LCAwLCAwLCAwLjc3Nzc4XSwKICAgICI4NzE5IjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuOTQ0NDVdLAogICAgIjg3MjAiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC45NDQ0NV0sCiAgICAiODcyMSI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAxLjA1NTU2XSwKICAgICI4NzMwIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDFdLAogICAgIjg3MzkiOiBbLTU5OWUtNSwgMC42MDYsIDAsIDAsIDAuMzMzMzNdLAogICAgIjg3NDEiOiBbLTU5OWUtNSwgMC42MDYsIDAsIDAsIDAuNTU1NTZdLAogICAgIjg3NDciOiBbMC4zMDYxMiwgMC44MDUsIDAuMTk0NDUsIDAsIDAuNDcyMjJdLAogICAgIjg3NDgiOiBbMC4zMDYsIDAuODA1LCAwLjE5NDQ1LCAwLCAwLjQ3MjIyXSwKICAgICI4NzQ5IjogWzAuMzA2LCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sCiAgICAiODc1MCI6IFswLjMwNjEyLCAwLjgwNSwgMC4xOTQ0NSwgMCwgMC40NzIyMl0sCiAgICAiODg5NiI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSwKICAgICI4ODk3IjogWzAuMjUwMDEsIDAuNzUsIDAsIDAsIDAuODMzMzRdLAogICAgIjg4OTgiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sCiAgICAiODg5OSI6IFswLjI1MDAxLCAwLjc1LCAwLCAwLCAwLjgzMzM0XSwKICAgICI4OTY4IjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLAogICAgIjg5NjkiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sCiAgICAiODk3MCI6IFswLjM1MDAxLCAwLjg1LCAwLCAwLCAwLjQ3MjIyXSwKICAgICI4OTcxIjogWzAuMzUwMDEsIDAuODUsIDAsIDAsIDAuNDcyMjJdLAogICAgIjkxNjgiOiBbLTk5ZS01LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sCiAgICAiMTAyMTYiOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sCiAgICAiMTAyMTciOiBbMC4zNTAwMSwgMC44NSwgMCwgMCwgMC40NzIyMl0sCiAgICAiMTA3NTIiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sCiAgICAiMTA3NTMiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sCiAgICAiMTA3NTQiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMS4xMTExMV0sCiAgICAiMTA3NTYiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0sCiAgICAiMTA3NTgiOiBbMC4yNTAwMSwgMC43NSwgMCwgMCwgMC44MzMzNF0KICB9LAogICJTaXplMi1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjQwIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTk3MjJdLAogICAgIjQxIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTk3MjJdLAogICAgIjQ3IjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODExMTFdLAogICAgIjkxIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNDcyMjJdLAogICAgIjkyIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuODExMTFdLAogICAgIjkzIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNDcyMjJdLAogICAgIjEyMyI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjY2NjY3XSwKICAgICIxMjUiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42NjY2N10sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjcxMCI6IFswLCAwLjc1LCAwLCAwLCAxXSwKICAgICI3MzIiOiBbMCwgMC43NSwgMCwgMCwgMV0sCiAgICAiNzcwIjogWzAsIDAuNzUsIDAsIDAsIDFdLAogICAgIjc3MSI6IFswLCAwLjc1LCAwLCAwLCAxXSwKICAgICI4NzE5IjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMjc3NzhdLAogICAgIjg3MjAiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4yNzc3OF0sCiAgICAiODcyMSI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjQ0NDQ1XSwKICAgICI4NzMwIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDFdLAogICAgIjg3NDciOiBbMC44NjIyNSwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sCiAgICAiODc0OCI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sCiAgICAiODc0OSI6IFswLjg2MiwgMS4zNiwgMC40NDQ0NSwgMCwgMC41NTU1Nl0sCiAgICAiODc1MCI6IFswLjg2MjI1LCAxLjM2LCAwLjQ0NDQ1LCAwLCAwLjU1NTU2XSwKICAgICI4ODk2IjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLAogICAgIjg4OTciOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sCiAgICAiODg5OCI6IFswLjU1MDAxLCAxLjA1LCAwLCAwLCAxLjExMTExXSwKICAgICI4ODk5IjogWzAuNTUwMDEsIDEuMDUsIDAsIDAsIDEuMTExMTFdLAogICAgIjg5NjgiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sCiAgICAiODk2OSI6IFswLjY1MDAyLCAxLjE1LCAwLCAwLCAwLjUyNzc4XSwKICAgICI4OTcwIjogWzAuNjUwMDIsIDEuMTUsIDAsIDAsIDAuNTI3NzhdLAogICAgIjg5NzEiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC41Mjc3OF0sCiAgICAiMTAyMTYiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42MTExMV0sCiAgICAiMTAyMTciOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC42MTExMV0sCiAgICAiMTA3NTIiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS41MTExMl0sCiAgICAiMTA3NTMiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS41MTExMl0sCiAgICAiMTA3NTQiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS41MTExMl0sCiAgICAiMTA3NTYiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0sCiAgICAiMTA3NTgiOiBbMC41NTAwMSwgMS4wNSwgMCwgMCwgMS4xMTExMV0KICB9LAogICJTaXplMy1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjQwIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzM2MTFdLAogICAgIjQxIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNzM2MTFdLAogICAgIjQ3IjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMDQ0NDVdLAogICAgIjkxIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTI3NzhdLAogICAgIjkyIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDEuMDQ0NDVdLAogICAgIjkzIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTI3NzhdLAogICAgIjEyMyI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjc1XSwKICAgICIxMjUiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjcxMCI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSwKICAgICI3MzIiOiBbMCwgMC43NSwgMCwgMCwgMS40NDQ0NV0sCiAgICAiNzcwIjogWzAsIDAuNzUsIDAsIDAsIDEuNDQ0NDVdLAogICAgIjc3MSI6IFswLCAwLjc1LCAwLCAwLCAxLjQ0NDQ1XSwKICAgICI4NzMwIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDFdLAogICAgIjg5NjgiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sCiAgICAiODk2OSI6IFswLjk1MDAzLCAxLjQ1LCAwLCAwLCAwLjU4MzM0XSwKICAgICI4OTcwIjogWzAuOTUwMDMsIDEuNDUsIDAsIDAsIDAuNTgzMzRdLAogICAgIjg5NzEiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC41ODMzNF0sCiAgICAiMTAyMTYiOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0sCiAgICAiMTAyMTciOiBbMC45NTAwMywgMS40NSwgMCwgMCwgMC43NV0KICB9LAogICJTaXplNC1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjQwIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNzkxNjddLAogICAgIjQxIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNzkxNjddLAogICAgIjQ3IjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDEuMjc3NzhdLAogICAgIjkxIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNTgzMzRdLAogICAgIjkyIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDEuMjc3NzhdLAogICAgIjkzIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNTgzMzRdLAogICAgIjEyMyI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSwKICAgICIxMjUiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC44MDU1Nl0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuMjVdLAogICAgIjcxMCI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSwKICAgICI3MzIiOiBbMCwgMC44MjUsIDAsIDAsIDEuODg4OV0sCiAgICAiNzcwIjogWzAsIDAuODI1LCAwLCAwLCAxLjg4ODldLAogICAgIjc3MSI6IFswLCAwLjgyNSwgMCwgMCwgMS44ODg5XSwKICAgICI4NzMwIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDFdLAogICAgIjg5NjgiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sCiAgICAiODk2OSI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjYzODg5XSwKICAgICI4OTcwIjogWzEuMjUwMDMsIDEuNzUsIDAsIDAsIDAuNjM4ODldLAogICAgIjg5NzEiOiBbMS4yNTAwMywgMS43NSwgMCwgMCwgMC42Mzg4OV0sCiAgICAiOTExNSI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLAogICAgIjkxMTYiOiBbMWUtNSwgMC42LCAwLCAwLCAwLjg3NV0sCiAgICAiOTExNyI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC44NzVdLAogICAgIjkxMTgiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSwKICAgICI5MTE5IjogWzFlLTUsIDAuNiwgMCwgMCwgMC44NzVdLAogICAgIjkxMjAiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuODc1XSwKICAgICI5MTIxIjogWzAuNjQ1MDIsIDEuMTU1LCAwLCAwLCAwLjY2NjY3XSwKICAgICI5MTIyIjogWy05OWUtNSwgMC42MDEsIDAsIDAsIDAuNjY2NjddLAogICAgIjkxMjMiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLAogICAgIjkxMjQiOiBbMC42NDUwMiwgMS4xNTUsIDAsIDAsIDAuNjY2NjddLAogICAgIjkxMjUiOiBbLTk5ZS01LCAwLjYwMSwgMCwgMCwgMC42NjY2N10sCiAgICAiOTEyNiI6IFswLjY0NTAyLCAxLjE1NSwgMCwgMCwgMC42NjY2N10sCiAgICAiOTEyNyI6IFsxZS01LCAwLjksIDAsIDAsIDAuODg4ODldLAogICAgIjkxMjgiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44ODg4OV0sCiAgICAiOTEyOSI6IFswLjkwMDAxLCAwLCAwLCAwLCAwLjg4ODg5XSwKICAgICI5MTMwIjogWzAsIDAuMywgMCwgMCwgMC44ODg4OV0sCiAgICAiOTEzMSI6IFsxZS01LCAwLjksIDAsIDAsIDAuODg4ODldLAogICAgIjkxMzIiOiBbMC42NTAwMiwgMS4xNSwgMCwgMCwgMC44ODg4OV0sCiAgICAiOTEzMyI6IFswLjkwMDAxLCAwLCAwLCAwLCAwLjg4ODg5XSwKICAgICI5MTQzIjogWzAuODg1MDIsIDAuOTE1LCAwLCAwLCAxLjA1NTU2XSwKICAgICIxMDIxNiI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSwKICAgICIxMDIxNyI6IFsxLjI1MDAzLCAxLjc1LCAwLCAwLCAwLjgwNTU2XSwKICAgICI1NzM0NCI6IFstNDk5ZS01LCAwLjYwNSwgMCwgMCwgMS4wNTU1Nl0sCiAgICAiNTczNDUiOiBbLTQ5OWUtNSwgMC42MDUsIDAsIDAsIDEuMDU1NTZdLAogICAgIjU3NjgwIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLAogICAgIjU3NjgxIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLAogICAgIjU3NjgyIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdLAogICAgIjU3NjgzIjogWzAsIDAuMTIsIDAsIDAsIDAuNDVdCiAgfSwKICAiVHlwZXdyaXRlci1SZWd1bGFyIjogewogICAgIjMyIjogWzAsIDAsIDAsIDAsIDAuNTI1XSwKICAgICIzMyI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiMzQiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjM1IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICIzNiI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sCiAgICAiMzciOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLAogICAgIjM4IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICIzOSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNDAiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLAogICAgIjQxIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSwKICAgICI0MiI6IFswLCAwLjUyMDgzLCAwLCAwLCAwLjUyNV0sCiAgICAiNDMiOiBbLTAuMDgwNTYsIDAuNTMwNTUsIDAsIDAsIDAuNTI1XSwKICAgICI0NCI6IFswLjEzODg5LCAwLjEyNSwgMCwgMCwgMC41MjVdLAogICAgIjQ1IjogWy0wLjA4MDU2LCAwLjUzMDU1LCAwLCAwLCAwLjUyNV0sCiAgICAiNDYiOiBbMCwgMC4xMjUsIDAsIDAsIDAuNTI1XSwKICAgICI0NyI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sCiAgICAiNDgiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjQ5IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI1MCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNTEiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjUyIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI1MyI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNTQiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjU1IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI1NiI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNTciOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjU4IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICI1OSI6IFswLjEzODg5LCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiNjAiOiBbLTAuMDU1NTYsIDAuNTU1NTYsIDAsIDAsIDAuNTI1XSwKICAgICI2MSI6IFstMC4xOTU0OSwgMC40MTU2MiwgMCwgMCwgMC41MjVdLAogICAgIjYyIjogWy0wLjA1NTU2LCAwLjU1NTU2LCAwLCAwLCAwLjUyNV0sCiAgICAiNjMiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjY0IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI2NSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNjYiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjY3IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI2OCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNjkiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjcwIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI3MSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNzIiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjczIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI3NCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNzUiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjc2IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI3NyI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNzgiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjc5IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4MCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiODEiOiBbMC4xMzg4OSwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjgyIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4MyI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiODQiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjg1IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4NiI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiODciOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjg4IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4OSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiOTAiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjkxIjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSwKICAgICI5MiI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sCiAgICAiOTMiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLAogICAgIjk0IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI5NSI6IFswLjA5NTE0LCAwLCAwLCAwLCAwLjUyNV0sCiAgICAiOTYiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjk3IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICI5OCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiOTkiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLAogICAgIjEwMCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiMTAxIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICIxMDIiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjEwMyI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiMTA0IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICIxMDUiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjEwNiI6IFswLjIyMjIyLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiMTA3IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICIxMDgiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjEwOSI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiMTEwIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICIxMTEiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLAogICAgIjExMiI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiMTEzIjogWzAuMjIyMjIsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICIxMTQiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLAogICAgIjExNSI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiMTE2IjogWzAsIDAuNTUzNTgsIDAsIDAsIDAuNTI1XSwKICAgICIxMTciOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLAogICAgIjExOCI6IFswLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiMTE5IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICIxMjAiOiBbMCwgMC40MzA1NiwgMCwgMCwgMC41MjVdLAogICAgIjEyMSI6IFswLjIyMjIyLCAwLjQzMDU2LCAwLCAwLCAwLjUyNV0sCiAgICAiMTIyIjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICIxMjMiOiBbMC4wODMzMywgMC42OTQ0NCwgMCwgMCwgMC41MjVdLAogICAgIjEyNCI6IFswLjA4MzMzLCAwLjY5NDQ0LCAwLCAwLCAwLjUyNV0sCiAgICAiMTI1IjogWzAuMDgzMzMsIDAuNjk0NDQsIDAsIDAsIDAuNTI1XSwKICAgICIxMjYiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjEyNyI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiMTYwIjogWzAsIDAsIDAsIDAsIDAuNTI1XSwKICAgICIxNzYiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjE4NCI6IFswLjE5NDQ1LCAwLCAwLCAwLCAwLjUyNV0sCiAgICAiMzA1IjogWzAsIDAuNDMwNTYsIDAsIDAsIDAuNTI1XSwKICAgICI1NjciOiBbMC4yMjIyMiwgMC40MzA1NiwgMCwgMCwgMC41MjVdLAogICAgIjcxMSI6IFswLCAwLjU2NTk3LCAwLCAwLCAwLjUyNV0sCiAgICAiNzEzIjogWzAsIDAuNTY1NTUsIDAsIDAsIDAuNTI1XSwKICAgICI3MTQiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjcxNSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNzI4IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI3MzAiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjc3MCI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiNzcxIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI3NzYiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjkxNSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiOTE2IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI5MjAiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjkyMyI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiOTI2IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI5MjgiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjkzMSI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiOTMzIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI5MzQiOiBbMCwgMC42MTExMSwgMCwgMCwgMC41MjVdLAogICAgIjkzNiI6IFswLCAwLjYxMTExLCAwLCAwLCAwLjUyNV0sCiAgICAiOTM3IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4MjE2IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4MjE3IjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI4MjQyIjogWzAsIDAuNjExMTEsIDAsIDAsIDAuNTI1XSwKICAgICI5MjUxIjogWzAuMTExMTEsIDAuMjE5NDQsIDAsIDAsIDAuNTI1XQogIH0KfTsKdmFyIHNpZ21hc0FuZFhpcyA9IHsKICBzbGFudDogWzAuMjUsIDAuMjUsIDAuMjVdLAogIC8vIHNpZ21hMQogIHNwYWNlOiBbMCwgMCwgMF0sCiAgLy8gc2lnbWEyCiAgc3RyZXRjaDogWzAsIDAsIDBdLAogIC8vIHNpZ21hMwogIHNocmluazogWzAsIDAsIDBdLAogIC8vIHNpZ21hNAogIHhIZWlnaHQ6IFswLjQzMSwgMC40MzEsIDAuNDMxXSwKICAvLyBzaWdtYTUKICBxdWFkOiBbMSwgMS4xNzEsIDEuNDcyXSwKICAvLyBzaWdtYTYKICBleHRyYVNwYWNlOiBbMCwgMCwgMF0sCiAgLy8gc2lnbWE3CiAgbnVtMTogWzAuNjc3LCAwLjczMiwgMC45MjVdLAogIC8vIHNpZ21hOAogIG51bTI6IFswLjM5NCwgMC4zODQsIDAuMzg3XSwKICAvLyBzaWdtYTkKICBudW0zOiBbMC40NDQsIDAuNDcxLCAwLjUwNF0sCiAgLy8gc2lnbWExMAogIGRlbm9tMTogWzAuNjg2LCAwLjc1MiwgMS4wMjVdLAogIC8vIHNpZ21hMTEKICBkZW5vbTI6IFswLjM0NSwgMC4zNDQsIDAuNTMyXSwKICAvLyBzaWdtYTEyCiAgc3VwMTogWzAuNDEzLCAwLjUwMywgMC41MDRdLAogIC8vIHNpZ21hMTMKICBzdXAyOiBbMC4zNjMsIDAuNDMxLCAwLjQwNF0sCiAgLy8gc2lnbWExNAogIHN1cDM6IFswLjI4OSwgMC4yODYsIDAuMjk0XSwKICAvLyBzaWdtYTE1CiAgc3ViMTogWzAuMTUsIDAuMTQzLCAwLjJdLAogIC8vIHNpZ21hMTYKICBzdWIyOiBbMC4yNDcsIDAuMjg2LCAwLjRdLAogIC8vIHNpZ21hMTcKICBzdXBEcm9wOiBbMC4zODYsIDAuMzUzLCAwLjQ5NF0sCiAgLy8gc2lnbWExOAogIHN1YkRyb3A6IFswLjA1LCAwLjA3MSwgMC4xXSwKICAvLyBzaWdtYTE5CiAgZGVsaW0xOiBbMi4zOSwgMS43LCAxLjk4XSwKICAvLyBzaWdtYTIwCiAgZGVsaW0yOiBbMS4wMSwgMS4xNTcsIDEuNDJdLAogIC8vIHNpZ21hMjEKICBheGlzSGVpZ2h0OiBbMC4yNSwgMC4yNSwgMC4yNV0sCiAgLy8gc2lnbWEyMgogIC8vIFRoZXNlIGZvbnQgbWV0cmljcyBhcmUgZXh0cmFjdGVkIGZyb20gVGVYIGJ5IHVzaW5nIHRmdG9wbCBvbiBjbWV4MTAudGZtOwogIC8vIHRoZXkgY29ycmVzcG9uZCB0byB0aGUgZm9udCBwYXJhbWV0ZXJzIG9mIHRoZSBleHRlbnNpb24gZm9udHMgKGZhbWlseSAzKS4KICAvLyBTZWUgdGhlIFRlWGJvb2ssIHBhZ2UgNDQxLiBJbiBBTVNUZVgsIHRoZSBleHRlbnNpb24gZm9udHMgc2NhbGU7IHRvCiAgLy8gbWF0Y2ggY21leDcsIHdlJ2QgdXNlIGNtZXg3LnRmbSB2YWx1ZXMgZm9yIHNjcmlwdCBhbmQgc2NyaXB0c2NyaXB0CiAgLy8gdmFsdWVzLgogIGRlZmF1bHRSdWxlVGhpY2tuZXNzOiBbMC4wNCwgMC4wNDksIDAuMDQ5XSwKICAvLyB4aTg7IGNtZXg3OiAwLjA0OQogIGJpZ09wU3BhY2luZzE6IFswLjExMSwgMC4xMTEsIDAuMTExXSwKICAvLyB4aTkKICBiaWdPcFNwYWNpbmcyOiBbMC4xNjYsIDAuMTY2LCAwLjE2Nl0sCiAgLy8geGkxMAogIGJpZ09wU3BhY2luZzM6IFswLjIsIDAuMiwgMC4yXSwKICAvLyB4aTExCiAgYmlnT3BTcGFjaW5nNDogWzAuNiwgMC42MTEsIDAuNjExXSwKICAvLyB4aTEyOyBjbWV4NzogMC42MTEKICBiaWdPcFNwYWNpbmc1OiBbMC4xLCAwLjE0MywgMC4xNDNdLAogIC8vIHhpMTM7IGNtZXg3OiAwLjE0MwogIC8vIFRoZSBcc3FydCBydWxlIHdpZHRoIGlzIHRha2VuIGZyb20gdGhlIGhlaWdodCBvZiB0aGUgc3VyZCBjaGFyYWN0ZXIuCiAgLy8gU2luY2Ugd2UgdXNlIHRoZSBzYW1lIGZvbnQgYXQgYWxsIHNpemVzLCB0aGlzIHRoaWNrbmVzcyBkb2Vzbid0IHNjYWxlLgogIHNxcnRSdWxlVGhpY2tuZXNzOiBbMC4wNCwgMC4wNCwgMC4wNF0sCiAgLy8gVGhpcyB2YWx1ZSBkZXRlcm1pbmVzIGhvdyBsYXJnZSBhIHB0IGlzLCBmb3IgbWV0cmljcyB3aGljaCBhcmUgZGVmaW5lZAogIC8vIGluIHRlcm1zIG9mIHB0cy4KICAvLyBUaGlzIHZhbHVlIGlzIGFsc28gdXNlZCBpbiBrYXRleC5zY3NzOyBpZiB5b3UgY2hhbmdlIGl0IG1ha2Ugc3VyZSB0aGUKICAvLyB2YWx1ZXMgbWF0Y2guCiAgcHRQZXJFbTogWzEwLCAxMCwgMTBdLAogIC8vIFRoZSBzcGFjZSBiZXR3ZWVuIGFkamFjZW50IGB8YCBjb2x1bW5zIGluIGFuIGFycmF5IGRlZmluaXRpb24uIEZyb20KICAvLyBgXHNob3d0aGVcZG91YmxlcnVsZXNlcGAgaW4gTGFUZVguIEVxdWFscyAyLjAgLyBwdFBlckVtLgogIGRvdWJsZVJ1bGVTZXA6IFswLjIsIDAuMiwgMC4yXSwKICAvLyBUaGUgd2lkdGggb2Ygc2VwYXJhdG9yIGxpbmVzIGluIHthcnJheX0gZW52aXJvbm1lbnRzLiBGcm9tCiAgLy8gYFxzaG93dGhlXGFycmF5cnVsZXdpZHRoYCBpbiBMYVRlWC4gRXF1YWxzIDAuNCAvIHB0UGVyRW0uCiAgYXJyYXlSdWxlV2lkdGg6IFswLjA0LCAwLjA0LCAwLjA0XSwKICAvLyBUd28gdmFsdWVzIGZyb20gTGFUZVggc291cmNlMmU6CiAgZmJveHNlcDogWzAuMywgMC4zLCAwLjNdLAogIC8vICAgICAgICAzIHB0IC8gcHRQZXJFbQogIGZib3hydWxlOiBbMC4wNCwgMC4wNCwgMC4wNF0KICAvLyAwLjQgcHQgLyBwdFBlckVtCn07CnZhciBleHRyYUNoYXJhY3Rlck1hcCA9IHsKICAvLyBMYXRpbi0xCiAgIsOFIjogIkEiLAogICLDkCI6ICJEIiwKICAiw54iOiAibyIsCiAgIsOlIjogImEiLAogICLDsCI6ICJkIiwKICAiw74iOiAibyIsCiAgLy8gQ3lyaWxsaWMKICAi0JAiOiAiQSIsCiAgItCRIjogIkIiLAogICLQkiI6ICJCIiwKICAi0JMiOiAiRiIsCiAgItCUIjogIkEiLAogICLQlSI6ICJFIiwKICAi0JYiOiAiSyIsCiAgItCXIjogIjMiLAogICLQmCI6ICJOIiwKICAi0JkiOiAiTiIsCiAgItCaIjogIksiLAogICLQmyI6ICJOIiwKICAi0JwiOiAiTSIsCiAgItCdIjogIkgiLAogICLQniI6ICJPIiwKICAi0J8iOiAiTiIsCiAgItCgIjogIlAiLAogICLQoSI6ICJDIiwKICAi0KIiOiAiVCIsCiAgItCjIjogInkiLAogICLQpCI6ICJPIiwKICAi0KUiOiAiWCIsCiAgItCmIjogIlUiLAogICLQpyI6ICJoIiwKICAi0KgiOiAiVyIsCiAgItCpIjogIlciLAogICLQqiI6ICJCIiwKICAi0KsiOiAiWCIsCiAgItCsIjogIkIiLAogICLQrSI6ICIzIiwKICAi0K4iOiAiWCIsCiAgItCvIjogIlIiLAogICLQsCI6ICJhIiwKICAi0LEiOiAiYiIsCiAgItCyIjogImEiLAogICLQsyI6ICJyIiwKICAi0LQiOiAieSIsCiAgItC1IjogImUiLAogICLQtiI6ICJtIiwKICAi0LciOiAiZSIsCiAgItC4IjogIm4iLAogICLQuSI6ICJuIiwKICAi0LoiOiAibiIsCiAgItC7IjogIm4iLAogICLQvCI6ICJtIiwKICAi0L0iOiAibiIsCiAgItC+IjogIm8iLAogICLQvyI6ICJuIiwKICAi0YAiOiAicCIsCiAgItGBIjogImMiLAogICLRgiI6ICJvIiwKICAi0YMiOiAieSIsCiAgItGEIjogImIiLAogICLRhSI6ICJ4IiwKICAi0YYiOiAibiIsCiAgItGHIjogIm4iLAogICLRiCI6ICJ3IiwKICAi0YkiOiAidyIsCiAgItGKIjogImEiLAogICLRiyI6ICJtIiwKICAi0YwiOiAiYSIsCiAgItGNIjogImUiLAogICLRjiI6ICJtIiwKICAi0Y8iOiAiciIKfTsKZnVuY3Rpb24gc2V0Rm9udE1ldHJpY3MoZm9udE5hbWUsIG1ldHJpY3MpIHsKICBmb250TWV0cmljc0RhdGFbZm9udE5hbWVdID0gbWV0cmljczsKfQpmdW5jdGlvbiBnZXRDaGFyYWN0ZXJNZXRyaWNzKGNoYXJhY3RlciwgZm9udCwgbW9kZSkgewogIGlmICghZm9udE1ldHJpY3NEYXRhW2ZvbnRdKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIkZvbnQgbWV0cmljcyBub3QgZm91bmQgZm9yIGZvbnQ6ICIgKyBmb250ICsgIi4iKTsKICB9CiAgdmFyIGNoID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCk7CiAgdmFyIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bY2hdOwogIGlmICghbWV0cmljcyAmJiBjaGFyYWN0ZXJbMF0gaW4gZXh0cmFDaGFyYWN0ZXJNYXApIHsKICAgIGNoID0gZXh0cmFDaGFyYWN0ZXJNYXBbY2hhcmFjdGVyWzBdXS5jaGFyQ29kZUF0KDApOwogICAgbWV0cmljcyA9IGZvbnRNZXRyaWNzRGF0YVtmb250XVtjaF07CiAgfQogIGlmICghbWV0cmljcyAmJiBtb2RlID09PSAidGV4dCIpIHsKICAgIGlmIChzdXBwb3J0ZWRDb2RlcG9pbnQoY2gpKSB7CiAgICAgIG1ldHJpY3MgPSBmb250TWV0cmljc0RhdGFbZm9udF1bNzddOwogICAgfQogIH0KICBpZiAobWV0cmljcykgewogICAgcmV0dXJuIHsKICAgICAgZGVwdGg6IG1ldHJpY3NbMF0sCiAgICAgIGhlaWdodDogbWV0cmljc1sxXSwKICAgICAgaXRhbGljOiBtZXRyaWNzWzJdLAogICAgICBza2V3OiBtZXRyaWNzWzNdLAogICAgICB3aWR0aDogbWV0cmljc1s0XQogICAgfTsKICB9Cn0KdmFyIGZvbnRNZXRyaWNzQnlTaXplSW5kZXggPSB7fTsKZnVuY3Rpb24gZ2V0R2xvYmFsTWV0cmljcyhzaXplKSB7CiAgdmFyIHNpemVJbmRleDsKICBpZiAoc2l6ZSA+PSA1KSB7CiAgICBzaXplSW5kZXggPSAwOwogIH0gZWxzZSBpZiAoc2l6ZSA+PSAzKSB7CiAgICBzaXplSW5kZXggPSAxOwogIH0gZWxzZSB7CiAgICBzaXplSW5kZXggPSAyOwogIH0KICBpZiAoIWZvbnRNZXRyaWNzQnlTaXplSW5kZXhbc2l6ZUluZGV4XSkgewogICAgdmFyIG1ldHJpY3MgPSBmb250TWV0cmljc0J5U2l6ZUluZGV4W3NpemVJbmRleF0gPSB7CiAgICAgIGNzc0VtUGVyTXU6IHNpZ21hc0FuZFhpcy5xdWFkW3NpemVJbmRleF0gLyAxOAogICAgfTsKICAgIGZvciAodmFyIGtleSBpbiBzaWdtYXNBbmRYaXMpIHsKICAgICAgaWYgKHNpZ21hc0FuZFhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgICAgbWV0cmljc1trZXldID0gc2lnbWFzQW5kWGlzW2tleV1bc2l6ZUluZGV4XTsKICAgICAgfQogICAgfQogIH0KICByZXR1cm4gZm9udE1ldHJpY3NCeVNpemVJbmRleFtzaXplSW5kZXhdOwp9CnZhciBzaXplU3R5bGVNYXAgPSBbCiAgLy8gRWFjaCBlbGVtZW50IGNvbnRhaW5zIFt0ZXh0c2l6ZSwgc2NyaXB0c2l6ZSwgc2NyaXB0c2NyaXB0c2l6ZV0uCiAgLy8gVGhlIHNpemUgbWFwcGluZ3MgYXJlIHRha2VuIGZyb20gVGVYIHdpdGggXG5vcm1hbHNpemU9MTBwdC4KICBbMSwgMSwgMV0sCiAgLy8gc2l6ZTE6IFs1LCA1LCA1XSAgICAgICAgICAgICAgXHRpbnkKICBbMiwgMSwgMV0sCiAgLy8gc2l6ZTI6IFs2LCA1LCA1XQogIFszLCAxLCAxXSwKICAvLyBzaXplMzogWzcsIDUsIDVdICAgICAgICAgICAgICBcc2NyaXB0c2l6ZQogIFs0LCAyLCAxXSwKICAvLyBzaXplNDogWzgsIDYsIDVdICAgICAgICAgICAgICBcZm9vdG5vdGVzaXplCiAgWzUsIDIsIDFdLAogIC8vIHNpemU1OiBbOSwgNiwgNV0gICAgICAgICAgICAgIFxzbWFsbAogIFs2LCAzLCAxXSwKICAvLyBzaXplNjogWzEwLCA3LCA1XSAgICAgICAgICAgICBcbm9ybWFsc2l6ZQogIFs3LCA0LCAyXSwKICAvLyBzaXplNzogWzEyLCA4LCA2XSAgICAgICAgICAgICBcbGFyZ2UKICBbOCwgNiwgM10sCiAgLy8gc2l6ZTg6IFsxNC40LCAxMCwgN10gICAgICAgICAgXExhcmdlCiAgWzksIDcsIDZdLAogIC8vIHNpemU5OiBbMTcuMjgsIDEyLCAxMF0gICAgICAgIFxMQVJHRQogIFsxMCwgOCwgN10sCiAgLy8gc2l6ZTEwOiBbMjAuNzQsIDE0LjQsIDEyXSAgICAgXGh1Z2UKICBbMTEsIDEwLCA5XQogIC8vIHNpemUxMTogWzI0Ljg4LCAyMC43NCwgMTcuMjhdIFxIVUdFCl07CnZhciBzaXplTXVsdGlwbGllcnMgPSBbCiAgLy8gZm9udE1ldHJpY3MuanM6Z2V0R2xvYmFsTWV0cmljcyBhbHNvIHVzZXMgc2l6ZSBpbmRleGVzLCBzbyBpZgogIC8vIHlvdSBjaGFuZ2Ugc2l6ZSBpbmRleGVzLCBjaGFuZ2UgdGhhdCBmdW5jdGlvbi4KICAwLjUsCiAgMC42LAogIDAuNywKICAwLjgsCiAgMC45LAogIDEsCiAgMS4yLAogIDEuNDQsCiAgMS43MjgsCiAgMi4wNzQsCiAgMi40ODgKXTsKdmFyIHNpemVBdFN0eWxlID0gZnVuY3Rpb24gc2l6ZUF0U3R5bGUyKHNpemUsIHN0eWxlKSB7CiAgcmV0dXJuIHN0eWxlLnNpemUgPCAyID8gc2l6ZSA6IHNpemVTdHlsZU1hcFtzaXplIC0gMV1bc3R5bGUuc2l6ZSAtIDFdOwp9Owp2YXIgT3B0aW9ucyA9IGNsYXNzIF9PcHRpb25zIHsKICAvLyBBIGZvbnQgZmFtaWx5IGFwcGxpZXMgdG8gYSBncm91cCBvZiBmb250cyAoaS5lLiBTYW5zU2VyaWYpLCB3aGlsZSBhIGZvbnQKICAvLyByZXByZXNlbnRzIGEgc3BlY2lmaWMgZm9udCAoaS5lLiBTYW5zU2VyaWYgQm9sZCkuCiAgLy8gU2VlOiBodHRwczovL3RleC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMjIzNTAvZGlmZmVyZW5jZS1iZXR3ZWVuLXRleHRybS1hbmQtbWF0aHJtCiAgLyoqCiAgICogVGhlIGJhc2Ugc2l6ZSBpbmRleC4KICAgKi8KICBjb25zdHJ1Y3RvcihkYXRhKSB7CiAgICB0aGlzLnN0eWxlID0gdm9pZCAwOwogICAgdGhpcy5jb2xvciA9IHZvaWQgMDsKICAgIHRoaXMuc2l6ZSA9IHZvaWQgMDsKICAgIHRoaXMudGV4dFNpemUgPSB2b2lkIDA7CiAgICB0aGlzLnBoYW50b20gPSB2b2lkIDA7CiAgICB0aGlzLmZvbnQgPSB2b2lkIDA7CiAgICB0aGlzLmZvbnRGYW1pbHkgPSB2b2lkIDA7CiAgICB0aGlzLmZvbnRXZWlnaHQgPSB2b2lkIDA7CiAgICB0aGlzLmZvbnRTaGFwZSA9IHZvaWQgMDsKICAgIHRoaXMuc2l6ZU11bHRpcGxpZXIgPSB2b2lkIDA7CiAgICB0aGlzLm1heFNpemUgPSB2b2lkIDA7CiAgICB0aGlzLm1pblJ1bGVUaGlja25lc3MgPSB2b2lkIDA7CiAgICB0aGlzLl9mb250TWV0cmljcyA9IHZvaWQgMDsKICAgIHRoaXMuc3R5bGUgPSBkYXRhLnN0eWxlOwogICAgdGhpcy5jb2xvciA9IGRhdGEuY29sb3I7CiAgICB0aGlzLnNpemUgPSBkYXRhLnNpemUgfHwgX09wdGlvbnMuQkFTRVNJWkU7CiAgICB0aGlzLnRleHRTaXplID0gZGF0YS50ZXh0U2l6ZSB8fCB0aGlzLnNpemU7CiAgICB0aGlzLnBoYW50b20gPSAhIWRhdGEucGhhbnRvbTsKICAgIHRoaXMuZm9udCA9IGRhdGEuZm9udCB8fCAiIjsKICAgIHRoaXMuZm9udEZhbWlseSA9IGRhdGEuZm9udEZhbWlseSB8fCAiIjsKICAgIHRoaXMuZm9udFdlaWdodCA9IGRhdGEuZm9udFdlaWdodCB8fCAiIjsKICAgIHRoaXMuZm9udFNoYXBlID0gZGF0YS5mb250U2hhcGUgfHwgIiI7CiAgICB0aGlzLnNpemVNdWx0aXBsaWVyID0gc2l6ZU11bHRpcGxpZXJzW3RoaXMuc2l6ZSAtIDFdOwogICAgdGhpcy5tYXhTaXplID0gZGF0YS5tYXhTaXplOwogICAgdGhpcy5taW5SdWxlVGhpY2tuZXNzID0gZGF0YS5taW5SdWxlVGhpY2tuZXNzOwogICAgdGhpcy5fZm9udE1ldHJpY3MgPSB2b2lkIDA7CiAgfQogIC8qKgogICAqIFJldHVybnMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgc2FtZSBwcm9wZXJ0aWVzIGFzICJ0aGlzIi4gIFByb3BlcnRpZXMKICAgKiBmcm9tICJleHRlbnNpb24iIHdpbGwgYmUgY29waWVkIHRvIHRoZSBuZXcgb3B0aW9ucyBvYmplY3QuCiAgICovCiAgZXh0ZW5kKGV4dGVuc2lvbikgewogICAgdmFyIGRhdGEgPSB7CiAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLAogICAgICBzaXplOiB0aGlzLnNpemUsCiAgICAgIHRleHRTaXplOiB0aGlzLnRleHRTaXplLAogICAgICBjb2xvcjogdGhpcy5jb2xvciwKICAgICAgcGhhbnRvbTogdGhpcy5waGFudG9tLAogICAgICBmb250OiB0aGlzLmZvbnQsCiAgICAgIGZvbnRGYW1pbHk6IHRoaXMuZm9udEZhbWlseSwKICAgICAgZm9udFdlaWdodDogdGhpcy5mb250V2VpZ2h0LAogICAgICBmb250U2hhcGU6IHRoaXMuZm9udFNoYXBlLAogICAgICBtYXhTaXplOiB0aGlzLm1heFNpemUsCiAgICAgIG1pblJ1bGVUaGlja25lc3M6IHRoaXMubWluUnVsZVRoaWNrbmVzcwogICAgfTsKICAgIGZvciAodmFyIGtleSBpbiBleHRlbnNpb24pIHsKICAgICAgaWYgKGV4dGVuc2lvbi5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7CiAgICAgICAgZGF0YVtrZXldID0gZXh0ZW5zaW9uW2tleV07CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBuZXcgX09wdGlvbnMoZGF0YSk7CiAgfQogIC8qKgogICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzdHlsZS4gSWYgYHRoaXMuc3R5bGUgPT09IHN0eWxlYCwKICAgKiByZXR1cm5zIGB0aGlzYC4KICAgKi8KICBoYXZpbmdTdHlsZShzdHlsZSkgewogICAgaWYgKHRoaXMuc3R5bGUgPT09IHN0eWxlKSB7CiAgICAgIHJldHVybiB0aGlzOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHsKICAgICAgICBzdHlsZSwKICAgICAgICBzaXplOiBzaXplQXRTdHlsZSh0aGlzLnRleHRTaXplLCBzdHlsZSkKICAgICAgfSk7CiAgICB9CiAgfQogIC8qKgogICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIGEgY3JhbXBlZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IHN0eWxlLiBJZgogICAqIHRoZSBjdXJyZW50IHN0eWxlIGlzIGNyYW1wZWQsIHJldHVybnMgYHRoaXNgLgogICAqLwogIGhhdmluZ0NyYW1wZWRTdHlsZSgpIHsKICAgIHJldHVybiB0aGlzLmhhdmluZ1N0eWxlKHRoaXMuc3R5bGUuY3JhbXAoKSk7CiAgfQogIC8qKgogICAqIFJldHVybiBhbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBzaXplIGFuZCBpbiBhdCBsZWFzdCBgXHRleHRzdHlsZWAuCiAgICogUmV0dXJucyBgdGhpc2AgaWYgYXBwcm9wcmlhdGUuCiAgICovCiAgaGF2aW5nU2l6ZShzaXplKSB7CiAgICBpZiAodGhpcy5zaXplID09PSBzaXplICYmIHRoaXMudGV4dFNpemUgPT09IHNpemUpIHsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gdGhpcy5leHRlbmQoewogICAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLnRleHQoKSwKICAgICAgICBzaXplLAogICAgICAgIHRleHRTaXplOiBzaXplLAogICAgICAgIHNpemVNdWx0aXBsaWVyOiBzaXplTXVsdGlwbGllcnNbc2l6ZSAtIDFdCiAgICAgIH0pOwogICAgfQogIH0KICAvKioKICAgKiBMaWtlIGB0aGlzLmhhdmluZ1NpemUoQkFTRVNJWkUpLmhhdmluZ1N0eWxlKHN0eWxlKWAuIElmIGBzdHlsZWAgaXMgb21pdHRlZCwKICAgKiBjaGFuZ2VzIHRvIGF0IGxlYXN0IGBcdGV4dHN0eWxlYC4KICAgKi8KICBoYXZpbmdCYXNlU3R5bGUoc3R5bGUpIHsKICAgIHN0eWxlID0gc3R5bGUgfHwgdGhpcy5zdHlsZS50ZXh0KCk7CiAgICB2YXIgd2FudFNpemUgPSBzaXplQXRTdHlsZShfT3B0aW9ucy5CQVNFU0laRSwgc3R5bGUpOwogICAgaWYgKHRoaXMuc2l6ZSA9PT0gd2FudFNpemUgJiYgdGhpcy50ZXh0U2l6ZSA9PT0gX09wdGlvbnMuQkFTRVNJWkUgJiYgdGhpcy5zdHlsZSA9PT0gc3R5bGUpIHsKICAgICAgcmV0dXJuIHRoaXM7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gdGhpcy5leHRlbmQoewogICAgICAgIHN0eWxlLAogICAgICAgIHNpemU6IHdhbnRTaXplCiAgICAgIH0pOwogICAgfQogIH0KICAvKioKICAgKiBSZW1vdmUgdGhlIGVmZmVjdCBvZiBzaXppbmcgY2hhbmdlcyBzdWNoIGFzIFxIdWdlLgogICAqIEtlZXAgdGhlIGVmZmVjdCBvZiB0aGUgY3VycmVudCBzdHlsZSwgc3VjaCBhcyBcc2NyaXB0c3R5bGUuCiAgICovCiAgaGF2aW5nQmFzZVNpemluZygpIHsKICAgIHZhciBzaXplOwogICAgc3dpdGNoICh0aGlzLnN0eWxlLmlkKSB7CiAgICAgIGNhc2UgNDoKICAgICAgY2FzZSA1OgogICAgICAgIHNpemUgPSAzOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlIDY6CiAgICAgIGNhc2UgNzoKICAgICAgICBzaXplID0gMTsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICBzaXplID0gNjsKICAgIH0KICAgIHJldHVybiB0aGlzLmV4dGVuZCh7CiAgICAgIHN0eWxlOiB0aGlzLnN0eWxlLnRleHQoKSwKICAgICAgc2l6ZQogICAgfSk7CiAgfQogIC8qKgogICAqIENyZWF0ZSBhIG5ldyBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2xvci4KICAgKi8KICB3aXRoQ29sb3IoY29sb3IpIHsKICAgIHJldHVybiB0aGlzLmV4dGVuZCh7CiAgICAgIGNvbG9yCiAgICB9KTsKICB9CiAgLyoqCiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggInBoYW50b20iIHNldCB0byB0cnVlLgogICAqLwogIHdpdGhQaGFudG9tKCkgewogICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHsKICAgICAgcGhhbnRvbTogdHJ1ZQogICAgfSk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbWF0aCBmb250IG9yIG9sZCB0ZXh0IGZvbnQuCiAgICogQHR5cGUge1t0eXBlXX0KICAgKi8KICB3aXRoRm9udChmb250KSB7CiAgICByZXR1cm4gdGhpcy5leHRlbmQoewogICAgICBmb250CiAgICB9KTsKICB9CiAgLyoqCiAgICogQ3JlYXRlIGEgbmV3IG9wdGlvbnMgb2JqZWN0cyB3aXRoIHRoZSBnaXZlbiBmb250RmFtaWx5LgogICAqLwogIHdpdGhUZXh0Rm9udEZhbWlseShmb250RmFtaWx5KSB7CiAgICByZXR1cm4gdGhpcy5leHRlbmQoewogICAgICBmb250RmFtaWx5LAogICAgICBmb250OiAiIgogICAgfSk7CiAgfQogIC8qKgogICAqIENyZWF0ZXMgYSBuZXcgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gZm9udCB3ZWlnaHQKICAgKi8KICB3aXRoVGV4dEZvbnRXZWlnaHQoZm9udFdlaWdodCkgewogICAgcmV0dXJuIHRoaXMuZXh0ZW5kKHsKICAgICAgZm9udFdlaWdodCwKICAgICAgZm9udDogIiIKICAgIH0pOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgbmV3IG9wdGlvbnMgb2JqZWN0IHdpdGggdGhlIGdpdmVuIGZvbnQgd2VpZ2h0CiAgICovCiAgd2l0aFRleHRGb250U2hhcGUoZm9udFNoYXBlKSB7CiAgICByZXR1cm4gdGhpcy5leHRlbmQoewogICAgICBmb250U2hhcGUsCiAgICAgIGZvbnQ6ICIiCiAgICB9KTsKICB9CiAgLyoqCiAgICogUmV0dXJuIHRoZSBDU1Mgc2l6aW5nIGNsYXNzZXMgcmVxdWlyZWQgdG8gc3dpdGNoIGZyb20gZW5jbG9zaW5nIG9wdGlvbnMKICAgKiBgb2xkT3B0aW9uc2AgdG8gYHRoaXNgLiBSZXR1cm5zIGFuIGFycmF5IG9mIGNsYXNzZXMuCiAgICovCiAgc2l6aW5nQ2xhc3NlcyhvbGRPcHRpb25zKSB7CiAgICBpZiAob2xkT3B0aW9ucy5zaXplICE9PSB0aGlzLnNpemUpIHsKICAgICAgcmV0dXJuIFsic2l6aW5nIiwgInJlc2V0LXNpemUiICsgb2xkT3B0aW9ucy5zaXplLCAic2l6ZSIgKyB0aGlzLnNpemVdOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIFtdOwogICAgfQogIH0KICAvKioKICAgKiBSZXR1cm4gdGhlIENTUyBzaXppbmcgY2xhc3NlcyByZXF1aXJlZCB0byBzd2l0Y2ggdG8gdGhlIGJhc2Ugc2l6ZS4gTGlrZQogICAqIGB0aGlzLmhhdmluZ1NpemUoQkFTRVNJWkUpLnNpemluZ0NsYXNzZXModGhpcylgLgogICAqLwogIGJhc2VTaXppbmdDbGFzc2VzKCkgewogICAgaWYgKHRoaXMuc2l6ZSAhPT0gX09wdGlvbnMuQkFTRVNJWkUpIHsKICAgICAgcmV0dXJuIFsic2l6aW5nIiwgInJlc2V0LXNpemUiICsgdGhpcy5zaXplLCAic2l6ZSIgKyBfT3B0aW9ucy5CQVNFU0laRV07CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gW107CiAgICB9CiAgfQogIC8qKgogICAqIFJldHVybiB0aGUgZm9udCBtZXRyaWNzIGZvciB0aGlzIHNpemUuCiAgICovCiAgZm9udE1ldHJpY3MoKSB7CiAgICBpZiAoIXRoaXMuX2ZvbnRNZXRyaWNzKSB7CiAgICAgIHRoaXMuX2ZvbnRNZXRyaWNzID0gZ2V0R2xvYmFsTWV0cmljcyh0aGlzLnNpemUpOwogICAgfQogICAgcmV0dXJuIHRoaXMuX2ZvbnRNZXRyaWNzOwogIH0KICAvKioKICAgKiBHZXRzIHRoZSBDU1MgY29sb3Igb2YgdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QKICAgKi8KICBnZXRDb2xvcigpIHsKICAgIGlmICh0aGlzLnBoYW50b20pIHsKICAgICAgcmV0dXJuICJ0cmFuc3BhcmVudCI7CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gdGhpcy5jb2xvcjsKICAgIH0KICB9Cn07Ck9wdGlvbnMuQkFTRVNJWkUgPSA2Owp2YXIgcHRQZXJVbml0ID0gewogIC8vIGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0xhVGVYL0xlbmd0aHMgYW5kCiAgLy8gaHR0cHM6Ly90ZXguc3RhY2tleGNoYW5nZS5jb20vYS84MjYzCiAgInB0IjogMSwKICAvLyBUZVggcG9pbnQKICAibW0iOiA3MjI3IC8gMjU0MCwKICAvLyBtaWxsaW1ldGVyCiAgImNtIjogNzIyNyAvIDI1NCwKICAvLyBjZW50aW1ldGVyCiAgImluIjogNzIuMjcsCiAgLy8gaW5jaAogICJicCI6IDgwMyAvIDgwMCwKICAvLyBiaWcgKFBvc3RTY3JpcHQpIHBvaW50cwogICJwYyI6IDEyLAogIC8vIHBpY2EKICAiZGQiOiAxMjM4IC8gMTE1NywKICAvLyBkaWRvdAogICJjYyI6IDE0ODU2IC8gMTE1NywKICAvLyBjaWNlcm8gKDEyIGRpZG90KQogICJuZCI6IDY4NSAvIDY0MiwKICAvLyBuZXcgZGlkb3QKICAibmMiOiAxMzcwIC8gMTA3LAogIC8vIG5ldyBjaWNlcm8gKDEyIG5ldyBkaWRvdCkKICAic3AiOiAxIC8gNjU1MzYsCiAgLy8gc2NhbGVkIHBvaW50IChUZVgncyBpbnRlcm5hbCBzbWFsbGVzdCB1bml0KQogIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL2EvNDEzNzEKICAicHgiOiA4MDMgLyA4MDAKICAvLyBccGRmcHhkaW1lbiBkZWZhdWx0cyB0byAxIGJwIGluIHBkZlRlWCBhbmQgTHVhVGVYCn07CnZhciByZWxhdGl2ZVVuaXQgPSB7CiAgImV4IjogdHJ1ZSwKICAiZW0iOiB0cnVlLAogICJtdSI6IHRydWUKfTsKdmFyIHZhbGlkVW5pdCA9IGZ1bmN0aW9uIHZhbGlkVW5pdDIodW5pdCkgewogIGlmICh0eXBlb2YgdW5pdCAhPT0gInN0cmluZyIpIHsKICAgIHVuaXQgPSB1bml0LnVuaXQ7CiAgfQogIHJldHVybiB1bml0IGluIHB0UGVyVW5pdCB8fCB1bml0IGluIHJlbGF0aXZlVW5pdCB8fCB1bml0ID09PSAiZXgiOwp9Owp2YXIgY2FsY3VsYXRlU2l6ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVNpemUyKHNpemVWYWx1ZSwgb3B0aW9ucykgewogIHZhciBzY2FsZTsKICBpZiAoc2l6ZVZhbHVlLnVuaXQgaW4gcHRQZXJVbml0KSB7CiAgICBzY2FsZSA9IHB0UGVyVW5pdFtzaXplVmFsdWUudW5pdF0gLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbSAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgfSBlbHNlIGlmIChzaXplVmFsdWUudW5pdCA9PT0gIm11IikgewogICAgc2NhbGUgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuY3NzRW1QZXJNdTsKICB9IGVsc2UgewogICAgdmFyIHVuaXRPcHRpb25zOwogICAgaWYgKG9wdGlvbnMuc3R5bGUuaXNUaWdodCgpKSB7CiAgICAgIHVuaXRPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7CiAgICB9IGVsc2UgewogICAgICB1bml0T3B0aW9ucyA9IG9wdGlvbnM7CiAgICB9CiAgICBpZiAoc2l6ZVZhbHVlLnVuaXQgPT09ICJleCIpIHsKICAgICAgc2NhbGUgPSB1bml0T3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7CiAgICB9IGVsc2UgaWYgKHNpemVWYWx1ZS51bml0ID09PSAiZW0iKSB7CiAgICAgIHNjYWxlID0gdW5pdE9wdGlvbnMuZm9udE1ldHJpY3MoKS5xdWFkOwogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkludmFsaWQgdW5pdDogJyIgKyBzaXplVmFsdWUudW5pdCArICInIik7CiAgICB9CiAgICBpZiAodW5pdE9wdGlvbnMgIT09IG9wdGlvbnMpIHsKICAgICAgc2NhbGUgKj0gdW5pdE9wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyOwogICAgfQogIH0KICByZXR1cm4gTWF0aC5taW4oc2l6ZVZhbHVlLm51bWJlciAqIHNjYWxlLCBvcHRpb25zLm1heFNpemUpOwp9Owp2YXIgbWFrZUVtID0gZnVuY3Rpb24gbWFrZUVtMihuKSB7CiAgcmV0dXJuICtuLnRvRml4ZWQoNCkgKyAiZW0iOwp9Owp2YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiBjcmVhdGVDbGFzczIoY2xhc3NlcykgewogIHJldHVybiBjbGFzc2VzLmZpbHRlcigoY2xzKSA9PiBjbHMpLmpvaW4oIiAiKTsKfTsKdmFyIGluaXROb2RlID0gZnVuY3Rpb24gaW5pdE5vZGUyKGNsYXNzZXMsIG9wdGlvbnMsIHN0eWxlKSB7CiAgdGhpcy5jbGFzc2VzID0gY2xhc3NlcyB8fCBbXTsKICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTsKICB0aGlzLmhlaWdodCA9IDA7CiAgdGhpcy5kZXB0aCA9IDA7CiAgdGhpcy5tYXhGb250U2l6ZSA9IDA7CiAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9OwogIGlmIChvcHRpb25zKSB7CiAgICBpZiAob3B0aW9ucy5zdHlsZS5pc1RpZ2h0KCkpIHsKICAgICAgdGhpcy5jbGFzc2VzLnB1c2goIm10aWdodCIpOwogICAgfQogICAgdmFyIGNvbG9yID0gb3B0aW9ucy5nZXRDb2xvcigpOwogICAgaWYgKGNvbG9yKSB7CiAgICAgIHRoaXMuc3R5bGUuY29sb3IgPSBjb2xvcjsKICAgIH0KICB9Cn07CnZhciB0b05vZGUgPSBmdW5jdGlvbiB0b05vZGUyKHRhZ05hbWUpIHsKICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7CiAgbm9kZS5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpOwogIGZvciAodmFyIHN0eWxlIGluIHRoaXMuc3R5bGUpIHsKICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkgewogICAgICBub2RlLnN0eWxlW3N0eWxlXSA9IHRoaXMuc3R5bGVbc3R5bGVdOwogICAgfQogIH0KICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykgewogICAgaWYgKHRoaXMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgewogICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCB0aGlzLmF0dHJpYnV0ZXNbYXR0cl0pOwogICAgfQogIH0KICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcy5jaGlsZHJlbltpXS50b05vZGUoKSk7CiAgfQogIHJldHVybiBub2RlOwp9Owp2YXIgaW52YWxpZEF0dHJpYnV0ZU5hbWVSZWdleCA9IC9bXHMiJz4vPVx4MDAtXHgxZl0vOwp2YXIgdG9NYXJrdXAgPSBmdW5jdGlvbiB0b01hcmt1cDIodGFnTmFtZSkgewogIHZhciBtYXJrdXAgPSAiPCIgKyB0YWdOYW1lOwogIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7CiAgICBtYXJrdXAgKz0gJyBjbGFzcz0iJyArIHV0aWxzLmVzY2FwZShjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpKSArICciJzsKICB9CiAgdmFyIHN0eWxlczIgPSAiIjsKICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7CiAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHsKICAgICAgc3R5bGVzMiArPSB1dGlscy5oeXBoZW5hdGUoc3R5bGUpICsgIjoiICsgdGhpcy5zdHlsZVtzdHlsZV0gKyAiOyI7CiAgICB9CiAgfQogIGlmIChzdHlsZXMyKSB7CiAgICBtYXJrdXAgKz0gJyBzdHlsZT0iJyArIHV0aWxzLmVzY2FwZShzdHlsZXMyKSArICciJzsKICB9CiAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHsKICAgIGlmICh0aGlzLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHsKICAgICAgaWYgKGludmFsaWRBdHRyaWJ1dGVOYW1lUmVnZXgudGVzdChhdHRyKSkgewogICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lICciICsgYXR0ciArICInIik7CiAgICAgIH0KICAgICAgbWFya3VwICs9ICIgIiArIGF0dHIgKyAnPSInICsgdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSkgKyAnIic7CiAgICB9CiAgfQogIG1hcmt1cCArPSAiPiI7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpOwogIH0KICBtYXJrdXAgKz0gIjwvIiArIHRhZ05hbWUgKyAiPiI7CiAgcmV0dXJuIG1hcmt1cDsKfTsKdmFyIFNwYW4gPSBjbGFzcyB7CiAgY29uc3RydWN0b3IoY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMsIHN0eWxlKSB7CiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwOwogICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwOwogICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwOwogICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7CiAgICB0aGlzLmRlcHRoID0gdm9pZCAwOwogICAgdGhpcy53aWR0aCA9IHZvaWQgMDsKICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7CiAgICB0aGlzLnN0eWxlID0gdm9pZCAwOwogICAgaW5pdE5vZGUuY2FsbCh0aGlzLCBjbGFzc2VzLCBvcHRpb25zLCBzdHlsZSk7CiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107CiAgfQogIC8qKgogICAqIFNldHMgYW4gYXJiaXRyYXJ5IGF0dHJpYnV0ZSBvbiB0aGUgc3Bhbi4gV2FybmluZzogdXNlIHRoaXMgd2lzZWx5LiBOb3QKICAgKiBhbGwgYnJvd3NlcnMgc3VwcG9ydCBhdHRyaWJ1dGVzIHRoZSBzYW1lLCBhbmQgaGF2aW5nIHRvbyBtYW55IGN1c3RvbQogICAqIGF0dHJpYnV0ZXMgaXMgcHJvYmFibHkgYmFkLgogICAqLwogIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7CiAgICB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlXSA9IHZhbHVlOwogIH0KICBoYXNDbGFzcyhjbGFzc05hbWUpIHsKICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSk7CiAgfQogIHRvTm9kZSgpIHsKICAgIHJldHVybiB0b05vZGUuY2FsbCh0aGlzLCAic3BhbiIpOwogIH0KICB0b01hcmt1cCgpIHsKICAgIHJldHVybiB0b01hcmt1cC5jYWxsKHRoaXMsICJzcGFuIik7CiAgfQp9Owp2YXIgQW5jaG9yID0gY2xhc3MgewogIGNvbnN0cnVjdG9yKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7CiAgICB0aGlzLmNoaWxkcmVuID0gdm9pZCAwOwogICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwOwogICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwOwogICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7CiAgICB0aGlzLmRlcHRoID0gdm9pZCAwOwogICAgdGhpcy5tYXhGb250U2l6ZSA9IHZvaWQgMDsKICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7CiAgICBpbml0Tm9kZS5jYWxsKHRoaXMsIGNsYXNzZXMsIG9wdGlvbnMpOwogICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IFtdOwogICAgdGhpcy5zZXRBdHRyaWJ1dGUoImhyZWYiLCBocmVmKTsKICB9CiAgc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpIHsKICAgIHRoaXMuYXR0cmlidXRlc1thdHRyaWJ1dGVdID0gdmFsdWU7CiAgfQogIGhhc0NsYXNzKGNsYXNzTmFtZSkgewogICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTsKICB9CiAgdG9Ob2RlKCkgewogICAgcmV0dXJuIHRvTm9kZS5jYWxsKHRoaXMsICJhIik7CiAgfQogIHRvTWFya3VwKCkgewogICAgcmV0dXJuIHRvTWFya3VwLmNhbGwodGhpcywgImEiKTsKICB9Cn07CnZhciBJbWcgPSBjbGFzcyB7CiAgY29uc3RydWN0b3Ioc3JjLCBhbHQsIHN0eWxlKSB7CiAgICB0aGlzLnNyYyA9IHZvaWQgMDsKICAgIHRoaXMuYWx0ID0gdm9pZCAwOwogICAgdGhpcy5jbGFzc2VzID0gdm9pZCAwOwogICAgdGhpcy5oZWlnaHQgPSB2b2lkIDA7CiAgICB0aGlzLmRlcHRoID0gdm9pZCAwOwogICAgdGhpcy5tYXhGb250U2l6ZSA9IHZvaWQgMDsKICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7CiAgICB0aGlzLmFsdCA9IGFsdDsKICAgIHRoaXMuc3JjID0gc3JjOwogICAgdGhpcy5jbGFzc2VzID0gWyJtb3JkIl07CiAgICB0aGlzLnN0eWxlID0gc3R5bGU7CiAgfQogIGhhc0NsYXNzKGNsYXNzTmFtZSkgewogICAgcmV0dXJuIHV0aWxzLmNvbnRhaW5zKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKTsKICB9CiAgdG9Ob2RlKCkgewogICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKTsKICAgIG5vZGUuc3JjID0gdGhpcy5zcmM7CiAgICBub2RlLmFsdCA9IHRoaXMuYWx0OwogICAgbm9kZS5jbGFzc05hbWUgPSAibW9yZCI7CiAgICBmb3IgKHZhciBzdHlsZSBpbiB0aGlzLnN0eWxlKSB7CiAgICAgIGlmICh0aGlzLnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSkgewogICAgICAgIG5vZGUuc3R5bGVbc3R5bGVdID0gdGhpcy5zdHlsZVtzdHlsZV07CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBub2RlOwogIH0KICB0b01hcmt1cCgpIHsKICAgIHZhciBtYXJrdXAgPSAnPGltZyBzcmM9IicgKyB1dGlscy5lc2NhcGUodGhpcy5zcmMpICsgJyInICsgKCcgYWx0PSInICsgdXRpbHMuZXNjYXBlKHRoaXMuYWx0KSArICciJyk7CiAgICB2YXIgc3R5bGVzMiA9ICIiOwogICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkgewogICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHsKICAgICAgICBzdHlsZXMyICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyAiOiIgKyB0aGlzLnN0eWxlW3N0eWxlXSArICI7IjsKICAgICAgfQogICAgfQogICAgaWYgKHN0eWxlczIpIHsKICAgICAgbWFya3VwICs9ICcgc3R5bGU9IicgKyB1dGlscy5lc2NhcGUoc3R5bGVzMikgKyAnIic7CiAgICB9CiAgICBtYXJrdXAgKz0gIicvPiI7CiAgICByZXR1cm4gbWFya3VwOwogIH0KfTsKdmFyIGlDb21iaW5hdGlvbnMgPSB7CiAgIsOuIjogIsSxzIIiLAogICLDryI6ICLEscyIIiwKICAiw60iOiAixLHMgSIsCiAgLy8gJ8SrJzogJ1x1MDEzMVx1MDMwNCcsIC8vIGVuYWJsZSB3aGVuIHdlIGFkZCBFeHRlbmRlZCBMYXRpbgogICLDrCI6ICLEscyAIgp9Owp2YXIgU3ltYm9sTm9kZSA9IGNsYXNzIHsKICBjb25zdHJ1Y3Rvcih0ZXh0MiwgaGVpZ2h0LCBkZXB0aCwgaXRhbGljLCBza2V3LCB3aWR0aCwgY2xhc3Nlcywgc3R5bGUpIHsKICAgIHRoaXMudGV4dCA9IHZvaWQgMDsKICAgIHRoaXMuaGVpZ2h0ID0gdm9pZCAwOwogICAgdGhpcy5kZXB0aCA9IHZvaWQgMDsKICAgIHRoaXMuaXRhbGljID0gdm9pZCAwOwogICAgdGhpcy5za2V3ID0gdm9pZCAwOwogICAgdGhpcy53aWR0aCA9IHZvaWQgMDsKICAgIHRoaXMubWF4Rm9udFNpemUgPSB2b2lkIDA7CiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7CiAgICB0aGlzLnN0eWxlID0gdm9pZCAwOwogICAgdGhpcy50ZXh0ID0gdGV4dDI7CiAgICB0aGlzLmhlaWdodCA9IGhlaWdodCB8fCAwOwogICAgdGhpcy5kZXB0aCA9IGRlcHRoIHx8IDA7CiAgICB0aGlzLml0YWxpYyA9IGl0YWxpYyB8fCAwOwogICAgdGhpcy5za2V3ID0gc2tldyB8fCAwOwogICAgdGhpcy53aWR0aCA9IHdpZHRoIHx8IDA7CiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdOwogICAgdGhpcy5zdHlsZSA9IHN0eWxlIHx8IHt9OwogICAgdGhpcy5tYXhGb250U2l6ZSA9IDA7CiAgICB2YXIgc2NyaXB0ID0gc2NyaXB0RnJvbUNvZGVwb2ludCh0aGlzLnRleHQuY2hhckNvZGVBdCgwKSk7CiAgICBpZiAoc2NyaXB0KSB7CiAgICAgIHRoaXMuY2xhc3Nlcy5wdXNoKHNjcmlwdCArICJfZmFsbGJhY2siKTsKICAgIH0KICAgIGlmICgvW8Ouw6/DrcOsXS8udGVzdCh0aGlzLnRleHQpKSB7CiAgICAgIHRoaXMudGV4dCA9IGlDb21iaW5hdGlvbnNbdGhpcy50ZXh0XTsKICAgIH0KICB9CiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7CiAgICByZXR1cm4gdXRpbHMuY29udGFpbnModGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpOwogIH0KICAvKioKICAgKiBDcmVhdGVzIGEgdGV4dCBub2RlIG9yIHNwYW4gZnJvbSBhIHN5bWJvbCBub2RlLiBOb3RlIHRoYXQgYSBzcGFuIGlzIG9ubHkKICAgKiBjcmVhdGVkIGlmIGl0IGlzIG5lZWRlZC4KICAgKi8KICB0b05vZGUoKSB7CiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGV4dCk7CiAgICB2YXIgc3BhbiA9IG51bGw7CiAgICBpZiAodGhpcy5pdGFsaWMgPiAwKSB7CiAgICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7CiAgICAgIHNwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0odGhpcy5pdGFsaWMpOwogICAgfQogICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7CiAgICAgIHNwYW4gPSBzcGFuIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoInNwYW4iKTsKICAgICAgc3Bhbi5jbGFzc05hbWUgPSBjcmVhdGVDbGFzcyh0aGlzLmNsYXNzZXMpOwogICAgfQogICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkgewogICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHsKICAgICAgICBzcGFuID0gc3BhbiB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJzcGFuIik7CiAgICAgICAgc3Bhbi5zdHlsZVtzdHlsZV0gPSB0aGlzLnN0eWxlW3N0eWxlXTsKICAgICAgfQogICAgfQogICAgaWYgKHNwYW4pIHsKICAgICAgc3Bhbi5hcHBlbmRDaGlsZChub2RlKTsKICAgICAgcmV0dXJuIHNwYW47CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gbm9kZTsKICAgIH0KICB9CiAgLyoqCiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgc3ltYm9sIG5vZGUuCiAgICovCiAgdG9NYXJrdXAoKSB7CiAgICB2YXIgbmVlZHNTcGFuID0gZmFsc2U7CiAgICB2YXIgbWFya3VwID0gIjxzcGFuIjsKICAgIGlmICh0aGlzLmNsYXNzZXMubGVuZ3RoKSB7CiAgICAgIG5lZWRzU3BhbiA9IHRydWU7CiAgICAgIG1hcmt1cCArPSAnIGNsYXNzPSInOwogICAgICBtYXJrdXAgKz0gdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpOwogICAgICBtYXJrdXAgKz0gJyInOwogICAgfQogICAgdmFyIHN0eWxlczIgPSAiIjsKICAgIGlmICh0aGlzLml0YWxpYyA+IDApIHsKICAgICAgc3R5bGVzMiArPSAibWFyZ2luLXJpZ2h0OiIgKyB0aGlzLml0YWxpYyArICJlbTsiOwogICAgfQogICAgZm9yICh2YXIgc3R5bGUgaW4gdGhpcy5zdHlsZSkgewogICAgICBpZiAodGhpcy5zdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZSkpIHsKICAgICAgICBzdHlsZXMyICs9IHV0aWxzLmh5cGhlbmF0ZShzdHlsZSkgKyAiOiIgKyB0aGlzLnN0eWxlW3N0eWxlXSArICI7IjsKICAgICAgfQogICAgfQogICAgaWYgKHN0eWxlczIpIHsKICAgICAgbmVlZHNTcGFuID0gdHJ1ZTsKICAgICAgbWFya3VwICs9ICcgc3R5bGU9IicgKyB1dGlscy5lc2NhcGUoc3R5bGVzMikgKyAnIic7CiAgICB9CiAgICB2YXIgZXNjYXBlZCA9IHV0aWxzLmVzY2FwZSh0aGlzLnRleHQpOwogICAgaWYgKG5lZWRzU3BhbikgewogICAgICBtYXJrdXAgKz0gIj4iOwogICAgICBtYXJrdXAgKz0gZXNjYXBlZDsKICAgICAgbWFya3VwICs9ICI8L3NwYW4+IjsKICAgICAgcmV0dXJuIG1hcmt1cDsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBlc2NhcGVkOwogICAgfQogIH0KfTsKdmFyIFN2Z05vZGUgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IoY2hpbGRyZW4sIGF0dHJpYnV0ZXMpIHsKICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7CiAgICB0aGlzLmF0dHJpYnV0ZXMgPSB2b2lkIDA7CiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107CiAgICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9OwogIH0KICB0b05vZGUoKSB7CiAgICB2YXIgc3ZnTlMgPSAiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciOwogICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsICJzdmciKTsKICAgIGZvciAodmFyIGF0dHIgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7CiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5hdHRyaWJ1dGVzLCBhdHRyKSkgewogICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHIsIHRoaXMuYXR0cmlidXRlc1thdHRyXSk7CiAgICAgIH0KICAgIH0KICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykgewogICAgICBub2RlLmFwcGVuZENoaWxkKHRoaXMuY2hpbGRyZW5baV0udG9Ob2RlKCkpOwogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQogIHRvTWFya3VwKCkgewogICAgdmFyIG1hcmt1cCA9ICc8c3ZnIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyInOwogICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHsKICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7CiAgICAgICAgbWFya3VwICs9ICIgIiArIGF0dHIgKyAnPSInICsgdXRpbHMuZXNjYXBlKHRoaXMuYXR0cmlidXRlc1thdHRyXSkgKyAnIic7CiAgICAgIH0KICAgIH0KICAgIG1hcmt1cCArPSAiPiI7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgICAgbWFya3VwICs9IHRoaXMuY2hpbGRyZW5baV0udG9NYXJrdXAoKTsKICAgIH0KICAgIG1hcmt1cCArPSAiPC9zdmc+IjsKICAgIHJldHVybiBtYXJrdXA7CiAgfQp9Owp2YXIgUGF0aE5vZGUgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IocGF0aE5hbWUsIGFsdGVybmF0ZSkgewogICAgdGhpcy5wYXRoTmFtZSA9IHZvaWQgMDsKICAgIHRoaXMuYWx0ZXJuYXRlID0gdm9pZCAwOwogICAgdGhpcy5wYXRoTmFtZSA9IHBhdGhOYW1lOwogICAgdGhpcy5hbHRlcm5hdGUgPSBhbHRlcm5hdGU7CiAgfQogIHRvTm9kZSgpIHsKICAgIHZhciBzdmdOUyA9ICJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI7CiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmdOUywgInBhdGgiKTsKICAgIGlmICh0aGlzLmFsdGVybmF0ZSkgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgiZCIsIHRoaXMuYWx0ZXJuYXRlKTsKICAgIH0gZWxzZSB7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJkIiwgcGF0aFt0aGlzLnBhdGhOYW1lXSk7CiAgICB9CiAgICByZXR1cm4gbm9kZTsKICB9CiAgdG9NYXJrdXAoKSB7CiAgICBpZiAodGhpcy5hbHRlcm5hdGUpIHsKICAgICAgcmV0dXJuICc8cGF0aCBkPSInICsgdXRpbHMuZXNjYXBlKHRoaXMuYWx0ZXJuYXRlKSArICciLz4nOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICc8cGF0aCBkPSInICsgdXRpbHMuZXNjYXBlKHBhdGhbdGhpcy5wYXRoTmFtZV0pICsgJyIvPic7CiAgICB9CiAgfQp9Owp2YXIgTGluZU5vZGUgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IoYXR0cmlidXRlcykgewogICAgdGhpcy5hdHRyaWJ1dGVzID0gdm9pZCAwOwogICAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTsKICB9CiAgdG9Ob2RlKCkgewogICAgdmFyIHN2Z05TID0gImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIjsKICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCAibGluZSIpOwogICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHsKICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7CiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQogIHRvTWFya3VwKCkgewogICAgdmFyIG1hcmt1cCA9ICI8bGluZSI7CiAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cmlidXRlcykgewogICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuYXR0cmlidXRlcywgYXR0cikpIHsKICAgICAgICBtYXJrdXAgKz0gIiAiICsgYXR0ciArICc9IicgKyB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKSArICciJzsKICAgICAgfQogICAgfQogICAgbWFya3VwICs9ICIvPiI7CiAgICByZXR1cm4gbWFya3VwOwogIH0KfTsKZnVuY3Rpb24gYXNzZXJ0U3ltYm9sRG9tTm9kZShncm91cCkgewogIGlmIChncm91cCBpbnN0YW5jZW9mIFN5bWJvbE5vZGUpIHsKICAgIHJldHVybiBncm91cDsKICB9IGVsc2UgewogICAgdGhyb3cgbmV3IEVycm9yKCJFeHBlY3RlZCBzeW1ib2xOb2RlIGJ1dCBnb3QgIiArIFN0cmluZyhncm91cCkgKyAiLiIpOwogIH0KfQpmdW5jdGlvbiBhc3NlcnRTcGFuKGdyb3VwKSB7CiAgaWYgKGdyb3VwIGluc3RhbmNlb2YgU3BhbikgewogICAgcmV0dXJuIGdyb3VwOwogIH0gZWxzZSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIkV4cGVjdGVkIHNwYW48SHRtbERvbU5vZGU+IGJ1dCBnb3QgIiArIFN0cmluZyhncm91cCkgKyAiLiIpOwogIH0KfQp2YXIgQVRPTVMgPSB7CiAgImJpbiI6IDEsCiAgImNsb3NlIjogMSwKICAiaW5uZXIiOiAxLAogICJvcGVuIjogMSwKICAicHVuY3QiOiAxLAogICJyZWwiOiAxCn07CnZhciBOT05fQVRPTVMgPSB7CiAgImFjY2VudC10b2tlbiI6IDEsCiAgIm1hdGhvcmQiOiAxLAogICJvcC10b2tlbiI6IDEsCiAgInNwYWNpbmciOiAxLAogICJ0ZXh0b3JkIjogMQp9Owp2YXIgc3ltYm9scyA9IHsKICAibWF0aCI6IHt9LAogICJ0ZXh0Ijoge30KfTsKZnVuY3Rpb24gZGVmaW5lU3ltYm9sKG1vZGUsIGZvbnQsIGdyb3VwLCByZXBsYWNlLCBuYW1lLCBhY2NlcHRVbmljb2RlQ2hhcikgewogIHN5bWJvbHNbbW9kZV1bbmFtZV0gPSB7CiAgICBmb250LAogICAgZ3JvdXAsCiAgICByZXBsYWNlCiAgfTsKICBpZiAoYWNjZXB0VW5pY29kZUNoYXIgJiYgcmVwbGFjZSkgewogICAgc3ltYm9sc1ttb2RlXVtyZXBsYWNlXSA9IHN5bWJvbHNbbW9kZV1bbmFtZV07CiAgfQp9CnZhciBtYXRoID0gIm1hdGgiOwp2YXIgdGV4dCA9ICJ0ZXh0IjsKdmFyIG1haW4gPSAibWFpbiI7CnZhciBhbXMgPSAiYW1zIjsKdmFyIGFjY2VudCA9ICJhY2NlbnQtdG9rZW4iOwp2YXIgYmluID0gImJpbiI7CnZhciBjbG9zZSA9ICJjbG9zZSI7CnZhciBpbm5lciA9ICJpbm5lciI7CnZhciBtYXRob3JkID0gIm1hdGhvcmQiOwp2YXIgb3AgPSAib3AtdG9rZW4iOwp2YXIgb3BlbiA9ICJvcGVuIjsKdmFyIHB1bmN0ID0gInB1bmN0IjsKdmFyIHJlbCA9ICJyZWwiOwp2YXIgc3BhY2luZyA9ICJzcGFjaW5nIjsKdmFyIHRleHRvcmQgPSAidGV4dG9yZCI7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiaEiLCAiXFxlcXVpdiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4om6IiwgIlxccHJlYyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4om7IiwgIlxcc3VjYyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oi8IiwgIlxcc2ltIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiqUiLCAiXFxwZXJwIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiqq8iLCAiXFxwcmVjZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKqsCIsICJcXHN1Y2NlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4omDIiwgIlxcc2ltZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKIoyIsICJcXG1pZCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4omqIiwgIlxcbGwiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKJqyIsICJcXGdnIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiY0iLCAiXFxhc3ltcCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oilIiwgIlxccGFyYWxsZWwiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKLiCIsICJcXGJvd3RpZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oyjIiwgIlxcc21pbGUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKKkSIsICJcXHNxc3Vic2V0ZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKKkiIsICJcXHNxc3Vwc2V0ZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKJkCIsICJcXGRvdGVxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLijKIiLCAiXFxmcm93biIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oiLIiwgIlxcbmkiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKInSIsICJcXHByb3B0byIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oqiIiwgIlxcdmRhc2giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKKoyIsICJcXGRhc2h2IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiIsiLCAiXFxvd25zIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBwdW5jdCwgIi4iLCAiXFxsZG90cCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsICLii4UiLCAiXFxjZG90cCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIiMiLCAiXFwjIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiIyIsICJcXCMiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICImIiwgIlxcJiIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIiYiLCAiXFwmIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oS1IiwgIlxcYWxlcGgiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiIAiLCAiXFxmb3JhbGwiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLihI8iLCAiXFxoYmFyIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oiDIiwgIlxcZXhpc3RzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oiHIiwgIlxcbmFibGEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLima0iLCAiXFxmbGF0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oSTIiwgIlxcZWxsIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4pmuIiwgIlxcbmF0dXJhbCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKZoyIsICJcXGNsdWJzdWl0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oSYIiwgIlxcd3AiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLima8iLCAiXFxzaGFycCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKZoiIsICJcXGRpYW1vbmRzdWl0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oScIiwgIlxcUmUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLimaEiLCAiXFxoZWFydHN1aXQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLihJEiLCAiXFxJbSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKZoCIsICJcXHNwYWRlc3VpdCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIsKnIiwgIlxcUyIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsKnIiwgIlxcUyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIsK2IiwgIlxcUCIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsK2IiwgIlxcUCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKAoCIsICJcXGRhZyIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIuKAoCIsICJcXGRhZyIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIuKAoCIsICJcXHRleHRkYWdnZXIiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLigKEiLCAiXFxkZGFnIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAi4oChIiwgIlxcZGRhZyIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIuKAoSIsICJcXHRleHRkYWdnZXJkYmwiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAi4o6xIiwgIlxccm1vdXN0YWNoZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgIuKOsCIsICJcXGxtb3VzdGFjaGUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAi4p+vIiwgIlxccmdyb3VwIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCAi4p+uIiwgIlxcbGdyb3VwIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLiiJMiLCAiXFxtcCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oqWIiwgIlxcb21pbnVzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLiio4iLCAiXFx1cGx1cyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oqTIiwgIlxcc3FjYXAiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKIlyIsICJcXGFzdCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oqUIiwgIlxcc3FjdXAiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKXryIsICJcXGJpZ2NpcmMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKImSIsICJcXGJ1bGxldCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oChIiwgIlxcZGRhZ2dlciIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4omAIiwgIlxcd3IiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKovyIsICJcXGFtYWxnIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICImIiwgIlxcQW5kIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLin7UiLCAiXFxsb25nbGVmdGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLih5AiLCAiXFxMZWZ0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKfuCIsICJcXExvbmdsZWZ0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKftiIsICJcXGxvbmdyaWdodGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLih5IiLCAiXFxSaWdodGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLin7kiLCAiXFxMb25ncmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oaUIiwgIlxcbGVmdHJpZ2h0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKftyIsICJcXGxvbmdsZWZ0cmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oeUIiwgIlxcTGVmdHJpZ2h0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKfuiIsICJcXExvbmdsZWZ0cmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oamIiwgIlxcbWFwc3RvIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLin7wiLCAiXFxsb25nbWFwc3RvIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLihpciLCAiXFxuZWFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLihqkiLCAiXFxob29rbGVmdGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLihqoiLCAiXFxob29rcmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oaYIiwgIlxcc2VhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oa8IiwgIlxcbGVmdGhhcnBvb251cCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oeAIiwgIlxccmlnaHRoYXJwb29udXAiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKGmSIsICJcXHN3YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKGvSIsICJcXGxlZnRoYXJwb29uZG93biIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oeBIiwgIlxccmlnaHRoYXJwb29uZG93biIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oaWIiwgIlxcbndhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oeMIiwgIlxccmlnaHRsZWZ0aGFycG9vbnMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omuIiwgIlxcbmxlc3MiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi7oCQIiwgIlxcQG5sZXFzbGFudCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugJEiLCAiXFxAbmxlcXEiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4qqHIiwgIlxcbG5lcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiagiLCAiXFxsbmVxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugIwiLCAiXFxAbHZlcnRuZXFxIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLpiIsICJcXGxuc2ltIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKqiSIsICJcXGxuYXBwcm94IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKgCIsICJcXG5wcmVjIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLoCIsICJcXG5wcmVjZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4ouoIiwgIlxccHJlY25zaW0iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4qq5IiwgIlxccHJlY25hcHByb3giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omBIiwgIlxcbnNpbSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugIYiLCAiXFxAbnNob3J0bWlkIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKIpCIsICJcXG5taWQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oqsIiwgIlxcbnZkYXNoIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKrSIsICJcXG52RGFzaCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLii6oiLCAiXFxudHJpYW5nbGVsZWZ0Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLrCIsICJcXG50cmlhbmdsZWxlZnRlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiooiLCAiXFxzdWJzZXRuZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi7oCaIiwgIlxcQHZhcnN1YnNldG5lcSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiq4siLCAiXFxzdWJzZXRuZXFxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIu6AlyIsICJcXEB2YXJzdWJzZXRuZXFxIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJryIsICJcXG5ndHIiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi7oCPIiwgIlxcQG5nZXFzbGFudCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugI4iLCAiXFxAbmdlcXEiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4qqIIiwgIlxcZ25lcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiakiLCAiXFxnbmVxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugI0iLCAiXFxAZ3ZlcnRuZXFxIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLpyIsICJcXGduc2ltIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKqiiIsICJcXGduYXBwcm94IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKgSIsICJcXG5zdWNjIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLoSIsICJcXG5zdWNjZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oupIiwgIlxcc3VjY25zaW0iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4qq6IiwgIlxcc3VjY25hcHByb3giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omGIiwgIlxcbmNvbmciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi7oCHIiwgIlxcQG5zaG9ydHBhcmFsbGVsIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKIpiIsICJcXG5wYXJhbGxlbCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiq8iLCAiXFxuVkRhc2giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4ourIiwgIlxcbnRyaWFuZ2xlcmlnaHQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4outIiwgIlxcbnRyaWFuZ2xlcmlnaHRlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugJgiLCAiXFxAbnN1cHNldGVxcSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiosiLCAiXFxzdXBzZXRuZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi7oCbIiwgIlxcQHZhcnN1cHNldG5lcSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiq4wiLCAiXFxzdXBzZXRuZXFxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIu6AmSIsICJcXEB2YXJzdXBzZXRuZXFxIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKriIsICJcXG5WZGFzaCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqrUiLCAiXFxwcmVjbmVxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqrYiLCAiXFxzdWNjbmVxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLugJYiLCAiXFxAbnN1YnNldGVxcSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiirQiLCAiXFx1bmxoZCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiirUiLCAiXFx1bnJoZCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihpoiLCAiXFxubGVmdGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKGmyIsICJcXG5yaWdodGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKHjSIsICJcXG5MZWZ0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oePIiwgIlxcblJpZ2h0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oauIiwgIlxcbmxlZnRyaWdodGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKHjiIsICJcXG5MZWZ0cmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLilrMiLCAiXFx2YXJ0cmlhbmdsZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4oSPIiwgIlxcaHNsYXNoIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLilr0iLCAiXFx0cmlhbmdsZWRvd24iKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKXiiIsICJcXGxvemVuZ2UiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKTiCIsICJcXGNpcmNsZWRTIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLCriIsICJcXGNpcmNsZWRSIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsICLCriIsICJcXGNpcmNsZWRSIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLiiKEiLCAiXFxtZWFzdXJlZGFuZ2xlIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLiiIQiLCAiXFxuZXhpc3RzIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLihKciLCAiXFxtaG8iKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKEsiIsICJcXEZpbnYiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKFgSIsICJcXEdhbWUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKAtSIsICJcXGJhY2twcmltZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4payIiwgIlxcYmxhY2t0cmlhbmdsZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4pa8IiwgIlxcYmxhY2t0cmlhbmdsZWRvd24iKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKWoCIsICJcXGJsYWNrc3F1YXJlIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLip6siLCAiXFxibGFja2xvemVuZ2UiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKYhSIsICJcXGJpZ3N0YXIiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKIoiIsICJcXHNwaGVyaWNhbGFuZ2xlIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLiiIEiLCAiXFxjb21wbGVtZW50IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLDsCIsICJcXGV0aCIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsOwIiwgIsOwIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLilbEiLCAiXFxkaWFndXAiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKVsiIsICJcXGRpYWdkb3duIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLilqEiLCAiXFxzcXVhcmUiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIuKWoSIsICJcXEJveCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4peKIiwgIlxcRGlhbW9uZCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAiwqUiLCAiXFx5ZW4iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgIsKlIiwgIlxceWVuIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLinJMiLCAiXFxjaGVja21hcmsiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgIuKckyIsICJcXGNoZWNrbWFyayIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4oS2IiwgIlxcYmV0aCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4oS4IiwgIlxcZGFsZXRoIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLihLciLCAiXFxnaW1lbCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAiz50iLCAiXFxkaWdhbW1hIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICLPsCIsICJcXHZhcmthcHBhIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIG9wZW4sICLilIwiLCAiXFxAdWxjb3JuZXIiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgY2xvc2UsICLilJAiLCAiXFxAdXJjb3JuZXIiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgb3BlbiwgIuKUlCIsICJcXEBsbGNvcm5lciIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBjbG9zZSwgIuKUmCIsICJcXEBscmNvcm5lciIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiaYiLCAiXFxsZXFxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKpvSIsICJcXGxlcXNsYW50IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKqlSIsICJcXGVxc2xhbnRsZXNzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJsiIsICJcXGxlc3NzaW0iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4qqFIiwgIlxcbGVzc2FwcHJveCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiYoiLCAiXFxhcHByb3hlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLii5YiLCAiXFxsZXNzZG90Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLmCIsICJcXGxsbCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiibYiLCAiXFxsZXNzZ3RyIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLmiIsICJcXGxlc3NlcWd0ciIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqosiLCAiXFxsZXNzZXFxZ3RyIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJkSIsICJcXGRvdGVxZG90Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJkyIsICJcXHJpc2luZ2RvdHNlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiZIiLCAiXFxmYWxsaW5nZG90c2VxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKIvSIsICJcXGJhY2tzaW0iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4ouNIiwgIlxcYmFja3NpbWVxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKrhSIsICJcXHN1YnNldGVxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLii5AiLCAiXFxTdWJzZXQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oqPIiwgIlxcc3FzdWJzZXQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4om8IiwgIlxccHJlY2N1cmx5ZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oueIiwgIlxcY3VybHllcXByZWMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4om+IiwgIlxccHJlY3NpbSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqrciLCAiXFxwcmVjYXBwcm94IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKsiIsICJcXHZhcnRyaWFuZ2xlbGVmdCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiirQiLCAiXFx0cmlhbmdsZWxlZnRlcSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiqgiLCAiXFx2RGFzaCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiqoiLCAiXFxWdmRhc2giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oyjIiwgIlxcc21hbGxzbWlsZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLijKIiLCAiXFxzbWFsbGZyb3duIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJjyIsICJcXGJ1bXBlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiY4iLCAiXFxCdW1wZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omnIiwgIlxcZ2VxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqb4iLCAiXFxnZXFzbGFudCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqpYiLCAiXFxlcXNsYW50Z3RyIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJsyIsICJcXGd0cnNpbSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqoYiLCAiXFxndHJhcHByb3giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCAi4ouXIiwgIlxcZ3RyZG90Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLmSIsICJcXGdnZyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiibciLCAiXFxndHJsZXNzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKLmyIsICJcXGd0cmVxbGVzcyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqowiLCAiXFxndHJlcXFsZXNzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJliIsICJcXGVxY2lyYyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiZciLCAiXFxjaXJjZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omcIiwgIlxcdHJpYW5nbGVxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKIvCIsICJcXHRoaWNrc2ltIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKJiCIsICJcXHRoaWNrYXBwcm94Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKrhiIsICJcXHN1cHNldGVxcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLii5EiLCAiXFxTdXBzZXQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oqQIiwgIlxcc3FzdXBzZXQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4om9IiwgIlxcc3VjY2N1cmx5ZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oufIiwgIlxcY3VybHllcXN1Y2MiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4om/IiwgIlxcc3VjY3NpbSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiqrgiLCAiXFxzdWNjYXBwcm94IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKsyIsICJcXHZhcnRyaWFuZ2xlcmlnaHQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oq1IiwgIlxcdHJpYW5nbGVyaWdodGVxIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKqSIsICJcXFZkYXNoIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKIoyIsICJcXHNob3J0bWlkIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKIpSIsICJcXHNob3J0cGFyYWxsZWwiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omsIiwgIlxcYmV0d2VlbiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLii5QiLCAiXFxwaXRjaGZvcmsiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oidIiwgIlxcdmFycHJvcHRvIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKXgCIsICJcXGJsYWNrdHJpYW5nbGVsZWZ0Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKItCIsICJcXHRoZXJlZm9yZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiI0iLCAiXFxiYWNrZXBzaWxvbiIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLilrYiLCAiXFxibGFja3RyaWFuZ2xlcmlnaHQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oi1IiwgIlxcYmVjYXVzZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLii5giLCAiXFxsbGxlc3MiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4ouZIiwgIlxcZ2dndHIiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCAi4oqyIiwgIlxcbGhkIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKKsyIsICJcXHJoZCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiYIiLCAiXFxlcXNpbSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4ouIIiwgIlxcSm9pbiIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiiZEiLCAiXFxEb3RlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiiJQiLCAiXFxkb3RwbHVzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKIliIsICJcXHNtYWxsc2V0bWludXMiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCAi4ouSIiwgIlxcQ2FwIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKLkyIsICJcXEN1cCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiqZ4iLCAiXFxkb3VibGViYXJ3ZWRnZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiip8iLCAiXFxib3htaW51cyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiip4iLCAiXFxib3hwbHVzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKLhyIsICJcXGRpdmlkZW9udGltZXMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCAi4ouJIiwgIlxcbHRpbWVzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKLiiIsICJcXHJ0aW1lcyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLii4siLCAiXFxsZWZ0dGhyZWV0aW1lcyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLii4wiLCAiXFxyaWdodHRocmVldGltZXMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCAi4ouPIiwgIlxcY3VybHl3ZWRnZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLii44iLCAiXFxjdXJseXZlZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiip0iLCAiXFxjaXJjbGVkZGFzaCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiipsiLCAiXFxjaXJjbGVkYXN0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKLhSIsICJcXGNlbnRlcmRvdCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiiroiLCAiXFxpbnRlcmNhbCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLii5IiLCAiXFxkb3VibGVjYXAiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgYmluLCAi4ouTIiwgIlxcZG91YmxlY3VwIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKKoCIsICJcXGJveHRpbWVzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKHoiIsICJcXGRhc2hyaWdodGFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKHoCIsICJcXGRhc2hsZWZ0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oeHIiwgIlxcbGVmdGxlZnRhcnJvd3MiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oeGIiwgIlxcbGVmdHJpZ2h0YXJyb3dzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKHmiIsICJcXExsZWZ0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oaeIiwgIlxcdHdvaGVhZGxlZnRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihqIiLCAiXFxsZWZ0YXJyb3d0YWlsIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKGqyIsICJcXGxvb3BhcnJvd2xlZnQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oeLIiwgIlxcbGVmdHJpZ2h0aGFycG9vbnMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oa2IiwgIlxcY3VydmVhcnJvd2xlZnQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oa6IiwgIlxcY2lyY2xlYXJyb3dsZWZ0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKGsCIsICJcXExzaCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLih4giLCAiXFx1cHVwYXJyb3dzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKGvyIsICJcXHVwaGFycG9vbmxlZnQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oeDIiwgIlxcZG93bmhhcnBvb25sZWZ0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiirYiLCAiXFxvcmlnb2YiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKKtyIsICJcXGltYWdlb2YiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oq4IiwgIlxcbXVsdGltYXAiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oatIiwgIlxcbGVmdHJpZ2h0c3F1aWdhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLih4kiLCAiXFxyaWdodHJpZ2h0YXJyb3dzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKHhCIsICJcXHJpZ2h0bGVmdGFycm93cyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihqAiLCAiXFx0d29oZWFkcmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihqMiLCAiXFxyaWdodGFycm93dGFpbCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihqwiLCAiXFxsb29wYXJyb3dyaWdodCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihrciLCAiXFxjdXJ2ZWFycm93cmlnaHQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oa7IiwgIlxcY2lyY2xlYXJyb3dyaWdodCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihrEiLCAiXFxSc2giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oeKIiwgIlxcZG93bmRvd25hcnJvd3MiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oa+IiwgIlxcdXBoYXJwb29ucmlnaHQiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oeCIiwgIlxcZG93bmhhcnBvb25yaWdodCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLih50iLCAiXFxyaWdodHNxdWlnYXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oedIiwgIlxcbGVhZHN0byIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLih5siLCAiXFxScmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLihr4iLCAiXFxyZXN0cmljdGlvbiIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKAmCIsICJgIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiJCIsICJcXCQiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICIkIiwgIlxcJCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIiQiLCAiXFx0ZXh0ZG9sbGFyIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiJSIsICJcXCUiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICIlIiwgIlxcJSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIl8iLCAiXFxfIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiXyIsICJcXF8iKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICJfIiwgIlxcdGV4dHVuZGVyc2NvcmUiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiKAiLCAiXFxhbmdsZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKIniIsICJcXGluZnR5IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oCyIiwgIlxccHJpbWUiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLilrMiLCAiXFx0cmlhbmdsZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIs6TIiwgIlxcR2FtbWEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLOlCIsICJcXERlbHRhIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAizpgiLCAiXFxUaGV0YSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIs6bIiwgIlxcTGFtYmRhIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAizp4iLCAiXFxYaSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIs6gIiwgIlxcUGkiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLOoyIsICJcXFNpZ21hIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAizqUiLCAiXFxVcHNpbG9uIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAizqYiLCAiXFxQaGkiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLOqCIsICJcXFBzaSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIs6pIiwgIlxcT21lZ2EiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICJBIiwgIs6RIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiQiIsICLOkiIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIkUiLCAizpUiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICJaIiwgIs6WIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiSCIsICLOlyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIkkiLCAizpkiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICJLIiwgIs6aIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiTSIsICLOnCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIk4iLCAizp0iKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICJPIiwgIs6fIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiUCIsICLOoSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIlQiLCAizqQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICJYIiwgIs6nIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiwqwiLCAiXFxuZWciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLCrCIsICJcXGxub3QiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiqQiLCAiXFx0b3AiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiqUiLCAiXFxib3QiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiIUiLCAiXFxlbXB0eXNldCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4oiFIiwgIlxcdmFybm90aGluZyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs6xIiwgIlxcYWxwaGEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLOsiIsICJcXGJldGEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLOsyIsICJcXGdhbW1hIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAizrQiLCAiXFxkZWx0YSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+1IiwgIlxcZXBzaWxvbiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs62IiwgIlxcemV0YSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs63IiwgIlxcZXRhIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAizrgiLCAiXFx0aGV0YSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs65IiwgIlxcaW90YSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs66IiwgIlxca2FwcGEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLOuyIsICJcXGxhbWJkYSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs68IiwgIlxcbXUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLOvSIsICJcXG51IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAizr4iLCAiXFx4aSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs6/IiwgIlxcb21pY3JvbiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+AIiwgIlxccGkiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLPgSIsICJcXHJobyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+DIiwgIlxcc2lnbWEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLPhCIsICJcXHRhdSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+FIiwgIlxcdXBzaWxvbiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+VIiwgIlxccGhpIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAiz4ciLCAiXFxjaGkiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLPiCIsICJcXHBzaSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+JIiwgIlxcb21lZ2EiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLOtSIsICJcXHZhcmVwc2lsb24iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICLPkSIsICJcXHZhcnRoZXRhIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAiz5YiLCAiXFx2YXJwaSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+xIiwgIlxcdmFycmhvIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAiz4IiLCAiXFx2YXJzaWdtYSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgIs+GIiwgIlxcdmFycGhpIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLiiJciLCAiKiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAiKyIsICIrIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLiiJIiLCAiLSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4ouFIiwgIlxcY2RvdCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oiYIiwgIlxcY2lyYyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAiw7ciLCAiXFxkaXYiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIsKxIiwgIlxccG0iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIsOXIiwgIlxcdGltZXMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKIqSIsICJcXGNhcCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oiqIiwgIlxcY3VwIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLiiJYiLCAiXFxzZXRtaW51cyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oinIiwgIlxcbGFuZCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oioIiwgIlxcbG9yIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLiiKciLCAiXFx3ZWRnZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oioIiwgIlxcdmVlIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4oiaIiwgIlxcc3VyZCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgIuKfqCIsICJcXGxhbmdsZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgIuKIoyIsICJcXGx2ZXJ0Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCAi4oilIiwgIlxcbFZlcnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAiPyIsICI/Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgIiEiLCAiISIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsICLin6kiLCAiXFxyYW5nbGUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAi4oijIiwgIlxccnZlcnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAi4oilIiwgIlxcclZlcnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIj0iLCAiPSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAiOiIsICI6Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiYgiLCAiXFxhcHByb3giLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKJhSIsICJcXGNvbmciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKJpSIsICJcXGdlIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiaUiLCAiXFxnZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKGkCIsICJcXGdldHMiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIj4iLCAiXFxndCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oiIIiwgIlxcaW4iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIu6AoCIsICJcXEBub3QiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKKgiIsICJcXHN1YnNldCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oqDIiwgIlxcc3Vwc2V0IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiioYiLCAiXFxzdWJzZXRlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oqHIiwgIlxcc3Vwc2V0ZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4oqIIiwgIlxcbnN1YnNldGVxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHJlbCwgIuKKiSIsICJcXG5zdXBzZXRlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oqoIiwgIlxcbW9kZWxzIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLihpAiLCAiXFxsZWZ0YXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKJpCIsICJcXGxlIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLiiaQiLCAiXFxsZXEiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIjwiLCAiXFxsdCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oaSIiwgIlxccmlnaHRhcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oaSIiwgIlxcdG8iKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgcmVsLCAi4omxIiwgIlxcbmdlcSIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCByZWwsICLiibAiLCAiXFxubGVxIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCAiwqAiLCAiXFwgIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBzcGFjaW5nLCAiwqAiLCAiXFxzcGFjZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgIsKgIiwgIlxcbm9icmVha3NwYWNlIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCAiwqAiLCAiXFwgIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBzcGFjaW5nLCAiwqAiLCAiICIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgc3BhY2luZywgIsKgIiwgIlxcc3BhY2UiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHNwYWNpbmcsICLCoCIsICJcXG5vYnJlYWtzcGFjZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgIlxcbm9icmVhayIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgc3BhY2luZywgbnVsbCwgIlxcYWxsb3dicmVhayIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcHVuY3QsICIsIiwgIiwiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHB1bmN0LCAiOyIsICI7Iik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKKvCIsICJcXGJhcndlZGdlIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIGJpbiwgIuKKuyIsICJcXHZlZWJhciIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oqZIiwgIlxcb2RvdCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oqVIiwgIlxcb3BsdXMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKKlyIsICJcXG90aW1lcyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKIgiIsICJcXHBhcnRpYWwiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKKmCIsICJcXG9zbGFzaCIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiipoiLCAiXFxjaXJjbGVkY2lyYyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCBiaW4sICLiiqEiLCAiXFxib3hkb3QiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKWsyIsICJcXGJpZ3RyaWFuZ2xldXAiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKWvSIsICJcXGJpZ3RyaWFuZ2xlZG93biIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYmluLCAi4oCgIiwgIlxcZGFnZ2VyIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLii4QiLCAiXFxkaWFtb25kIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLii4YiLCAiXFxzdGFyIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBiaW4sICLil4MiLCAiXFx0cmlhbmdsZWxlZnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGJpbiwgIuKWuSIsICJcXHRyaWFuZ2xlcmlnaHQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wZW4sICJ7IiwgIlxceyIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgInsiLCAiXFx7Iik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAieyIsICJcXHRleHRicmFjZWxlZnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAifSIsICJcXH0iKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICJ9IiwgIlxcfSIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIn0iLCAiXFx0ZXh0YnJhY2VyaWdodCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgInsiLCAiXFxsYnJhY2UiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGNsb3NlLCAifSIsICJcXHJicmFjZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgIlsiLCAiXFxsYnJhY2siLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICJbIiwgIlxcbGJyYWNrIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgIl0iLCAiXFxyYnJhY2siLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICJdIiwgIlxccmJyYWNrIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCAiKCIsICJcXGxwYXJlbiIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgY2xvc2UsICIpIiwgIlxccnBhcmVuIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiPCIsICJcXHRleHRsZXNzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiPiIsICJcXHRleHRncmVhdGVyIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcGVuLCAi4oyKIiwgIlxcbGZsb29yIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgIuKMiyIsICJcXHJmbG9vciIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3BlbiwgIuKMiCIsICJcXGxjZWlsIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBjbG9zZSwgIuKMiSIsICJcXHJjZWlsIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAiXFwiLCAiXFxiYWNrc2xhc2giKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiKMiLCAifCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKIoyIsICJcXHZlcnQiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICJ8IiwgIlxcdGV4dGJhciIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIuKIpSIsICJcXHwiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLiiKUiLCAiXFxWZXJ0Iik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAi4oilIiwgIlxcdGV4dGJhcmRibCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIn4iLCAiXFx0ZXh0YXNjaWl0aWxkZSIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIlxcIiwgIlxcdGV4dGJhY2tzbGFzaCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIl4iLCAiXFx0ZXh0YXNjaWljaXJjdW0iKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKGkSIsICJcXHVwYXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKHkSIsICJcXFVwYXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHJlbCwgIuKGkyIsICJcXGRvd25hcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oeTIiwgIlxcRG93bmFycm93IiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCByZWwsICLihpUiLCAiXFx1cGRvd25hcnJvdyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgcmVsLCAi4oeVIiwgIlxcVXBkb3duYXJyb3ciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCAi4oiQIiwgIlxcY29wcm9kIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKLgSIsICJcXGJpZ3ZlZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLii4AiLCAiXFxiaWd3ZWRnZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLiqIQiLCAiXFxiaWd1cGx1cyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLii4IiLCAiXFxiaWdjYXAiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCAi4ouDIiwgIlxcYmlnY3VwIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKIqyIsICJcXGludCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLiiKsiLCAiXFxpbnRvcCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLiiKwiLCAiXFxpaW50Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKIrSIsICJcXGlpaW50Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKIjyIsICJcXHByb2QiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCAi4oiRIiwgIlxcc3VtIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKogiIsICJcXGJpZ290aW1lcyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLiqIEiLCAiXFxiaWdvcGx1cyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgb3AsICLiqIAiLCAiXFxiaWdvZG90Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKIriIsICJcXG9pbnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCAi4oivIiwgIlxcb2lpbnQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG9wLCAi4oiwIiwgIlxcb2lpaW50Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKohiIsICJcXGJpZ3NxY3VwIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBvcCwgIuKIqyIsICJcXHNtYWxsaW50Iik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBpbm5lciwgIuKApiIsICJcXHRleHRlbGxpcHNpcyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgaW5uZXIsICLigKYiLCAiXFxtYXRoZWxsaXBzaXMiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGlubmVyLCAi4oCmIiwgIlxcbGRvdHMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCAi4oCmIiwgIlxcbGRvdHMiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGlubmVyLCAi4ouvIiwgIlxcQGNkb3RzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBpbm5lciwgIuKLsSIsICJcXGRkb3RzIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAi4ouuIiwgIlxcdmFydmRvdHMiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLii64iLCAiXFx2YXJ2ZG90cyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCAiy4oiLCAiXFxhY3V0ZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCAiy4siLCAiXFxncmF2ZSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgYWNjZW50LCAiwqgiLCAiXFxkZG90Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsICJ+IiwgIlxcdGlsZGUiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgIsuJIiwgIlxcYmFyIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsICLLmCIsICJcXGJyZXZlIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsICLLhyIsICJcXGNoZWNrIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsICJeIiwgIlxcaGF0Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsICLig5ciLCAiXFx2ZWMiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIGFjY2VudCwgIsuZIiwgIlxcZG90Iik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBhY2NlbnQsICLLmiIsICJcXG1hdGhyaW5nIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAi7oSxIiwgIlxcQGltYXRoIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCAi7oi3IiwgIlxcQGptYXRoIik7CmRlZmluZVN5bWJvbChtYXRoLCBtYWluLCB0ZXh0b3JkLCAixLEiLCAixLEiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLItyIsICLItyIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsSxIiwgIlxcaSIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsi3IiwgIlxcaiIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsOfIiwgIlxcc3MiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLDpiIsICJcXGFlIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAixZMiLCAiXFxvZSIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsO4IiwgIlxcbyIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIsOGIiwgIlxcQUUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLFkiIsICJcXE9FIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiw5giLCAiXFxPIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsICLLiiIsICJcXCciKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgIsuLIiwgIlxcYCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCAiy4YiLCAiXFxeIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsICLLnCIsICJcXH4iKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgIsuJIiwgIlxcPSIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCAiy5giLCAiXFx1Iik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsICLLmSIsICJcXC4iKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgIsK4IiwgIlxcYyIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCAiy5oiLCAiXFxyIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsICLLhyIsICJcXHYiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIGFjY2VudCwgIsKoIiwgJ1xcIicpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgYWNjZW50LCAiy50iLCAiXFxIIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCBhY2NlbnQsICLil68iLCAiXFx0ZXh0Y2lyY2xlZCIpOwp2YXIgbGlnYXR1cmVzID0gewogICItLSI6IHRydWUsCiAgIi0tLSI6IHRydWUsCiAgImBgIjogdHJ1ZSwKICAiJyciOiB0cnVlCn07CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAi4oCTIiwgIi0tIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAi4oCTIiwgIlxcdGV4dGVuZGFzaCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIuKAlCIsICItLS0iLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLigJQiLCAiXFx0ZXh0ZW1kYXNoIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAi4oCYIiwgImAiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLigJgiLCAiXFx0ZXh0cXVvdGVsZWZ0Iik7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAi4oCZIiwgIiciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLigJkiLCAiXFx0ZXh0cXVvdGVyaWdodCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIuKAnCIsICJgYCIsIHRydWUpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgIuKAnCIsICJcXHRleHRxdW90ZWRibGxlZnQiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLigJ0iLCAiJyciLCB0cnVlKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLigJ0iLCAiXFx0ZXh0cXVvdGVkYmxyaWdodCIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIsKwIiwgIlxcZGVncmVlIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiwrAiLCAiXFxkZWdyZWUiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLCsCIsICJcXHRleHRkZWdyZWUiLCB0cnVlKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIHRleHRvcmQsICLCoyIsICJcXHBvdW5kcyIpOwpkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgIsKjIiwgIlxcbWF0aHN0ZXJsaW5nIiwgdHJ1ZSk7CmRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCAiwqMiLCAiXFxwb3VuZHMiKTsKZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsICLCoyIsICJcXHRleHRzdGVybGluZyIsIHRydWUpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAi4pygIiwgIlxcbWFsdGVzZSIpOwpkZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCAi4pygIiwgIlxcbWFsdGVzZSIpOwp2YXIgbWF0aFRleHRTeW1ib2xzID0gJzAxMjM0NTY3ODkvQC4iJzsKZm9yIChpID0gMDsgaSA8IG1hdGhUZXh0U3ltYm9scy5sZW5ndGg7IGkrKykgewogIGNoID0gbWF0aFRleHRTeW1ib2xzLmNoYXJBdChpKTsKICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgdGV4dG9yZCwgY2gsIGNoKTsKfQp2YXIgY2g7CnZhciBpOwp2YXIgdGV4dFN5bWJvbHMgPSAnMDEyMzQ1Njc4OSFAKigpLT0rIjs6Py8uLCc7CmZvciAoX2kgPSAwOyBfaSA8IHRleHRTeW1ib2xzLmxlbmd0aDsgX2krKykgewogIF9jaCA9IHRleHRTeW1ib2xzLmNoYXJBdChfaSk7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaCwgX2NoKTsKfQp2YXIgX2NoOwp2YXIgX2k7CnZhciBsZXR0ZXJzID0gIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoiOwpmb3IgKF9pMiA9IDA7IF9pMiA8IGxldHRlcnMubGVuZ3RoOyBfaTIrKykgewogIF9jaDIgPSBsZXR0ZXJzLmNoYXJBdChfaTIpOwogIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gyLCBfY2gyKTsKICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMiwgX2NoMik7Cn0KdmFyIF9jaDI7CnZhciBfaTI7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICJDIiwgIuKEgiIpOwpkZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCAiQyIsICLihIIiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIkgiLCAi4oSNIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsICJIIiwgIuKEjSIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAiTiIsICLihJUiKTsKZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgIk4iLCAi4oSVIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICJQIiwgIuKEmSIpOwpkZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCAiUCIsICLihJkiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIGFtcywgdGV4dG9yZCwgIlEiLCAi4oSaIik7CmRlZmluZVN5bWJvbCh0ZXh0LCBhbXMsIHRleHRvcmQsICJRIiwgIuKEmiIpOwpkZWZpbmVTeW1ib2wobWF0aCwgYW1zLCB0ZXh0b3JkLCAiUiIsICLihJ0iKTsKZGVmaW5lU3ltYm9sKHRleHQsIGFtcywgdGV4dG9yZCwgIlIiLCAi4oSdIik7CmRlZmluZVN5bWJvbChtYXRoLCBhbXMsIHRleHRvcmQsICJaIiwgIuKEpCIpOwpkZWZpbmVTeW1ib2wodGV4dCwgYW1zLCB0ZXh0b3JkLCAiWiIsICLihKQiKTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICJoIiwgIuKEjiIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgbWF0aG9yZCwgImgiLCAi4oSOIik7CnZhciB3aWRlQ2hhciA9ICIiOwpmb3IgKF9pMyA9IDA7IF9pMyA8IGxldHRlcnMubGVuZ3RoOyBfaTMrKykgewogIF9jaDMgPSBsZXR0ZXJzLmNoYXJBdChfaTMpOwogIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTM0OSwgNTYzMjAgKyBfaTMpOwogIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUzNDksIDU2MzcyICsgX2kzKTsKICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpOwogIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1MzQ5LCA1NjQyNCArIF9pMyk7CiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpOwogIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTM0OSwgNTY1ODAgKyBfaTMpOwogIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUzNDksIDU2Njg0ICsgX2kzKTsKICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpOwogIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1MzQ5LCA1NjczNiArIF9pMyk7CiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpOwogIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTM0OSwgNTY3ODggKyBfaTMpOwogIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUzNDksIDU2ODQwICsgX2kzKTsKICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpOwogIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1MzQ5LCA1Njk0NCArIF9pMyk7CiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoMywgd2lkZUNoYXIpOwogIGlmIChfaTMgPCAyNikgewogICAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1MzQ5LCA1NjYzMiArIF9pMyk7CiAgICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoMywgd2lkZUNoYXIpOwogICAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICAgIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTM0OSwgNTY0NzYgKyBfaTMpOwogICAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDMsIHdpZGVDaGFyKTsKICAgIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2gzLCB3aWRlQ2hhcik7CiAgfQp9CnZhciBfY2gzOwp2YXIgX2kzOwp3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUzNDksIDU2NjY4KTsKZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsICJrIiwgd2lkZUNoYXIpOwpkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgImsiLCB3aWRlQ2hhcik7CmZvciAoX2k0ID0gMDsgX2k0IDwgMTA7IF9pNCsrKSB7CiAgX2NoNCA9IF9pNC50b1N0cmluZygpOwogIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTM0OSwgNTcyOTQgKyBfaTQpOwogIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2g0LCB3aWRlQ2hhcik7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDQsIHdpZGVDaGFyKTsKICB3aWRlQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUzNDksIDU3MzE0ICsgX2k0KTsKICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNCwgd2lkZUNoYXIpOwogIGRlZmluZVN5bWJvbCh0ZXh0LCBtYWluLCB0ZXh0b3JkLCBfY2g0LCB3aWRlQ2hhcik7CiAgd2lkZUNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1MzQ5LCA1NzMyNCArIF9pNCk7CiAgZGVmaW5lU3ltYm9sKG1hdGgsIG1haW4sIG1hdGhvcmQsIF9jaDQsIHdpZGVDaGFyKTsKICBkZWZpbmVTeW1ib2wodGV4dCwgbWFpbiwgdGV4dG9yZCwgX2NoNCwgd2lkZUNoYXIpOwogIHdpZGVDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZSg1NTM0OSwgNTczMzQgKyBfaTQpOwogIGRlZmluZVN5bWJvbChtYXRoLCBtYWluLCBtYXRob3JkLCBfY2g0LCB3aWRlQ2hhcik7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDQsIHdpZGVDaGFyKTsKfQp2YXIgX2NoNDsKdmFyIF9pNDsKdmFyIGV4dHJhTGF0aW4gPSAiw5DDnsO+IjsKZm9yIChfaTUgPSAwOyBfaTUgPCBleHRyYUxhdGluLmxlbmd0aDsgX2k1KyspIHsKICBfY2g1ID0gZXh0cmFMYXRpbi5jaGFyQXQoX2k1KTsKICBkZWZpbmVTeW1ib2wobWF0aCwgbWFpbiwgbWF0aG9yZCwgX2NoNSwgX2NoNSk7CiAgZGVmaW5lU3ltYm9sKHRleHQsIG1haW4sIHRleHRvcmQsIF9jaDUsIF9jaDUpOwp9CnZhciBfY2g1Owp2YXIgX2k1Owp2YXIgd2lkZUxhdGluTGV0dGVyRGF0YSA9IFsKICBbIm1hdGhiZiIsICJ0ZXh0YmYiLCAiTWFpbi1Cb2xkIl0sCiAgLy8gQS1aIGJvbGQgdXByaWdodAogIFsibWF0aGJmIiwgInRleHRiZiIsICJNYWluLUJvbGQiXSwKICAvLyBhLXogYm9sZCB1cHJpZ2h0CiAgWyJtYXRobm9ybWFsIiwgInRleHRpdCIsICJNYXRoLUl0YWxpYyJdLAogIC8vIEEtWiBpdGFsaWMKICBbIm1hdGhub3JtYWwiLCAidGV4dGl0IiwgIk1hdGgtSXRhbGljIl0sCiAgLy8gYS16IGl0YWxpYwogIFsiYm9sZHN5bWJvbCIsICJib2xkc3ltYm9sIiwgIk1haW4tQm9sZEl0YWxpYyJdLAogIC8vIEEtWiBib2xkIGl0YWxpYwogIFsiYm9sZHN5bWJvbCIsICJib2xkc3ltYm9sIiwgIk1haW4tQm9sZEl0YWxpYyJdLAogIC8vIGEteiBib2xkIGl0YWxpYwogIC8vIE1hcCBmYW5jeSBBLVogbGV0dGVycyB0byBzY3JpcHQsIG5vdCBjYWxsaWdyYXBoaWMuCiAgLy8gVGhpcyBhbGlnbnMgd2l0aCB1bmljb2RlLW1hdGggYW5kIG1hdGggZm9udHMgKGV4Y2VwdCBDYW1icmlhIE1hdGgpLgogIFsibWF0aHNjciIsICJ0ZXh0c2NyIiwgIlNjcmlwdC1SZWd1bGFyIl0sCiAgLy8gQS1aIHNjcmlwdAogIFsiIiwgIiIsICIiXSwKICAvLyBhLXogc2NyaXB0LiAgTm8gZm9udAogIFsiIiwgIiIsICIiXSwKICAvLyBBLVogYm9sZCBzY3JpcHQuIE5vIGZvbnQKICBbIiIsICIiLCAiIl0sCiAgLy8gYS16IGJvbGQgc2NyaXB0LiBObyBmb250CiAgWyJtYXRoZnJhayIsICJ0ZXh0ZnJhayIsICJGcmFrdHVyLVJlZ3VsYXIiXSwKICAvLyBBLVogRnJha3R1cgogIFsibWF0aGZyYWsiLCAidGV4dGZyYWsiLCAiRnJha3R1ci1SZWd1bGFyIl0sCiAgLy8gYS16IEZyYWt0dXIKICBbIm1hdGhiYiIsICJ0ZXh0YmIiLCAiQU1TLVJlZ3VsYXIiXSwKICAvLyBBLVogZG91YmxlLXN0cnVjawogIFsibWF0aGJiIiwgInRleHRiYiIsICJBTVMtUmVndWxhciJdLAogIC8vIGsgZG91YmxlLXN0cnVjawogIC8vIE5vdGUgdGhhdCB3ZSBhcmUgdXNpbmcgYSBib2xkIGZvbnQsIGJ1dCBmb250IG1ldHJpY3MgZm9yIHJlZ3VsYXIgRnJha3R1ci4KICBbIm1hdGhib2xkZnJhayIsICJ0ZXh0Ym9sZGZyYWsiLCAiRnJha3R1ci1SZWd1bGFyIl0sCiAgLy8gQS1aIGJvbGQgRnJha3R1cgogIFsibWF0aGJvbGRmcmFrIiwgInRleHRib2xkZnJhayIsICJGcmFrdHVyLVJlZ3VsYXIiXSwKICAvLyBhLXogYm9sZCBGcmFrdHVyCiAgWyJtYXRoc2YiLCAidGV4dHNmIiwgIlNhbnNTZXJpZi1SZWd1bGFyIl0sCiAgLy8gQS1aIHNhbnMtc2VyaWYKICBbIm1hdGhzZiIsICJ0ZXh0c2YiLCAiU2Fuc1NlcmlmLVJlZ3VsYXIiXSwKICAvLyBhLXogc2Fucy1zZXJpZgogIFsibWF0aGJvbGRzZiIsICJ0ZXh0Ym9sZHNmIiwgIlNhbnNTZXJpZi1Cb2xkIl0sCiAgLy8gQS1aIGJvbGQgc2Fucy1zZXJpZgogIFsibWF0aGJvbGRzZiIsICJ0ZXh0Ym9sZHNmIiwgIlNhbnNTZXJpZi1Cb2xkIl0sCiAgLy8gYS16IGJvbGQgc2Fucy1zZXJpZgogIFsibWF0aGl0c2YiLCAidGV4dGl0c2YiLCAiU2Fuc1NlcmlmLUl0YWxpYyJdLAogIC8vIEEtWiBpdGFsaWMgc2Fucy1zZXJpZgogIFsibWF0aGl0c2YiLCAidGV4dGl0c2YiLCAiU2Fuc1NlcmlmLUl0YWxpYyJdLAogIC8vIGEteiBpdGFsaWMgc2Fucy1zZXJpZgogIFsiIiwgIiIsICIiXSwKICAvLyBBLVogYm9sZCBpdGFsaWMgc2Fucy4gTm8gZm9udAogIFsiIiwgIiIsICIiXSwKICAvLyBhLXogYm9sZCBpdGFsaWMgc2Fucy4gTm8gZm9udAogIFsibWF0aHR0IiwgInRleHR0dCIsICJUeXBld3JpdGVyLVJlZ3VsYXIiXSwKICAvLyBBLVogbW9ub3NwYWNlCiAgWyJtYXRodHQiLCAidGV4dHR0IiwgIlR5cGV3cml0ZXItUmVndWxhciJdCiAgLy8gYS16IG1vbm9zcGFjZQpdOwp2YXIgd2lkZU51bWVyYWxEYXRhID0gWwogIFsibWF0aGJmIiwgInRleHRiZiIsICJNYWluLUJvbGQiXSwKICAvLyAwLTkgYm9sZAogIFsiIiwgIiIsICIiXSwKICAvLyAwLTkgZG91YmxlLXN0cnVjay4gTm8gS2FUZVggZm9udC4KICBbIm1hdGhzZiIsICJ0ZXh0c2YiLCAiU2Fuc1NlcmlmLVJlZ3VsYXIiXSwKICAvLyAwLTkgc2Fucy1zZXJpZgogIFsibWF0aGJvbGRzZiIsICJ0ZXh0Ym9sZHNmIiwgIlNhbnNTZXJpZi1Cb2xkIl0sCiAgLy8gMC05IGJvbGQgc2Fucy1zZXJpZgogIFsibWF0aHR0IiwgInRleHR0dCIsICJUeXBld3JpdGVyLVJlZ3VsYXIiXQogIC8vIDAtOSBtb25vc3BhY2UKXTsKdmFyIHdpZGVDaGFyYWN0ZXJGb250ID0gZnVuY3Rpb24gd2lkZUNoYXJhY3RlckZvbnQyKHdpZGVDaGFyMiwgbW9kZSkgewogIHZhciBIID0gd2lkZUNoYXIyLmNoYXJDb2RlQXQoMCk7CiAgdmFyIEwgPSB3aWRlQ2hhcjIuY2hhckNvZGVBdCgxKTsKICB2YXIgY29kZVBvaW50ID0gKEggLSA1NTI5NikgKiAxMDI0ICsgKEwgLSA1NjMyMCkgKyA2NTUzNjsKICB2YXIgaiA9IG1vZGUgPT09ICJtYXRoIiA/IDAgOiAxOwogIGlmICgxMTk4MDggPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8IDEyMDQ4NCkgewogICAgdmFyIGkgPSBNYXRoLmZsb29yKChjb2RlUG9pbnQgLSAxMTk4MDgpIC8gMjYpOwogICAgcmV0dXJuIFt3aWRlTGF0aW5MZXR0ZXJEYXRhW2ldWzJdLCB3aWRlTGF0aW5MZXR0ZXJEYXRhW2ldW2pdXTsKICB9IGVsc2UgaWYgKDEyMDc4MiA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDEyMDgzMSkgewogICAgdmFyIF9pID0gTWF0aC5mbG9vcigoY29kZVBvaW50IC0gMTIwNzgyKSAvIDEwKTsKICAgIHJldHVybiBbd2lkZU51bWVyYWxEYXRhW19pXVsyXSwgd2lkZU51bWVyYWxEYXRhW19pXVtqXV07CiAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPT09IDEyMDQ4NSB8fCBjb2RlUG9pbnQgPT09IDEyMDQ4NikgewogICAgcmV0dXJuIFt3aWRlTGF0aW5MZXR0ZXJEYXRhWzBdWzJdLCB3aWRlTGF0aW5MZXR0ZXJEYXRhWzBdW2pdXTsKICB9IGVsc2UgaWYgKDEyMDQ4NiA8IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPCAxMjA3ODIpIHsKICAgIHJldHVybiBbIiIsICIiXTsKICB9IGVsc2UgewogICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVuc3VwcG9ydGVkIGNoYXJhY3RlcjogIiArIHdpZGVDaGFyMik7CiAgfQp9Owp2YXIgbG9va3VwU3ltYm9sID0gZnVuY3Rpb24gbG9va3VwU3ltYm9sMih2YWx1ZSwgZm9udE5hbWUsIG1vZGUpIHsKICBpZiAoc3ltYm9sc1ttb2RlXVt2YWx1ZV0gJiYgc3ltYm9sc1ttb2RlXVt2YWx1ZV0ucmVwbGFjZSkgewogICAgdmFsdWUgPSBzeW1ib2xzW21vZGVdW3ZhbHVlXS5yZXBsYWNlOwogIH0KICByZXR1cm4gewogICAgdmFsdWUsCiAgICBtZXRyaWNzOiBnZXRDaGFyYWN0ZXJNZXRyaWNzKHZhbHVlLCBmb250TmFtZSwgbW9kZSkKICB9Owp9Owp2YXIgbWFrZVN5bWJvbCA9IGZ1bmN0aW9uIG1ha2VTeW1ib2wyKHZhbHVlLCBmb250TmFtZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcykgewogIHZhciBsb29rdXAgPSBsb29rdXBTeW1ib2wodmFsdWUsIGZvbnROYW1lLCBtb2RlKTsKICB2YXIgbWV0cmljcyA9IGxvb2t1cC5tZXRyaWNzOwogIHZhbHVlID0gbG9va3VwLnZhbHVlOwogIHZhciBzeW1ib2xOb2RlOwogIGlmIChtZXRyaWNzKSB7CiAgICB2YXIgaXRhbGljID0gbWV0cmljcy5pdGFsaWM7CiAgICBpZiAobW9kZSA9PT0gInRleHQiIHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5mb250ID09PSAibWF0aGl0IikgewogICAgICBpdGFsaWMgPSAwOwogICAgfQogICAgc3ltYm9sTm9kZSA9IG5ldyBTeW1ib2xOb2RlKHZhbHVlLCBtZXRyaWNzLmhlaWdodCwgbWV0cmljcy5kZXB0aCwgaXRhbGljLCBtZXRyaWNzLnNrZXcsIG1ldHJpY3Mud2lkdGgsIGNsYXNzZXMpOwogIH0gZWxzZSB7CiAgICB0eXBlb2YgY29uc29sZSAhPT0gInVuZGVmaW5lZCIgJiYgY29uc29sZS53YXJuKCJObyBjaGFyYWN0ZXIgbWV0cmljcyAiICsgKCJmb3IgJyIgKyB2YWx1ZSArICInIGluIHN0eWxlICciICsgZm9udE5hbWUgKyAiJyBhbmQgbW9kZSAnIiArIG1vZGUgKyAiJyIpKTsKICAgIHN5bWJvbE5vZGUgPSBuZXcgU3ltYm9sTm9kZSh2YWx1ZSwgMCwgMCwgMCwgMCwgMCwgY2xhc3Nlcyk7CiAgfQogIGlmIChvcHRpb25zKSB7CiAgICBzeW1ib2xOb2RlLm1heEZvbnRTaXplID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsKICAgIGlmIChvcHRpb25zLnN0eWxlLmlzVGlnaHQoKSkgewogICAgICBzeW1ib2xOb2RlLmNsYXNzZXMucHVzaCgibXRpZ2h0Iik7CiAgICB9CiAgICB2YXIgY29sb3IgPSBvcHRpb25zLmdldENvbG9yKCk7CiAgICBpZiAoY29sb3IpIHsKICAgICAgc3ltYm9sTm9kZS5zdHlsZS5jb2xvciA9IGNvbG9yOwogICAgfQogIH0KICByZXR1cm4gc3ltYm9sTm9kZTsKfTsKdmFyIG1hdGhzeW0gPSBmdW5jdGlvbiBtYXRoc3ltMih2YWx1ZSwgbW9kZSwgb3B0aW9ucywgY2xhc3NlcykgewogIGlmIChjbGFzc2VzID09PSB2b2lkIDApIHsKICAgIGNsYXNzZXMgPSBbXTsKICB9CiAgaWYgKG9wdGlvbnMuZm9udCA9PT0gImJvbGRzeW1ib2wiICYmIGxvb2t1cFN5bWJvbCh2YWx1ZSwgIk1haW4tQm9sZCIsIG1vZGUpLm1ldHJpY3MpIHsKICAgIHJldHVybiBtYWtlU3ltYm9sKHZhbHVlLCAiTWFpbi1Cb2xkIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoWyJtYXRoYmYiXSkpOwogIH0gZWxzZSBpZiAodmFsdWUgPT09ICJcXCIgfHwgc3ltYm9sc1ttb2RlXVt2YWx1ZV0uZm9udCA9PT0gIm1haW4iKSB7CiAgICByZXR1cm4gbWFrZVN5bWJvbCh2YWx1ZSwgIk1haW4tUmVndWxhciIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMpOwogIH0gZWxzZSB7CiAgICByZXR1cm4gbWFrZVN5bWJvbCh2YWx1ZSwgIkFNUy1SZWd1bGFyIiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQoWyJhbXNybSJdKSk7CiAgfQp9Owp2YXIgYm9sZHN5bWJvbCA9IGZ1bmN0aW9uIGJvbGRzeW1ib2wyKHZhbHVlLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLCB0eXBlKSB7CiAgaWYgKHR5cGUgIT09ICJ0ZXh0b3JkIiAmJiBsb29rdXBTeW1ib2wodmFsdWUsICJNYXRoLUJvbGRJdGFsaWMiLCBtb2RlKS5tZXRyaWNzKSB7CiAgICByZXR1cm4gewogICAgICBmb250TmFtZTogIk1hdGgtQm9sZEl0YWxpYyIsCiAgICAgIGZvbnRDbGFzczogImJvbGRzeW1ib2wiCiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gewogICAgICBmb250TmFtZTogIk1haW4tQm9sZCIsCiAgICAgIGZvbnRDbGFzczogIm1hdGhiZiIKICAgIH07CiAgfQp9Owp2YXIgbWFrZU9yZCA9IGZ1bmN0aW9uIG1ha2VPcmQyKGdyb3VwLCBvcHRpb25zLCB0eXBlKSB7CiAgdmFyIG1vZGUgPSBncm91cC5tb2RlOwogIHZhciB0ZXh0MiA9IGdyb3VwLnRleHQ7CiAgdmFyIGNsYXNzZXMgPSBbIm1vcmQiXTsKICB2YXIgaXNGb250ID0gbW9kZSA9PT0gIm1hdGgiIHx8IG1vZGUgPT09ICJ0ZXh0IiAmJiBvcHRpb25zLmZvbnQ7CiAgdmFyIGZvbnRPckZhbWlseSA9IGlzRm9udCA/IG9wdGlvbnMuZm9udCA6IG9wdGlvbnMuZm9udEZhbWlseTsKICB2YXIgd2lkZUZvbnROYW1lID0gIiI7CiAgdmFyIHdpZGVGb250Q2xhc3MgPSAiIjsKICBpZiAodGV4dDIuY2hhckNvZGVBdCgwKSA9PT0gNTUzNDkpIHsKICAgIFt3aWRlRm9udE5hbWUsIHdpZGVGb250Q2xhc3NdID0gd2lkZUNoYXJhY3RlckZvbnQodGV4dDIsIG1vZGUpOwogIH0KICBpZiAod2lkZUZvbnROYW1lLmxlbmd0aCA+IDApIHsKICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQyLCB3aWRlRm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KHdpZGVGb250Q2xhc3MpKTsKICB9IGVsc2UgaWYgKGZvbnRPckZhbWlseSkgewogICAgdmFyIGZvbnROYW1lOwogICAgdmFyIGZvbnRDbGFzc2VzOwogICAgaWYgKGZvbnRPckZhbWlseSA9PT0gImJvbGRzeW1ib2wiKSB7CiAgICAgIHZhciBmb250RGF0YSA9IGJvbGRzeW1ib2wodGV4dDIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMsIHR5cGUpOwogICAgICBmb250TmFtZSA9IGZvbnREYXRhLmZvbnROYW1lOwogICAgICBmb250Q2xhc3NlcyA9IFtmb250RGF0YS5mb250Q2xhc3NdOwogICAgfSBlbHNlIGlmIChpc0ZvbnQpIHsKICAgICAgZm9udE5hbWUgPSBmb250TWFwW2ZvbnRPckZhbWlseV0uZm9udE5hbWU7CiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnRPckZhbWlseV07CiAgICB9IGVsc2UgewogICAgICBmb250TmFtZSA9IHJldHJpZXZlVGV4dEZvbnROYW1lKGZvbnRPckZhbWlseSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7CiAgICAgIGZvbnRDbGFzc2VzID0gW2ZvbnRPckZhbWlseSwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZV07CiAgICB9CiAgICBpZiAobG9va3VwU3ltYm9sKHRleHQyLCBmb250TmFtZSwgbW9kZSkubWV0cmljcykgewogICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0MiwgZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KGZvbnRDbGFzc2VzKSk7CiAgICB9IGVsc2UgaWYgKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0MikgJiYgZm9udE5hbWUuc2xpY2UoMCwgMTApID09PSAiVHlwZXdyaXRlciIpIHsKICAgICAgdmFyIHBhcnRzID0gW107CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dDIubGVuZ3RoOyBpKyspIHsKICAgICAgICBwYXJ0cy5wdXNoKG1ha2VTeW1ib2wodGV4dDJbaV0sIGZvbnROYW1lLCBtb2RlLCBvcHRpb25zLCBjbGFzc2VzLmNvbmNhdChmb250Q2xhc3NlcykpKTsKICAgICAgfQogICAgICByZXR1cm4gbWFrZUZyYWdtZW50KHBhcnRzKTsKICAgIH0KICB9CiAgaWYgKHR5cGUgPT09ICJtYXRob3JkIikgewogICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dDIsICJNYXRoLUl0YWxpYyIsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KFsibWF0aG5vcm1hbCJdKSk7CiAgfSBlbHNlIGlmICh0eXBlID09PSAidGV4dG9yZCIpIHsKICAgIHZhciBmb250ID0gc3ltYm9sc1ttb2RlXVt0ZXh0Ml0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0Ml0uZm9udDsKICAgIGlmIChmb250ID09PSAiYW1zIikgewogICAgICB2YXIgX2ZvbnROYW1lID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoImFtc3JtIiwgb3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSk7CiAgICAgIHJldHVybiBtYWtlU3ltYm9sKHRleHQyLCBfZm9udE5hbWUsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KCJhbXNybSIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpKTsKICAgIH0gZWxzZSBpZiAoZm9udCA9PT0gIm1haW4iIHx8ICFmb250KSB7CiAgICAgIHZhciBfZm9udE5hbWUyID0gcmV0cmlldmVUZXh0Rm9udE5hbWUoInRleHRybSIsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpOwogICAgICByZXR1cm4gbWFrZVN5bWJvbCh0ZXh0MiwgX2ZvbnROYW1lMiwgbW9kZSwgb3B0aW9ucywgY2xhc3Nlcy5jb25jYXQob3B0aW9ucy5mb250V2VpZ2h0LCBvcHRpb25zLmZvbnRTaGFwZSkpOwogICAgfSBlbHNlIHsKICAgICAgdmFyIF9mb250TmFtZTMgPSByZXRyaWV2ZVRleHRGb250TmFtZShmb250LCBvcHRpb25zLmZvbnRXZWlnaHQsIG9wdGlvbnMuZm9udFNoYXBlKTsKICAgICAgcmV0dXJuIG1ha2VTeW1ib2wodGV4dDIsIF9mb250TmFtZTMsIG1vZGUsIG9wdGlvbnMsIGNsYXNzZXMuY29uY2F0KF9mb250TmFtZTMsIG9wdGlvbnMuZm9udFdlaWdodCwgb3B0aW9ucy5mb250U2hhcGUpKTsKICAgIH0KICB9IGVsc2UgewogICAgdGhyb3cgbmV3IEVycm9yKCJ1bmV4cGVjdGVkIHR5cGU6ICIgKyB0eXBlICsgIiBpbiBtYWtlT3JkIik7CiAgfQp9Owp2YXIgY2FuQ29tYmluZSA9IChwcmV2LCBuZXh0KSA9PiB7CiAgaWYgKGNyZWF0ZUNsYXNzKHByZXYuY2xhc3NlcykgIT09IGNyZWF0ZUNsYXNzKG5leHQuY2xhc3NlcykgfHwgcHJldi5za2V3ICE9PSBuZXh0LnNrZXcgfHwgcHJldi5tYXhGb250U2l6ZSAhPT0gbmV4dC5tYXhGb250U2l6ZSkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICBpZiAocHJldi5jbGFzc2VzLmxlbmd0aCA9PT0gMSkgewogICAgdmFyIGNscyA9IHByZXYuY2xhc3Nlc1swXTsKICAgIGlmIChjbHMgPT09ICJtYmluIiB8fCBjbHMgPT09ICJtb3JkIikgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgfQogIGZvciAodmFyIHN0eWxlIGluIHByZXYuc3R5bGUpIHsKICAgIGlmIChwcmV2LnN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlKSAmJiBwcmV2LnN0eWxlW3N0eWxlXSAhPT0gbmV4dC5zdHlsZVtzdHlsZV0pIHsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogIH0KICBmb3IgKHZhciBfc3R5bGUgaW4gbmV4dC5zdHlsZSkgewogICAgaWYgKG5leHQuc3R5bGUuaGFzT3duUHJvcGVydHkoX3N0eWxlKSAmJiBwcmV2LnN0eWxlW19zdHlsZV0gIT09IG5leHQuc3R5bGVbX3N0eWxlXSkgewogICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgfQogIHJldHVybiB0cnVlOwp9Owp2YXIgdHJ5Q29tYmluZUNoYXJzID0gKGNoYXJzKSA9PiB7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFycy5sZW5ndGggLSAxOyBpKyspIHsKICAgIHZhciBwcmV2ID0gY2hhcnNbaV07CiAgICB2YXIgbmV4dCA9IGNoYXJzW2kgKyAxXTsKICAgIGlmIChwcmV2IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBuZXh0IGluc3RhbmNlb2YgU3ltYm9sTm9kZSAmJiBjYW5Db21iaW5lKHByZXYsIG5leHQpKSB7CiAgICAgIHByZXYudGV4dCArPSBuZXh0LnRleHQ7CiAgICAgIHByZXYuaGVpZ2h0ID0gTWF0aC5tYXgocHJldi5oZWlnaHQsIG5leHQuaGVpZ2h0KTsKICAgICAgcHJldi5kZXB0aCA9IE1hdGgubWF4KHByZXYuZGVwdGgsIG5leHQuZGVwdGgpOwogICAgICBwcmV2Lml0YWxpYyA9IG5leHQuaXRhbGljOwogICAgICBjaGFycy5zcGxpY2UoaSArIDEsIDEpOwogICAgICBpLS07CiAgICB9CiAgfQogIHJldHVybiBjaGFyczsKfTsKdmFyIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuID0gZnVuY3Rpb24gc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4yKGVsZW0pIHsKICB2YXIgaGVpZ2h0ID0gMDsKICB2YXIgZGVwdGggPSAwOwogIHZhciBtYXhGb250U2l6ZSA9IDA7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbGVtLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgY2hpbGQgPSBlbGVtLmNoaWxkcmVuW2ldOwogICAgaWYgKGNoaWxkLmhlaWdodCA+IGhlaWdodCkgewogICAgICBoZWlnaHQgPSBjaGlsZC5oZWlnaHQ7CiAgICB9CiAgICBpZiAoY2hpbGQuZGVwdGggPiBkZXB0aCkgewogICAgICBkZXB0aCA9IGNoaWxkLmRlcHRoOwogICAgfQogICAgaWYgKGNoaWxkLm1heEZvbnRTaXplID4gbWF4Rm9udFNpemUpIHsKICAgICAgbWF4Rm9udFNpemUgPSBjaGlsZC5tYXhGb250U2l6ZTsKICAgIH0KICB9CiAgZWxlbS5oZWlnaHQgPSBoZWlnaHQ7CiAgZWxlbS5kZXB0aCA9IGRlcHRoOwogIGVsZW0ubWF4Rm9udFNpemUgPSBtYXhGb250U2l6ZTsKfTsKdmFyIG1ha2VTcGFuJDIgPSBmdW5jdGlvbiBtYWtlU3BhbihjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpIHsKICB2YXIgc3BhbiA9IG5ldyBTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSk7CiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oc3Bhbik7CiAgcmV0dXJuIHNwYW47Cn07CnZhciBtYWtlU3ZnU3BhbiA9IChjbGFzc2VzLCBjaGlsZHJlbiwgb3B0aW9ucywgc3R5bGUpID0+IG5ldyBTcGFuKGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zLCBzdHlsZSk7CnZhciBtYWtlTGluZVNwYW4gPSBmdW5jdGlvbiBtYWtlTGluZVNwYW4yKGNsYXNzTmFtZSwgb3B0aW9ucywgdGhpY2tuZXNzKSB7CiAgdmFyIGxpbmUgPSBtYWtlU3BhbiQyKFtjbGFzc05hbWVdLCBbXSwgb3B0aW9ucyk7CiAgbGluZS5oZWlnaHQgPSBNYXRoLm1heCh0aGlja25lc3MgfHwgb3B0aW9ucy5mb250TWV0cmljcygpLmRlZmF1bHRSdWxlVGhpY2tuZXNzLCBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MpOwogIGxpbmUuc3R5bGUuYm9yZGVyQm90dG9tV2lkdGggPSBtYWtlRW0obGluZS5oZWlnaHQpOwogIGxpbmUubWF4Rm9udFNpemUgPSAxOwogIHJldHVybiBsaW5lOwp9Owp2YXIgbWFrZUFuY2hvciA9IGZ1bmN0aW9uIG1ha2VBbmNob3IyKGhyZWYsIGNsYXNzZXMsIGNoaWxkcmVuLCBvcHRpb25zKSB7CiAgdmFyIGFuY2hvciA9IG5ldyBBbmNob3IoaHJlZiwgY2xhc3NlcywgY2hpbGRyZW4sIG9wdGlvbnMpOwogIHNpemVFbGVtZW50RnJvbUNoaWxkcmVuKGFuY2hvcik7CiAgcmV0dXJuIGFuY2hvcjsKfTsKdmFyIG1ha2VGcmFnbWVudCA9IGZ1bmN0aW9uIG1ha2VGcmFnbWVudDIoY2hpbGRyZW4pIHsKICB2YXIgZnJhZ21lbnQgPSBuZXcgRG9jdW1lbnRGcmFnbWVudChjaGlsZHJlbik7CiAgc2l6ZUVsZW1lbnRGcm9tQ2hpbGRyZW4oZnJhZ21lbnQpOwogIHJldHVybiBmcmFnbWVudDsKfTsKdmFyIHdyYXBGcmFnbWVudCA9IGZ1bmN0aW9uIHdyYXBGcmFnbWVudDIoZ3JvdXAsIG9wdGlvbnMpIHsKICBpZiAoZ3JvdXAgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7CiAgICByZXR1cm4gbWFrZVNwYW4kMihbXSwgW2dyb3VwXSwgb3B0aW9ucyk7CiAgfQogIHJldHVybiBncm91cDsKfTsKdmFyIGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aCA9IGZ1bmN0aW9uIGdldFZMaXN0Q2hpbGRyZW5BbmREZXB0aDIocGFyYW1zKSB7CiAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09ICJpbmRpdmlkdWFsU2hpZnQiKSB7CiAgICB2YXIgb2xkQ2hpbGRyZW4gPSBwYXJhbXMuY2hpbGRyZW47CiAgICB2YXIgY2hpbGRyZW4gPSBbb2xkQ2hpbGRyZW5bMF1dOwogICAgdmFyIF9kZXB0aCA9IC1vbGRDaGlsZHJlblswXS5zaGlmdCAtIG9sZENoaWxkcmVuWzBdLmVsZW0uZGVwdGg7CiAgICB2YXIgY3VyclBvcyA9IF9kZXB0aDsKICAgIGZvciAodmFyIGkgPSAxOyBpIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgICAgdmFyIGRpZmYgPSAtb2xkQ2hpbGRyZW5baV0uc2hpZnQgLSBjdXJyUG9zIC0gb2xkQ2hpbGRyZW5baV0uZWxlbS5kZXB0aDsKICAgICAgdmFyIHNpemUgPSBkaWZmIC0gKG9sZENoaWxkcmVuW2kgLSAxXS5lbGVtLmhlaWdodCArIG9sZENoaWxkcmVuW2kgLSAxXS5lbGVtLmRlcHRoKTsKICAgICAgY3VyclBvcyA9IGN1cnJQb3MgKyBkaWZmOwogICAgICBjaGlsZHJlbi5wdXNoKHsKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZQogICAgICB9KTsKICAgICAgY2hpbGRyZW4ucHVzaChvbGRDaGlsZHJlbltpXSk7CiAgICB9CiAgICByZXR1cm4gewogICAgICBjaGlsZHJlbiwKICAgICAgZGVwdGg6IF9kZXB0aAogICAgfTsKICB9CiAgdmFyIGRlcHRoOwogIGlmIChwYXJhbXMucG9zaXRpb25UeXBlID09PSAidG9wIikgewogICAgdmFyIGJvdHRvbSA9IHBhcmFtcy5wb3NpdGlvbkRhdGE7CiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgcGFyYW1zLmNoaWxkcmVuLmxlbmd0aDsgX2krKykgewogICAgICB2YXIgY2hpbGQgPSBwYXJhbXMuY2hpbGRyZW5bX2ldOwogICAgICBib3R0b20gLT0gY2hpbGQudHlwZSA9PT0gImtlcm4iID8gY2hpbGQuc2l6ZSA6IGNoaWxkLmVsZW0uaGVpZ2h0ICsgY2hpbGQuZWxlbS5kZXB0aDsKICAgIH0KICAgIGRlcHRoID0gYm90dG9tOwogIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gImJvdHRvbSIpIHsKICAgIGRlcHRoID0gLXBhcmFtcy5wb3NpdGlvbkRhdGE7CiAgfSBlbHNlIHsKICAgIHZhciBmaXJzdENoaWxkID0gcGFyYW1zLmNoaWxkcmVuWzBdOwogICAgaWYgKGZpcnN0Q2hpbGQudHlwZSAhPT0gImVsZW0iKSB7CiAgICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgY2hpbGQgbXVzdCBoYXZlIHR5cGUgImVsZW0iLicpOwogICAgfQogICAgaWYgKHBhcmFtcy5wb3NpdGlvblR5cGUgPT09ICJzaGlmdCIpIHsKICAgICAgZGVwdGggPSAtZmlyc3RDaGlsZC5lbGVtLmRlcHRoIC0gcGFyYW1zLnBvc2l0aW9uRGF0YTsKICAgIH0gZWxzZSBpZiAocGFyYW1zLnBvc2l0aW9uVHlwZSA9PT0gImZpcnN0QmFzZWxpbmUiKSB7CiAgICAgIGRlcHRoID0gLWZpcnN0Q2hpbGQuZWxlbS5kZXB0aDsKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBFcnJvcigiSW52YWxpZCBwb3NpdGlvblR5cGUgIiArIHBhcmFtcy5wb3NpdGlvblR5cGUgKyAiLiIpOwogICAgfQogIH0KICByZXR1cm4gewogICAgY2hpbGRyZW46IHBhcmFtcy5jaGlsZHJlbiwKICAgIGRlcHRoCiAgfTsKfTsKdmFyIG1ha2VWTGlzdCA9IGZ1bmN0aW9uIG1ha2VWTGlzdDIocGFyYW1zLCBvcHRpb25zKSB7CiAgdmFyIHsKICAgIGNoaWxkcmVuLAogICAgZGVwdGgKICB9ID0gZ2V0Vkxpc3RDaGlsZHJlbkFuZERlcHRoKHBhcmFtcyk7CiAgdmFyIHBzdHJ1dFNpemUgPSAwOwogIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHsKICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldOwogICAgaWYgKGNoaWxkLnR5cGUgPT09ICJlbGVtIikgewogICAgICB2YXIgZWxlbSA9IGNoaWxkLmVsZW07CiAgICAgIHBzdHJ1dFNpemUgPSBNYXRoLm1heChwc3RydXRTaXplLCBlbGVtLm1heEZvbnRTaXplLCBlbGVtLmhlaWdodCk7CiAgICB9CiAgfQogIHBzdHJ1dFNpemUgKz0gMjsKICB2YXIgcHN0cnV0ID0gbWFrZVNwYW4kMihbInBzdHJ1dCJdLCBbXSk7CiAgcHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShwc3RydXRTaXplKTsKICB2YXIgcmVhbENoaWxkcmVuID0gW107CiAgdmFyIG1pblBvcyA9IGRlcHRoOwogIHZhciBtYXhQb3MgPSBkZXB0aDsKICB2YXIgY3VyclBvcyA9IGRlcHRoOwogIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGNoaWxkcmVuLmxlbmd0aDsgX2kyKyspIHsKICAgIHZhciBfY2hpbGQgPSBjaGlsZHJlbltfaTJdOwogICAgaWYgKF9jaGlsZC50eXBlID09PSAia2VybiIpIHsKICAgICAgY3VyclBvcyArPSBfY2hpbGQuc2l6ZTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBfZWxlbSA9IF9jaGlsZC5lbGVtOwogICAgICB2YXIgY2xhc3NlcyA9IF9jaGlsZC53cmFwcGVyQ2xhc3NlcyB8fCBbXTsKICAgICAgdmFyIHN0eWxlID0gX2NoaWxkLndyYXBwZXJTdHlsZSB8fCB7fTsKICAgICAgdmFyIGNoaWxkV3JhcCA9IG1ha2VTcGFuJDIoY2xhc3NlcywgW3BzdHJ1dCwgX2VsZW1dLCB2b2lkIDAsIHN0eWxlKTsKICAgICAgY2hpbGRXcmFwLnN0eWxlLnRvcCA9IG1ha2VFbSgtcHN0cnV0U2l6ZSAtIGN1cnJQb3MgLSBfZWxlbS5kZXB0aCk7CiAgICAgIGlmIChfY2hpbGQubWFyZ2luTGVmdCkgewogICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5MZWZ0ID0gX2NoaWxkLm1hcmdpbkxlZnQ7CiAgICAgIH0KICAgICAgaWYgKF9jaGlsZC5tYXJnaW5SaWdodCkgewogICAgICAgIGNoaWxkV3JhcC5zdHlsZS5tYXJnaW5SaWdodCA9IF9jaGlsZC5tYXJnaW5SaWdodDsKICAgICAgfQogICAgICByZWFsQ2hpbGRyZW4ucHVzaChjaGlsZFdyYXApOwogICAgICBjdXJyUG9zICs9IF9lbGVtLmhlaWdodCArIF9lbGVtLmRlcHRoOwogICAgfQogICAgbWluUG9zID0gTWF0aC5taW4obWluUG9zLCBjdXJyUG9zKTsKICAgIG1heFBvcyA9IE1hdGgubWF4KG1heFBvcywgY3VyclBvcyk7CiAgfQogIHZhciB2bGlzdCA9IG1ha2VTcGFuJDIoWyJ2bGlzdCJdLCByZWFsQ2hpbGRyZW4pOwogIHZsaXN0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShtYXhQb3MpOwogIHZhciByb3dzOwogIGlmIChtaW5Qb3MgPCAwKSB7CiAgICB2YXIgZW1wdHlTcGFuID0gbWFrZVNwYW4kMihbXSwgW10pOwogICAgdmFyIGRlcHRoU3RydXQgPSBtYWtlU3BhbiQyKFsidmxpc3QiXSwgW2VtcHR5U3Bhbl0pOwogICAgZGVwdGhTdHJ1dC5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oLW1pblBvcyk7CiAgICB2YXIgdG9wU3RydXQgPSBtYWtlU3BhbiQyKFsidmxpc3QtcyJdLCBbbmV3IFN5bWJvbE5vZGUoIuKAiyIpXSk7CiAgICByb3dzID0gW21ha2VTcGFuJDIoWyJ2bGlzdC1yIl0sIFt2bGlzdCwgdG9wU3RydXRdKSwgbWFrZVNwYW4kMihbInZsaXN0LXIiXSwgW2RlcHRoU3RydXRdKV07CiAgfSBlbHNlIHsKICAgIHJvd3MgPSBbbWFrZVNwYW4kMihbInZsaXN0LXIiXSwgW3ZsaXN0XSldOwogIH0KICB2YXIgdnRhYmxlID0gbWFrZVNwYW4kMihbInZsaXN0LXQiXSwgcm93cyk7CiAgaWYgKHJvd3MubGVuZ3RoID09PSAyKSB7CiAgICB2dGFibGUuY2xhc3Nlcy5wdXNoKCJ2bGlzdC10MiIpOwogIH0KICB2dGFibGUuaGVpZ2h0ID0gbWF4UG9zOwogIHZ0YWJsZS5kZXB0aCA9IC1taW5Qb3M7CiAgcmV0dXJuIHZ0YWJsZTsKfTsKdmFyIG1ha2VHbHVlID0gKG1lYXN1cmVtZW50LCBvcHRpb25zKSA9PiB7CiAgdmFyIHJ1bGUgPSBtYWtlU3BhbiQyKFsibXNwYWNlIl0sIFtdLCBvcHRpb25zKTsKICB2YXIgc2l6ZSA9IGNhbGN1bGF0ZVNpemUobWVhc3VyZW1lbnQsIG9wdGlvbnMpOwogIHJ1bGUuc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0oc2l6ZSk7CiAgcmV0dXJuIHJ1bGU7Cn07CnZhciByZXRyaWV2ZVRleHRGb250TmFtZSA9IGZ1bmN0aW9uIHJldHJpZXZlVGV4dEZvbnROYW1lMihmb250RmFtaWx5LCBmb250V2VpZ2h0LCBmb250U2hhcGUpIHsKICB2YXIgYmFzZUZvbnROYW1lID0gIiI7CiAgc3dpdGNoIChmb250RmFtaWx5KSB7CiAgICBjYXNlICJhbXNybSI6CiAgICAgIGJhc2VGb250TmFtZSA9ICJBTVMiOwogICAgICBicmVhazsKICAgIGNhc2UgInRleHRybSI6CiAgICAgIGJhc2VGb250TmFtZSA9ICJNYWluIjsKICAgICAgYnJlYWs7CiAgICBjYXNlICJ0ZXh0c2YiOgogICAgICBiYXNlRm9udE5hbWUgPSAiU2Fuc1NlcmlmIjsKICAgICAgYnJlYWs7CiAgICBjYXNlICJ0ZXh0dHQiOgogICAgICBiYXNlRm9udE5hbWUgPSAiVHlwZXdyaXRlciI7CiAgICAgIGJyZWFrOwogICAgZGVmYXVsdDoKICAgICAgYmFzZUZvbnROYW1lID0gZm9udEZhbWlseTsKICB9CiAgdmFyIGZvbnRTdHlsZXNOYW1lOwogIGlmIChmb250V2VpZ2h0ID09PSAidGV4dGJmIiAmJiBmb250U2hhcGUgPT09ICJ0ZXh0aXQiKSB7CiAgICBmb250U3R5bGVzTmFtZSA9ICJCb2xkSXRhbGljIjsKICB9IGVsc2UgaWYgKGZvbnRXZWlnaHQgPT09ICJ0ZXh0YmYiKSB7CiAgICBmb250U3R5bGVzTmFtZSA9ICJCb2xkIjsKICB9IGVsc2UgaWYgKGZvbnRXZWlnaHQgPT09ICJ0ZXh0aXQiKSB7CiAgICBmb250U3R5bGVzTmFtZSA9ICJJdGFsaWMiOwogIH0gZWxzZSB7CiAgICBmb250U3R5bGVzTmFtZSA9ICJSZWd1bGFyIjsKICB9CiAgcmV0dXJuIGJhc2VGb250TmFtZSArICItIiArIGZvbnRTdHlsZXNOYW1lOwp9Owp2YXIgZm9udE1hcCA9IHsKICAvLyBzdHlsZXMKICAibWF0aGJmIjogewogICAgdmFyaWFudDogImJvbGQiLAogICAgZm9udE5hbWU6ICJNYWluLUJvbGQiCiAgfSwKICAibWF0aHJtIjogewogICAgdmFyaWFudDogIm5vcm1hbCIsCiAgICBmb250TmFtZTogIk1haW4tUmVndWxhciIKICB9LAogICJ0ZXh0aXQiOiB7CiAgICB2YXJpYW50OiAiaXRhbGljIiwKICAgIGZvbnROYW1lOiAiTWFpbi1JdGFsaWMiCiAgfSwKICAibWF0aGl0IjogewogICAgdmFyaWFudDogIml0YWxpYyIsCiAgICBmb250TmFtZTogIk1haW4tSXRhbGljIgogIH0sCiAgIm1hdGhub3JtYWwiOiB7CiAgICB2YXJpYW50OiAiaXRhbGljIiwKICAgIGZvbnROYW1lOiAiTWF0aC1JdGFsaWMiCiAgfSwKICAibWF0aHNmaXQiOiB7CiAgICB2YXJpYW50OiAic2Fucy1zZXJpZi1pdGFsaWMiLAogICAgZm9udE5hbWU6ICJTYW5zU2VyaWYtSXRhbGljIgogIH0sCiAgLy8gImJvbGRzeW1ib2wiIGlzIG1pc3NpbmcgYmVjYXVzZSB0aGV5IHJlcXVpcmUgdGhlIHVzZSBvZiBtdWx0aXBsZSBmb250czoKICAvLyBNYXRoLUJvbGRJdGFsaWMgYW5kIE1haW4tQm9sZC4gIFRoaXMgaXMgaGFuZGxlZCBieSBhIHNwZWNpYWwgY2FzZSBpbgogIC8vIG1ha2VPcmQgd2hpY2ggZW5kcyB1cCBjYWxsaW5nIGJvbGRzeW1ib2wuCiAgLy8gZmFtaWxpZXMKICAibWF0aGJiIjogewogICAgdmFyaWFudDogImRvdWJsZS1zdHJ1Y2siLAogICAgZm9udE5hbWU6ICJBTVMtUmVndWxhciIKICB9LAogICJtYXRoY2FsIjogewogICAgdmFyaWFudDogInNjcmlwdCIsCiAgICBmb250TmFtZTogIkNhbGlncmFwaGljLVJlZ3VsYXIiCiAgfSwKICAibWF0aGZyYWsiOiB7CiAgICB2YXJpYW50OiAiZnJha3R1ciIsCiAgICBmb250TmFtZTogIkZyYWt0dXItUmVndWxhciIKICB9LAogICJtYXRoc2NyIjogewogICAgdmFyaWFudDogInNjcmlwdCIsCiAgICBmb250TmFtZTogIlNjcmlwdC1SZWd1bGFyIgogIH0sCiAgIm1hdGhzZiI6IHsKICAgIHZhcmlhbnQ6ICJzYW5zLXNlcmlmIiwKICAgIGZvbnROYW1lOiAiU2Fuc1NlcmlmLVJlZ3VsYXIiCiAgfSwKICAibWF0aHR0IjogewogICAgdmFyaWFudDogIm1vbm9zcGFjZSIsCiAgICBmb250TmFtZTogIlR5cGV3cml0ZXItUmVndWxhciIKICB9Cn07CnZhciBzdmdEYXRhID0gewogIC8vICAgcGF0aCwgd2lkdGgsIGhlaWdodAogIHZlYzogWyJ2ZWMiLCAwLjQ3MSwgMC43MTRdLAogIC8vIHZhbHVlcyBmcm9tIHRoZSBmb250IGdseXBoCiAgb2lpbnRTaXplMTogWyJvaWludFNpemUxIiwgMC45NTcsIDAuNDk5XSwKICAvLyBvdmFsIHRvIG92ZXJsYXkgdGhlIGludGVncmFuZAogIG9paW50U2l6ZTI6IFsib2lpbnRTaXplMiIsIDEuNDcyLCAwLjY1OV0sCiAgb2lpaW50U2l6ZTE6IFsib2lpaW50U2l6ZTEiLCAxLjMwNCwgMC40OTldLAogIG9paWludFNpemUyOiBbIm9paWludFNpemUyIiwgMS45OCwgMC42NTldCn07CnZhciBzdGF0aWNTdmcgPSBmdW5jdGlvbiBzdGF0aWNTdmcyKHZhbHVlLCBvcHRpb25zKSB7CiAgdmFyIFtwYXRoTmFtZSwgd2lkdGgsIGhlaWdodF0gPSBzdmdEYXRhW3ZhbHVlXTsKICB2YXIgcGF0aDIgPSBuZXcgUGF0aE5vZGUocGF0aE5hbWUpOwogIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGgyXSwgewogICAgIndpZHRoIjogbWFrZUVtKHdpZHRoKSwKICAgICJoZWlnaHQiOiBtYWtlRW0oaGVpZ2h0KSwKICAgIC8vIE92ZXJyaWRlIENTUyBydWxlIGAua2F0ZXggc3ZnIHsgd2lkdGg6IDEwMCUgfWAKICAgICJzdHlsZSI6ICJ3aWR0aDoiICsgbWFrZUVtKHdpZHRoKSwKICAgICJ2aWV3Qm94IjogIjAgMCAiICsgMWUzICogd2lkdGggKyAiICIgKyAxZTMgKiBoZWlnaHQsCiAgICAicHJlc2VydmVBc3BlY3RSYXRpbyI6ICJ4TWluWU1pbiIKICB9KTsKICB2YXIgc3BhbiA9IG1ha2VTdmdTcGFuKFsib3ZlcmxheSJdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpOwogIHNwYW4uaGVpZ2h0ID0gaGVpZ2h0OwogIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7CiAgc3Bhbi5zdHlsZS53aWR0aCA9IG1ha2VFbSh3aWR0aCk7CiAgcmV0dXJuIHNwYW47Cn07CnZhciBidWlsZENvbW1vbiA9IHsKICBmb250TWFwLAogIG1ha2VTeW1ib2wsCiAgbWF0aHN5bSwKICBtYWtlU3BhbjogbWFrZVNwYW4kMiwKICBtYWtlU3ZnU3BhbiwKICBtYWtlTGluZVNwYW4sCiAgbWFrZUFuY2hvciwKICBtYWtlRnJhZ21lbnQsCiAgd3JhcEZyYWdtZW50LAogIG1ha2VWTGlzdCwKICBtYWtlT3JkLAogIG1ha2VHbHVlLAogIHN0YXRpY1N2ZywKICBzdmdEYXRhLAogIHRyeUNvbWJpbmVDaGFycwp9Owp2YXIgdGhpbnNwYWNlID0gewogIG51bWJlcjogMywKICB1bml0OiAibXUiCn07CnZhciBtZWRpdW1zcGFjZSA9IHsKICBudW1iZXI6IDQsCiAgdW5pdDogIm11Igp9Owp2YXIgdGhpY2tzcGFjZSA9IHsKICBudW1iZXI6IDUsCiAgdW5pdDogIm11Igp9Owp2YXIgc3BhY2luZ3MgPSB7CiAgbW9yZDogewogICAgbW9wOiB0aGluc3BhY2UsCiAgICBtYmluOiBtZWRpdW1zcGFjZSwKICAgIG1yZWw6IHRoaWNrc3BhY2UsCiAgICBtaW5uZXI6IHRoaW5zcGFjZQogIH0sCiAgbW9wOiB7CiAgICBtb3JkOiB0aGluc3BhY2UsCiAgICBtb3A6IHRoaW5zcGFjZSwKICAgIG1yZWw6IHRoaWNrc3BhY2UsCiAgICBtaW5uZXI6IHRoaW5zcGFjZQogIH0sCiAgbWJpbjogewogICAgbW9yZDogbWVkaXVtc3BhY2UsCiAgICBtb3A6IG1lZGl1bXNwYWNlLAogICAgbW9wZW46IG1lZGl1bXNwYWNlLAogICAgbWlubmVyOiBtZWRpdW1zcGFjZQogIH0sCiAgbXJlbDogewogICAgbW9yZDogdGhpY2tzcGFjZSwKICAgIG1vcDogdGhpY2tzcGFjZSwKICAgIG1vcGVuOiB0aGlja3NwYWNlLAogICAgbWlubmVyOiB0aGlja3NwYWNlCiAgfSwKICBtb3Blbjoge30sCiAgbWNsb3NlOiB7CiAgICBtb3A6IHRoaW5zcGFjZSwKICAgIG1iaW46IG1lZGl1bXNwYWNlLAogICAgbXJlbDogdGhpY2tzcGFjZSwKICAgIG1pbm5lcjogdGhpbnNwYWNlCiAgfSwKICBtcHVuY3Q6IHsKICAgIG1vcmQ6IHRoaW5zcGFjZSwKICAgIG1vcDogdGhpbnNwYWNlLAogICAgbXJlbDogdGhpY2tzcGFjZSwKICAgIG1vcGVuOiB0aGluc3BhY2UsCiAgICBtY2xvc2U6IHRoaW5zcGFjZSwKICAgIG1wdW5jdDogdGhpbnNwYWNlLAogICAgbWlubmVyOiB0aGluc3BhY2UKICB9LAogIG1pbm5lcjogewogICAgbW9yZDogdGhpbnNwYWNlLAogICAgbW9wOiB0aGluc3BhY2UsCiAgICBtYmluOiBtZWRpdW1zcGFjZSwKICAgIG1yZWw6IHRoaWNrc3BhY2UsCiAgICBtb3BlbjogdGhpbnNwYWNlLAogICAgbXB1bmN0OiB0aGluc3BhY2UsCiAgICBtaW5uZXI6IHRoaW5zcGFjZQogIH0KfTsKdmFyIHRpZ2h0U3BhY2luZ3MgPSB7CiAgbW9yZDogewogICAgbW9wOiB0aGluc3BhY2UKICB9LAogIG1vcDogewogICAgbW9yZDogdGhpbnNwYWNlLAogICAgbW9wOiB0aGluc3BhY2UKICB9LAogIG1iaW46IHt9LAogIG1yZWw6IHt9LAogIG1vcGVuOiB7fSwKICBtY2xvc2U6IHsKICAgIG1vcDogdGhpbnNwYWNlCiAgfSwKICBtcHVuY3Q6IHt9LAogIG1pbm5lcjogewogICAgbW9wOiB0aGluc3BhY2UKICB9Cn07CnZhciBfZnVuY3Rpb25zID0ge307CnZhciBfaHRtbEdyb3VwQnVpbGRlcnMgPSB7fTsKdmFyIF9tYXRobWxHcm91cEJ1aWxkZXJzID0ge307CmZ1bmN0aW9uIGRlZmluZUZ1bmN0aW9uKF9yZWYpIHsKICB2YXIgewogICAgdHlwZSwKICAgIG5hbWVzLAogICAgcHJvcHMsCiAgICBoYW5kbGVyLAogICAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyMywKICAgIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIzCiAgfSA9IF9yZWY7CiAgdmFyIGRhdGEgPSB7CiAgICB0eXBlLAogICAgbnVtQXJnczogcHJvcHMubnVtQXJncywKICAgIGFyZ1R5cGVzOiBwcm9wcy5hcmdUeXBlcywKICAgIGFsbG93ZWRJbkFyZ3VtZW50OiAhIXByb3BzLmFsbG93ZWRJbkFyZ3VtZW50LAogICAgYWxsb3dlZEluVGV4dDogISFwcm9wcy5hbGxvd2VkSW5UZXh0LAogICAgYWxsb3dlZEluTWF0aDogcHJvcHMuYWxsb3dlZEluTWF0aCA9PT0gdm9pZCAwID8gdHJ1ZSA6IHByb3BzLmFsbG93ZWRJbk1hdGgsCiAgICBudW1PcHRpb25hbEFyZ3M6IHByb3BzLm51bU9wdGlvbmFsQXJncyB8fCAwLAogICAgaW5maXg6ICEhcHJvcHMuaW5maXgsCiAgICBwcmltaXRpdmU6ICEhcHJvcHMucHJpbWl0aXZlLAogICAgaGFuZGxlcgogIH07CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkgewogICAgX2Z1bmN0aW9uc1tuYW1lc1tpXV0gPSBkYXRhOwogIH0KICBpZiAodHlwZSkgewogICAgaWYgKGh0bWxCdWlsZGVyMykgewogICAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjM7CiAgICB9CiAgICBpZiAobWF0aG1sQnVpbGRlcjMpIHsKICAgICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyMzsKICAgIH0KICB9Cn0KZnVuY3Rpb24gZGVmaW5lRnVuY3Rpb25CdWlsZGVycyhfcmVmMikgewogIHZhciB7CiAgICB0eXBlLAogICAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyMywKICAgIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIzCiAgfSA9IF9yZWYyOwogIGRlZmluZUZ1bmN0aW9uKHsKICAgIHR5cGUsCiAgICBuYW1lczogW10sCiAgICBwcm9wczogewogICAgICBudW1BcmdzOiAwCiAgICB9LAogICAgaGFuZGxlcigpIHsKICAgICAgdGhyb3cgbmV3IEVycm9yKCJTaG91bGQgbmV2ZXIgYmUgY2FsbGVkLiIpOwogICAgfSwKICAgIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlcjMsCiAgICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyMwogIH0pOwp9CnZhciBub3JtYWxpemVBcmd1bWVudCA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUFyZ3VtZW50MihhcmcpIHsKICByZXR1cm4gYXJnLnR5cGUgPT09ICJvcmRncm91cCIgJiYgYXJnLmJvZHkubGVuZ3RoID09PSAxID8gYXJnLmJvZHlbMF0gOiBhcmc7Cn07CnZhciBvcmRhcmd1bWVudCA9IGZ1bmN0aW9uIG9yZGFyZ3VtZW50MihhcmcpIHsKICByZXR1cm4gYXJnLnR5cGUgPT09ICJvcmRncm91cCIgPyBhcmcuYm9keSA6IFthcmddOwp9Owp2YXIgbWFrZVNwYW4kMSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuOwp2YXIgYmluTGVmdENhbmNlbGxlciA9IFsibGVmdG1vc3QiLCAibWJpbiIsICJtb3BlbiIsICJtcmVsIiwgIm1vcCIsICJtcHVuY3QiXTsKdmFyIGJpblJpZ2h0Q2FuY2VsbGVyID0gWyJyaWdodG1vc3QiLCAibXJlbCIsICJtY2xvc2UiLCAibXB1bmN0Il07CnZhciBzdHlsZU1hcCQxID0gewogICJkaXNwbGF5IjogU3R5bGUkMS5ESVNQTEFZLAogICJ0ZXh0IjogU3R5bGUkMS5URVhULAogICJzY3JpcHQiOiBTdHlsZSQxLlNDUklQVCwKICAic2NyaXB0c2NyaXB0IjogU3R5bGUkMS5TQ1JJUFRTQ1JJUFQKfTsKdmFyIERvbUVudW0gPSB7CiAgbW9yZDogIm1vcmQiLAogIG1vcDogIm1vcCIsCiAgbWJpbjogIm1iaW4iLAogIG1yZWw6ICJtcmVsIiwKICBtb3BlbjogIm1vcGVuIiwKICBtY2xvc2U6ICJtY2xvc2UiLAogIG1wdW5jdDogIm1wdW5jdCIsCiAgbWlubmVyOiAibWlubmVyIgp9Owp2YXIgYnVpbGRFeHByZXNzaW9uJDEgPSBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb24oZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNSZWFsR3JvdXAsIHN1cnJvdW5kaW5nKSB7CiAgaWYgKHN1cnJvdW5kaW5nID09PSB2b2lkIDApIHsKICAgIHN1cnJvdW5kaW5nID0gW251bGwsIG51bGxdOwogIH0KICB2YXIgZ3JvdXBzID0gW107CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgb3V0cHV0ID0gYnVpbGRHcm91cCQxKGV4cHJlc3Npb25baV0sIG9wdGlvbnMpOwogICAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHsKICAgICAgdmFyIGNoaWxkcmVuID0gb3V0cHV0LmNoaWxkcmVuOwogICAgICBncm91cHMucHVzaCguLi5jaGlsZHJlbik7CiAgICB9IGVsc2UgewogICAgICBncm91cHMucHVzaChvdXRwdXQpOwogICAgfQogIH0KICBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoZ3JvdXBzKTsKICBpZiAoIWlzUmVhbEdyb3VwKSB7CiAgICByZXR1cm4gZ3JvdXBzOwogIH0KICB2YXIgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zOwogIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSkgewogICAgdmFyIG5vZGUgPSBleHByZXNzaW9uWzBdOwogICAgaWYgKG5vZGUudHlwZSA9PT0gInNpemluZyIpIHsKICAgICAgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUobm9kZS5zaXplKTsKICAgIH0gZWxzZSBpZiAobm9kZS50eXBlID09PSAic3R5bGluZyIpIHsKICAgICAgZ2x1ZU9wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlTWFwJDFbbm9kZS5zdHlsZV0pOwogICAgfQogIH0KICB2YXIgZHVtbXlQcmV2ID0gbWFrZVNwYW4kMShbc3Vycm91bmRpbmdbMF0gfHwgImxlZnRtb3N0Il0sIFtdLCBvcHRpb25zKTsKICB2YXIgZHVtbXlOZXh0ID0gbWFrZVNwYW4kMShbc3Vycm91bmRpbmdbMV0gfHwgInJpZ2h0bW9zdCJdLCBbXSwgb3B0aW9ucyk7CiAgdmFyIGlzUm9vdCA9IGlzUmVhbEdyb3VwID09PSAicm9vdCI7CiAgdHJhdmVyc2VOb25TcGFjZU5vZGVzKGdyb3VwcywgKG5vZGUyLCBwcmV2KSA9PiB7CiAgICB2YXIgcHJldlR5cGUgPSBwcmV2LmNsYXNzZXNbMF07CiAgICB2YXIgdHlwZSA9IG5vZGUyLmNsYXNzZXNbMF07CiAgICBpZiAocHJldlR5cGUgPT09ICJtYmluIiAmJiB1dGlscy5jb250YWlucyhiaW5SaWdodENhbmNlbGxlciwgdHlwZSkpIHsKICAgICAgcHJldi5jbGFzc2VzWzBdID0gIm1vcmQiOwogICAgfSBlbHNlIGlmICh0eXBlID09PSAibWJpbiIgJiYgdXRpbHMuY29udGFpbnMoYmluTGVmdENhbmNlbGxlciwgcHJldlR5cGUpKSB7CiAgICAgIG5vZGUyLmNsYXNzZXNbMF0gPSAibW9yZCI7CiAgICB9CiAgfSwgewogICAgbm9kZTogZHVtbXlQcmV2CiAgfSwgZHVtbXlOZXh0LCBpc1Jvb3QpOwogIHRyYXZlcnNlTm9uU3BhY2VOb2Rlcyhncm91cHMsIChub2RlMiwgcHJldikgPT4gewogICAgdmFyIHByZXZUeXBlID0gZ2V0VHlwZU9mRG9tVHJlZShwcmV2KTsKICAgIHZhciB0eXBlID0gZ2V0VHlwZU9mRG9tVHJlZShub2RlMik7CiAgICB2YXIgc3BhY2UgPSBwcmV2VHlwZSAmJiB0eXBlID8gbm9kZTIuaGFzQ2xhc3MoIm10aWdodCIpID8gdGlnaHRTcGFjaW5nc1twcmV2VHlwZV1bdHlwZV0gOiBzcGFjaW5nc1twcmV2VHlwZV1bdHlwZV0gOiBudWxsOwogICAgaWYgKHNwYWNlKSB7CiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlR2x1ZShzcGFjZSwgZ2x1ZU9wdGlvbnMpOwogICAgfQogIH0sIHsKICAgIG5vZGU6IGR1bW15UHJldgogIH0sIGR1bW15TmV4dCwgaXNSb290KTsKICByZXR1cm4gZ3JvdXBzOwp9Owp2YXIgdHJhdmVyc2VOb25TcGFjZU5vZGVzID0gZnVuY3Rpb24gdHJhdmVyc2VOb25TcGFjZU5vZGVzMihub2RlcywgY2FsbGJhY2ssIHByZXYsIG5leHQsIGlzUm9vdCkgewogIGlmIChuZXh0KSB7CiAgICBub2Rlcy5wdXNoKG5leHQpOwogIH0KICB2YXIgaSA9IDA7CiAgZm9yICg7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykgewogICAgdmFyIG5vZGUgPSBub2Rlc1tpXTsKICAgIHZhciBwYXJ0aWFsR3JvdXAgPSBjaGVja1BhcnRpYWxHcm91cChub2RlKTsKICAgIGlmIChwYXJ0aWFsR3JvdXApIHsKICAgICAgdHJhdmVyc2VOb25TcGFjZU5vZGVzMihwYXJ0aWFsR3JvdXAuY2hpbGRyZW4sIGNhbGxiYWNrLCBwcmV2LCBudWxsLCBpc1Jvb3QpOwogICAgICBjb250aW51ZTsKICAgIH0KICAgIHZhciBub25zcGFjZSA9ICFub2RlLmhhc0NsYXNzKCJtc3BhY2UiKTsKICAgIGlmIChub25zcGFjZSkgewogICAgICB2YXIgcmVzdWx0ID0gY2FsbGJhY2sobm9kZSwgcHJldi5ub2RlKTsKICAgICAgaWYgKHJlc3VsdCkgewogICAgICAgIGlmIChwcmV2Lmluc2VydEFmdGVyKSB7CiAgICAgICAgICBwcmV2Lmluc2VydEFmdGVyKHJlc3VsdCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG5vZGVzLnVuc2hpZnQocmVzdWx0KTsKICAgICAgICAgIGkrKzsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGlmIChub25zcGFjZSkgewogICAgICBwcmV2Lm5vZGUgPSBub2RlOwogICAgfSBlbHNlIGlmIChpc1Jvb3QgJiYgbm9kZS5oYXNDbGFzcygibmV3bGluZSIpKSB7CiAgICAgIHByZXYubm9kZSA9IG1ha2VTcGFuJDEoWyJsZWZ0bW9zdCJdKTsKICAgIH0KICAgIHByZXYuaW5zZXJ0QWZ0ZXIgPSAvKiBAX19QVVJFX18gKi8gKChpbmRleCkgPT4gKG4pID0+IHsKICAgICAgbm9kZXMuc3BsaWNlKGluZGV4ICsgMSwgMCwgbik7CiAgICAgIGkrKzsKICAgIH0pKGkpOwogIH0KICBpZiAobmV4dCkgewogICAgbm9kZXMucG9wKCk7CiAgfQp9Owp2YXIgY2hlY2tQYXJ0aWFsR3JvdXAgPSBmdW5jdGlvbiBjaGVja1BhcnRpYWxHcm91cDIobm9kZSkgewogIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCB8fCBub2RlIGluc3RhbmNlb2YgQW5jaG9yIHx8IG5vZGUgaW5zdGFuY2VvZiBTcGFuICYmIG5vZGUuaGFzQ2xhc3MoImVuY2xvc2luZyIpKSB7CiAgICByZXR1cm4gbm9kZTsKICB9CiAgcmV0dXJuIG51bGw7Cn07CnZhciBnZXRPdXRlcm1vc3ROb2RlID0gZnVuY3Rpb24gZ2V0T3V0ZXJtb3N0Tm9kZTIobm9kZSwgc2lkZSkgewogIHZhciBwYXJ0aWFsR3JvdXAgPSBjaGVja1BhcnRpYWxHcm91cChub2RlKTsKICBpZiAocGFydGlhbEdyb3VwKSB7CiAgICB2YXIgY2hpbGRyZW4gPSBwYXJ0aWFsR3JvdXAuY2hpbGRyZW47CiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7CiAgICAgIGlmIChzaWRlID09PSAicmlnaHQiKSB7CiAgICAgICAgcmV0dXJuIGdldE91dGVybW9zdE5vZGUyKGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdLCAicmlnaHQiKTsKICAgICAgfSBlbHNlIGlmIChzaWRlID09PSAibGVmdCIpIHsKICAgICAgICByZXR1cm4gZ2V0T3V0ZXJtb3N0Tm9kZTIoY2hpbGRyZW5bMF0sICJsZWZ0Iik7CiAgICAgIH0KICAgIH0KICB9CiAgcmV0dXJuIG5vZGU7Cn07CnZhciBnZXRUeXBlT2ZEb21UcmVlID0gZnVuY3Rpb24gZ2V0VHlwZU9mRG9tVHJlZTIobm9kZSwgc2lkZSkgewogIGlmICghbm9kZSkgewogICAgcmV0dXJuIG51bGw7CiAgfQogIGlmIChzaWRlKSB7CiAgICBub2RlID0gZ2V0T3V0ZXJtb3N0Tm9kZShub2RlLCBzaWRlKTsKICB9CiAgcmV0dXJuIERvbUVudW1bbm9kZS5jbGFzc2VzWzBdXSB8fCBudWxsOwp9Owp2YXIgbWFrZU51bGxEZWxpbWl0ZXIgPSBmdW5jdGlvbiBtYWtlTnVsbERlbGltaXRlcjIob3B0aW9ucywgY2xhc3NlcykgewogIHZhciBtb3JlQ2xhc3NlcyA9IFsibnVsbGRlbGltaXRlciJdLmNvbmNhdChvcHRpb25zLmJhc2VTaXppbmdDbGFzc2VzKCkpOwogIHJldHVybiBtYWtlU3BhbiQxKGNsYXNzZXMuY29uY2F0KG1vcmVDbGFzc2VzKSk7Cn07CnZhciBidWlsZEdyb3VwJDEgPSBmdW5jdGlvbiBidWlsZEdyb3VwKGdyb3VwLCBvcHRpb25zLCBiYXNlT3B0aW9ucykgewogIGlmICghZ3JvdXApIHsKICAgIHJldHVybiBtYWtlU3BhbiQxKCk7CiAgfQogIGlmIChfaHRtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0pIHsKICAgIHZhciBncm91cE5vZGUgPSBfaHRtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0oZ3JvdXAsIG9wdGlvbnMpOwogICAgaWYgKGJhc2VPcHRpb25zICYmIG9wdGlvbnMuc2l6ZSAhPT0gYmFzZU9wdGlvbnMuc2l6ZSkgewogICAgICBncm91cE5vZGUgPSBtYWtlU3BhbiQxKG9wdGlvbnMuc2l6aW5nQ2xhc3NlcyhiYXNlT3B0aW9ucyksIFtncm91cE5vZGVdLCBvcHRpb25zKTsKICAgICAgdmFyIG11bHRpcGxpZXIgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gYmFzZU9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgICAgIGdyb3VwTm9kZS5oZWlnaHQgKj0gbXVsdGlwbGllcjsKICAgICAgZ3JvdXBOb2RlLmRlcHRoICo9IG11bHRpcGxpZXI7CiAgICB9CiAgICByZXR1cm4gZ3JvdXBOb2RlOwogIH0gZWxzZSB7CiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiR290IGdyb3VwIG9mIHVua25vd24gdHlwZTogJyIgKyBncm91cC50eXBlICsgIiciKTsKICB9Cn07CmZ1bmN0aW9uIGJ1aWxkSFRNTFVuYnJlYWthYmxlKGNoaWxkcmVuLCBvcHRpb25zKSB7CiAgdmFyIGJvZHkgPSBtYWtlU3BhbiQxKFsiYmFzZSJdLCBjaGlsZHJlbiwgb3B0aW9ucyk7CiAgdmFyIHN0cnV0ID0gbWFrZVNwYW4kMShbInN0cnV0Il0pOwogIHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShib2R5LmhlaWdodCArIGJvZHkuZGVwdGgpOwogIGlmIChib2R5LmRlcHRoKSB7CiAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1ib2R5LmRlcHRoKTsKICB9CiAgYm9keS5jaGlsZHJlbi51bnNoaWZ0KHN0cnV0KTsKICByZXR1cm4gYm9keTsKfQpmdW5jdGlvbiBidWlsZEhUTUwodHJlZSwgb3B0aW9ucykgewogIHZhciB0YWcgPSBudWxsOwogIGlmICh0cmVlLmxlbmd0aCA9PT0gMSAmJiB0cmVlWzBdLnR5cGUgPT09ICJ0YWciKSB7CiAgICB0YWcgPSB0cmVlWzBdLnRhZzsKICAgIHRyZWUgPSB0cmVlWzBdLmJvZHk7CiAgfQogIHZhciBleHByZXNzaW9uID0gYnVpbGRFeHByZXNzaW9uJDEodHJlZSwgb3B0aW9ucywgInJvb3QiKTsKICB2YXIgZXFuTnVtOwogIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMiAmJiBleHByZXNzaW9uWzFdLmhhc0NsYXNzKCJ0YWciKSkgewogICAgZXFuTnVtID0gZXhwcmVzc2lvbi5wb3AoKTsKICB9CiAgdmFyIGNoaWxkcmVuID0gW107CiAgdmFyIHBhcnRzID0gW107CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7CiAgICBwYXJ0cy5wdXNoKGV4cHJlc3Npb25baV0pOwogICAgaWYgKGV4cHJlc3Npb25baV0uaGFzQ2xhc3MoIm1iaW4iKSB8fCBleHByZXNzaW9uW2ldLmhhc0NsYXNzKCJtcmVsIikgfHwgZXhwcmVzc2lvbltpXS5oYXNDbGFzcygiYWxsb3dicmVhayIpKSB7CiAgICAgIHZhciBub2JyZWFrID0gZmFsc2U7CiAgICAgIHdoaWxlIChpIDwgZXhwcmVzc2lvbi5sZW5ndGggLSAxICYmIGV4cHJlc3Npb25baSArIDFdLmhhc0NsYXNzKCJtc3BhY2UiKSAmJiAhZXhwcmVzc2lvbltpICsgMV0uaGFzQ2xhc3MoIm5ld2xpbmUiKSkgewogICAgICAgIGkrKzsKICAgICAgICBwYXJ0cy5wdXNoKGV4cHJlc3Npb25baV0pOwogICAgICAgIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKCJub2JyZWFrIikpIHsKICAgICAgICAgIG5vYnJlYWsgPSB0cnVlOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoIW5vYnJlYWspIHsKICAgICAgICBjaGlsZHJlbi5wdXNoKGJ1aWxkSFRNTFVuYnJlYWthYmxlKHBhcnRzLCBvcHRpb25zKSk7CiAgICAgICAgcGFydHMgPSBbXTsKICAgICAgfQogICAgfSBlbHNlIGlmIChleHByZXNzaW9uW2ldLmhhc0NsYXNzKCJuZXdsaW5lIikpIHsKICAgICAgcGFydHMucG9wKCk7CiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAwKSB7CiAgICAgICAgY2hpbGRyZW4ucHVzaChidWlsZEhUTUxVbmJyZWFrYWJsZShwYXJ0cywgb3B0aW9ucykpOwogICAgICAgIHBhcnRzID0gW107CiAgICAgIH0KICAgICAgY2hpbGRyZW4ucHVzaChleHByZXNzaW9uW2ldKTsKICAgIH0KICB9CiAgaWYgKHBhcnRzLmxlbmd0aCA+IDApIHsKICAgIGNoaWxkcmVuLnB1c2goYnVpbGRIVE1MVW5icmVha2FibGUocGFydHMsIG9wdGlvbnMpKTsKICB9CiAgdmFyIHRhZ0NoaWxkOwogIGlmICh0YWcpIHsKICAgIHRhZ0NoaWxkID0gYnVpbGRIVE1MVW5icmVha2FibGUoYnVpbGRFeHByZXNzaW9uJDEodGFnLCBvcHRpb25zLCB0cnVlKSk7CiAgICB0YWdDaGlsZC5jbGFzc2VzID0gWyJ0YWciXTsKICAgIGNoaWxkcmVuLnB1c2godGFnQ2hpbGQpOwogIH0gZWxzZSBpZiAoZXFuTnVtKSB7CiAgICBjaGlsZHJlbi5wdXNoKGVxbk51bSk7CiAgfQogIHZhciBodG1sTm9kZSA9IG1ha2VTcGFuJDEoWyJrYXRleC1odG1sIl0sIGNoaWxkcmVuKTsKICBodG1sTm9kZS5zZXRBdHRyaWJ1dGUoImFyaWEtaGlkZGVuIiwgInRydWUiKTsKICBpZiAodGFnQ2hpbGQpIHsKICAgIHZhciBzdHJ1dCA9IHRhZ0NoaWxkLmNoaWxkcmVuWzBdOwogICAgc3RydXQuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGh0bWxOb2RlLmhlaWdodCArIGh0bWxOb2RlLmRlcHRoKTsKICAgIGlmIChodG1sTm9kZS5kZXB0aCkgewogICAgICBzdHJ1dC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1odG1sTm9kZS5kZXB0aCk7CiAgICB9CiAgfQogIHJldHVybiBodG1sTm9kZTsKfQpmdW5jdGlvbiBuZXdEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKSB7CiAgcmV0dXJuIG5ldyBEb2N1bWVudEZyYWdtZW50KGNoaWxkcmVuKTsKfQp2YXIgTWF0aE5vZGUgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IodHlwZSwgY2hpbGRyZW4sIGNsYXNzZXMpIHsKICAgIHRoaXMudHlwZSA9IHZvaWQgMDsKICAgIHRoaXMuYXR0cmlidXRlcyA9IHZvaWQgMDsKICAgIHRoaXMuY2hpbGRyZW4gPSB2b2lkIDA7CiAgICB0aGlzLmNsYXNzZXMgPSB2b2lkIDA7CiAgICB0aGlzLnR5cGUgPSB0eXBlOwogICAgdGhpcy5hdHRyaWJ1dGVzID0ge307CiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW4gfHwgW107CiAgICB0aGlzLmNsYXNzZXMgPSBjbGFzc2VzIHx8IFtdOwogIH0KICAvKioKICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiBhIE1hdGhNTCBub2RlLiBNYXRoTUwgZGVwZW5kcyBvbiBhdHRyaWJ1dGVzIHRvIGNvbnZleSBhCiAgICogc2VtYW50aWMgY29udGVudCwgc28gdGhpcyBpcyB1c2VkIGhlYXZpbHkuCiAgICovCiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7CiAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTsKICB9CiAgLyoqCiAgICogR2V0cyBhbiBhdHRyaWJ1dGUgb24gYSBNYXRoTUwgbm9kZS4KICAgKi8KICBnZXRBdHRyaWJ1dGUobmFtZSkgewogICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1tuYW1lXTsKICB9CiAgLyoqCiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGEgTWF0aE1MLW5hbWVzcGFjZWQgRE9NIGVsZW1lbnQuCiAgICovCiAgdG9Ob2RlKCkgewogICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwiLCB0aGlzLnR5cGUpOwogICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHsKICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7CiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgdGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTsKICAgICAgfQogICAgfQogICAgaWYgKHRoaXMuY2xhc3Nlcy5sZW5ndGggPiAwKSB7CiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3JlYXRlQ2xhc3ModGhpcy5jbGFzc2VzKTsKICAgIH0KICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykgewogICAgICBpZiAodGhpcy5jaGlsZHJlbltpXSBpbnN0YW5jZW9mIFRleHROb2RlICYmIHRoaXMuY2hpbGRyZW5baSArIDFdIGluc3RhbmNlb2YgVGV4dE5vZGUpIHsKICAgICAgICB2YXIgdGV4dDIgPSB0aGlzLmNoaWxkcmVuW2ldLnRvVGV4dCgpICsgdGhpcy5jaGlsZHJlblsrK2ldLnRvVGV4dCgpOwogICAgICAgIHdoaWxlICh0aGlzLmNoaWxkcmVuW2kgKyAxXSBpbnN0YW5jZW9mIFRleHROb2RlKSB7CiAgICAgICAgICB0ZXh0MiArPSB0aGlzLmNoaWxkcmVuWysraV0udG9UZXh0KCk7CiAgICAgICAgfQogICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3IFRleHROb2RlKHRleHQyKS50b05vZGUoKSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNoaWxkcmVuW2ldLnRvTm9kZSgpKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQogIC8qKgogICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhbiBIVE1MIG1hcmt1cCBzdHJpbmcuCiAgICovCiAgdG9NYXJrdXAoKSB7CiAgICB2YXIgbWFya3VwID0gIjwiICsgdGhpcy50eXBlOwogICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJpYnV0ZXMpIHsKICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmF0dHJpYnV0ZXMsIGF0dHIpKSB7CiAgICAgICAgbWFya3VwICs9ICIgIiArIGF0dHIgKyAnPSInOwogICAgICAgIG1hcmt1cCArPSB1dGlscy5lc2NhcGUodGhpcy5hdHRyaWJ1dGVzW2F0dHJdKTsKICAgICAgICBtYXJrdXAgKz0gJyInOwogICAgICB9CiAgICB9CiAgICBpZiAodGhpcy5jbGFzc2VzLmxlbmd0aCA+IDApIHsKICAgICAgbWFya3VwICs9ICcgY2xhc3MgPSInICsgdXRpbHMuZXNjYXBlKGNyZWF0ZUNsYXNzKHRoaXMuY2xhc3NlcykpICsgJyInOwogICAgfQogICAgbWFya3VwICs9ICI+IjsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykgewogICAgICBtYXJrdXAgKz0gdGhpcy5jaGlsZHJlbltpXS50b01hcmt1cCgpOwogICAgfQogICAgbWFya3VwICs9ICI8LyIgKyB0aGlzLnR5cGUgKyAiPiI7CiAgICByZXR1cm4gbWFya3VwOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBzdHJpbmcsIHNpbWlsYXIgdG8gaW5uZXJUZXh0LCBidXQgZXNjYXBlZC4KICAgKi8KICB0b1RleHQoKSB7CiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC50b1RleHQoKSkuam9pbigiIik7CiAgfQp9Owp2YXIgVGV4dE5vZGUgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IodGV4dDIpIHsKICAgIHRoaXMudGV4dCA9IHZvaWQgMDsKICAgIHRoaXMudGV4dCA9IHRleHQyOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gYSBET00gdGV4dCBub2RlLgogICAqLwogIHRvTm9kZSgpIHsKICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyB0aGUgdGV4dCBub2RlIGludG8gZXNjYXBlZCBIVE1MIG1hcmt1cAogICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS4KICAgKi8KICB0b01hcmt1cCgpIHsKICAgIHJldHVybiB1dGlscy5lc2NhcGUodGhpcy50b1RleHQoKSk7CiAgfQogIC8qKgogICAqIENvbnZlcnRzIHRoZSB0ZXh0IG5vZGUgaW50byBhIHN0cmluZwogICAqIChyZXByZXNlbnRpbmcgdGhlIHRleHQgaXRzZWxmKS4KICAgKi8KICB0b1RleHQoKSB7CiAgICByZXR1cm4gdGhpcy50ZXh0OwogIH0KfTsKdmFyIFNwYWNlTm9kZSA9IGNsYXNzIHsKICAvKioKICAgKiBDcmVhdGUgYSBTcGFjZSBub2RlIHdpdGggd2lkdGggZ2l2ZW4gaW4gQ1NTIGVtcy4KICAgKi8KICBjb25zdHJ1Y3Rvcih3aWR0aCkgewogICAgdGhpcy53aWR0aCA9IHZvaWQgMDsKICAgIHRoaXMuY2hhcmFjdGVyID0gdm9pZCAwOwogICAgdGhpcy53aWR0aCA9IHdpZHRoOwogICAgaWYgKHdpZHRoID49IDAuMDU1NTUgJiYgd2lkdGggPD0gMC4wNTU1NikgewogICAgICB0aGlzLmNoYXJhY3RlciA9ICLigIoiOwogICAgfSBlbHNlIGlmICh3aWR0aCA+PSAwLjE2NjYgJiYgd2lkdGggPD0gMC4xNjY3KSB7CiAgICAgIHRoaXMuY2hhcmFjdGVyID0gIuKAiSI7CiAgICB9IGVsc2UgaWYgKHdpZHRoID49IDAuMjIyMiAmJiB3aWR0aCA8PSAwLjIyMjMpIHsKICAgICAgdGhpcy5jaGFyYWN0ZXIgPSAi4oCFIjsKICAgIH0gZWxzZSBpZiAod2lkdGggPj0gMC4yNzc3ICYmIHdpZHRoIDw9IDAuMjc3OCkgewogICAgICB0aGlzLmNoYXJhY3RlciA9ICLigIXigIoiOwogICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4wNTU1NiAmJiB3aWR0aCA8PSAtMC4wNTU1NSkgewogICAgICB0aGlzLmNoYXJhY3RlciA9ICLigIrigaMiOwogICAgfSBlbHNlIGlmICh3aWR0aCA+PSAtMC4xNjY3ICYmIHdpZHRoIDw9IC0wLjE2NjYpIHsKICAgICAgdGhpcy5jaGFyYWN0ZXIgPSAi4oCJ4oGjIjsKICAgIH0gZWxzZSBpZiAod2lkdGggPj0gLTAuMjIyMyAmJiB3aWR0aCA8PSAtMC4yMjIyKSB7CiAgICAgIHRoaXMuY2hhcmFjdGVyID0gIuKBn+KBoyI7CiAgICB9IGVsc2UgaWYgKHdpZHRoID49IC0wLjI3NzggJiYgd2lkdGggPD0gLTAuMjc3NykgewogICAgICB0aGlzLmNoYXJhY3RlciA9ICLigIXigaMiOwogICAgfSBlbHNlIHsKICAgICAgdGhpcy5jaGFyYWN0ZXIgPSBudWxsOwogICAgfQogIH0KICAvKioKICAgKiBDb252ZXJ0cyB0aGUgbWF0aCBub2RlIGludG8gYSBNYXRoTUwtbmFtZXNwYWNlZCBET00gZWxlbWVudC4KICAgKi8KICB0b05vZGUoKSB7CiAgICBpZiAodGhpcy5jaGFyYWN0ZXIpIHsKICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMuY2hhcmFjdGVyKTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MIiwgIm1zcGFjZSIpOwogICAgICBub2RlLnNldEF0dHJpYnV0ZSgid2lkdGgiLCBtYWtlRW0odGhpcy53aWR0aCkpOwogICAgICByZXR1cm4gbm9kZTsKICAgIH0KICB9CiAgLyoqCiAgICogQ29udmVydHMgdGhlIG1hdGggbm9kZSBpbnRvIGFuIEhUTUwgbWFya3VwIHN0cmluZy4KICAgKi8KICB0b01hcmt1cCgpIHsKICAgIGlmICh0aGlzLmNoYXJhY3RlcikgewogICAgICByZXR1cm4gIjxtdGV4dD4iICsgdGhpcy5jaGFyYWN0ZXIgKyAiPC9tdGV4dD4iOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICc8bXNwYWNlIHdpZHRoPSInICsgbWFrZUVtKHRoaXMud2lkdGgpICsgJyIvPic7CiAgICB9CiAgfQogIC8qKgogICAqIENvbnZlcnRzIHRoZSBtYXRoIG5vZGUgaW50byBhIHN0cmluZywgc2ltaWxhciB0byBpbm5lclRleHQuCiAgICovCiAgdG9UZXh0KCkgewogICAgaWYgKHRoaXMuY2hhcmFjdGVyKSB7CiAgICAgIHJldHVybiB0aGlzLmNoYXJhY3RlcjsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiAiICI7CiAgICB9CiAgfQp9Owp2YXIgbWF0aE1MVHJlZSA9IHsKICBNYXRoTm9kZSwKICBUZXh0Tm9kZSwKICBTcGFjZU5vZGUsCiAgbmV3RG9jdW1lbnRGcmFnbWVudAp9Owp2YXIgbWFrZVRleHQgPSBmdW5jdGlvbiBtYWtlVGV4dDIodGV4dDIsIG1vZGUsIG9wdGlvbnMpIHsKICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0Ml0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0Ml0ucmVwbGFjZSAmJiB0ZXh0Mi5jaGFyQ29kZUF0KDApICE9PSA1NTM0OSAmJiAhKGxpZ2F0dXJlcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0MikgJiYgb3B0aW9ucyAmJiAob3B0aW9ucy5mb250RmFtaWx5ICYmIG9wdGlvbnMuZm9udEZhbWlseS5zbGljZSg0LCA2KSA9PT0gInR0IiB8fCBvcHRpb25zLmZvbnQgJiYgb3B0aW9ucy5mb250LnNsaWNlKDQsIDYpID09PSAidHQiKSkpIHsKICAgIHRleHQyID0gc3ltYm9sc1ttb2RlXVt0ZXh0Ml0ucmVwbGFjZTsKICB9CiAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlRleHROb2RlKHRleHQyKTsKfTsKdmFyIG1ha2VSb3cgPSBmdW5jdGlvbiBtYWtlUm93Mihib2R5KSB7CiAgaWYgKGJvZHkubGVuZ3RoID09PSAxKSB7CiAgICByZXR1cm4gYm9keVswXTsKICB9IGVsc2UgewogICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcm93IiwgYm9keSk7CiAgfQp9Owp2YXIgZ2V0VmFyaWFudCA9IGZ1bmN0aW9uIGdldFZhcmlhbnQyKGdyb3VwLCBvcHRpb25zKSB7CiAgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gInRleHR0dCIpIHsKICAgIHJldHVybiAibW9ub3NwYWNlIjsKICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udEZhbWlseSA9PT0gInRleHRzZiIpIHsKICAgIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gInRleHRpdCIgJiYgb3B0aW9ucy5mb250V2VpZ2h0ID09PSAidGV4dGJmIikgewogICAgICByZXR1cm4gInNhbnMtc2VyaWYtYm9sZC1pdGFsaWMiOwogICAgfSBlbHNlIGlmIChvcHRpb25zLmZvbnRTaGFwZSA9PT0gInRleHRpdCIpIHsKICAgICAgcmV0dXJuICJzYW5zLXNlcmlmLWl0YWxpYyI7CiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFdlaWdodCA9PT0gInRleHRiZiIpIHsKICAgICAgcmV0dXJuICJib2xkLXNhbnMtc2VyaWYiOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuICJzYW5zLXNlcmlmIjsKICAgIH0KICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSAidGV4dGl0IiAmJiBvcHRpb25zLmZvbnRXZWlnaHQgPT09ICJ0ZXh0YmYiKSB7CiAgICByZXR1cm4gImJvbGQtaXRhbGljIjsKICB9IGVsc2UgaWYgKG9wdGlvbnMuZm9udFNoYXBlID09PSAidGV4dGl0IikgewogICAgcmV0dXJuICJpdGFsaWMiOwogIH0gZWxzZSBpZiAob3B0aW9ucy5mb250V2VpZ2h0ID09PSAidGV4dGJmIikgewogICAgcmV0dXJuICJib2xkIjsKICB9CiAgdmFyIGZvbnQgPSBvcHRpb25zLmZvbnQ7CiAgaWYgKCFmb250IHx8IGZvbnQgPT09ICJtYXRobm9ybWFsIikgewogICAgcmV0dXJuIG51bGw7CiAgfQogIHZhciBtb2RlID0gZ3JvdXAubW9kZTsKICBpZiAoZm9udCA9PT0gIm1hdGhpdCIpIHsKICAgIHJldHVybiAiaXRhbGljIjsKICB9IGVsc2UgaWYgKGZvbnQgPT09ICJib2xkc3ltYm9sIikgewogICAgcmV0dXJuIGdyb3VwLnR5cGUgPT09ICJ0ZXh0b3JkIiA/ICJib2xkIiA6ICJib2xkLWl0YWxpYyI7CiAgfSBlbHNlIGlmIChmb250ID09PSAibWF0aGJmIikgewogICAgcmV0dXJuICJib2xkIjsKICB9IGVsc2UgaWYgKGZvbnQgPT09ICJtYXRoYmIiKSB7CiAgICByZXR1cm4gImRvdWJsZS1zdHJ1Y2siOwogIH0gZWxzZSBpZiAoZm9udCA9PT0gIm1hdGhzZml0IikgewogICAgcmV0dXJuICJzYW5zLXNlcmlmLWl0YWxpYyI7CiAgfSBlbHNlIGlmIChmb250ID09PSAibWF0aGZyYWsiKSB7CiAgICByZXR1cm4gImZyYWt0dXIiOwogIH0gZWxzZSBpZiAoZm9udCA9PT0gIm1hdGhzY3IiIHx8IGZvbnQgPT09ICJtYXRoY2FsIikgewogICAgcmV0dXJuICJzY3JpcHQiOwogIH0gZWxzZSBpZiAoZm9udCA9PT0gIm1hdGhzZiIpIHsKICAgIHJldHVybiAic2Fucy1zZXJpZiI7CiAgfSBlbHNlIGlmIChmb250ID09PSAibWF0aHR0IikgewogICAgcmV0dXJuICJtb25vc3BhY2UiOwogIH0KICB2YXIgdGV4dDIgPSBncm91cC50ZXh0OwogIGlmICh1dGlscy5jb250YWlucyhbIlxcaW1hdGgiLCAiXFxqbWF0aCJdLCB0ZXh0MikpIHsKICAgIHJldHVybiBudWxsOwogIH0KICBpZiAoc3ltYm9sc1ttb2RlXVt0ZXh0Ml0gJiYgc3ltYm9sc1ttb2RlXVt0ZXh0Ml0ucmVwbGFjZSkgewogICAgdGV4dDIgPSBzeW1ib2xzW21vZGVdW3RleHQyXS5yZXBsYWNlOwogIH0KICB2YXIgZm9udE5hbWUgPSBidWlsZENvbW1vbi5mb250TWFwW2ZvbnRdLmZvbnROYW1lOwogIGlmIChnZXRDaGFyYWN0ZXJNZXRyaWNzKHRleHQyLCBmb250TmFtZSwgbW9kZSkpIHsKICAgIHJldHVybiBidWlsZENvbW1vbi5mb250TWFwW2ZvbnRdLnZhcmlhbnQ7CiAgfQogIHJldHVybiBudWxsOwp9OwpmdW5jdGlvbiBpc051bWJlclB1bmN0dWF0aW9uKGdyb3VwKSB7CiAgaWYgKCFncm91cCkgewogICAgcmV0dXJuIGZhbHNlOwogIH0KICBpZiAoZ3JvdXAudHlwZSA9PT0gIm1pIiAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHsKICAgIHZhciBjaGlsZCA9IGdyb3VwLmNoaWxkcmVuWzBdOwogICAgcmV0dXJuIGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dCA9PT0gIi4iOwogIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gIm1vIiAmJiBncm91cC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgZ3JvdXAuZ2V0QXR0cmlidXRlKCJzZXBhcmF0b3IiKSA9PT0gInRydWUiICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgibHNwYWNlIikgPT09ICIwZW0iICYmIGdyb3VwLmdldEF0dHJpYnV0ZSgicnNwYWNlIikgPT09ICIwZW0iKSB7CiAgICB2YXIgX2NoaWxkID0gZ3JvdXAuY2hpbGRyZW5bMF07CiAgICByZXR1cm4gX2NoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgX2NoaWxkLnRleHQgPT09ICIsIjsKICB9IGVsc2UgewogICAgcmV0dXJuIGZhbHNlOwogIH0KfQp2YXIgYnVpbGRFeHByZXNzaW9uMiA9IGZ1bmN0aW9uIGJ1aWxkRXhwcmVzc2lvbjMoZXhwcmVzc2lvbiwgb3B0aW9ucywgaXNPcmRncm91cCkgewogIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSkgewogICAgdmFyIGdyb3VwID0gYnVpbGRHcm91cDIoZXhwcmVzc2lvblswXSwgb3B0aW9ucyk7CiAgICBpZiAoaXNPcmRncm91cCAmJiBncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGdyb3VwLnR5cGUgPT09ICJtbyIpIHsKICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKCJsc3BhY2UiLCAiMGVtIik7CiAgICAgIGdyb3VwLnNldEF0dHJpYnV0ZSgicnNwYWNlIiwgIjBlbSIpOwogICAgfQogICAgcmV0dXJuIFtncm91cF07CiAgfQogIHZhciBncm91cHMgPSBbXTsKICB2YXIgbGFzdEdyb3VwOwogIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwcmVzc2lvbi5sZW5ndGg7IGkrKykgewogICAgdmFyIF9ncm91cCA9IGJ1aWxkR3JvdXAyKGV4cHJlc3Npb25baV0sIG9wdGlvbnMpOwogICAgaWYgKF9ncm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGxhc3RHcm91cCBpbnN0YW5jZW9mIE1hdGhOb2RlKSB7CiAgICAgIGlmIChfZ3JvdXAudHlwZSA9PT0gIm10ZXh0IiAmJiBsYXN0R3JvdXAudHlwZSA9PT0gIm10ZXh0IiAmJiBfZ3JvdXAuZ2V0QXR0cmlidXRlKCJtYXRodmFyaWFudCIpID09PSBsYXN0R3JvdXAuZ2V0QXR0cmlidXRlKCJtYXRodmFyaWFudCIpKSB7CiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uX2dyb3VwLmNoaWxkcmVuKTsKICAgICAgICBjb250aW51ZTsKICAgICAgfSBlbHNlIGlmIChfZ3JvdXAudHlwZSA9PT0gIm1uIiAmJiBsYXN0R3JvdXAudHlwZSA9PT0gIm1uIikgewogICAgICAgIGxhc3RHcm91cC5jaGlsZHJlbi5wdXNoKC4uLl9ncm91cC5jaGlsZHJlbik7CiAgICAgICAgY29udGludWU7CiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXJQdW5jdHVhdGlvbihfZ3JvdXApICYmIGxhc3RHcm91cC50eXBlID09PSAibW4iKSB7CiAgICAgICAgbGFzdEdyb3VwLmNoaWxkcmVuLnB1c2goLi4uX2dyb3VwLmNoaWxkcmVuKTsKICAgICAgICBjb250aW51ZTsKICAgICAgfSBlbHNlIGlmIChfZ3JvdXAudHlwZSA9PT0gIm1uIiAmJiBpc051bWJlclB1bmN0dWF0aW9uKGxhc3RHcm91cCkpIHsKICAgICAgICBfZ3JvdXAuY2hpbGRyZW4gPSBbLi4ubGFzdEdyb3VwLmNoaWxkcmVuLCAuLi5fZ3JvdXAuY2hpbGRyZW5dOwogICAgICAgIGdyb3Vwcy5wb3AoKTsKICAgICAgfSBlbHNlIGlmICgoX2dyb3VwLnR5cGUgPT09ICJtc3VwIiB8fCBfZ3JvdXAudHlwZSA9PT0gIm1zdWIiKSAmJiBfZ3JvdXAuY2hpbGRyZW4ubGVuZ3RoID49IDEgJiYgKGxhc3RHcm91cC50eXBlID09PSAibW4iIHx8IGlzTnVtYmVyUHVuY3R1YXRpb24obGFzdEdyb3VwKSkpIHsKICAgICAgICB2YXIgYmFzZSA9IF9ncm91cC5jaGlsZHJlblswXTsKICAgICAgICBpZiAoYmFzZSBpbnN0YW5jZW9mIE1hdGhOb2RlICYmIGJhc2UudHlwZSA9PT0gIm1uIikgewogICAgICAgICAgYmFzZS5jaGlsZHJlbiA9IFsuLi5sYXN0R3JvdXAuY2hpbGRyZW4sIC4uLmJhc2UuY2hpbGRyZW5dOwogICAgICAgICAgZ3JvdXBzLnBvcCgpOwogICAgICAgIH0KICAgICAgfSBlbHNlIGlmIChsYXN0R3JvdXAudHlwZSA9PT0gIm1pIiAmJiBsYXN0R3JvdXAuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7CiAgICAgICAgdmFyIGxhc3RDaGlsZCA9IGxhc3RHcm91cC5jaGlsZHJlblswXTsKICAgICAgICBpZiAobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgbGFzdENoaWxkLnRleHQgPT09ICLMuCIgJiYgKF9ncm91cC50eXBlID09PSAibW8iIHx8IF9ncm91cC50eXBlID09PSAibWkiIHx8IF9ncm91cC50eXBlID09PSAibW4iKSkgewogICAgICAgICAgdmFyIGNoaWxkID0gX2dyb3VwLmNoaWxkcmVuWzBdOwogICAgICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dE5vZGUgJiYgY2hpbGQudGV4dC5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnNsaWNlKDAsIDEpICsgIsy4IiArIGNoaWxkLnRleHQuc2xpY2UoMSk7CiAgICAgICAgICAgIGdyb3Vwcy5wb3AoKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGdyb3Vwcy5wdXNoKF9ncm91cCk7CiAgICBsYXN0R3JvdXAgPSBfZ3JvdXA7CiAgfQogIHJldHVybiBncm91cHM7Cn07CnZhciBidWlsZEV4cHJlc3Npb25Sb3cgPSBmdW5jdGlvbiBidWlsZEV4cHJlc3Npb25Sb3cyKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApIHsKICByZXR1cm4gbWFrZVJvdyhidWlsZEV4cHJlc3Npb24yKGV4cHJlc3Npb24sIG9wdGlvbnMsIGlzT3JkZ3JvdXApKTsKfTsKdmFyIGJ1aWxkR3JvdXAyID0gZnVuY3Rpb24gYnVpbGRHcm91cDMoZ3JvdXAsIG9wdGlvbnMpIHsKICBpZiAoIWdyb3VwKSB7CiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1yb3ciKTsKICB9CiAgaWYgKF9tYXRobWxHcm91cEJ1aWxkZXJzW2dyb3VwLnR5cGVdKSB7CiAgICB2YXIgcmVzdWx0ID0gX21hdGhtbEdyb3VwQnVpbGRlcnNbZ3JvdXAudHlwZV0oZ3JvdXAsIG9wdGlvbnMpOwogICAgcmV0dXJuIHJlc3VsdDsKICB9IGVsc2UgewogICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkdvdCBncm91cCBvZiB1bmtub3duIHR5cGU6ICciICsgZ3JvdXAudHlwZSArICInIik7CiAgfQp9OwpmdW5jdGlvbiBidWlsZE1hdGhNTCh0cmVlLCB0ZXhFeHByZXNzaW9uLCBvcHRpb25zLCBpc0Rpc3BsYXlNb2RlLCBmb3JNYXRobWxPbmx5KSB7CiAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24yKHRyZWUsIG9wdGlvbnMpOwogIHZhciB3cmFwcGVyOwogIGlmIChleHByZXNzaW9uLmxlbmd0aCA9PT0gMSAmJiBleHByZXNzaW9uWzBdIGluc3RhbmNlb2YgTWF0aE5vZGUgJiYgdXRpbHMuY29udGFpbnMoWyJtcm93IiwgIm10YWJsZSJdLCBleHByZXNzaW9uWzBdLnR5cGUpKSB7CiAgICB3cmFwcGVyID0gZXhwcmVzc2lvblswXTsKICB9IGVsc2UgewogICAgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcm93IiwgZXhwcmVzc2lvbik7CiAgfQogIHZhciBhbm5vdGF0aW9uID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoImFubm90YXRpb24iLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUodGV4RXhwcmVzc2lvbildKTsKICBhbm5vdGF0aW9uLnNldEF0dHJpYnV0ZSgiZW5jb2RpbmciLCAiYXBwbGljYXRpb24veC10ZXgiKTsKICB2YXIgc2VtYW50aWNzID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoInNlbWFudGljcyIsIFt3cmFwcGVyLCBhbm5vdGF0aW9uXSk7CiAgdmFyIG1hdGgyID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1hdGgiLCBbc2VtYW50aWNzXSk7CiAgbWF0aDIuc2V0QXR0cmlidXRlKCJ4bWxucyIsICJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MIik7CiAgaWYgKGlzRGlzcGxheU1vZGUpIHsKICAgIG1hdGgyLnNldEF0dHJpYnV0ZSgiZGlzcGxheSIsICJibG9jayIpOwogIH0KICB2YXIgd3JhcHBlckNsYXNzID0gZm9yTWF0aG1sT25seSA/ICJrYXRleCIgOiAia2F0ZXgtbWF0aG1sIjsKICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW3dyYXBwZXJDbGFzc10sIFttYXRoMl0pOwp9CnZhciBvcHRpb25zRnJvbVNldHRpbmdzID0gZnVuY3Rpb24gb3B0aW9uc0Zyb21TZXR0aW5nczIoc2V0dGluZ3MpIHsKICByZXR1cm4gbmV3IE9wdGlvbnMoewogICAgc3R5bGU6IHNldHRpbmdzLmRpc3BsYXlNb2RlID8gU3R5bGUkMS5ESVNQTEFZIDogU3R5bGUkMS5URVhULAogICAgbWF4U2l6ZTogc2V0dGluZ3MubWF4U2l6ZSwKICAgIG1pblJ1bGVUaGlja25lc3M6IHNldHRpbmdzLm1pblJ1bGVUaGlja25lc3MKICB9KTsKfTsKdmFyIGRpc3BsYXlXcmFwID0gZnVuY3Rpb24gZGlzcGxheVdyYXAyKG5vZGUsIHNldHRpbmdzKSB7CiAgaWYgKHNldHRpbmdzLmRpc3BsYXlNb2RlKSB7CiAgICB2YXIgY2xhc3NlcyA9IFsia2F0ZXgtZGlzcGxheSJdOwogICAgaWYgKHNldHRpbmdzLmxlcW5vKSB7CiAgICAgIGNsYXNzZXMucHVzaCgibGVxbm8iKTsKICAgIH0KICAgIGlmIChzZXR0aW5ncy5mbGVxbikgewogICAgICBjbGFzc2VzLnB1c2goImZsZXFuIik7CiAgICB9CiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oY2xhc3NlcywgW25vZGVdKTsKICB9CiAgcmV0dXJuIG5vZGU7Cn07CnZhciBidWlsZFRyZWUgPSBmdW5jdGlvbiBidWlsZFRyZWUyKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7CiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zRnJvbVNldHRpbmdzKHNldHRpbmdzKTsKICB2YXIga2F0ZXhOb2RlOwogIGlmIChzZXR0aW5ncy5vdXRwdXQgPT09ICJtYXRobWwiKSB7CiAgICByZXR1cm4gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgc2V0dGluZ3MuZGlzcGxheU1vZGUsIHRydWUpOwogIH0gZWxzZSBpZiAoc2V0dGluZ3Mub3V0cHV0ID09PSAiaHRtbCIpIHsKICAgIHZhciBodG1sTm9kZSA9IGJ1aWxkSFRNTCh0cmVlLCBvcHRpb25zKTsKICAgIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsia2F0ZXgiXSwgW2h0bWxOb2RlXSk7CiAgfSBlbHNlIHsKICAgIHZhciBtYXRoTUxOb2RlID0gYnVpbGRNYXRoTUwodHJlZSwgZXhwcmVzc2lvbiwgb3B0aW9ucywgc2V0dGluZ3MuZGlzcGxheU1vZGUsIGZhbHNlKTsKICAgIHZhciBfaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7CiAgICBrYXRleE5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbImthdGV4Il0sIFttYXRoTUxOb2RlLCBfaHRtbE5vZGVdKTsKICB9CiAgcmV0dXJuIGRpc3BsYXlXcmFwKGthdGV4Tm9kZSwgc2V0dGluZ3MpOwp9Owp2YXIgYnVpbGRIVE1MVHJlZSA9IGZ1bmN0aW9uIGJ1aWxkSFRNTFRyZWUyKHRyZWUsIGV4cHJlc3Npb24sIHNldHRpbmdzKSB7CiAgdmFyIG9wdGlvbnMgPSBvcHRpb25zRnJvbVNldHRpbmdzKHNldHRpbmdzKTsKICB2YXIgaHRtbE5vZGUgPSBidWlsZEhUTUwodHJlZSwgb3B0aW9ucyk7CiAgdmFyIGthdGV4Tm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsia2F0ZXgiXSwgW2h0bWxOb2RlXSk7CiAgcmV0dXJuIGRpc3BsYXlXcmFwKGthdGV4Tm9kZSwgc2V0dGluZ3MpOwp9Owp2YXIgc3RyZXRjaHlDb2RlUG9pbnQgPSB7CiAgd2lkZWhhdDogIl4iLAogIHdpZGVjaGVjazogIsuHIiwKICB3aWRldGlsZGU6ICJ+IiwKICB1dGlsZGU6ICJ+IiwKICBvdmVybGVmdGFycm93OiAi4oaQIiwKICB1bmRlcmxlZnRhcnJvdzogIuKGkCIsCiAgeGxlZnRhcnJvdzogIuKGkCIsCiAgb3ZlcnJpZ2h0YXJyb3c6ICLihpIiLAogIHVuZGVycmlnaHRhcnJvdzogIuKGkiIsCiAgeHJpZ2h0YXJyb3c6ICLihpIiLAogIHVuZGVyYnJhY2U6ICLij58iLAogIG92ZXJicmFjZTogIuKPniIsCiAgb3Zlcmdyb3VwOiAi4o+gIiwKICB1bmRlcmdyb3VwOiAi4o+hIiwKICBvdmVybGVmdHJpZ2h0YXJyb3c6ICLihpQiLAogIHVuZGVybGVmdHJpZ2h0YXJyb3c6ICLihpQiLAogIHhsZWZ0cmlnaHRhcnJvdzogIuKGlCIsCiAgT3ZlcnJpZ2h0YXJyb3c6ICLih5IiLAogIHhSaWdodGFycm93OiAi4oeSIiwKICBvdmVybGVmdGhhcnBvb246ICLihrwiLAogIHhsZWZ0aGFycG9vbnVwOiAi4oa8IiwKICBvdmVycmlnaHRoYXJwb29uOiAi4oeAIiwKICB4cmlnaHRoYXJwb29udXA6ICLih4AiLAogIHhMZWZ0YXJyb3c6ICLih5AiLAogIHhMZWZ0cmlnaHRhcnJvdzogIuKHlCIsCiAgeGhvb2tsZWZ0YXJyb3c6ICLihqkiLAogIHhob29rcmlnaHRhcnJvdzogIuKGqiIsCiAgeG1hcHN0bzogIuKGpiIsCiAgeHJpZ2h0aGFycG9vbmRvd246ICLih4EiLAogIHhsZWZ0aGFycG9vbmRvd246ICLihr0iLAogIHhyaWdodGxlZnRoYXJwb29uczogIuKHjCIsCiAgeGxlZnRyaWdodGhhcnBvb25zOiAi4oeLIiwKICB4dHdvaGVhZGxlZnRhcnJvdzogIuKGniIsCiAgeHR3b2hlYWRyaWdodGFycm93OiAi4oagIiwKICB4bG9uZ2VxdWFsOiAiPSIsCiAgeHRvZnJvbTogIuKHhCIsCiAgeHJpZ2h0bGVmdGFycm93czogIuKHhCIsCiAgeHJpZ2h0ZXF1aWxpYnJpdW06ICLih4wiLAogIC8vIE5vdCBhIHBlcmZlY3QgbWF0Y2guCiAgeGxlZnRlcXVpbGlicml1bTogIuKHiyIsCiAgLy8gTm9uZSBiZXR0ZXIgYXZhaWxhYmxlLgogICJcXGNkcmlnaHRhcnJvdyI6ICLihpIiLAogICJcXGNkbGVmdGFycm93IjogIuKGkCIsCiAgIlxcY2Rsb25nZXF1YWwiOiAiPSIKfTsKdmFyIG1hdGhNTG5vZGUgPSBmdW5jdGlvbiBtYXRoTUxub2RlMihsYWJlbCkgewogIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1vIiwgW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHN0cmV0Y2h5Q29kZVBvaW50W2xhYmVsLnJlcGxhY2UoL15cXC8sICIiKV0pXSk7CiAgbm9kZS5zZXRBdHRyaWJ1dGUoInN0cmV0Y2h5IiwgInRydWUiKTsKICByZXR1cm4gbm9kZTsKfTsKdmFyIGthdGV4SW1hZ2VzRGF0YSA9IHsKICAvLyAgIHBhdGgocyksIG1pbldpZHRoLCBoZWlnaHQsIGFsaWduCiAgb3ZlcnJpZ2h0YXJyb3c6IFtbInJpZ2h0YXJyb3ciXSwgMC44ODgsIDUyMiwgInhNYXhZTWluIl0sCiAgb3ZlcmxlZnRhcnJvdzogW1sibGVmdGFycm93Il0sIDAuODg4LCA1MjIsICJ4TWluWU1pbiJdLAogIHVuZGVycmlnaHRhcnJvdzogW1sicmlnaHRhcnJvdyJdLCAwLjg4OCwgNTIyLCAieE1heFlNaW4iXSwKICB1bmRlcmxlZnRhcnJvdzogW1sibGVmdGFycm93Il0sIDAuODg4LCA1MjIsICJ4TWluWU1pbiJdLAogIHhyaWdodGFycm93OiBbWyJyaWdodGFycm93Il0sIDEuNDY5LCA1MjIsICJ4TWF4WU1pbiJdLAogICJcXGNkcmlnaHRhcnJvdyI6IFtbInJpZ2h0YXJyb3ciXSwgMywgNTIyLCAieE1heFlNaW4iXSwKICAvLyBDRCBtaW53d2lkdGgyLjVwYwogIHhsZWZ0YXJyb3c6IFtbImxlZnRhcnJvdyJdLCAxLjQ2OSwgNTIyLCAieE1pbllNaW4iXSwKICAiXFxjZGxlZnRhcnJvdyI6IFtbImxlZnRhcnJvdyJdLCAzLCA1MjIsICJ4TWluWU1pbiJdLAogIE92ZXJyaWdodGFycm93OiBbWyJkb3VibGVyaWdodGFycm93Il0sIDAuODg4LCA1NjAsICJ4TWF4WU1pbiJdLAogIHhSaWdodGFycm93OiBbWyJkb3VibGVyaWdodGFycm93Il0sIDEuNTI2LCA1NjAsICJ4TWF4WU1pbiJdLAogIHhMZWZ0YXJyb3c6IFtbImRvdWJsZWxlZnRhcnJvdyJdLCAxLjUyNiwgNTYwLCAieE1pbllNaW4iXSwKICBvdmVybGVmdGhhcnBvb246IFtbImxlZnRoYXJwb29uIl0sIDAuODg4LCA1MjIsICJ4TWluWU1pbiJdLAogIHhsZWZ0aGFycG9vbnVwOiBbWyJsZWZ0aGFycG9vbiJdLCAwLjg4OCwgNTIyLCAieE1pbllNaW4iXSwKICB4bGVmdGhhcnBvb25kb3duOiBbWyJsZWZ0aGFycG9vbmRvd24iXSwgMC44ODgsIDUyMiwgInhNaW5ZTWluIl0sCiAgb3ZlcnJpZ2h0aGFycG9vbjogW1sicmlnaHRoYXJwb29uIl0sIDAuODg4LCA1MjIsICJ4TWF4WU1pbiJdLAogIHhyaWdodGhhcnBvb251cDogW1sicmlnaHRoYXJwb29uIl0sIDAuODg4LCA1MjIsICJ4TWF4WU1pbiJdLAogIHhyaWdodGhhcnBvb25kb3duOiBbWyJyaWdodGhhcnBvb25kb3duIl0sIDAuODg4LCA1MjIsICJ4TWF4WU1pbiJdLAogIHhsb25nZXF1YWw6IFtbImxvbmdlcXVhbCJdLCAwLjg4OCwgMzM0LCAieE1pbllNaW4iXSwKICAiXFxjZGxvbmdlcXVhbCI6IFtbImxvbmdlcXVhbCJdLCAzLCAzMzQsICJ4TWluWU1pbiJdLAogIHh0d29oZWFkbGVmdGFycm93OiBbWyJ0d29oZWFkbGVmdGFycm93Il0sIDAuODg4LCAzMzQsICJ4TWluWU1pbiJdLAogIHh0d29oZWFkcmlnaHRhcnJvdzogW1sidHdvaGVhZHJpZ2h0YXJyb3ciXSwgMC44ODgsIDMzNCwgInhNYXhZTWluIl0sCiAgb3ZlcmxlZnRyaWdodGFycm93OiBbWyJsZWZ0YXJyb3ciLCAicmlnaHRhcnJvdyJdLCAwLjg4OCwgNTIyXSwKICBvdmVyYnJhY2U6IFtbImxlZnRicmFjZSIsICJtaWRicmFjZSIsICJyaWdodGJyYWNlIl0sIDEuNiwgNTQ4XSwKICB1bmRlcmJyYWNlOiBbWyJsZWZ0YnJhY2V1bmRlciIsICJtaWRicmFjZXVuZGVyIiwgInJpZ2h0YnJhY2V1bmRlciJdLCAxLjYsIDU0OF0sCiAgdW5kZXJsZWZ0cmlnaHRhcnJvdzogW1sibGVmdGFycm93IiwgInJpZ2h0YXJyb3ciXSwgMC44ODgsIDUyMl0sCiAgeGxlZnRyaWdodGFycm93OiBbWyJsZWZ0YXJyb3ciLCAicmlnaHRhcnJvdyJdLCAxLjc1LCA1MjJdLAogIHhMZWZ0cmlnaHRhcnJvdzogW1siZG91YmxlbGVmdGFycm93IiwgImRvdWJsZXJpZ2h0YXJyb3ciXSwgMS43NSwgNTYwXSwKICB4cmlnaHRsZWZ0aGFycG9vbnM6IFtbImxlZnRoYXJwb29uZG93bnBsdXMiLCAicmlnaHRoYXJwb29ucGx1cyJdLCAxLjc1LCA3MTZdLAogIHhsZWZ0cmlnaHRoYXJwb29uczogW1sibGVmdGhhcnBvb25wbHVzIiwgInJpZ2h0aGFycG9vbmRvd25wbHVzIl0sIDEuNzUsIDcxNl0sCiAgeGhvb2tsZWZ0YXJyb3c6IFtbImxlZnRhcnJvdyIsICJyaWdodGhvb2siXSwgMS4wOCwgNTIyXSwKICB4aG9va3JpZ2h0YXJyb3c6IFtbImxlZnRob29rIiwgInJpZ2h0YXJyb3ciXSwgMS4wOCwgNTIyXSwKICBvdmVybGluZXNlZ21lbnQ6IFtbImxlZnRsaW5lc2VnbWVudCIsICJyaWdodGxpbmVzZWdtZW50Il0sIDAuODg4LCA1MjJdLAogIHVuZGVybGluZXNlZ21lbnQ6IFtbImxlZnRsaW5lc2VnbWVudCIsICJyaWdodGxpbmVzZWdtZW50Il0sIDAuODg4LCA1MjJdLAogIG92ZXJncm91cDogW1sibGVmdGdyb3VwIiwgInJpZ2h0Z3JvdXAiXSwgMC44ODgsIDM0Ml0sCiAgdW5kZXJncm91cDogW1sibGVmdGdyb3VwdW5kZXIiLCAicmlnaHRncm91cHVuZGVyIl0sIDAuODg4LCAzNDJdLAogIHhtYXBzdG86IFtbImxlZnRtYXBzdG8iLCAicmlnaHRhcnJvdyJdLCAxLjUsIDUyMl0sCiAgeHRvZnJvbTogW1sibGVmdFRvRnJvbSIsICJyaWdodFRvRnJvbSJdLCAxLjc1LCA1MjhdLAogIC8vIFRoZSBuZXh0IHRocmVlIGFycm93cyBhcmUgZnJvbSB0aGUgbWhjaGVtIHBhY2thZ2UuCiAgLy8gSW4gbWhjaGVtLnN0eSwgbWluLWxlbmd0aCBpcyAyLjBlbS4gQnV0IHRoZXNlIGFycm93cyBtaWdodCBhcHBlYXIgaW4gdGhlCiAgLy8gZG9jdW1lbnQgYXMgXHhyaWdodGFycm93IG9yIFx4cmlnaHRsZWZ0aGFycG9vbnMuIFRob3NlIGhhdmUKICAvLyBtaW4tbGVuZ3RoID0gMS43NWVtLCBzbyB3ZSBzZXQgbWluLWxlbmd0aCBvbiB0aGVzZSBuZXh0IHRocmVlIHRvIG1hdGNoLgogIHhyaWdodGxlZnRhcnJvd3M6IFtbImJhcmFib3ZlbGVmdGFycm93IiwgInJpZ2h0YXJyb3dhYm92ZWJhciJdLCAxLjc1LCA5MDFdLAogIHhyaWdodGVxdWlsaWJyaXVtOiBbWyJiYXJhYm92ZXNob3J0bGVmdGhhcnBvb24iLCAicmlnaHRoYXJwb29uYWJvdmVzaG9ydGJhciJdLCAxLjc1LCA3MTZdLAogIHhsZWZ0ZXF1aWxpYnJpdW06IFtbInNob3J0YmFyYWJvdmVsZWZ0aGFycG9vbiIsICJzaG9ydHJpZ2h0aGFycG9vbmFib3ZlYmFyIl0sIDEuNzUsIDcxNl0KfTsKdmFyIGdyb3VwTGVuZ3RoID0gZnVuY3Rpb24gZ3JvdXBMZW5ndGgyKGFyZykgewogIGlmIChhcmcudHlwZSA9PT0gIm9yZGdyb3VwIikgewogICAgcmV0dXJuIGFyZy5ib2R5Lmxlbmd0aDsKICB9IGVsc2UgewogICAgcmV0dXJuIDE7CiAgfQp9Owp2YXIgc3ZnU3BhbiA9IGZ1bmN0aW9uIHN2Z1NwYW4yKGdyb3VwLCBvcHRpb25zKSB7CiAgZnVuY3Rpb24gYnVpbGRTdmdTcGFuXygpIHsKICAgIHZhciB2aWV3Qm94V2lkdGggPSA0ZTU7CiAgICB2YXIgbGFiZWwgPSBncm91cC5sYWJlbC5zbGljZSgxKTsKICAgIGlmICh1dGlscy5jb250YWlucyhbIndpZGVoYXQiLCAid2lkZWNoZWNrIiwgIndpZGV0aWxkZSIsICJ1dGlsZGUiXSwgbGFiZWwpKSB7CiAgICAgIHZhciBncnAgPSBncm91cDsKICAgICAgdmFyIG51bUNoYXJzID0gZ3JvdXBMZW5ndGgoZ3JwLmJhc2UpOwogICAgICB2YXIgdmlld0JveEhlaWdodDsKICAgICAgdmFyIHBhdGhOYW1lOwogICAgICB2YXIgX2hlaWdodDsKICAgICAgaWYgKG51bUNoYXJzID4gNSkgewogICAgICAgIGlmIChsYWJlbCA9PT0gIndpZGVoYXQiIHx8IGxhYmVsID09PSAid2lkZWNoZWNrIikgewogICAgICAgICAgdmlld0JveEhlaWdodCA9IDQyMDsKICAgICAgICAgIHZpZXdCb3hXaWR0aCA9IDIzNjQ7CiAgICAgICAgICBfaGVpZ2h0ID0gMC40MjsKICAgICAgICAgIHBhdGhOYW1lID0gbGFiZWwgKyAiNCI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSAzMTI7CiAgICAgICAgICB2aWV3Qm94V2lkdGggPSAyMzQwOwogICAgICAgICAgX2hlaWdodCA9IDAuMzQ7CiAgICAgICAgICBwYXRoTmFtZSA9ICJ0aWxkZTQiOwogICAgICAgIH0KICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgaW1nSW5kZXggPSBbMSwgMSwgMiwgMiwgMywgM11bbnVtQ2hhcnNdOwogICAgICAgIGlmIChsYWJlbCA9PT0gIndpZGVoYXQiIHx8IGxhYmVsID09PSAid2lkZWNoZWNrIikgewogICAgICAgICAgdmlld0JveFdpZHRoID0gWzAsIDEwNjIsIDIzNjQsIDIzNjQsIDIzNjRdW2ltZ0luZGV4XTsKICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjM5LCAzMDAsIDM2MCwgNDIwXVtpbWdJbmRleF07CiAgICAgICAgICBfaGVpZ2h0ID0gWzAsIDAuMjQsIDAuMywgMC4zLCAwLjM2LCAwLjQyXVtpbWdJbmRleF07CiAgICAgICAgICBwYXRoTmFtZSA9IGxhYmVsICsgaW1nSW5kZXg7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHZpZXdCb3hXaWR0aCA9IFswLCA2MDAsIDEwMzMsIDIzMzksIDIzNDBdW2ltZ0luZGV4XTsKICAgICAgICAgIHZpZXdCb3hIZWlnaHQgPSBbMCwgMjYwLCAyODYsIDMwNiwgMzEyXVtpbWdJbmRleF07CiAgICAgICAgICBfaGVpZ2h0ID0gWzAsIDAuMjYsIDAuMjg2LCAwLjMsIDAuMzA2LCAwLjM0XVtpbWdJbmRleF07CiAgICAgICAgICBwYXRoTmFtZSA9ICJ0aWxkZSIgKyBpbWdJbmRleDsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIHBhdGgyID0gbmV3IFBhdGhOb2RlKHBhdGhOYW1lKTsKICAgICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbcGF0aDJdLCB7CiAgICAgICAgIndpZHRoIjogIjEwMCUiLAogICAgICAgICJoZWlnaHQiOiBtYWtlRW0oX2hlaWdodCksCiAgICAgICAgInZpZXdCb3giOiAiMCAwICIgKyB2aWV3Qm94V2lkdGggKyAiICIgKyB2aWV3Qm94SGVpZ2h0LAogICAgICAgICJwcmVzZXJ2ZUFzcGVjdFJhdGlvIjogIm5vbmUiCiAgICAgIH0pOwogICAgICByZXR1cm4gewogICAgICAgIHNwYW46IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpLAogICAgICAgIG1pbldpZHRoOiAwLAogICAgICAgIGhlaWdodDogX2hlaWdodAogICAgICB9OwogICAgfSBlbHNlIHsKICAgICAgdmFyIHNwYW5zID0gW107CiAgICAgIHZhciBkYXRhID0ga2F0ZXhJbWFnZXNEYXRhW2xhYmVsXTsKICAgICAgdmFyIFtwYXRocywgX21pbldpZHRoLCBfdmlld0JveEhlaWdodF0gPSBkYXRhOwogICAgICB2YXIgX2hlaWdodDIgPSBfdmlld0JveEhlaWdodCAvIDFlMzsKICAgICAgdmFyIG51bVN2Z0NoaWxkcmVuID0gcGF0aHMubGVuZ3RoOwogICAgICB2YXIgd2lkdGhDbGFzc2VzOwogICAgICB2YXIgYWxpZ25zOwogICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHsKICAgICAgICB2YXIgYWxpZ24xID0gZGF0YVszXTsKICAgICAgICB3aWR0aENsYXNzZXMgPSBbImhpZGUtdGFpbCJdOwogICAgICAgIGFsaWducyA9IFthbGlnbjFdOwogICAgICB9IGVsc2UgaWYgKG51bVN2Z0NoaWxkcmVuID09PSAyKSB7CiAgICAgICAgd2lkdGhDbGFzc2VzID0gWyJoYWxmYXJyb3ctbGVmdCIsICJoYWxmYXJyb3ctcmlnaHQiXTsKICAgICAgICBhbGlnbnMgPSBbInhNaW5ZTWluIiwgInhNYXhZTWluIl07CiAgICAgIH0gZWxzZSBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDMpIHsKICAgICAgICB3aWR0aENsYXNzZXMgPSBbImJyYWNlLWxlZnQiLCAiYnJhY2UtY2VudGVyIiwgImJyYWNlLXJpZ2h0Il07CiAgICAgICAgYWxpZ25zID0gWyJ4TWluWU1pbiIsICJ4TWlkWU1pbiIsICJ4TWF4WU1pbiJdOwogICAgICB9IGVsc2UgewogICAgICAgIHRocm93IG5ldyBFcnJvcigiQ29ycmVjdCBrYXRleEltYWdlc0RhdGEgb3IgdXBkYXRlIGNvZGUgaGVyZSB0byBzdXBwb3J0XG4gICAgICAgICAgICAgICAgICAgICIgKyBudW1TdmdDaGlsZHJlbiArICIgY2hpbGRyZW4uIik7CiAgICAgIH0KICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1TdmdDaGlsZHJlbjsgaSsrKSB7CiAgICAgICAgdmFyIF9wYXRoID0gbmV3IFBhdGhOb2RlKHBhdGhzW2ldKTsKICAgICAgICB2YXIgX3N2Z05vZGUgPSBuZXcgU3ZnTm9kZShbX3BhdGhdLCB7CiAgICAgICAgICAid2lkdGgiOiAiNDAwZW0iLAogICAgICAgICAgImhlaWdodCI6IG1ha2VFbShfaGVpZ2h0MiksCiAgICAgICAgICAidmlld0JveCI6ICIwIDAgIiArIHZpZXdCb3hXaWR0aCArICIgIiArIF92aWV3Qm94SGVpZ2h0LAogICAgICAgICAgInByZXNlcnZlQXNwZWN0UmF0aW8iOiBhbGlnbnNbaV0gKyAiIHNsaWNlIgogICAgICAgIH0pOwogICAgICAgIHZhciBfc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFt3aWR0aENsYXNzZXNbaV1dLCBbX3N2Z05vZGVdLCBvcHRpb25zKTsKICAgICAgICBpZiAobnVtU3ZnQ2hpbGRyZW4gPT09IDEpIHsKICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIHNwYW46IF9zcGFuLAogICAgICAgICAgICBtaW5XaWR0aDogX21pbldpZHRoLAogICAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHQyCiAgICAgICAgICB9OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBfc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oX2hlaWdodDIpOwogICAgICAgICAgc3BhbnMucHVzaChfc3Bhbik7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiB7CiAgICAgICAgc3BhbjogYnVpbGRDb21tb24ubWFrZVNwYW4oWyJzdHJldGNoeSJdLCBzcGFucywgb3B0aW9ucyksCiAgICAgICAgbWluV2lkdGg6IF9taW5XaWR0aCwKICAgICAgICBoZWlnaHQ6IF9oZWlnaHQyCiAgICAgIH07CiAgICB9CiAgfQogIHZhciB7CiAgICBzcGFuLAogICAgbWluV2lkdGgsCiAgICBoZWlnaHQKICB9ID0gYnVpbGRTdmdTcGFuXygpOwogIHNwYW4uaGVpZ2h0ID0gaGVpZ2h0OwogIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7CiAgaWYgKG1pbldpZHRoID4gMCkgewogICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9IG1ha2VFbShtaW5XaWR0aCk7CiAgfQogIHJldHVybiBzcGFuOwp9Owp2YXIgZW5jbG9zZVNwYW4gPSBmdW5jdGlvbiBlbmNsb3NlU3BhbjIoaW5uZXIyLCBsYWJlbCwgdG9wUGFkLCBib3R0b21QYWQsIG9wdGlvbnMpIHsKICB2YXIgaW1nOwogIHZhciB0b3RhbEhlaWdodCA9IGlubmVyMi5oZWlnaHQgKyBpbm5lcjIuZGVwdGggKyB0b3BQYWQgKyBib3R0b21QYWQ7CiAgaWYgKC9mYm94fGNvbG9yfGFuZ2wvLnRlc3QobGFiZWwpKSB7CiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbInN0cmV0Y2h5IiwgbGFiZWxdLCBbXSwgb3B0aW9ucyk7CiAgICBpZiAobGFiZWwgPT09ICJmYm94IikgewogICAgICB2YXIgY29sb3IgPSBvcHRpb25zLmNvbG9yICYmIG9wdGlvbnMuZ2V0Q29sb3IoKTsKICAgICAgaWYgKGNvbG9yKSB7CiAgICAgICAgaW1nLnN0eWxlLmJvcmRlckNvbG9yID0gY29sb3I7CiAgICAgIH0KICAgIH0KICB9IGVsc2UgewogICAgdmFyIGxpbmVzID0gW107CiAgICBpZiAoL15bYnhdY2FuY2VsJC8udGVzdChsYWJlbCkpIHsKICAgICAgbGluZXMucHVzaChuZXcgTGluZU5vZGUoewogICAgICAgICJ4MSI6ICIwIiwKICAgICAgICAieTEiOiAiMCIsCiAgICAgICAgIngyIjogIjEwMCUiLAogICAgICAgICJ5MiI6ICIxMDAlIiwKICAgICAgICAic3Ryb2tlLXdpZHRoIjogIjAuMDQ2ZW0iCiAgICAgIH0pKTsKICAgIH0KICAgIGlmICgvXng/Y2FuY2VsJC8udGVzdChsYWJlbCkpIHsKICAgICAgbGluZXMucHVzaChuZXcgTGluZU5vZGUoewogICAgICAgICJ4MSI6ICIwIiwKICAgICAgICAieTEiOiAiMTAwJSIsCiAgICAgICAgIngyIjogIjEwMCUiLAogICAgICAgICJ5MiI6ICIwIiwKICAgICAgICAic3Ryb2tlLXdpZHRoIjogIjAuMDQ2ZW0iCiAgICAgIH0pKTsKICAgIH0KICAgIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUobGluZXMsIHsKICAgICAgIndpZHRoIjogIjEwMCUiLAogICAgICAiaGVpZ2h0IjogbWFrZUVtKHRvdGFsSGVpZ2h0KQogICAgfSk7CiAgICBpbWcgPSBidWlsZENvbW1vbi5tYWtlU3ZnU3BhbihbXSwgW3N2Z05vZGVdLCBvcHRpb25zKTsKICB9CiAgaW1nLmhlaWdodCA9IHRvdGFsSGVpZ2h0OwogIGltZy5zdHlsZS5oZWlnaHQgPSBtYWtlRW0odG90YWxIZWlnaHQpOwogIHJldHVybiBpbWc7Cn07CnZhciBzdHJldGNoeSA9IHsKICBlbmNsb3NlU3BhbiwKICBtYXRoTUxub2RlLAogIHN2Z1NwYW4KfTsKZnVuY3Rpb24gYXNzZXJ0Tm9kZVR5cGUobm9kZSwgdHlwZSkgewogIGlmICghbm9kZSB8fCBub2RlLnR5cGUgIT09IHR5cGUpIHsKICAgIHRocm93IG5ldyBFcnJvcigiRXhwZWN0ZWQgbm9kZSBvZiB0eXBlICIgKyB0eXBlICsgIiwgYnV0IGdvdCAiICsgKG5vZGUgPyAibm9kZSBvZiB0eXBlICIgKyBub2RlLnR5cGUgOiBTdHJpbmcobm9kZSkpKTsKICB9CiAgcmV0dXJuIG5vZGU7Cn0KZnVuY3Rpb24gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobm9kZSkgewogIHZhciB0eXBlZE5vZGUgPSBjaGVja1N5bWJvbE5vZGVUeXBlKG5vZGUpOwogIGlmICghdHlwZWROb2RlKSB7CiAgICB0aHJvdyBuZXcgRXJyb3IoIkV4cGVjdGVkIG5vZGUgb2Ygc3ltYm9sIGdyb3VwIHR5cGUsIGJ1dCBnb3QgIiArIChub2RlID8gIm5vZGUgb2YgdHlwZSAiICsgbm9kZS50eXBlIDogU3RyaW5nKG5vZGUpKSk7CiAgfQogIHJldHVybiB0eXBlZE5vZGU7Cn0KZnVuY3Rpb24gY2hlY2tTeW1ib2xOb2RlVHlwZShub2RlKSB7CiAgaWYgKG5vZGUgJiYgKG5vZGUudHlwZSA9PT0gImF0b20iIHx8IE5PTl9BVE9NUy5oYXNPd25Qcm9wZXJ0eShub2RlLnR5cGUpKSkgewogICAgcmV0dXJuIG5vZGU7CiAgfQogIHJldHVybiBudWxsOwp9CnZhciBodG1sQnVpbGRlciRhID0gKGdycCwgb3B0aW9ucykgPT4gewogIHZhciBiYXNlOwogIHZhciBncm91cDsKICB2YXIgc3VwU3ViR3JvdXA7CiAgaWYgKGdycCAmJiBncnAudHlwZSA9PT0gInN1cHN1YiIpIHsKICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsICJhY2NlbnQiKTsKICAgIGJhc2UgPSBncm91cC5iYXNlOwogICAgZ3JwLmJhc2UgPSBiYXNlOwogICAgc3VwU3ViR3JvdXAgPSBhc3NlcnRTcGFuKGJ1aWxkR3JvdXAkMShncnAsIG9wdGlvbnMpKTsKICAgIGdycC5iYXNlID0gZ3JvdXA7CiAgfSBlbHNlIHsKICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCAiYWNjZW50Iik7CiAgICBiYXNlID0gZ3JvdXAuYmFzZTsKICB9CiAgdmFyIGJvZHkgPSBidWlsZEdyb3VwJDEoYmFzZSwgb3B0aW9ucy5oYXZpbmdDcmFtcGVkU3R5bGUoKSk7CiAgdmFyIG11c3RTaGlmdCA9IGdyb3VwLmlzU2hpZnR5ICYmIHV0aWxzLmlzQ2hhcmFjdGVyQm94KGJhc2UpOwogIHZhciBza2V3ID0gMDsKICBpZiAobXVzdFNoaWZ0KSB7CiAgICB2YXIgYmFzZUNoYXIgPSB1dGlscy5nZXRCYXNlRWxlbShiYXNlKTsKICAgIHZhciBiYXNlR3JvdXAgPSBidWlsZEdyb3VwJDEoYmFzZUNoYXIsIG9wdGlvbnMuaGF2aW5nQ3JhbXBlZFN0eWxlKCkpOwogICAgc2tldyA9IGFzc2VydFN5bWJvbERvbU5vZGUoYmFzZUdyb3VwKS5za2V3OwogIH0KICB2YXIgYWNjZW50QmVsb3cgPSBncm91cC5sYWJlbCA9PT0gIlxcYyI7CiAgdmFyIGNsZWFyYW5jZSA9IGFjY2VudEJlbG93ID8gYm9keS5oZWlnaHQgKyBib2R5LmRlcHRoIDogTWF0aC5taW4oYm9keS5oZWlnaHQsIG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0KTsKICB2YXIgYWNjZW50Qm9keTsKICBpZiAoIWdyb3VwLmlzU3RyZXRjaHkpIHsKICAgIHZhciBhY2NlbnQyOwogICAgdmFyIHdpZHRoOwogICAgaWYgKGdyb3VwLmxhYmVsID09PSAiXFx2ZWMiKSB7CiAgICAgIGFjY2VudDIgPSBidWlsZENvbW1vbi5zdGF0aWNTdmcoInZlYyIsIG9wdGlvbnMpOwogICAgICB3aWR0aCA9IGJ1aWxkQ29tbW9uLnN2Z0RhdGEudmVjWzFdOwogICAgfSBlbHNlIHsKICAgICAgYWNjZW50MiA9IGJ1aWxkQ29tbW9uLm1ha2VPcmQoewogICAgICAgIG1vZGU6IGdyb3VwLm1vZGUsCiAgICAgICAgdGV4dDogZ3JvdXAubGFiZWwKICAgICAgfSwgb3B0aW9ucywgInRleHRvcmQiKTsKICAgICAgYWNjZW50MiA9IGFzc2VydFN5bWJvbERvbU5vZGUoYWNjZW50Mik7CiAgICAgIGFjY2VudDIuaXRhbGljID0gMDsKICAgICAgd2lkdGggPSBhY2NlbnQyLndpZHRoOwogICAgICBpZiAoYWNjZW50QmVsb3cpIHsKICAgICAgICBjbGVhcmFuY2UgKz0gYWNjZW50Mi5kZXB0aDsKICAgICAgfQogICAgfQogICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsiYWNjZW50LWJvZHkiXSwgW2FjY2VudDJdKTsKICAgIHZhciBhY2NlbnRGdWxsID0gZ3JvdXAubGFiZWwgPT09ICJcXHRleHRjaXJjbGVkIjsKICAgIGlmIChhY2NlbnRGdWxsKSB7CiAgICAgIGFjY2VudEJvZHkuY2xhc3Nlcy5wdXNoKCJhY2NlbnQtZnVsbCIpOwogICAgICBjbGVhcmFuY2UgPSBib2R5LmhlaWdodDsKICAgIH0KICAgIHZhciBsZWZ0ID0gc2tldzsKICAgIGlmICghYWNjZW50RnVsbCkgewogICAgICBsZWZ0IC09IHdpZHRoIC8gMjsKICAgIH0KICAgIGFjY2VudEJvZHkuc3R5bGUubGVmdCA9IG1ha2VFbShsZWZ0KTsKICAgIGlmIChncm91cC5sYWJlbCA9PT0gIlxcdGV4dGNpcmNsZWQiKSB7CiAgICAgIGFjY2VudEJvZHkuc3R5bGUudG9wID0gIi4yZW0iOwogICAgfQogICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImZpcnN0QmFzZWxpbmUiLAogICAgICBjaGlsZHJlbjogW3sKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogYm9keQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImtlcm4iLAogICAgICAgIHNpemU6IC1jbGVhcmFuY2UKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBhY2NlbnRCb2R5CiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICB9IGVsc2UgewogICAgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpOwogICAgYWNjZW50Qm9keSA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImZpcnN0QmFzZWxpbmUiLAogICAgICBjaGlsZHJlbjogW3sKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogYm9keQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGFjY2VudEJvZHksCiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFsic3ZnLWFsaWduIl0sCiAgICAgICAgd3JhcHBlclN0eWxlOiBza2V3ID4gMCA/IHsKICAgICAgICAgIHdpZHRoOiAiY2FsYygxMDAlIC0gIiArIG1ha2VFbSgyICogc2tldykgKyAiKSIsCiAgICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oMiAqIHNrZXcpCiAgICAgICAgfSA6IHZvaWQgMAogICAgICB9XQogICAgfSwgb3B0aW9ucyk7CiAgfQogIHZhciBhY2NlbnRXcmFwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3JkIiwgImFjY2VudCJdLCBbYWNjZW50Qm9keV0sIG9wdGlvbnMpOwogIGlmIChzdXBTdWJHcm91cCkgewogICAgc3VwU3ViR3JvdXAuY2hpbGRyZW5bMF0gPSBhY2NlbnRXcmFwOwogICAgc3VwU3ViR3JvdXAuaGVpZ2h0ID0gTWF0aC5tYXgoYWNjZW50V3JhcC5oZWlnaHQsIHN1cFN1Ykdyb3VwLmhlaWdodCk7CiAgICBzdXBTdWJHcm91cC5jbGFzc2VzWzBdID0gIm1vcmQiOwogICAgcmV0dXJuIHN1cFN1Ykdyb3VwOwogIH0gZWxzZSB7CiAgICByZXR1cm4gYWNjZW50V3JhcDsKICB9Cn07CnZhciBtYXRobWxCdWlsZGVyJDkgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgYWNjZW50Tm9kZSA9IGdyb3VwLmlzU3RyZXRjaHkgPyBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKSA6IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtbyIsIFttYWtlVGV4dChncm91cC5sYWJlbCwgZ3JvdXAubW9kZSldKTsKICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtb3ZlciIsIFtidWlsZEdyb3VwMihncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pOwogIG5vZGUuc2V0QXR0cmlidXRlKCJhY2NlbnQiLCAidHJ1ZSIpOwogIHJldHVybiBub2RlOwp9Owp2YXIgTk9OX1NUUkVUQ0hZX0FDQ0VOVF9SRUdFWCA9IG5ldyBSZWdFeHAoWyJcXGFjdXRlIiwgIlxcZ3JhdmUiLCAiXFxkZG90IiwgIlxcdGlsZGUiLCAiXFxiYXIiLCAiXFxicmV2ZSIsICJcXGNoZWNrIiwgIlxcaGF0IiwgIlxcdmVjIiwgIlxcZG90IiwgIlxcbWF0aHJpbmciXS5tYXAoKGFjY2VudDIpID0+ICJcXCIgKyBhY2NlbnQyKS5qb2luKCJ8IikpOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImFjY2VudCIsCiAgbmFtZXM6IFsiXFxhY3V0ZSIsICJcXGdyYXZlIiwgIlxcZGRvdCIsICJcXHRpbGRlIiwgIlxcYmFyIiwgIlxcYnJldmUiLCAiXFxjaGVjayIsICJcXGhhdCIsICJcXHZlYyIsICJcXGRvdCIsICJcXG1hdGhyaW5nIiwgIlxcd2lkZWNoZWNrIiwgIlxcd2lkZWhhdCIsICJcXHdpZGV0aWxkZSIsICJcXG92ZXJyaWdodGFycm93IiwgIlxcb3ZlcmxlZnRhcnJvdyIsICJcXE92ZXJyaWdodGFycm93IiwgIlxcb3ZlcmxlZnRyaWdodGFycm93IiwgIlxcb3Zlcmdyb3VwIiwgIlxcb3ZlcmxpbmVzZWdtZW50IiwgIlxcb3ZlcmxlZnRoYXJwb29uIiwgIlxcb3ZlcnJpZ2h0aGFycG9vbiJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxCiAgfSwKICBoYW5kbGVyOiAoY29udGV4dCwgYXJncykgPT4gewogICAgdmFyIGJhc2UgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzBdKTsKICAgIHZhciBpc1N0cmV0Y2h5ID0gIU5PTl9TVFJFVENIWV9BQ0NFTlRfUkVHRVgudGVzdChjb250ZXh0LmZ1bmNOYW1lKTsKICAgIHZhciBpc1NoaWZ0eSA9ICFpc1N0cmV0Y2h5IHx8IGNvbnRleHQuZnVuY05hbWUgPT09ICJcXHdpZGVoYXQiIHx8IGNvbnRleHQuZnVuY05hbWUgPT09ICJcXHdpZGV0aWxkZSIgfHwgY29udGV4dC5mdW5jTmFtZSA9PT0gIlxcd2lkZWNoZWNrIjsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJhY2NlbnQiLAogICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLAogICAgICBsYWJlbDogY29udGV4dC5mdW5jTmFtZSwKICAgICAgaXNTdHJldGNoeSwKICAgICAgaXNTaGlmdHksCiAgICAgIGJhc2UKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkYSwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDkKfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiYWNjZW50IiwKICBuYW1lczogWyJcXCciLCAiXFxgIiwgIlxcXiIsICJcXH4iLCAiXFw9IiwgIlxcdSIsICJcXC4iLCAnXFwiJywgIlxcYyIsICJcXHIiLCAiXFxIIiwgIlxcdiIsICJcXHRleHRjaXJjbGVkIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLAogICAgYWxsb3dlZEluTWF0aDogdHJ1ZSwKICAgIC8vIHVubGVzcyBpbiBzdHJpY3QgbW9kZQogICAgYXJnVHlwZXM6IFsicHJpbWl0aXZlIl0KICB9LAogIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7CiAgICB2YXIgYmFzZSA9IGFyZ3NbMF07CiAgICB2YXIgbW9kZSA9IGNvbnRleHQucGFyc2VyLm1vZGU7CiAgICBpZiAobW9kZSA9PT0gIm1hdGgiKSB7CiAgICAgIGNvbnRleHQucGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdCgibWF0aFZzVGV4dEFjY2VudHMiLCAiTGFUZVgncyBhY2NlbnQgIiArIGNvbnRleHQuZnVuY05hbWUgKyAiIHdvcmtzIG9ubHkgaW4gdGV4dCBtb2RlIik7CiAgICAgIG1vZGUgPSAidGV4dCI7CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiYWNjZW50IiwKICAgICAgbW9kZSwKICAgICAgbGFiZWw6IGNvbnRleHQuZnVuY05hbWUsCiAgICAgIGlzU3RyZXRjaHk6IGZhbHNlLAogICAgICBpc1NoaWZ0eTogdHJ1ZSwKICAgICAgYmFzZQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciRhLAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJhY2NlbnRVbmRlciIsCiAgbmFtZXM6IFsiXFx1bmRlcmxlZnRhcnJvdyIsICJcXHVuZGVycmlnaHRhcnJvdyIsICJcXHVuZGVybGVmdHJpZ2h0YXJyb3ciLCAiXFx1bmRlcmdyb3VwIiwgIlxcdW5kZXJsaW5lc2VnbWVudCIsICJcXHV0aWxkZSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxCiAgfSwKICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4gewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWY7CiAgICB2YXIgYmFzZSA9IGFyZ3NbMF07CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiYWNjZW50VW5kZXIiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbGFiZWw6IGZ1bmNOYW1lLAogICAgICBiYXNlCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGlubmVyR3JvdXAgPSBidWlsZEdyb3VwJDEoZ3JvdXAuYmFzZSwgb3B0aW9ucyk7CiAgICB2YXIgYWNjZW50Qm9keSA9IHN0cmV0Y2h5LnN2Z1NwYW4oZ3JvdXAsIG9wdGlvbnMpOwogICAgdmFyIGtlcm4gPSBncm91cC5sYWJlbCA9PT0gIlxcdXRpbGRlIiA/IDAuMTIgOiAwOwogICAgdmFyIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgcG9zaXRpb25UeXBlOiAidG9wIiwKICAgICAgcG9zaXRpb25EYXRhOiBpbm5lckdyb3VwLmhlaWdodCwKICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGFjY2VudEJvZHksCiAgICAgICAgd3JhcHBlckNsYXNzZXM6IFsic3ZnLWFsaWduIl0KICAgICAgfSwgewogICAgICAgIHR5cGU6ICJrZXJuIiwKICAgICAgICBzaXplOiBrZXJuCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogaW5uZXJHcm91cAogICAgICB9XQogICAgfSwgb3B0aW9ucyk7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3JkIiwgImFjY2VudHVuZGVyIl0sIFt2bGlzdF0sIG9wdGlvbnMpOwogIH0sCiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpOwogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXVuZGVyIiwgW2J1aWxkR3JvdXAyKGdyb3VwLmJhc2UsIG9wdGlvbnMpLCBhY2NlbnROb2RlXSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgiYWNjZW50dW5kZXIiLCAidHJ1ZSIpOwogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKdmFyIHBhZGRlZE5vZGUgPSAoZ3JvdXApID0+IHsKICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcGFkZGVkIiwgZ3JvdXAgPyBbZ3JvdXBdIDogW10pOwogIG5vZGUuc2V0QXR0cmlidXRlKCJ3aWR0aCIsICIrMC42ZW0iKTsKICBub2RlLnNldEF0dHJpYnV0ZSgibHNwYWNlIiwgIjAuM2VtIik7CiAgcmV0dXJuIG5vZGU7Cn07CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAieEFycm93IiwKICBuYW1lczogWwogICAgIlxceGxlZnRhcnJvdyIsCiAgICAiXFx4cmlnaHRhcnJvdyIsCiAgICAiXFx4TGVmdGFycm93IiwKICAgICJcXHhSaWdodGFycm93IiwKICAgICJcXHhsZWZ0cmlnaHRhcnJvdyIsCiAgICAiXFx4TGVmdHJpZ2h0YXJyb3ciLAogICAgIlxceGhvb2tsZWZ0YXJyb3ciLAogICAgIlxceGhvb2tyaWdodGFycm93IiwKICAgICJcXHhtYXBzdG8iLAogICAgIlxceHJpZ2h0aGFycG9vbmRvd24iLAogICAgIlxceHJpZ2h0aGFycG9vbnVwIiwKICAgICJcXHhsZWZ0aGFycG9vbmRvd24iLAogICAgIlxceGxlZnRoYXJwb29udXAiLAogICAgIlxceHJpZ2h0bGVmdGhhcnBvb25zIiwKICAgICJcXHhsZWZ0cmlnaHRoYXJwb29ucyIsCiAgICAiXFx4bG9uZ2VxdWFsIiwKICAgICJcXHh0d29oZWFkcmlnaHRhcnJvdyIsCiAgICAiXFx4dHdvaGVhZGxlZnRhcnJvdyIsCiAgICAiXFx4dG9mcm9tIiwKICAgIC8vIFRoZSBuZXh0IDMgZnVuY3Rpb25zIGFyZSBoZXJlIHRvIHN1cHBvcnQgdGhlIG1oY2hlbSBleHRlbnNpb24uCiAgICAvLyBEaXJlY3QgdXNlIG9mIHRoZXNlIGZ1bmN0aW9ucyBpcyBkaXNjb3VyYWdlZCBhbmQgbWF5IGJyZWFrIHNvbWVkYXkuCiAgICAiXFx4cmlnaHRsZWZ0YXJyb3dzIiwKICAgICJcXHhyaWdodGVxdWlsaWJyaXVtIiwKICAgICJcXHhsZWZ0ZXF1aWxpYnJpdW0iLAogICAgLy8gVGhlIG5leHQgMyBmdW5jdGlvbnMgYXJlIGhlcmUgb25seSB0byBzdXBwb3J0IHRoZSB7Q0R9IGVudmlyb25tZW50LgogICAgIlxcXFxjZHJpZ2h0YXJyb3ciLAogICAgIlxcXFxjZGxlZnRhcnJvdyIsCiAgICAiXFxcXGNkbG9uZ2VxdWFsIgogIF0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBudW1PcHRpb25hbEFyZ3M6IDEKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWY7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAieEFycm93IiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGxhYmVsOiBmdW5jTmFtZSwKICAgICAgYm9keTogYXJnc1swXSwKICAgICAgYmVsb3c6IG9wdEFyZ3NbMF0KICAgIH07CiAgfSwKICAvLyBGbG93IGlzIHVuYWJsZSB0byBjb3JyZWN0bHkgaW5mZXIgdGhlIHR5cGUgb2YgYGdyb3VwYCwgZXZlbiB0aG91Z2ggaXQncwogIC8vIHVuYW1iaWd1b3VzbHkgZGV0ZXJtaW5lZCBmcm9tIHRoZSBwYXNzZWQtaW4gYHR5cGVgIGFib3ZlLgogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgc3R5bGUgPSBvcHRpb25zLnN0eWxlOwogICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlLnN1cCgpKTsKICAgIHZhciB1cHBlckdyb3VwID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKSwgb3B0aW9ucyk7CiAgICB2YXIgYXJyb3dQcmVmaXggPSBncm91cC5sYWJlbC5zbGljZSgwLCAyKSA9PT0gIlxceCIgPyAieCIgOiAiY2QiOwogICAgdXBwZXJHcm91cC5jbGFzc2VzLnB1c2goYXJyb3dQcmVmaXggKyAiLWFycm93LXBhZCIpOwogICAgdmFyIGxvd2VyR3JvdXA7CiAgICBpZiAoZ3JvdXAuYmVsb3cpIHsKICAgICAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpOwogICAgICBsb3dlckdyb3VwID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5iZWxvdywgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpOwogICAgICBsb3dlckdyb3VwLmNsYXNzZXMucHVzaChhcnJvd1ByZWZpeCArICItYXJyb3ctcGFkIik7CiAgICB9CiAgICB2YXIgYXJyb3dCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7CiAgICB2YXIgYXJyb3dTaGlmdCA9IC1vcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCArIDAuNSAqIGFycm93Qm9keS5oZWlnaHQ7CiAgICB2YXIgdXBwZXJTaGlmdCA9IC1vcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodCAtIDAuNSAqIGFycm93Qm9keS5oZWlnaHQgLSAwLjExMTsKICAgIGlmICh1cHBlckdyb3VwLmRlcHRoID4gMC4yNSB8fCBncm91cC5sYWJlbCA9PT0gIlxceGxlZnRlcXVpbGlicml1bSIpIHsKICAgICAgdXBwZXJTaGlmdCAtPSB1cHBlckdyb3VwLmRlcHRoOwogICAgfQogICAgdmFyIHZsaXN0OwogICAgaWYgKGxvd2VyR3JvdXApIHsKICAgICAgdmFyIGxvd2VyU2hpZnQgPSAtb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKyBsb3dlckdyb3VwLmhlaWdodCArIDAuNSAqIGFycm93Qm9keS5oZWlnaHQgKyAwLjExMTsKICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICAgIHBvc2l0aW9uVHlwZTogImluZGl2aWR1YWxTaGlmdCIsCiAgICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiB1cHBlckdyb3VwLAogICAgICAgICAgc2hpZnQ6IHVwcGVyU2hpZnQKICAgICAgICB9LCB7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiBhcnJvd0JvZHksCiAgICAgICAgICBzaGlmdDogYXJyb3dTaGlmdAogICAgICAgIH0sIHsKICAgICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICAgIGVsZW06IGxvd2VyR3JvdXAsCiAgICAgICAgICBzaGlmdDogbG93ZXJTaGlmdAogICAgICAgIH1dCiAgICAgIH0sIG9wdGlvbnMpOwogICAgfSBlbHNlIHsKICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICAgIHBvc2l0aW9uVHlwZTogImluZGl2aWR1YWxTaGlmdCIsCiAgICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiB1cHBlckdyb3VwLAogICAgICAgICAgc2hpZnQ6IHVwcGVyU2hpZnQKICAgICAgICB9LCB7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiBhcnJvd0JvZHksCiAgICAgICAgICBzaGlmdDogYXJyb3dTaGlmdAogICAgICAgIH1dCiAgICAgIH0sIG9wdGlvbnMpOwogICAgfQogICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMV0uY2xhc3Nlcy5wdXNoKCJzdmctYWxpZ24iKTsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1yZWwiLCAieC1hcnJvdyJdLCBbdmxpc3RdLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBhcnJvd05vZGUgPSBzdHJldGNoeS5tYXRoTUxub2RlKGdyb3VwLmxhYmVsKTsKICAgIGFycm93Tm9kZS5zZXRBdHRyaWJ1dGUoIm1pbnNpemUiLCBncm91cC5sYWJlbC5jaGFyQXQoMCkgPT09ICJ4IiA/ICIxLjc1ZW0iIDogIjMuMGVtIik7CiAgICB2YXIgbm9kZTsKICAgIGlmIChncm91cC5ib2R5KSB7CiAgICAgIHZhciB1cHBlck5vZGUgPSBwYWRkZWROb2RlKGJ1aWxkR3JvdXAyKGdyb3VwLmJvZHksIG9wdGlvbnMpKTsKICAgICAgaWYgKGdyb3VwLmJlbG93KSB7CiAgICAgICAgdmFyIGxvd2VyTm9kZSA9IHBhZGRlZE5vZGUoYnVpbGRHcm91cDIoZ3JvdXAuYmVsb3csIG9wdGlvbnMpKTsKICAgICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm11bmRlcm92ZXIiLCBbYXJyb3dOb2RlLCBsb3dlck5vZGUsIHVwcGVyTm9kZV0pOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibW92ZXIiLCBbYXJyb3dOb2RlLCB1cHBlck5vZGVdKTsKICAgICAgfQogICAgfSBlbHNlIGlmIChncm91cC5iZWxvdykgewogICAgICB2YXIgX2xvd2VyTm9kZSA9IHBhZGRlZE5vZGUoYnVpbGRHcm91cDIoZ3JvdXAuYmVsb3csIG9wdGlvbnMpKTsKICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtdW5kZXIiLCBbYXJyb3dOb2RlLCBfbG93ZXJOb2RlXSk7CiAgICB9IGVsc2UgewogICAgICBub2RlID0gcGFkZGVkTm9kZSgpOwogICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1vdmVyIiwgW2Fycm93Tm9kZSwgbm9kZV0pOwogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKdmFyIG1ha2VTcGFuMiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuOwpmdW5jdGlvbiBodG1sQnVpbGRlciQ5KGdyb3VwLCBvcHRpb25zKSB7CiAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7CiAgcmV0dXJuIG1ha2VTcGFuMihbZ3JvdXAubWNsYXNzXSwgZWxlbWVudHMsIG9wdGlvbnMpOwp9CmZ1bmN0aW9uIG1hdGhtbEJ1aWxkZXIkOChncm91cCwgb3B0aW9ucykgewogIHZhciBub2RlOwogIHZhciBpbm5lcjIgPSBidWlsZEV4cHJlc3Npb24yKGdyb3VwLmJvZHksIG9wdGlvbnMpOwogIGlmIChncm91cC5tY2xhc3MgPT09ICJtaW5uZXIiKSB7CiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1wYWRkZWQiLCBpbm5lcjIpOwogIH0gZWxzZSBpZiAoZ3JvdXAubWNsYXNzID09PSAibW9yZCIpIHsKICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCkgewogICAgICBub2RlID0gaW5uZXIyWzBdOwogICAgICBub2RlLnR5cGUgPSAibWkiOwogICAgfSBlbHNlIHsKICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtaSIsIGlubmVyMik7CiAgICB9CiAgfSBlbHNlIHsKICAgIGlmIChncm91cC5pc0NoYXJhY3RlckJveCkgewogICAgICBub2RlID0gaW5uZXIyWzBdOwogICAgICBub2RlLnR5cGUgPSAibW8iOwogICAgfSBlbHNlIHsKICAgICAgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtbyIsIGlubmVyMik7CiAgICB9CiAgICBpZiAoZ3JvdXAubWNsYXNzID09PSAibWJpbiIpIHsKICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9ICIwLjIyZW0iOwogICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gIjAuMjJlbSI7CiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gIm1wdW5jdCIpIHsKICAgICAgbm9kZS5hdHRyaWJ1dGVzLmxzcGFjZSA9ICIwZW0iOwogICAgICBub2RlLmF0dHJpYnV0ZXMucnNwYWNlID0gIjAuMTdlbSI7CiAgICB9IGVsc2UgaWYgKGdyb3VwLm1jbGFzcyA9PT0gIm1vcGVuIiB8fCBncm91cC5tY2xhc3MgPT09ICJtY2xvc2UiKSB7CiAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSAiMGVtIjsKICAgICAgbm9kZS5hdHRyaWJ1dGVzLnJzcGFjZSA9ICIwZW0iOwogICAgfSBlbHNlIGlmIChncm91cC5tY2xhc3MgPT09ICJtaW5uZXIiKSB7CiAgICAgIG5vZGUuYXR0cmlidXRlcy5sc3BhY2UgPSAiMC4wNTU2ZW0iOwogICAgICBub2RlLmF0dHJpYnV0ZXMud2lkdGggPSAiKzAuMTExMWVtIjsKICAgIH0KICB9CiAgcmV0dXJuIG5vZGU7Cn0KZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJtY2xhc3MiLAogIG5hbWVzOiBbIlxcbWF0aG9yZCIsICJcXG1hdGhiaW4iLCAiXFxtYXRocmVsIiwgIlxcbWF0aG9wZW4iLCAiXFxtYXRoY2xvc2UiLCAiXFxtYXRocHVuY3QiLCAiXFxtYXRoaW5uZXIiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIHByaW1pdGl2ZTogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjsKICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJtY2xhc3MiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbWNsYXNzOiAibSIgKyBmdW5jTmFtZS5zbGljZSg1KSwKICAgICAgLy8gVE9ETyhrZXZpbmIpOiBkb24ndCBwcmVmaXggd2l0aCAnbScKICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSksCiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChib2R5KQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ5LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOAp9KTsKdmFyIGJpbnJlbENsYXNzID0gKGFyZykgPT4gewogIHZhciBhdG9tID0gYXJnLnR5cGUgPT09ICJvcmRncm91cCIgJiYgYXJnLmJvZHkubGVuZ3RoID8gYXJnLmJvZHlbMF0gOiBhcmc7CiAgaWYgKGF0b20udHlwZSA9PT0gImF0b20iICYmIChhdG9tLmZhbWlseSA9PT0gImJpbiIgfHwgYXRvbS5mYW1pbHkgPT09ICJyZWwiKSkgewogICAgcmV0dXJuICJtIiArIGF0b20uZmFtaWx5OwogIH0gZWxzZSB7CiAgICByZXR1cm4gIm1vcmQiOwogIH0KfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJtY2xhc3MiLAogIG5hbWVzOiBbIlxcQGJpbnJlbCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAyCiAgfSwKICBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmMjsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJtY2xhc3MiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbWNsYXNzOiBiaW5yZWxDbGFzcyhhcmdzWzBdKSwKICAgICAgYm9keTogb3JkYXJndW1lbnQoYXJnc1sxXSksCiAgICAgIGlzQ2hhcmFjdGVyQm94OiB1dGlscy5pc0NoYXJhY3RlckJveChhcmdzWzFdKQogICAgfTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogIm1jbGFzcyIsCiAgbmFtZXM6IFsiXFxzdGFja3JlbCIsICJcXG92ZXJzZXQiLCAiXFx1bmRlcnNldCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAyCiAgfSwKICBoYW5kbGVyKF9yZWYzLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjM7CiAgICB2YXIgYmFzZUFyZyA9IGFyZ3NbMV07CiAgICB2YXIgc2hpZnRlZEFyZyA9IGFyZ3NbMF07CiAgICB2YXIgbWNsYXNzOwogICAgaWYgKGZ1bmNOYW1lICE9PSAiXFxzdGFja3JlbCIpIHsKICAgICAgbWNsYXNzID0gYmlucmVsQ2xhc3MoYmFzZUFyZyk7CiAgICB9IGVsc2UgewogICAgICBtY2xhc3MgPSAibXJlbCI7CiAgICB9CiAgICB2YXIgYmFzZU9wID0gewogICAgICB0eXBlOiAib3AiLAogICAgICBtb2RlOiBiYXNlQXJnLm1vZGUsCiAgICAgIGxpbWl0czogdHJ1ZSwKICAgICAgYWx3YXlzSGFuZGxlU3VwU3ViOiB0cnVlLAogICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsCiAgICAgIHN5bWJvbDogZmFsc2UsCiAgICAgIHN1cHByZXNzQmFzZVNoaWZ0OiBmdW5jTmFtZSAhPT0gIlxcc3RhY2tyZWwiLAogICAgICBib2R5OiBvcmRhcmd1bWVudChiYXNlQXJnKQogICAgfTsKICAgIHZhciBzdXBzdWIgPSB7CiAgICAgIHR5cGU6ICJzdXBzdWIiLAogICAgICBtb2RlOiBzaGlmdGVkQXJnLm1vZGUsCiAgICAgIGJhc2U6IGJhc2VPcCwKICAgICAgc3VwOiBmdW5jTmFtZSA9PT0gIlxcdW5kZXJzZXQiID8gbnVsbCA6IHNoaWZ0ZWRBcmcsCiAgICAgIHN1YjogZnVuY05hbWUgPT09ICJcXHVuZGVyc2V0IiA/IHNoaWZ0ZWRBcmcgOiBudWxsCiAgICB9OwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogIm1jbGFzcyIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBtY2xhc3MsCiAgICAgIGJvZHk6IFtzdXBzdWJdLAogICAgICBpc0NoYXJhY3RlckJveDogdXRpbHMuaXNDaGFyYWN0ZXJCb3goc3Vwc3ViKQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ5LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkOAp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJwbWIiLAogIG5hbWVzOiBbIlxccG1iIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAicG1iIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYXJnc1swXSksCiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpOwogICAgdmFyIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbZ3JvdXAubWNsYXNzXSwgZWxlbWVudHMsIG9wdGlvbnMpOwogICAgbm9kZS5zdHlsZS50ZXh0U2hhZG93ID0gIjAuMDJlbSAwLjAxZW0gMC4wNHB4IjsKICAgIHJldHVybiBub2RlOwogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgc3R5bGUpIHsKICAgIHZhciBpbm5lcjIgPSBidWlsZEV4cHJlc3Npb24yKGdyb3VwLmJvZHksIHN0eWxlKTsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1zdHlsZSIsIGlubmVyMik7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgic3R5bGUiLCAidGV4dC1zaGFkb3c6IDAuMDJlbSAwLjAxZW0gMC4wNHB4Iik7CiAgICByZXR1cm4gbm9kZTsKICB9Cn0pOwp2YXIgY2RBcnJvd0Z1bmN0aW9uTmFtZSA9IHsKICAiPiI6ICJcXFxcY2RyaWdodGFycm93IiwKICAiPCI6ICJcXFxcY2RsZWZ0YXJyb3ciLAogICI9IjogIlxcXFxjZGxvbmdlcXVhbCIsCiAgIkEiOiAiXFx1cGFycm93IiwKICAiViI6ICJcXGRvd25hcnJvdyIsCiAgInwiOiAiXFxWZXJ0IiwKICAiLiI6ICJubyBhcnJvdyIKfTsKdmFyIG5ld0NlbGwgPSAoKSA9PiB7CiAgcmV0dXJuIHsKICAgIHR5cGU6ICJzdHlsaW5nIiwKICAgIGJvZHk6IFtdLAogICAgbW9kZTogIm1hdGgiLAogICAgc3R5bGU6ICJkaXNwbGF5IgogIH07Cn07CnZhciBpc1N0YXJ0T2ZBcnJvdyA9IChub2RlKSA9PiB7CiAgcmV0dXJuIG5vZGUudHlwZSA9PT0gInRleHRvcmQiICYmIG5vZGUudGV4dCA9PT0gIkAiOwp9Owp2YXIgaXNMYWJlbEVuZCA9IChub2RlLCBlbmRDaGFyKSA9PiB7CiAgcmV0dXJuIChub2RlLnR5cGUgPT09ICJtYXRob3JkIiB8fCBub2RlLnR5cGUgPT09ICJhdG9tIikgJiYgbm9kZS50ZXh0ID09PSBlbmRDaGFyOwp9OwpmdW5jdGlvbiBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpIHsKICB2YXIgZnVuY05hbWUgPSBjZEFycm93RnVuY3Rpb25OYW1lW2Fycm93Q2hhcl07CiAgc3dpdGNoIChmdW5jTmFtZSkgewogICAgY2FzZSAiXFxcXGNkcmlnaHRhcnJvdyI6CiAgICBjYXNlICJcXFxcY2RsZWZ0YXJyb3ciOgogICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbihmdW5jTmFtZSwgW2xhYmVsc1swXV0sIFtsYWJlbHNbMV1dKTsKICAgIGNhc2UgIlxcdXBhcnJvdyI6CiAgICBjYXNlICJcXGRvd25hcnJvdyI6IHsKICAgICAgdmFyIGxlZnRMYWJlbCA9IHBhcnNlci5jYWxsRnVuY3Rpb24oIlxcXFxjZGxlZnQiLCBbbGFiZWxzWzBdXSwgW10pOwogICAgICB2YXIgYmFyZUFycm93ID0gewogICAgICAgIHR5cGU6ICJhdG9tIiwKICAgICAgICB0ZXh0OiBmdW5jTmFtZSwKICAgICAgICBtb2RlOiAibWF0aCIsCiAgICAgICAgZmFtaWx5OiAicmVsIgogICAgICB9OwogICAgICB2YXIgc2l6ZWRBcnJvdyA9IHBhcnNlci5jYWxsRnVuY3Rpb24oIlxcQmlnIiwgW2JhcmVBcnJvd10sIFtdKTsKICAgICAgdmFyIHJpZ2h0TGFiZWwgPSBwYXJzZXIuY2FsbEZ1bmN0aW9uKCJcXFxcY2RyaWdodCIsIFtsYWJlbHNbMV1dLCBbXSk7CiAgICAgIHZhciBhcnJvd0dyb3VwID0gewogICAgICAgIHR5cGU6ICJvcmRncm91cCIsCiAgICAgICAgbW9kZTogIm1hdGgiLAogICAgICAgIGJvZHk6IFtsZWZ0TGFiZWwsIHNpemVkQXJyb3csIHJpZ2h0TGFiZWxdCiAgICAgIH07CiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKCJcXFxcY2RwYXJlbnQiLCBbYXJyb3dHcm91cF0sIFtdKTsKICAgIH0KICAgIGNhc2UgIlxcXFxjZGxvbmdlcXVhbCI6CiAgICAgIHJldHVybiBwYXJzZXIuY2FsbEZ1bmN0aW9uKCJcXFxcY2Rsb25nZXF1YWwiLCBbXSwgW10pOwogICAgY2FzZSAiXFxWZXJ0IjogewogICAgICB2YXIgYXJyb3cgPSB7CiAgICAgICAgdHlwZTogInRleHRvcmQiLAogICAgICAgIHRleHQ6ICJcXFZlcnQiLAogICAgICAgIG1vZGU6ICJtYXRoIgogICAgICB9OwogICAgICByZXR1cm4gcGFyc2VyLmNhbGxGdW5jdGlvbigiXFxCaWciLCBbYXJyb3ddLCBbXSk7CiAgICB9CiAgICBkZWZhdWx0OgogICAgICByZXR1cm4gewogICAgICAgIHR5cGU6ICJ0ZXh0b3JkIiwKICAgICAgICB0ZXh0OiAiICIsCiAgICAgICAgbW9kZTogIm1hdGgiCiAgICAgIH07CiAgfQp9CmZ1bmN0aW9uIHBhcnNlQ0QocGFyc2VyKSB7CiAgdmFyIHBhcnNlZFJvd3MgPSBbXTsKICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTsKICBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5zZXQoIlxcY3IiLCAiXFxcXFxccmVsYXgiKTsKICBwYXJzZXIuZ3VsbGV0LmJlZ2luR3JvdXAoKTsKICB3aGlsZSAodHJ1ZSkgewogICAgcGFyc2VkUm93cy5wdXNoKHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsICJcXFxcIikpOwogICAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOwogICAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7CiAgICB2YXIgbmV4dCA9IHBhcnNlci5mZXRjaCgpLnRleHQ7CiAgICBpZiAobmV4dCA9PT0gIiYiIHx8IG5leHQgPT09ICJcXFxcIikgewogICAgICBwYXJzZXIuY29uc3VtZSgpOwogICAgfSBlbHNlIGlmIChuZXh0ID09PSAiXFxlbmQiKSB7CiAgICAgIGlmIChwYXJzZWRSb3dzW3BhcnNlZFJvd3MubGVuZ3RoIC0gMV0ubGVuZ3RoID09PSAwKSB7CiAgICAgICAgcGFyc2VkUm93cy5wb3AoKTsKICAgICAgfQogICAgICBicmVhazsKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJFeHBlY3RlZCBcXFxcIG9yIFxcY3Igb3IgXFxlbmQiLCBwYXJzZXIubmV4dFRva2VuKTsKICAgIH0KICB9CiAgdmFyIHJvdyA9IFtdOwogIHZhciBib2R5ID0gW3Jvd107CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJzZWRSb3dzLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgcm93Tm9kZXMgPSBwYXJzZWRSb3dzW2ldOwogICAgdmFyIGNlbGwgPSBuZXdDZWxsKCk7CiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJvd05vZGVzLmxlbmd0aDsgaisrKSB7CiAgICAgIGlmICghaXNTdGFydE9mQXJyb3cocm93Tm9kZXNbal0pKSB7CiAgICAgICAgY2VsbC5ib2R5LnB1c2gocm93Tm9kZXNbal0pOwogICAgICB9IGVsc2UgewogICAgICAgIHJvdy5wdXNoKGNlbGwpOwogICAgICAgIGogKz0gMTsKICAgICAgICB2YXIgYXJyb3dDaGFyID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUocm93Tm9kZXNbal0pLnRleHQ7CiAgICAgICAgdmFyIGxhYmVscyA9IG5ldyBBcnJheSgyKTsKICAgICAgICBsYWJlbHNbMF0gPSB7CiAgICAgICAgICB0eXBlOiAib3JkZ3JvdXAiLAogICAgICAgICAgbW9kZTogIm1hdGgiLAogICAgICAgICAgYm9keTogW10KICAgICAgICB9OwogICAgICAgIGxhYmVsc1sxXSA9IHsKICAgICAgICAgIHR5cGU6ICJvcmRncm91cCIsCiAgICAgICAgICBtb2RlOiAibWF0aCIsCiAgICAgICAgICBib2R5OiBbXQogICAgICAgIH07CiAgICAgICAgaWYgKCI9fC4iLmluZGV4T2YoYXJyb3dDaGFyKSA+IC0xKSA7CiAgICAgICAgZWxzZSBpZiAoIjw+QVYiLmluZGV4T2YoYXJyb3dDaGFyKSA+IC0xKSB7CiAgICAgICAgICBmb3IgKHZhciBsYWJlbE51bSA9IDA7IGxhYmVsTnVtIDwgMjsgbGFiZWxOdW0rKykgewogICAgICAgICAgICB2YXIgaW5MYWJlbCA9IHRydWU7CiAgICAgICAgICAgIGZvciAodmFyIGsgPSBqICsgMTsgayA8IHJvd05vZGVzLmxlbmd0aDsgaysrKSB7CiAgICAgICAgICAgICAgaWYgKGlzTGFiZWxFbmQocm93Tm9kZXNba10sIGFycm93Q2hhcikpIHsKICAgICAgICAgICAgICAgIGluTGFiZWwgPSBmYWxzZTsKICAgICAgICAgICAgICAgIGogPSBrOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChpc1N0YXJ0T2ZBcnJvdyhyb3dOb2Rlc1trXSkpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJNaXNzaW5nIGEgIiArIGFycm93Q2hhciArICIgY2hhcmFjdGVyIHRvIGNvbXBsZXRlIGEgQ0QgYXJyb3cuIiwgcm93Tm9kZXNba10pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBsYWJlbHNbbGFiZWxOdW1dLmJvZHkucHVzaChyb3dOb2Rlc1trXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGluTGFiZWwpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiTWlzc2luZyBhICIgKyBhcnJvd0NoYXIgKyAiIGNoYXJhY3RlciB0byBjb21wbGV0ZSBhIENEIGFycm93LiIsIHJvd05vZGVzW2pdKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignRXhwZWN0ZWQgb25lIG9mICI8PkFWPXwuIiBhZnRlciBAJywgcm93Tm9kZXNbal0pOwogICAgICAgIH0KICAgICAgICB2YXIgYXJyb3cgPSBjZEFycm93KGFycm93Q2hhciwgbGFiZWxzLCBwYXJzZXIpOwogICAgICAgIHZhciB3cmFwcGVkQXJyb3cgPSB7CiAgICAgICAgICB0eXBlOiAic3R5bGluZyIsCiAgICAgICAgICBib2R5OiBbYXJyb3ddLAogICAgICAgICAgbW9kZTogIm1hdGgiLAogICAgICAgICAgc3R5bGU6ICJkaXNwbGF5IgogICAgICAgICAgLy8gQ0QgaXMgYWx3YXlzIGRpc3BsYXlzdHlsZS4KICAgICAgICB9OwogICAgICAgIHJvdy5wdXNoKHdyYXBwZWRBcnJvdyk7CiAgICAgICAgY2VsbCA9IG5ld0NlbGwoKTsKICAgICAgfQogICAgfQogICAgaWYgKGkgJSAyID09PSAwKSB7CiAgICAgIHJvdy5wdXNoKGNlbGwpOwogICAgfSBlbHNlIHsKICAgICAgcm93LnNoaWZ0KCk7CiAgICB9CiAgICByb3cgPSBbXTsKICAgIGJvZHkucHVzaChyb3cpOwogIH0KICBwYXJzZXIuZ3VsbGV0LmVuZEdyb3VwKCk7CiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOwogIHZhciBjb2xzID0gbmV3IEFycmF5KGJvZHlbMF0ubGVuZ3RoKS5maWxsKHsKICAgIHR5cGU6ICJhbGlnbiIsCiAgICBhbGlnbjogImMiLAogICAgcHJlZ2FwOiAwLjI1LAogICAgLy8gQ0QgcGFja2FnZSBzZXRzIFxlbnNraXAgYmV0d2VlbiBjb2x1bW5zLgogICAgcG9zdGdhcDogMC4yNQogICAgLy8gU28gcHJlIGFuZCBwb3N0IGVhY2ggZ2V0IGhhbGYgYW4gXGVuc2tpcCwgaS5lLiAwLjI1ZW0uCiAgfSk7CiAgcmV0dXJuIHsKICAgIHR5cGU6ICJhcnJheSIsCiAgICBtb2RlOiAibWF0aCIsCiAgICBib2R5LAogICAgYXJyYXlzdHJldGNoOiAxLAogICAgYWRkSm90OiB0cnVlLAogICAgcm93R2FwczogW251bGxdLAogICAgY29scywKICAgIGNvbFNlcGFyYXRpb25UeXBlOiAiQ0QiLAogICAgaExpbmVzQmVmb3JlUm93OiBuZXcgQXJyYXkoYm9keS5sZW5ndGggKyAxKS5maWxsKFtdKQogIH07Cn0KZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJjZGxhYmVsIiwKICBuYW1lczogWyJcXFxcY2RsZWZ0IiwgIlxcXFxjZHJpZ2h0Il0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWY7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiY2RsYWJlbCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBzaWRlOiBmdW5jTmFtZS5zbGljZSg0KSwKICAgICAgbGFiZWw6IGFyZ3NbMF0KICAgIH07CiAgfSwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3VwKCkpOwogICAgdmFyIGxhYmVsID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5sYWJlbCwgbmV3T3B0aW9ucywgb3B0aW9ucyksIG9wdGlvbnMpOwogICAgbGFiZWwuY2xhc3Nlcy5wdXNoKCJjZC1sYWJlbC0iICsgZ3JvdXAuc2lkZSk7CiAgICBsYWJlbC5zdHlsZS5ib3R0b20gPSBtYWtlRW0oMC44IC0gbGFiZWwuZGVwdGgpOwogICAgbGFiZWwuaGVpZ2h0ID0gMDsKICAgIGxhYmVsLmRlcHRoID0gMDsKICAgIHJldHVybiBsYWJlbDsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBsYWJlbCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcm93IiwgW2J1aWxkR3JvdXAyKGdyb3VwLmxhYmVsLCBvcHRpb25zKV0pOwogICAgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXBhZGRlZCIsIFtsYWJlbF0pOwogICAgbGFiZWwuc2V0QXR0cmlidXRlKCJ3aWR0aCIsICIwIik7CiAgICBpZiAoZ3JvdXAuc2lkZSA9PT0gImxlZnQiKSB7CiAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgibHNwYWNlIiwgIi0xd2lkdGgiKTsKICAgIH0KICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgidm9mZnNldCIsICIwLjdlbSIpOwogICAgbGFiZWwgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXN0eWxlIiwgW2xhYmVsXSk7CiAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoImRpc3BsYXlzdHlsZSIsICJmYWxzZSIpOwogICAgbGFiZWwuc2V0QXR0cmlidXRlKCJzY3JpcHRsZXZlbCIsICIxIik7CiAgICByZXR1cm4gbGFiZWw7CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJjZGxhYmVscGFyZW50IiwKICBuYW1lczogWyJcXFxcY2RwYXJlbnQiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMQogIH0sCiAgaGFuZGxlcihfcmVmMiwgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjI7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiY2RsYWJlbHBhcmVudCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBmcmFnbWVudDogYXJnc1swXQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgcGFyZW50ID0gYnVpbGRDb21tb24ud3JhcEZyYWdtZW50KGJ1aWxkR3JvdXAkMShncm91cC5mcmFnbWVudCwgb3B0aW9ucyksIG9wdGlvbnMpOwogICAgcGFyZW50LmNsYXNzZXMucHVzaCgiY2QtdmVydC1hcnJvdyIpOwogICAgcmV0dXJuIHBhcmVudDsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXJvdyIsIFtidWlsZEdyb3VwMihncm91cC5mcmFnbWVudCwgb3B0aW9ucyldKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogInRleHRvcmQiLAogIG5hbWVzOiBbIlxcQGNoYXIiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjsKICAgIHZhciBhcmcgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCAib3JkZ3JvdXAiKTsKICAgIHZhciBncm91cCA9IGFyZy5ib2R5OwogICAgdmFyIG51bWJlciA9ICIiOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykgewogICAgICB2YXIgbm9kZSA9IGFzc2VydE5vZGVUeXBlKGdyb3VwW2ldLCAidGV4dG9yZCIpOwogICAgICBudW1iZXIgKz0gbm9kZS50ZXh0OwogICAgfQogICAgdmFyIGNvZGUgPSBwYXJzZUludChudW1iZXIpOwogICAgdmFyIHRleHQyOwogICAgaWYgKGlzTmFOKGNvZGUpKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJcXEBjaGFyIGhhcyBub24tbnVtZXJpYyBhcmd1bWVudCAiICsgbnVtYmVyKTsKICAgIH0gZWxzZSBpZiAoY29kZSA8IDAgfHwgY29kZSA+PSAxMTE0MTExKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJcXEBjaGFyIHdpdGggaW52YWxpZCBjb2RlIHBvaW50ICIgKyBudW1iZXIpOwogICAgfSBlbHNlIGlmIChjb2RlIDw9IDY1NTM1KSB7CiAgICAgIHRleHQyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTsKICAgIH0gZWxzZSB7CiAgICAgIGNvZGUgLT0gNjU1MzY7CiAgICAgIHRleHQyID0gU3RyaW5nLmZyb21DaGFyQ29kZSgoY29kZSA+PiAxMCkgKyA1NTI5NiwgKGNvZGUgJiAxMDIzKSArIDU2MzIwKTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJ0ZXh0b3JkIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIHRleHQ6IHRleHQyCiAgICB9OwogIH0KfSk7CnZhciBodG1sQnVpbGRlciQ4ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoQ29sb3IoZ3JvdXAuY29sb3IpLCBmYWxzZSk7CiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7Cn07CnZhciBtYXRobWxCdWlsZGVyJDcgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgaW5uZXIyID0gYnVpbGRFeHByZXNzaW9uMihncm91cC5ib2R5LCBvcHRpb25zLndpdGhDb2xvcihncm91cC5jb2xvcikpOwogIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1zdHlsZSIsIGlubmVyMik7CiAgbm9kZS5zZXRBdHRyaWJ1dGUoIm1hdGhjb2xvciIsIGdyb3VwLmNvbG9yKTsKICByZXR1cm4gbm9kZTsKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJjb2xvciIsCiAgbmFtZXM6IFsiXFx0ZXh0Y29sb3IiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMiwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBhcmdUeXBlczogWyJjb2xvciIsICJvcmlnaW5hbCJdCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgY29sb3IgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCAiY29sb3ItdG9rZW4iKS5jb2xvcjsKICAgIHZhciBib2R5ID0gYXJnc1sxXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJjb2xvciIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBjb2xvciwKICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSkKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkOCwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDcKfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiY29sb3IiLAogIG5hbWVzOiBbIlxcY29sb3IiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBhcmdUeXBlczogWyJjb2xvciJdCiAgfSwKICBoYW5kbGVyKF9yZWYyLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGJyZWFrT25Ub2tlblRleHQKICAgIH0gPSBfcmVmMjsKICAgIHZhciBjb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sICJjb2xvci10b2tlbiIpLmNvbG9yOwogICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KCJcXGN1cnJlbnRAY29sb3IiLCBjb2xvcik7CiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiY29sb3IiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgY29sb3IsCiAgICAgIGJvZHkKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkOCwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDcKfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiY3IiLAogIG5hbWVzOiBbIlxcXFwiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMCwKICAgIG51bU9wdGlvbmFsQXJnczogMCwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncywgb3B0QXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjsKICAgIHZhciBzaXplID0gcGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSAiWyIgPyBwYXJzZXIucGFyc2VTaXplR3JvdXAodHJ1ZSkgOiBudWxsOwogICAgdmFyIG5ld0xpbmUgPSAhcGFyc2VyLnNldHRpbmdzLmRpc3BsYXlNb2RlIHx8ICFwYXJzZXIuc2V0dGluZ3MudXNlU3RyaWN0QmVoYXZpb3IoIm5ld0xpbmVJbkRpc3BsYXlNb2RlIiwgIkluIExhVGVYLCBcXFxcIG9yIFxcbmV3bGluZSBkb2VzIG5vdGhpbmcgaW4gZGlzcGxheSBtb2RlIik7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiY3IiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbmV3TGluZSwKICAgICAgc2l6ZTogc2l6ZSAmJiBhc3NlcnROb2RlVHlwZShzaXplLCAic2l6ZSIpLnZhbHVlCiAgICB9OwogIH0sCiAgLy8gVGhlIGZvbGxvd2luZyBidWlsZGVycyBhcmUgY2FsbGVkIG9ubHkgYXQgdGhlIHRvcCBsZXZlbCwKICAvLyBub3Qgd2l0aGluIHRhYnVsYXIvYXJyYXkgZW52aXJvbm1lbnRzLgogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibXNwYWNlIl0sIFtdLCBvcHRpb25zKTsKICAgIGlmIChncm91cC5uZXdMaW5lKSB7CiAgICAgIHNwYW4uY2xhc3Nlcy5wdXNoKCJuZXdsaW5lIik7CiAgICAgIGlmIChncm91cC5zaXplKSB7CiAgICAgICAgc3Bhbi5zdHlsZS5tYXJnaW5Ub3AgPSBtYWtlRW0oY2FsY3VsYXRlU2l6ZShncm91cC5zaXplLCBvcHRpb25zKSk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiBzcGFuOwogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXNwYWNlIik7CiAgICBpZiAoZ3JvdXAubmV3TGluZSkgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgibGluZWJyZWFrIiwgIm5ld2xpbmUiKTsKICAgICAgaWYgKGdyb3VwLnNpemUpIHsKICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IiwgbWFrZUVtKGNhbGN1bGF0ZVNpemUoZ3JvdXAuc2l6ZSwgb3B0aW9ucykpKTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKdmFyIGdsb2JhbE1hcCA9IHsKICAiXFxnbG9iYWwiOiAiXFxnbG9iYWwiLAogICJcXGxvbmciOiAiXFxcXGdsb2JhbGxvbmciLAogICJcXFxcZ2xvYmFsbG9uZyI6ICJcXFxcZ2xvYmFsbG9uZyIsCiAgIlxcZGVmIjogIlxcZ2RlZiIsCiAgIlxcZ2RlZiI6ICJcXGdkZWYiLAogICJcXGVkZWYiOiAiXFx4ZGVmIiwKICAiXFx4ZGVmIjogIlxceGRlZiIsCiAgIlxcbGV0IjogIlxcXFxnbG9iYWxsZXQiLAogICJcXGZ1dHVyZWxldCI6ICJcXFxcZ2xvYmFsZnV0dXJlIgp9Owp2YXIgY2hlY2tDb250cm9sU2VxdWVuY2UgPSAodG9rKSA9PiB7CiAgdmFyIG5hbWUgPSB0b2sudGV4dDsKICBpZiAoL14oPzpbXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkgewogICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkV4cGVjdGVkIGEgY29udHJvbCBzZXF1ZW5jZSIsIHRvayk7CiAgfQogIHJldHVybiBuYW1lOwp9Owp2YXIgZ2V0UkhTID0gKHBhcnNlcikgPT4gewogIHZhciB0b2sgPSBwYXJzZXIuZ3VsbGV0LnBvcFRva2VuKCk7CiAgaWYgKHRvay50ZXh0ID09PSAiPSIpIHsKICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTsKICAgIGlmICh0b2sudGV4dCA9PT0gIiAiKSB7CiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTsKICAgIH0KICB9CiAgcmV0dXJuIHRvazsKfTsKdmFyIGxldENvbW1hbmQgPSAocGFyc2VyLCBuYW1lLCB0b2ssIGdsb2JhbCkgPT4gewogIHZhciBtYWNybyA9IHBhcnNlci5ndWxsZXQubWFjcm9zLmdldCh0b2sudGV4dCk7CiAgaWYgKG1hY3JvID09IG51bGwpIHsKICAgIHRvay5ub2V4cGFuZCA9IHRydWU7CiAgICBtYWNybyA9IHsKICAgICAgdG9rZW5zOiBbdG9rXSwKICAgICAgbnVtQXJnczogMCwKICAgICAgLy8gcmVwcm9kdWNlIHRoZSBzYW1lIGJlaGF2aW9yIGluIGV4cGFuc2lvbgogICAgICB1bmV4cGFuZGFibGU6ICFwYXJzZXIuZ3VsbGV0LmlzRXhwYW5kYWJsZSh0b2sudGV4dCkKICAgIH07CiAgfQogIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldChuYW1lLCBtYWNybywgZ2xvYmFsKTsKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJpbnRlcm5hbCIsCiAgbmFtZXM6IFsKICAgICJcXGdsb2JhbCIsCiAgICAiXFxsb25nIiwKICAgICJcXFxcZ2xvYmFsbG9uZyIKICAgIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseQogIF0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyKF9yZWYpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmOwogICAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTsKICAgIHZhciB0b2tlbiA9IHBhcnNlci5mZXRjaCgpOwogICAgaWYgKGdsb2JhbE1hcFt0b2tlbi50ZXh0XSkgewogICAgICBpZiAoZnVuY05hbWUgPT09ICJcXGdsb2JhbCIgfHwgZnVuY05hbWUgPT09ICJcXFxcZ2xvYmFsbG9uZyIpIHsKICAgICAgICB0b2tlbi50ZXh0ID0gZ2xvYmFsTWFwW3Rva2VuLnRleHRdOwogICAgICB9CiAgICAgIHJldHVybiBhc3NlcnROb2RlVHlwZShwYXJzZXIucGFyc2VGdW5jdGlvbigpLCAiaW50ZXJuYWwiKTsKICAgIH0KICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIHRva2VuIGFmdGVyIG1hY3JvIHByZWZpeCIsIHRva2VuKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImludGVybmFsIiwKICBuYW1lczogWyJcXGRlZiIsICJcXGdkZWYiLCAiXFxlZGVmIiwgIlxceGRlZiJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZSwKICAgIHByaW1pdGl2ZTogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmMikgewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWYyOwogICAgdmFyIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTsKICAgIHZhciBuYW1lID0gdG9rLnRleHQ7CiAgICBpZiAoL14oPzpbXFx7fSQmI15fXXxFT0YpJC8udGVzdChuYW1lKSkgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiRXhwZWN0ZWQgYSBjb250cm9sIHNlcXVlbmNlIiwgdG9rKTsKICAgIH0KICAgIHZhciBudW1BcmdzID0gMDsKICAgIHZhciBpbnNlcnQ7CiAgICB2YXIgZGVsaW1pdGVyczIgPSBbW11dOwogICAgd2hpbGUgKHBhcnNlci5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gInsiKSB7CiAgICAgIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTsKICAgICAgaWYgKHRvay50ZXh0ID09PSAiIyIpIHsKICAgICAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ID09PSAieyIpIHsKICAgICAgICAgIGluc2VydCA9IHBhcnNlci5ndWxsZXQuZnV0dXJlKCk7CiAgICAgICAgICBkZWxpbWl0ZXJzMltudW1BcmdzXS5wdXNoKCJ7Iik7CiAgICAgICAgICBicmVhazsKICAgICAgICB9CiAgICAgICAgdG9rID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpOwogICAgICAgIGlmICghL15bMS05XSQvLnRlc3QodG9rLnRleHQpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignSW52YWxpZCBhcmd1bWVudCBudW1iZXIgIicgKyB0b2sudGV4dCArICciJyk7CiAgICAgICAgfQogICAgICAgIGlmIChwYXJzZUludCh0b2sudGV4dCkgIT09IG51bUFyZ3MgKyAxKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcignQXJndW1lbnQgbnVtYmVyICInICsgdG9rLnRleHQgKyAnIiBvdXQgb2Ygb3JkZXInKTsKICAgICAgICB9CiAgICAgICAgbnVtQXJncysrOwogICAgICAgIGRlbGltaXRlcnMyLnB1c2goW10pOwogICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSAiRU9GIikgewogICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJFeHBlY3RlZCBhIG1hY3JvIGRlZmluaXRpb24iKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBkZWxpbWl0ZXJzMltudW1BcmdzXS5wdXNoKHRvay50ZXh0KTsKICAgICAgfQogICAgfQogICAgdmFyIHsKICAgICAgdG9rZW5zCiAgICB9ID0gcGFyc2VyLmd1bGxldC5jb25zdW1lQXJnKCk7CiAgICBpZiAoaW5zZXJ0KSB7CiAgICAgIHRva2Vucy51bnNoaWZ0KGluc2VydCk7CiAgICB9CiAgICBpZiAoZnVuY05hbWUgPT09ICJcXGVkZWYiIHx8IGZ1bmNOYW1lID09PSAiXFx4ZGVmIikgewogICAgICB0b2tlbnMgPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZFRva2Vucyh0b2tlbnMpOwogICAgICB0b2tlbnMucmV2ZXJzZSgpOwogICAgfQogICAgcGFyc2VyLmd1bGxldC5tYWNyb3Muc2V0KG5hbWUsIHsKICAgICAgdG9rZW5zLAogICAgICBudW1BcmdzLAogICAgICBkZWxpbWl0ZXJzOiBkZWxpbWl0ZXJzMgogICAgfSwgZnVuY05hbWUgPT09IGdsb2JhbE1hcFtmdW5jTmFtZV0pOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImludGVybmFsIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUKICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJpbnRlcm5hbCIsCiAgbmFtZXM6IFsKICAgICJcXGxldCIsCiAgICAiXFxcXGdsb2JhbGxldCIKICAgIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseQogIF0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLAogICAgcHJpbWl0aXZlOiB0cnVlCiAgfSwKICBoYW5kbGVyKF9yZWYzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjM7CiAgICB2YXIgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7CiAgICBwYXJzZXIuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTsKICAgIHZhciB0b2sgPSBnZXRSSFMocGFyc2VyKTsKICAgIGxldENvbW1hbmQocGFyc2VyLCBuYW1lLCB0b2ssIGZ1bmNOYW1lID09PSAiXFxcXGdsb2JhbGxldCIpOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImludGVybmFsIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUKICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJpbnRlcm5hbCIsCiAgbmFtZXM6IFsKICAgICJcXGZ1dHVyZWxldCIsCiAgICAiXFxcXGdsb2JhbGZ1dHVyZSIKICAgIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseQogIF0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLAogICAgcHJpbWl0aXZlOiB0cnVlCiAgfSwKICBoYW5kbGVyKF9yZWY0KSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjQ7CiAgICB2YXIgbmFtZSA9IGNoZWNrQ29udHJvbFNlcXVlbmNlKHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKSk7CiAgICB2YXIgbWlkZGxlID0gcGFyc2VyLmd1bGxldC5wb3BUb2tlbigpOwogICAgdmFyIHRvayA9IHBhcnNlci5ndWxsZXQucG9wVG9rZW4oKTsKICAgIGxldENvbW1hbmQocGFyc2VyLCBuYW1lLCB0b2ssIGZ1bmNOYW1lID09PSAiXFxcXGdsb2JhbGZ1dHVyZSIpOwogICAgcGFyc2VyLmd1bGxldC5wdXNoVG9rZW4odG9rKTsKICAgIHBhcnNlci5ndWxsZXQucHVzaFRva2VuKG1pZGRsZSk7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiaW50ZXJuYWwiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZQogICAgfTsKICB9Cn0pOwp2YXIgZ2V0TWV0cmljcyA9IGZ1bmN0aW9uIGdldE1ldHJpY3MyKHN5bWJvbCwgZm9udCwgbW9kZSkgewogIHZhciByZXBsYWNlID0gc3ltYm9scy5tYXRoW3N5bWJvbF0gJiYgc3ltYm9scy5tYXRoW3N5bWJvbF0ucmVwbGFjZTsKICB2YXIgbWV0cmljcyA9IGdldENoYXJhY3Rlck1ldHJpY3MocmVwbGFjZSB8fCBzeW1ib2wsIGZvbnQsIG1vZGUpOwogIGlmICghbWV0cmljcykgewogICAgdGhyb3cgbmV3IEVycm9yKCJVbnN1cHBvcnRlZCBzeW1ib2wgIiArIHN5bWJvbCArICIgYW5kIGZvbnQgc2l6ZSAiICsgZm9udCArICIuIik7CiAgfQogIHJldHVybiBtZXRyaWNzOwp9Owp2YXIgc3R5bGVXcmFwID0gZnVuY3Rpb24gc3R5bGVXcmFwMihkZWxpbSwgdG9TdHlsZSwgb3B0aW9ucywgY2xhc3NlcykgewogIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUodG9TdHlsZSk7CiAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBbZGVsaW1dLCBvcHRpb25zKTsKICB2YXIgZGVsaW1TaXplTXVsdGlwbGllciA9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyOwogIHNwYW4uaGVpZ2h0ICo9IGRlbGltU2l6ZU11bHRpcGxpZXI7CiAgc3Bhbi5kZXB0aCAqPSBkZWxpbVNpemVNdWx0aXBsaWVyOwogIHNwYW4ubWF4Rm9udFNpemUgPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyOwogIHJldHVybiBzcGFuOwp9Owp2YXIgY2VudGVyU3BhbiA9IGZ1bmN0aW9uIGNlbnRlclNwYW4yKHNwYW4sIG9wdGlvbnMsIHN0eWxlKSB7CiAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShzdHlsZSk7CiAgdmFyIHNoaWZ0ID0gKDEgLSBvcHRpb25zLnNpemVNdWx0aXBsaWVyIC8gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcikgKiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDsKICBzcGFuLmNsYXNzZXMucHVzaCgiZGVsaW1jZW50ZXIiKTsKICBzcGFuLnN0eWxlLnRvcCA9IG1ha2VFbShzaGlmdCk7CiAgc3Bhbi5oZWlnaHQgLT0gc2hpZnQ7CiAgc3Bhbi5kZXB0aCArPSBzaGlmdDsKfTsKdmFyIG1ha2VTbWFsbERlbGltID0gZnVuY3Rpb24gbWFrZVNtYWxsRGVsaW0yKGRlbGltLCBzdHlsZSwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7CiAgdmFyIHRleHQyID0gYnVpbGRDb21tb24ubWFrZVN5bWJvbChkZWxpbSwgIk1haW4tUmVndWxhciIsIG1vZGUsIG9wdGlvbnMpOwogIHZhciBzcGFuID0gc3R5bGVXcmFwKHRleHQyLCBzdHlsZSwgb3B0aW9ucywgY2xhc3Nlcyk7CiAgaWYgKGNlbnRlcikgewogICAgY2VudGVyU3BhbihzcGFuLCBvcHRpb25zLCBzdHlsZSk7CiAgfQogIHJldHVybiBzcGFuOwp9Owp2YXIgbWF0aHJtU2l6ZSA9IGZ1bmN0aW9uIG1hdGhybVNpemUyKHZhbHVlLCBzaXplLCBtb2RlLCBvcHRpb25zKSB7CiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2wodmFsdWUsICJTaXplIiArIHNpemUgKyAiLVJlZ3VsYXIiLCBtb2RlLCBvcHRpb25zKTsKfTsKdmFyIG1ha2VMYXJnZURlbGltID0gZnVuY3Rpb24gbWFrZUxhcmdlRGVsaW0yKGRlbGltLCBzaXplLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpIHsKICB2YXIgaW5uZXIyID0gbWF0aHJtU2l6ZShkZWxpbSwgc2l6ZSwgbW9kZSwgb3B0aW9ucyk7CiAgdmFyIHNwYW4gPSBzdHlsZVdyYXAoYnVpbGRDb21tb24ubWFrZVNwYW4oWyJkZWxpbXNpemluZyIsICJzaXplIiArIHNpemVdLCBbaW5uZXIyXSwgb3B0aW9ucyksIFN0eWxlJDEuVEVYVCwgb3B0aW9ucywgY2xhc3Nlcyk7CiAgaWYgKGNlbnRlcikgewogICAgY2VudGVyU3BhbihzcGFuLCBvcHRpb25zLCBTdHlsZSQxLlRFWFQpOwogIH0KICByZXR1cm4gc3BhbjsKfTsKdmFyIG1ha2VHbHlwaFNwYW4gPSBmdW5jdGlvbiBtYWtlR2x5cGhTcGFuMihzeW1ib2wsIGZvbnQsIG1vZGUpIHsKICB2YXIgc2l6ZUNsYXNzOwogIGlmIChmb250ID09PSAiU2l6ZTEtUmVndWxhciIpIHsKICAgIHNpemVDbGFzcyA9ICJkZWxpbS1zaXplMSI7CiAgfSBlbHNlIHsKICAgIHNpemVDbGFzcyA9ICJkZWxpbS1zaXplNCI7CiAgfQogIHZhciBjb3JuZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbImRlbGltc2l6aW5naW5uZXIiLCBzaXplQ2xhc3NdLCBbYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZENvbW1vbi5tYWtlU3ltYm9sKHN5bWJvbCwgZm9udCwgbW9kZSldKV0pOwogIHJldHVybiB7CiAgICB0eXBlOiAiZWxlbSIsCiAgICBlbGVtOiBjb3JuZXIKICB9Owp9Owp2YXIgbWFrZUlubmVyID0gZnVuY3Rpb24gbWFrZUlubmVyMihjaCwgaGVpZ2h0LCBvcHRpb25zKSB7CiAgdmFyIHdpZHRoID0gZm9udE1ldHJpY3NEYXRhWyJTaXplNC1SZWd1bGFyIl1bY2guY2hhckNvZGVBdCgwKV0gPyBmb250TWV0cmljc0RhdGFbIlNpemU0LVJlZ3VsYXIiXVtjaC5jaGFyQ29kZUF0KDApXVs0XSA6IGZvbnRNZXRyaWNzRGF0YVsiU2l6ZTEtUmVndWxhciJdW2NoLmNoYXJDb2RlQXQoMCldWzRdOwogIHZhciBwYXRoMiA9IG5ldyBQYXRoTm9kZSgiaW5uZXIiLCBpbm5lclBhdGgoY2gsIE1hdGgucm91bmQoMWUzICogaGVpZ2h0KSkpOwogIHZhciBzdmdOb2RlID0gbmV3IFN2Z05vZGUoW3BhdGgyXSwgewogICAgIndpZHRoIjogbWFrZUVtKHdpZHRoKSwKICAgICJoZWlnaHQiOiBtYWtlRW0oaGVpZ2h0KSwKICAgIC8vIE92ZXJyaWRlIENTUyBydWxlIGAua2F0ZXggc3ZnIHsgd2lkdGg6IDEwMCUgfWAKICAgICJzdHlsZSI6ICJ3aWR0aDoiICsgbWFrZUVtKHdpZHRoKSwKICAgICJ2aWV3Qm94IjogIjAgMCAiICsgMWUzICogd2lkdGggKyAiICIgKyBNYXRoLnJvdW5kKDFlMyAqIGhlaWdodCksCiAgICAicHJlc2VydmVBc3BlY3RSYXRpbyI6ICJ4TWluWU1pbiIKICB9KTsKICB2YXIgc3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnTm9kZV0sIG9wdGlvbnMpOwogIHNwYW4uaGVpZ2h0ID0gaGVpZ2h0OwogIHNwYW4uc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGhlaWdodCk7CiAgc3Bhbi5zdHlsZS53aWR0aCA9IG1ha2VFbSh3aWR0aCk7CiAgcmV0dXJuIHsKICAgIHR5cGU6ICJlbGVtIiwKICAgIGVsZW06IHNwYW4KICB9Owp9Owp2YXIgbGFwSW5FbXMgPSA4ZS0zOwp2YXIgbGFwID0gewogIHR5cGU6ICJrZXJuIiwKICBzaXplOiAtMSAqIGxhcEluRW1zCn07CnZhciB2ZXJ0cyA9IFsifCIsICJcXGx2ZXJ0IiwgIlxccnZlcnQiLCAiXFx2ZXJ0Il07CnZhciBkb3VibGVWZXJ0cyA9IFsiXFx8IiwgIlxcbFZlcnQiLCAiXFxyVmVydCIsICJcXFZlcnQiXTsKdmFyIG1ha2VTdGFja2VkRGVsaW0gPSBmdW5jdGlvbiBtYWtlU3RhY2tlZERlbGltMihkZWxpbSwgaGVpZ2h0VG90YWwsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3NlcykgewogIHZhciB0b3A7CiAgdmFyIG1pZGRsZTsKICB2YXIgcmVwZWF0OwogIHZhciBib3R0b207CiAgdmFyIHN2Z0xhYmVsID0gIiI7CiAgdmFyIHZpZXdCb3hXaWR0aCA9IDA7CiAgdG9wID0gcmVwZWF0ID0gYm90dG9tID0gZGVsaW07CiAgbWlkZGxlID0gbnVsbDsKICB2YXIgZm9udCA9ICJTaXplMS1SZWd1bGFyIjsKICBpZiAoZGVsaW0gPT09ICJcXHVwYXJyb3ciKSB7CiAgICByZXBlYXQgPSBib3R0b20gPSAi4o+QIjsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiXFxVcGFycm93IikgewogICAgcmVwZWF0ID0gYm90dG9tID0gIuKAliI7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlxcZG93bmFycm93IikgewogICAgdG9wID0gcmVwZWF0ID0gIuKPkCI7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlxcRG93bmFycm93IikgewogICAgdG9wID0gcmVwZWF0ID0gIuKAliI7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlxcdXBkb3duYXJyb3ciKSB7CiAgICB0b3AgPSAiXFx1cGFycm93IjsKICAgIHJlcGVhdCA9ICLij5AiOwogICAgYm90dG9tID0gIlxcZG93bmFycm93IjsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiXFxVcGRvd25hcnJvdyIpIHsKICAgIHRvcCA9ICJcXFVwYXJyb3ciOwogICAgcmVwZWF0ID0gIuKAliI7CiAgICBib3R0b20gPSAiXFxEb3duYXJyb3ciOwogIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnModmVydHMsIGRlbGltKSkgewogICAgcmVwZWF0ID0gIuKIoyI7CiAgICBzdmdMYWJlbCA9ICJ2ZXJ0IjsKICAgIHZpZXdCb3hXaWR0aCA9IDMzMzsKICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKGRvdWJsZVZlcnRzLCBkZWxpbSkpIHsKICAgIHJlcGVhdCA9ICLiiKUiOwogICAgc3ZnTGFiZWwgPSAiZG91YmxldmVydCI7CiAgICB2aWV3Qm94V2lkdGggPSA1NTY7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlsiIHx8IGRlbGltID09PSAiXFxsYnJhY2siKSB7CiAgICB0b3AgPSAi4o6hIjsKICAgIHJlcGVhdCA9ICLijqIiOwogICAgYm90dG9tID0gIuKOoyI7CiAgICBmb250ID0gIlNpemU0LVJlZ3VsYXIiOwogICAgc3ZnTGFiZWwgPSAibGJyYWNrIjsKICAgIHZpZXdCb3hXaWR0aCA9IDY2NzsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiXSIgfHwgZGVsaW0gPT09ICJcXHJicmFjayIpIHsKICAgIHRvcCA9ICLijqQiOwogICAgcmVwZWF0ID0gIuKOpSI7CiAgICBib3R0b20gPSAi4o6mIjsKICAgIGZvbnQgPSAiU2l6ZTQtUmVndWxhciI7CiAgICBzdmdMYWJlbCA9ICJyYnJhY2siOwogICAgdmlld0JveFdpZHRoID0gNjY3OwogIH0gZWxzZSBpZiAoZGVsaW0gPT09ICJcXGxmbG9vciIgfHwgZGVsaW0gPT09ICLijIoiKSB7CiAgICByZXBlYXQgPSB0b3AgPSAi4o6iIjsKICAgIGJvdHRvbSA9ICLijqMiOwogICAgZm9udCA9ICJTaXplNC1SZWd1bGFyIjsKICAgIHN2Z0xhYmVsID0gImxmbG9vciI7CiAgICB2aWV3Qm94V2lkdGggPSA2Njc7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlxcbGNlaWwiIHx8IGRlbGltID09PSAi4oyIIikgewogICAgdG9wID0gIuKOoSI7CiAgICByZXBlYXQgPSBib3R0b20gPSAi4o6iIjsKICAgIGZvbnQgPSAiU2l6ZTQtUmVndWxhciI7CiAgICBzdmdMYWJlbCA9ICJsY2VpbCI7CiAgICB2aWV3Qm94V2lkdGggPSA2Njc7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlxccmZsb29yIiB8fCBkZWxpbSA9PT0gIuKMiyIpIHsKICAgIHJlcGVhdCA9IHRvcCA9ICLijqUiOwogICAgYm90dG9tID0gIuKOpiI7CiAgICBmb250ID0gIlNpemU0LVJlZ3VsYXIiOwogICAgc3ZnTGFiZWwgPSAicmZsb29yIjsKICAgIHZpZXdCb3hXaWR0aCA9IDY2NzsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiXFxyY2VpbCIgfHwgZGVsaW0gPT09ICLijIkiKSB7CiAgICB0b3AgPSAi4o6kIjsKICAgIHJlcGVhdCA9IGJvdHRvbSA9ICLijqUiOwogICAgZm9udCA9ICJTaXplNC1SZWd1bGFyIjsKICAgIHN2Z0xhYmVsID0gInJjZWlsIjsKICAgIHZpZXdCb3hXaWR0aCA9IDY2NzsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiKCIgfHwgZGVsaW0gPT09ICJcXGxwYXJlbiIpIHsKICAgIHRvcCA9ICLijpsiOwogICAgcmVwZWF0ID0gIuKOnCI7CiAgICBib3R0b20gPSAi4o6dIjsKICAgIGZvbnQgPSAiU2l6ZTQtUmVndWxhciI7CiAgICBzdmdMYWJlbCA9ICJscGFyZW4iOwogICAgdmlld0JveFdpZHRoID0gODc1OwogIH0gZWxzZSBpZiAoZGVsaW0gPT09ICIpIiB8fCBkZWxpbSA9PT0gIlxccnBhcmVuIikgewogICAgdG9wID0gIuKOniI7CiAgICByZXBlYXQgPSAi4o6fIjsKICAgIGJvdHRvbSA9ICLijqAiOwogICAgZm9udCA9ICJTaXplNC1SZWd1bGFyIjsKICAgIHN2Z0xhYmVsID0gInJwYXJlbiI7CiAgICB2aWV3Qm94V2lkdGggPSA4NzU7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIlxceyIgfHwgZGVsaW0gPT09ICJcXGxicmFjZSIpIHsKICAgIHRvcCA9ICLijqciOwogICAgbWlkZGxlID0gIuKOqCI7CiAgICBib3R0b20gPSAi4o6pIjsKICAgIHJlcGVhdCA9ICLijqoiOwogICAgZm9udCA9ICJTaXplNC1SZWd1bGFyIjsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiXFx9IiB8fCBkZWxpbSA9PT0gIlxccmJyYWNlIikgewogICAgdG9wID0gIuKOqyI7CiAgICBtaWRkbGUgPSAi4o6sIjsKICAgIGJvdHRvbSA9ICLijq0iOwogICAgcmVwZWF0ID0gIuKOqiI7CiAgICBmb250ID0gIlNpemU0LVJlZ3VsYXIiOwogIH0gZWxzZSBpZiAoZGVsaW0gPT09ICJcXGxncm91cCIgfHwgZGVsaW0gPT09ICLin64iKSB7CiAgICB0b3AgPSAi4o6nIjsKICAgIGJvdHRvbSA9ICLijqkiOwogICAgcmVwZWF0ID0gIuKOqiI7CiAgICBmb250ID0gIlNpemU0LVJlZ3VsYXIiOwogIH0gZWxzZSBpZiAoZGVsaW0gPT09ICJcXHJncm91cCIgfHwgZGVsaW0gPT09ICLin68iKSB7CiAgICB0b3AgPSAi4o6rIjsKICAgIGJvdHRvbSA9ICLijq0iOwogICAgcmVwZWF0ID0gIuKOqiI7CiAgICBmb250ID0gIlNpemU0LVJlZ3VsYXIiOwogIH0gZWxzZSBpZiAoZGVsaW0gPT09ICJcXGxtb3VzdGFjaGUiIHx8IGRlbGltID09PSAi4o6wIikgewogICAgdG9wID0gIuKOpyI7CiAgICBib3R0b20gPSAi4o6tIjsKICAgIHJlcGVhdCA9ICLijqoiOwogICAgZm9udCA9ICJTaXplNC1SZWd1bGFyIjsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiXFxybW91c3RhY2hlIiB8fCBkZWxpbSA9PT0gIuKOsSIpIHsKICAgIHRvcCA9ICLijqsiOwogICAgYm90dG9tID0gIuKOqSI7CiAgICByZXBlYXQgPSAi4o6qIjsKICAgIGZvbnQgPSAiU2l6ZTQtUmVndWxhciI7CiAgfQogIHZhciB0b3BNZXRyaWNzID0gZ2V0TWV0cmljcyh0b3AsIGZvbnQsIG1vZGUpOwogIHZhciB0b3BIZWlnaHRUb3RhbCA9IHRvcE1ldHJpY3MuaGVpZ2h0ICsgdG9wTWV0cmljcy5kZXB0aDsKICB2YXIgcmVwZWF0TWV0cmljcyA9IGdldE1ldHJpY3MocmVwZWF0LCBmb250LCBtb2RlKTsKICB2YXIgcmVwZWF0SGVpZ2h0VG90YWwgPSByZXBlYXRNZXRyaWNzLmhlaWdodCArIHJlcGVhdE1ldHJpY3MuZGVwdGg7CiAgdmFyIGJvdHRvbU1ldHJpY3MgPSBnZXRNZXRyaWNzKGJvdHRvbSwgZm9udCwgbW9kZSk7CiAgdmFyIGJvdHRvbUhlaWdodFRvdGFsID0gYm90dG9tTWV0cmljcy5oZWlnaHQgKyBib3R0b21NZXRyaWNzLmRlcHRoOwogIHZhciBtaWRkbGVIZWlnaHRUb3RhbCA9IDA7CiAgdmFyIG1pZGRsZUZhY3RvciA9IDE7CiAgaWYgKG1pZGRsZSAhPT0gbnVsbCkgewogICAgdmFyIG1pZGRsZU1ldHJpY3MgPSBnZXRNZXRyaWNzKG1pZGRsZSwgZm9udCwgbW9kZSk7CiAgICBtaWRkbGVIZWlnaHRUb3RhbCA9IG1pZGRsZU1ldHJpY3MuaGVpZ2h0ICsgbWlkZGxlTWV0cmljcy5kZXB0aDsKICAgIG1pZGRsZUZhY3RvciA9IDI7CiAgfQogIHZhciBtaW5IZWlnaHQgPSB0b3BIZWlnaHRUb3RhbCArIGJvdHRvbUhlaWdodFRvdGFsICsgbWlkZGxlSGVpZ2h0VG90YWw7CiAgdmFyIHJlcGVhdENvdW50ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChoZWlnaHRUb3RhbCAtIG1pbkhlaWdodCkgLyAobWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWwpKSk7CiAgdmFyIHJlYWxIZWlnaHRUb3RhbCA9IG1pbkhlaWdodCArIHJlcGVhdENvdW50ICogbWlkZGxlRmFjdG9yICogcmVwZWF0SGVpZ2h0VG90YWw7CiAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDsKICBpZiAoY2VudGVyKSB7CiAgICBheGlzSGVpZ2h0ICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgfQogIHZhciBkZXB0aCA9IHJlYWxIZWlnaHRUb3RhbCAvIDIgLSBheGlzSGVpZ2h0OwogIHZhciBzdGFjayA9IFtdOwogIGlmIChzdmdMYWJlbC5sZW5ndGggPiAwKSB7CiAgICB2YXIgbWlkSGVpZ2h0ID0gcmVhbEhlaWdodFRvdGFsIC0gdG9wSGVpZ2h0VG90YWwgLSBib3R0b21IZWlnaHRUb3RhbDsKICAgIHZhciB2aWV3Qm94SGVpZ2h0ID0gTWF0aC5yb3VuZChyZWFsSGVpZ2h0VG90YWwgKiAxZTMpOwogICAgdmFyIHBhdGhTdHIgPSB0YWxsRGVsaW0oc3ZnTGFiZWwsIE1hdGgucm91bmQobWlkSGVpZ2h0ICogMWUzKSk7CiAgICB2YXIgcGF0aDIgPSBuZXcgUGF0aE5vZGUoc3ZnTGFiZWwsIHBhdGhTdHIpOwogICAgdmFyIHdpZHRoID0gKHZpZXdCb3hXaWR0aCAvIDFlMykudG9GaXhlZCgzKSArICJlbSI7CiAgICB2YXIgaGVpZ2h0ID0gKHZpZXdCb3hIZWlnaHQgLyAxZTMpLnRvRml4ZWQoMykgKyAiZW0iOwogICAgdmFyIHN2ZyA9IG5ldyBTdmdOb2RlKFtwYXRoMl0sIHsKICAgICAgIndpZHRoIjogd2lkdGgsCiAgICAgICJoZWlnaHQiOiBoZWlnaHQsCiAgICAgICJ2aWV3Qm94IjogIjAgMCAiICsgdmlld0JveFdpZHRoICsgIiAiICsgdmlld0JveEhlaWdodAogICAgfSk7CiAgICB2YXIgd3JhcHBlciA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFtdLCBbc3ZnXSwgb3B0aW9ucyk7CiAgICB3cmFwcGVyLmhlaWdodCA9IHZpZXdCb3hIZWlnaHQgLyAxZTM7CiAgICB3cmFwcGVyLnN0eWxlLndpZHRoID0gd2lkdGg7CiAgICB3cmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlaWdodDsKICAgIHN0YWNrLnB1c2goewogICAgICB0eXBlOiAiZWxlbSIsCiAgICAgIGVsZW06IHdyYXBwZXIKICAgIH0pOwogIH0gZWxzZSB7CiAgICBzdGFjay5wdXNoKG1ha2VHbHlwaFNwYW4oYm90dG9tLCBmb250LCBtb2RlKSk7CiAgICBzdGFjay5wdXNoKGxhcCk7CiAgICBpZiAobWlkZGxlID09PSBudWxsKSB7CiAgICAgIHZhciBpbm5lckhlaWdodCA9IHJlYWxIZWlnaHRUb3RhbCAtIHRvcEhlaWdodFRvdGFsIC0gYm90dG9tSGVpZ2h0VG90YWwgKyAyICogbGFwSW5FbXM7CiAgICAgIHN0YWNrLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgaW5uZXJIZWlnaHQsIG9wdGlvbnMpKTsKICAgIH0gZWxzZSB7CiAgICAgIHZhciBfaW5uZXJIZWlnaHQgPSAocmVhbEhlaWdodFRvdGFsIC0gdG9wSGVpZ2h0VG90YWwgLSBib3R0b21IZWlnaHRUb3RhbCAtIG1pZGRsZUhlaWdodFRvdGFsKSAvIDIgKyAyICogbGFwSW5FbXM7CiAgICAgIHN0YWNrLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgX2lubmVySGVpZ2h0LCBvcHRpb25zKSk7CiAgICAgIHN0YWNrLnB1c2gobGFwKTsKICAgICAgc3RhY2sucHVzaChtYWtlR2x5cGhTcGFuKG1pZGRsZSwgZm9udCwgbW9kZSkpOwogICAgICBzdGFjay5wdXNoKGxhcCk7CiAgICAgIHN0YWNrLnB1c2gobWFrZUlubmVyKHJlcGVhdCwgX2lubmVySGVpZ2h0LCBvcHRpb25zKSk7CiAgICB9CiAgICBzdGFjay5wdXNoKGxhcCk7CiAgICBzdGFjay5wdXNoKG1ha2VHbHlwaFNwYW4odG9wLCBmb250LCBtb2RlKSk7CiAgfQogIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoU3R5bGUkMS5URVhUKTsKICB2YXIgaW5uZXIyID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgIHBvc2l0aW9uVHlwZTogImJvdHRvbSIsCiAgICBwb3NpdGlvbkRhdGE6IGRlcHRoLAogICAgY2hpbGRyZW46IHN0YWNrCiAgfSwgbmV3T3B0aW9ucyk7CiAgcmV0dXJuIHN0eWxlV3JhcChidWlsZENvbW1vbi5tYWtlU3BhbihbImRlbGltc2l6aW5nIiwgIm11bHQiXSwgW2lubmVyMl0sIG5ld09wdGlvbnMpLCBTdHlsZSQxLlRFWFQsIG9wdGlvbnMsIGNsYXNzZXMpOwp9Owp2YXIgdmJQYWQgPSA4MDsKdmFyIGVtUGFkID0gMC4wODsKdmFyIHNxcnRTdmcgPSBmdW5jdGlvbiBzcXJ0U3ZnMihzcXJ0TmFtZSwgaGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKSB7CiAgdmFyIHBhdGgyID0gc3FydFBhdGgoc3FydE5hbWUsIGV4dHJhVmluY3VsdW0sIHZpZXdCb3hIZWlnaHQpOwogIHZhciBwYXRoTm9kZSA9IG5ldyBQYXRoTm9kZShzcXJ0TmFtZSwgcGF0aDIpOwogIHZhciBzdmcgPSBuZXcgU3ZnTm9kZShbcGF0aE5vZGVdLCB7CiAgICAvLyBOb3RlOiAxMDAwOjEgcmF0aW8gb2Ygdmlld0JveCB0byBkb2N1bWVudCBlbSB3aWR0aC4KICAgICJ3aWR0aCI6ICI0MDBlbSIsCiAgICAiaGVpZ2h0IjogbWFrZUVtKGhlaWdodCksCiAgICAidmlld0JveCI6ICIwIDAgNDAwMDAwICIgKyB2aWV3Qm94SGVpZ2h0LAogICAgInByZXNlcnZlQXNwZWN0UmF0aW8iOiAieE1pbllNaW4gc2xpY2UiCiAgfSk7CiAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFsiaGlkZS10YWlsIl0sIFtzdmddLCBvcHRpb25zKTsKfTsKdmFyIG1ha2VTcXJ0SW1hZ2UgPSBmdW5jdGlvbiBtYWtlU3FydEltYWdlMihoZWlnaHQsIG9wdGlvbnMpIHsKICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nQmFzZVNpemluZygpOwogIHZhciBkZWxpbSA9IHRyYXZlcnNlU2VxdWVuY2UoIlxcc3VyZCIsIGhlaWdodCAqIG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIsIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSwgbmV3T3B0aW9ucyk7CiAgdmFyIHNpemVNdWx0aXBsaWVyID0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjsKICB2YXIgZXh0cmFWaW5jdWx1bSA9IE1hdGgubWF4KDAsIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcyAtIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5zcXJ0UnVsZVRoaWNrbmVzcyk7CiAgdmFyIHNwYW47CiAgdmFyIHNwYW5IZWlnaHQgPSAwOwogIHZhciB0ZXhIZWlnaHQgPSAwOwogIHZhciB2aWV3Qm94SGVpZ2h0ID0gMDsKICB2YXIgYWR2YW5jZVdpZHRoOwogIGlmIChkZWxpbS50eXBlID09PSAic21hbGwiKSB7CiAgICB2aWV3Qm94SGVpZ2h0ID0gMWUzICsgMWUzICogZXh0cmFWaW5jdWx1bSArIHZiUGFkOwogICAgaWYgKGhlaWdodCA8IDEpIHsKICAgICAgc2l6ZU11bHRpcGxpZXIgPSAxOwogICAgfSBlbHNlIGlmIChoZWlnaHQgPCAxLjQpIHsKICAgICAgc2l6ZU11bHRpcGxpZXIgPSAwLjc7CiAgICB9CiAgICBzcGFuSGVpZ2h0ID0gKDEgKyBleHRyYVZpbmN1bHVtICsgZW1QYWQpIC8gc2l6ZU11bHRpcGxpZXI7CiAgICB0ZXhIZWlnaHQgPSAoMSArIGV4dHJhVmluY3VsdW0pIC8gc2l6ZU11bHRpcGxpZXI7CiAgICBzcGFuID0gc3FydFN2Zygic3FydE1haW4iLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKTsKICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSAiMC44NTNlbSI7CiAgICBhZHZhbmNlV2lkdGggPSAwLjgzMyAvIHNpemVNdWx0aXBsaWVyOwogIH0gZWxzZSBpZiAoZGVsaW0udHlwZSA9PT0gImxhcmdlIikgewogICAgdmlld0JveEhlaWdodCA9ICgxZTMgKyB2YlBhZCkgKiBzaXplVG9NYXhIZWlnaHRbZGVsaW0uc2l6ZV07CiAgICB0ZXhIZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZXh0cmFWaW5jdWx1bSkgLyBzaXplTXVsdGlwbGllcjsKICAgIHNwYW5IZWlnaHQgPSAoc2l6ZVRvTWF4SGVpZ2h0W2RlbGltLnNpemVdICsgZXh0cmFWaW5jdWx1bSArIGVtUGFkKSAvIHNpemVNdWx0aXBsaWVyOwogICAgc3BhbiA9IHNxcnRTdmcoInNxcnRTaXplIiArIGRlbGltLnNpemUsIHNwYW5IZWlnaHQsIHZpZXdCb3hIZWlnaHQsIGV4dHJhVmluY3VsdW0sIG9wdGlvbnMpOwogICAgc3Bhbi5zdHlsZS5taW5XaWR0aCA9ICIxLjAyZW0iOwogICAgYWR2YW5jZVdpZHRoID0gMSAvIHNpemVNdWx0aXBsaWVyOwogIH0gZWxzZSB7CiAgICBzcGFuSGVpZ2h0ID0gaGVpZ2h0ICsgZXh0cmFWaW5jdWx1bSArIGVtUGFkOwogICAgdGV4SGVpZ2h0ID0gaGVpZ2h0ICsgZXh0cmFWaW5jdWx1bTsKICAgIHZpZXdCb3hIZWlnaHQgPSBNYXRoLmZsb29yKDFlMyAqIGhlaWdodCArIGV4dHJhVmluY3VsdW0pICsgdmJQYWQ7CiAgICBzcGFuID0gc3FydFN2Zygic3FydFRhbGwiLCBzcGFuSGVpZ2h0LCB2aWV3Qm94SGVpZ2h0LCBleHRyYVZpbmN1bHVtLCBvcHRpb25zKTsKICAgIHNwYW4uc3R5bGUubWluV2lkdGggPSAiMC43NDJlbSI7CiAgICBhZHZhbmNlV2lkdGggPSAxLjA1NjsKICB9CiAgc3Bhbi5oZWlnaHQgPSB0ZXhIZWlnaHQ7CiAgc3Bhbi5zdHlsZS5oZWlnaHQgPSBtYWtlRW0oc3BhbkhlaWdodCk7CiAgcmV0dXJuIHsKICAgIHNwYW4sCiAgICBhZHZhbmNlV2lkdGgsCiAgICAvLyBDYWxjdWxhdGUgdGhlIGFjdHVhbCBsaW5lIHdpZHRoLgogICAgLy8gVGhpcyBhY3R1YWxseSBzaG91bGQgZGVwZW5kIG9uIHRoZSBjaG9zZW4gZm9udCAtLSBlLmcuIFxib2xkbWF0aAogICAgLy8gc2hvdWxkIHVzZSB0aGUgdGhpY2tlciBzdXJkIHN5bWJvbHMgZnJvbSBlLmcuIEthVGVYX01haW4tQm9sZCwgYW5kCiAgICAvLyBoYXZlIHRoaWNrZXIgcnVsZXMuCiAgICBydWxlV2lkdGg6IChvcHRpb25zLmZvbnRNZXRyaWNzKCkuc3FydFJ1bGVUaGlja25lc3MgKyBleHRyYVZpbmN1bHVtKSAqIHNpemVNdWx0aXBsaWVyCiAgfTsKfTsKdmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJzID0gWyIoIiwgIlxcbHBhcmVuIiwgIikiLCAiXFxycGFyZW4iLCAiWyIsICJcXGxicmFjayIsICJdIiwgIlxccmJyYWNrIiwgIlxceyIsICJcXGxicmFjZSIsICJcXH0iLCAiXFxyYnJhY2UiLCAiXFxsZmxvb3IiLCAiXFxyZmxvb3IiLCAi4oyKIiwgIuKMiyIsICJcXGxjZWlsIiwgIlxccmNlaWwiLCAi4oyIIiwgIuKMiSIsICJcXHN1cmQiXTsKdmFyIHN0YWNrQWx3YXlzRGVsaW1pdGVycyA9IFsiXFx1cGFycm93IiwgIlxcZG93bmFycm93IiwgIlxcdXBkb3duYXJyb3ciLCAiXFxVcGFycm93IiwgIlxcRG93bmFycm93IiwgIlxcVXBkb3duYXJyb3ciLCAifCIsICJcXHwiLCAiXFx2ZXJ0IiwgIlxcVmVydCIsICJcXGx2ZXJ0IiwgIlxccnZlcnQiLCAiXFxsVmVydCIsICJcXHJWZXJ0IiwgIlxcbGdyb3VwIiwgIlxccmdyb3VwIiwgIuKfriIsICLin68iLCAiXFxsbW91c3RhY2hlIiwgIlxccm1vdXN0YWNoZSIsICLijrAiLCAi4o6xIl07CnZhciBzdGFja05ldmVyRGVsaW1pdGVycyA9IFsiPCIsICI+IiwgIlxcbGFuZ2xlIiwgIlxccmFuZ2xlIiwgIi8iLCAiXFxiYWNrc2xhc2giLCAiXFxsdCIsICJcXGd0Il07CnZhciBzaXplVG9NYXhIZWlnaHQgPSBbMCwgMS4yLCAxLjgsIDIuNCwgM107CnZhciBtYWtlU2l6ZWREZWxpbSA9IGZ1bmN0aW9uIG1ha2VTaXplZERlbGltMihkZWxpbSwgc2l6ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3NlcykgewogIGlmIChkZWxpbSA9PT0gIjwiIHx8IGRlbGltID09PSAiXFxsdCIgfHwgZGVsaW0gPT09ICLin6giKSB7CiAgICBkZWxpbSA9ICJcXGxhbmdsZSI7CiAgfSBlbHNlIGlmIChkZWxpbSA9PT0gIj4iIHx8IGRlbGltID09PSAiXFxndCIgfHwgZGVsaW0gPT09ICLin6kiKSB7CiAgICBkZWxpbSA9ICJcXHJhbmdsZSI7CiAgfQogIGlmICh1dGlscy5jb250YWlucyhzdGFja0xhcmdlRGVsaW1pdGVycywgZGVsaW0pIHx8IHV0aWxzLmNvbnRhaW5zKHN0YWNrTmV2ZXJEZWxpbWl0ZXJzLCBkZWxpbSkpIHsKICAgIHJldHVybiBtYWtlTGFyZ2VEZWxpbShkZWxpbSwgc2l6ZSwgZmFsc2UsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpOwogIH0gZWxzZSBpZiAodXRpbHMuY29udGFpbnMoc3RhY2tBbHdheXNEZWxpbWl0ZXJzLCBkZWxpbSkpIHsKICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKGRlbGltLCBzaXplVG9NYXhIZWlnaHRbc2l6ZV0sIGZhbHNlLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKTsKICB9IGVsc2UgewogICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIklsbGVnYWwgZGVsaW1pdGVyOiAnIiArIGRlbGltICsgIiciKTsKICB9Cn07CnZhciBzdGFja05ldmVyRGVsaW1pdGVyU2VxdWVuY2UgPSBbewogIHR5cGU6ICJzbWFsbCIsCiAgc3R5bGU6IFN0eWxlJDEuU0NSSVBUU0NSSVBUCn0sIHsKICB0eXBlOiAic21hbGwiLAogIHN0eWxlOiBTdHlsZSQxLlNDUklQVAp9LCB7CiAgdHlwZTogInNtYWxsIiwKICBzdHlsZTogU3R5bGUkMS5URVhUCn0sIHsKICB0eXBlOiAibGFyZ2UiLAogIHNpemU6IDEKfSwgewogIHR5cGU6ICJsYXJnZSIsCiAgc2l6ZTogMgp9LCB7CiAgdHlwZTogImxhcmdlIiwKICBzaXplOiAzCn0sIHsKICB0eXBlOiAibGFyZ2UiLAogIHNpemU6IDQKfV07CnZhciBzdGFja0Fsd2F5c0RlbGltaXRlclNlcXVlbmNlID0gW3sKICB0eXBlOiAic21hbGwiLAogIHN0eWxlOiBTdHlsZSQxLlNDUklQVFNDUklQVAp9LCB7CiAgdHlwZTogInNtYWxsIiwKICBzdHlsZTogU3R5bGUkMS5TQ1JJUFQKfSwgewogIHR5cGU6ICJzbWFsbCIsCiAgc3R5bGU6IFN0eWxlJDEuVEVYVAp9LCB7CiAgdHlwZTogInN0YWNrIgp9XTsKdmFyIHN0YWNrTGFyZ2VEZWxpbWl0ZXJTZXF1ZW5jZSA9IFt7CiAgdHlwZTogInNtYWxsIiwKICBzdHlsZTogU3R5bGUkMS5TQ1JJUFRTQ1JJUFQKfSwgewogIHR5cGU6ICJzbWFsbCIsCiAgc3R5bGU6IFN0eWxlJDEuU0NSSVBUCn0sIHsKICB0eXBlOiAic21hbGwiLAogIHN0eWxlOiBTdHlsZSQxLlRFWFQKfSwgewogIHR5cGU6ICJsYXJnZSIsCiAgc2l6ZTogMQp9LCB7CiAgdHlwZTogImxhcmdlIiwKICBzaXplOiAyCn0sIHsKICB0eXBlOiAibGFyZ2UiLAogIHNpemU6IDMKfSwgewogIHR5cGU6ICJsYXJnZSIsCiAgc2l6ZTogNAp9LCB7CiAgdHlwZTogInN0YWNrIgp9XTsKdmFyIGRlbGltVHlwZVRvRm9udCA9IGZ1bmN0aW9uIGRlbGltVHlwZVRvRm9udDIodHlwZSkgewogIGlmICh0eXBlLnR5cGUgPT09ICJzbWFsbCIpIHsKICAgIHJldHVybiAiTWFpbi1SZWd1bGFyIjsKICB9IGVsc2UgaWYgKHR5cGUudHlwZSA9PT0gImxhcmdlIikgewogICAgcmV0dXJuICJTaXplIiArIHR5cGUuc2l6ZSArICItUmVndWxhciI7CiAgfSBlbHNlIGlmICh0eXBlLnR5cGUgPT09ICJzdGFjayIpIHsKICAgIHJldHVybiAiU2l6ZTQtUmVndWxhciI7CiAgfSBlbHNlIHsKICAgIHRocm93IG5ldyBFcnJvcigiQWRkIHN1cHBvcnQgZm9yIGRlbGltIHR5cGUgJyIgKyB0eXBlLnR5cGUgKyAiJyBoZXJlLiIpOwogIH0KfTsKdmFyIHRyYXZlcnNlU2VxdWVuY2UgPSBmdW5jdGlvbiB0cmF2ZXJzZVNlcXVlbmNlMihkZWxpbSwgaGVpZ2h0LCBzZXF1ZW5jZSwgb3B0aW9ucykgewogIHZhciBzdGFydCA9IE1hdGgubWluKDIsIDMgLSBvcHRpb25zLnN0eWxlLnNpemUpOwogIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHNlcXVlbmNlLmxlbmd0aDsgaSsrKSB7CiAgICBpZiAoc2VxdWVuY2VbaV0udHlwZSA9PT0gInN0YWNrIikgewogICAgICBicmVhazsKICAgIH0KICAgIHZhciBtZXRyaWNzID0gZ2V0TWV0cmljcyhkZWxpbSwgZGVsaW1UeXBlVG9Gb250KHNlcXVlbmNlW2ldKSwgIm1hdGgiKTsKICAgIHZhciBoZWlnaHREZXB0aCA9IG1ldHJpY3MuaGVpZ2h0ICsgbWV0cmljcy5kZXB0aDsKICAgIGlmIChzZXF1ZW5jZVtpXS50eXBlID09PSAic21hbGwiKSB7CiAgICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU3R5bGUoc2VxdWVuY2VbaV0uc3R5bGUpOwogICAgICBoZWlnaHREZXB0aCAqPSBuZXdPcHRpb25zLnNpemVNdWx0aXBsaWVyOwogICAgfQogICAgaWYgKGhlaWdodERlcHRoID4gaGVpZ2h0KSB7CiAgICAgIHJldHVybiBzZXF1ZW5jZVtpXTsKICAgIH0KICB9CiAgcmV0dXJuIHNlcXVlbmNlW3NlcXVlbmNlLmxlbmd0aCAtIDFdOwp9Owp2YXIgbWFrZUN1c3RvbVNpemVkRGVsaW0gPSBmdW5jdGlvbiBtYWtlQ3VzdG9tU2l6ZWREZWxpbTIoZGVsaW0sIGhlaWdodCwgY2VudGVyLCBvcHRpb25zLCBtb2RlLCBjbGFzc2VzKSB7CiAgaWYgKGRlbGltID09PSAiPCIgfHwgZGVsaW0gPT09ICJcXGx0IiB8fCBkZWxpbSA9PT0gIuKfqCIpIHsKICAgIGRlbGltID0gIlxcbGFuZ2xlIjsKICB9IGVsc2UgaWYgKGRlbGltID09PSAiPiIgfHwgZGVsaW0gPT09ICJcXGd0IiB8fCBkZWxpbSA9PT0gIuKfqSIpIHsKICAgIGRlbGltID0gIlxccmFuZ2xlIjsKICB9CiAgdmFyIHNlcXVlbmNlOwogIGlmICh1dGlscy5jb250YWlucyhzdGFja05ldmVyRGVsaW1pdGVycywgZGVsaW0pKSB7CiAgICBzZXF1ZW5jZSA9IHN0YWNrTmV2ZXJEZWxpbWl0ZXJTZXF1ZW5jZTsKICB9IGVsc2UgaWYgKHV0aWxzLmNvbnRhaW5zKHN0YWNrTGFyZ2VEZWxpbWl0ZXJzLCBkZWxpbSkpIHsKICAgIHNlcXVlbmNlID0gc3RhY2tMYXJnZURlbGltaXRlclNlcXVlbmNlOwogIH0gZWxzZSB7CiAgICBzZXF1ZW5jZSA9IHN0YWNrQWx3YXlzRGVsaW1pdGVyU2VxdWVuY2U7CiAgfQogIHZhciBkZWxpbVR5cGUgPSB0cmF2ZXJzZVNlcXVlbmNlKGRlbGltLCBoZWlnaHQsIHNlcXVlbmNlLCBvcHRpb25zKTsKICBpZiAoZGVsaW1UeXBlLnR5cGUgPT09ICJzbWFsbCIpIHsKICAgIHJldHVybiBtYWtlU21hbGxEZWxpbShkZWxpbSwgZGVsaW1UeXBlLnN0eWxlLCBjZW50ZXIsIG9wdGlvbnMsIG1vZGUsIGNsYXNzZXMpOwogIH0gZWxzZSBpZiAoZGVsaW1UeXBlLnR5cGUgPT09ICJsYXJnZSIpIHsKICAgIHJldHVybiBtYWtlTGFyZ2VEZWxpbShkZWxpbSwgZGVsaW1UeXBlLnNpemUsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7CiAgfSBlbHNlIHsKICAgIHJldHVybiBtYWtlU3RhY2tlZERlbGltKGRlbGltLCBoZWlnaHQsIGNlbnRlciwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7CiAgfQp9Owp2YXIgbWFrZUxlZnRSaWdodERlbGltID0gZnVuY3Rpb24gbWFrZUxlZnRSaWdodERlbGltMihkZWxpbSwgaGVpZ2h0LCBkZXB0aCwgb3B0aW9ucywgbW9kZSwgY2xhc3NlcykgewogIHZhciBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQgKiBvcHRpb25zLnNpemVNdWx0aXBsaWVyOwogIHZhciBkZWxpbWl0ZXJGYWN0b3IgPSA5MDE7CiAgdmFyIGRlbGltaXRlckV4dGVuZCA9IDUgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTsKICB2YXIgbWF4RGlzdEZyb21BeGlzID0gTWF0aC5tYXgoaGVpZ2h0IC0gYXhpc0hlaWdodCwgZGVwdGggKyBheGlzSGVpZ2h0KTsKICB2YXIgdG90YWxIZWlnaHQgPSBNYXRoLm1heCgKICAgIC8vIEluIHJlYWwgVGVYLCBjYWxjdWxhdGlvbnMgYXJlIGRvbmUgdXNpbmcgaW50ZWdyYWwgdmFsdWVzIHdoaWNoIGFyZQogICAgLy8gNjU1MzYgcGVyIHB0LCBvciA2NTUzNjAgcGVyIGVtLiBTbywgdGhlIGRpdmlzaW9uIGhlcmUgdHJ1bmNhdGVzIGluCiAgICAvLyBUZVggYnV0IGRvZXNuJ3QgaGVyZSwgcHJvZHVjaW5nIGRpZmZlcmVudCByZXN1bHRzLiBJZiB3ZSB3YW50ZWQgdG8KICAgIC8vIGV4YWN0bHkgbWF0Y2ggVGVYJ3MgY2FsY3VsYXRpb24sIHdlIGNvdWxkIGRvCiAgICAvLyAgIE1hdGguZmxvb3IoNjU1MzYwICogbWF4RGlzdEZyb21BeGlzIC8gNTAwKSAqCiAgICAvLyAgICBkZWxpbWl0ZXJGYWN0b3IgLyA2NTUzNjAKICAgIC8vIChUbyBzZWUgdGhlIGRpZmZlcmVuY2UsIGNvbXBhcmUKICAgIC8vICAgIHhee3hee1xsZWZ0KFxydWxlezAuMWVtfXswLjY4ZW19XHJpZ2h0KX19CiAgICAvLyBpbiBUZVggYW5kIEthVGVYKQogICAgbWF4RGlzdEZyb21BeGlzIC8gNTAwICogZGVsaW1pdGVyRmFjdG9yLAogICAgMiAqIG1heERpc3RGcm9tQXhpcyAtIGRlbGltaXRlckV4dGVuZAogICk7CiAgcmV0dXJuIG1ha2VDdXN0b21TaXplZERlbGltKGRlbGltLCB0b3RhbEhlaWdodCwgdHJ1ZSwgb3B0aW9ucywgbW9kZSwgY2xhc3Nlcyk7Cn07CnZhciBkZWxpbWl0ZXIgPSB7CiAgc3FydEltYWdlOiBtYWtlU3FydEltYWdlLAogIHNpemVkRGVsaW06IG1ha2VTaXplZERlbGltLAogIHNpemVUb01heEhlaWdodCwKICBjdXN0b21TaXplZERlbGltOiBtYWtlQ3VzdG9tU2l6ZWREZWxpbSwKICBsZWZ0UmlnaHREZWxpbTogbWFrZUxlZnRSaWdodERlbGltCn07CnZhciBkZWxpbWl0ZXJTaXplcyA9IHsKICAiXFxiaWdsIjogewogICAgbWNsYXNzOiAibW9wZW4iLAogICAgc2l6ZTogMQogIH0sCiAgIlxcQmlnbCI6IHsKICAgIG1jbGFzczogIm1vcGVuIiwKICAgIHNpemU6IDIKICB9LAogICJcXGJpZ2dsIjogewogICAgbWNsYXNzOiAibW9wZW4iLAogICAgc2l6ZTogMwogIH0sCiAgIlxcQmlnZ2wiOiB7CiAgICBtY2xhc3M6ICJtb3BlbiIsCiAgICBzaXplOiA0CiAgfSwKICAiXFxiaWdyIjogewogICAgbWNsYXNzOiAibWNsb3NlIiwKICAgIHNpemU6IDEKICB9LAogICJcXEJpZ3IiOiB7CiAgICBtY2xhc3M6ICJtY2xvc2UiLAogICAgc2l6ZTogMgogIH0sCiAgIlxcYmlnZ3IiOiB7CiAgICBtY2xhc3M6ICJtY2xvc2UiLAogICAgc2l6ZTogMwogIH0sCiAgIlxcQmlnZ3IiOiB7CiAgICBtY2xhc3M6ICJtY2xvc2UiLAogICAgc2l6ZTogNAogIH0sCiAgIlxcYmlnbSI6IHsKICAgIG1jbGFzczogIm1yZWwiLAogICAgc2l6ZTogMQogIH0sCiAgIlxcQmlnbSI6IHsKICAgIG1jbGFzczogIm1yZWwiLAogICAgc2l6ZTogMgogIH0sCiAgIlxcYmlnZ20iOiB7CiAgICBtY2xhc3M6ICJtcmVsIiwKICAgIHNpemU6IDMKICB9LAogICJcXEJpZ2dtIjogewogICAgbWNsYXNzOiAibXJlbCIsCiAgICBzaXplOiA0CiAgfSwKICAiXFxiaWciOiB7CiAgICBtY2xhc3M6ICJtb3JkIiwKICAgIHNpemU6IDEKICB9LAogICJcXEJpZyI6IHsKICAgIG1jbGFzczogIm1vcmQiLAogICAgc2l6ZTogMgogIH0sCiAgIlxcYmlnZyI6IHsKICAgIG1jbGFzczogIm1vcmQiLAogICAgc2l6ZTogMwogIH0sCiAgIlxcQmlnZyI6IHsKICAgIG1jbGFzczogIm1vcmQiLAogICAgc2l6ZTogNAogIH0KfTsKdmFyIGRlbGltaXRlcnMgPSBbIigiLCAiXFxscGFyZW4iLCAiKSIsICJcXHJwYXJlbiIsICJbIiwgIlxcbGJyYWNrIiwgIl0iLCAiXFxyYnJhY2siLCAiXFx7IiwgIlxcbGJyYWNlIiwgIlxcfSIsICJcXHJicmFjZSIsICJcXGxmbG9vciIsICJcXHJmbG9vciIsICLijIoiLCAi4oyLIiwgIlxcbGNlaWwiLCAiXFxyY2VpbCIsICLijIgiLCAi4oyJIiwgIjwiLCAiPiIsICJcXGxhbmdsZSIsICLin6giLCAiXFxyYW5nbGUiLCAi4p+pIiwgIlxcbHQiLCAiXFxndCIsICJcXGx2ZXJ0IiwgIlxccnZlcnQiLCAiXFxsVmVydCIsICJcXHJWZXJ0IiwgIlxcbGdyb3VwIiwgIlxccmdyb3VwIiwgIuKfriIsICLin68iLCAiXFxsbW91c3RhY2hlIiwgIlxccm1vdXN0YWNoZSIsICLijrAiLCAi4o6xIiwgIi8iLCAiXFxiYWNrc2xhc2giLCAifCIsICJcXHZlcnQiLCAiXFx8IiwgIlxcVmVydCIsICJcXHVwYXJyb3ciLCAiXFxVcGFycm93IiwgIlxcZG93bmFycm93IiwgIlxcRG93bmFycm93IiwgIlxcdXBkb3duYXJyb3ciLCAiXFxVcGRvd25hcnJvdyIsICIuIl07CmZ1bmN0aW9uIGNoZWNrRGVsaW1pdGVyKGRlbGltLCBjb250ZXh0KSB7CiAgdmFyIHN5bURlbGltID0gY2hlY2tTeW1ib2xOb2RlVHlwZShkZWxpbSk7CiAgaWYgKHN5bURlbGltICYmIHV0aWxzLmNvbnRhaW5zKGRlbGltaXRlcnMsIHN5bURlbGltLnRleHQpKSB7CiAgICByZXR1cm4gc3ltRGVsaW07CiAgfSBlbHNlIGlmIChzeW1EZWxpbSkgewogICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkludmFsaWQgZGVsaW1pdGVyICciICsgc3ltRGVsaW0udGV4dCArICInIGFmdGVyICciICsgY29udGV4dC5mdW5jTmFtZSArICInIiwgZGVsaW0pOwogIH0gZWxzZSB7CiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiSW52YWxpZCBkZWxpbWl0ZXIgdHlwZSAnIiArIGRlbGltLnR5cGUgKyAiJyIsIGRlbGltKTsKICB9Cn0KZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJkZWxpbXNpemluZyIsCiAgbmFtZXM6IFsiXFxiaWdsIiwgIlxcQmlnbCIsICJcXGJpZ2dsIiwgIlxcQmlnZ2wiLCAiXFxiaWdyIiwgIlxcQmlnciIsICJcXGJpZ2dyIiwgIlxcQmlnZ3IiLCAiXFxiaWdtIiwgIlxcQmlnbSIsICJcXGJpZ2dtIiwgIlxcQmlnZ20iLCAiXFxiaWciLCAiXFxCaWciLCAiXFxiaWdnIiwgIlxcQmlnZyJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYXJnVHlwZXM6IFsicHJpbWl0aXZlIl0KICB9LAogIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7CiAgICB2YXIgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJkZWxpbXNpemluZyIsCiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsCiAgICAgIHNpemU6IGRlbGltaXRlclNpemVzW2NvbnRleHQuZnVuY05hbWVdLnNpemUsCiAgICAgIG1jbGFzczogZGVsaW1pdGVyU2l6ZXNbY29udGV4dC5mdW5jTmFtZV0ubWNsYXNzLAogICAgICBkZWxpbTogZGVsaW0udGV4dAogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICAgIGlmIChncm91cC5kZWxpbSA9PT0gIi4iKSB7CiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbZ3JvdXAubWNsYXNzXSk7CiAgICB9CiAgICByZXR1cm4gZGVsaW1pdGVyLnNpemVkRGVsaW0oZ3JvdXAuZGVsaW0sIGdyb3VwLnNpemUsIG9wdGlvbnMsIGdyb3VwLm1vZGUsIFtncm91cC5tY2xhc3NdKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCkgPT4gewogICAgdmFyIGNoaWxkcmVuID0gW107CiAgICBpZiAoZ3JvdXAuZGVsaW0gIT09ICIuIikgewogICAgICBjaGlsZHJlbi5wdXNoKG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKSk7CiAgICB9CiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtbyIsIGNoaWxkcmVuKTsKICAgIGlmIChncm91cC5tY2xhc3MgPT09ICJtb3BlbiIgfHwgZ3JvdXAubWNsYXNzID09PSAibWNsb3NlIikgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgiZmVuY2UiLCAidHJ1ZSIpOwogICAgfSBlbHNlIHsKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoImZlbmNlIiwgImZhbHNlIik7CiAgICB9CiAgICBub2RlLnNldEF0dHJpYnV0ZSgic3RyZXRjaHkiLCAidHJ1ZSIpOwogICAgdmFyIHNpemUgPSBtYWtlRW0oZGVsaW1pdGVyLnNpemVUb01heEhlaWdodFtncm91cC5zaXplXSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgibWluc2l6ZSIsIHNpemUpOwogICAgbm9kZS5zZXRBdHRyaWJ1dGUoIm1heHNpemUiLCBzaXplKTsKICAgIHJldHVybiBub2RlOwogIH0KfSk7CmZ1bmN0aW9uIGFzc2VydFBhcnNlZChncm91cCkgewogIGlmICghZ3JvdXAuYm9keSkgewogICAgdGhyb3cgbmV3IEVycm9yKCJCdWc6IFRoZSBsZWZ0cmlnaHQgUGFyc2VOb2RlIHdhc24ndCBmdWxseSBwYXJzZWQuIik7CiAgfQp9CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAibGVmdHJpZ2h0LXJpZ2h0IiwKICBuYW1lczogWyJcXHJpZ2h0Il0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBwcmltaXRpdmU6IHRydWUKICB9LAogIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7CiAgICB2YXIgY29sb3IgPSBjb250ZXh0LnBhcnNlci5ndWxsZXQubWFjcm9zLmdldCgiXFxjdXJyZW50QGNvbG9yIik7CiAgICBpZiAoY29sb3IgJiYgdHlwZW9mIGNvbG9yICE9PSAic3RyaW5nIikgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiXFxjdXJyZW50QGNvbG9yIHNldCB0byBub24tc3RyaW5nIGluIFxccmlnaHQiKTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJsZWZ0cmlnaHQtcmlnaHQiLAogICAgICBtb2RlOiBjb250ZXh0LnBhcnNlci5tb2RlLAogICAgICBkZWxpbTogY2hlY2tEZWxpbWl0ZXIoYXJnc1swXSwgY29udGV4dCkudGV4dCwKICAgICAgY29sb3IKICAgICAgLy8gdW5kZWZpbmVkIGlmIG5vdCBzZXQgdmlhIFxjb2xvcgogICAgfTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImxlZnRyaWdodCIsCiAgbmFtZXM6IFsiXFxsZWZ0Il0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBwcmltaXRpdmU6IHRydWUKICB9LAogIGhhbmRsZXI6IChjb250ZXh0LCBhcmdzKSA9PiB7CiAgICB2YXIgZGVsaW0gPSBjaGVja0RlbGltaXRlcihhcmdzWzBdLCBjb250ZXh0KTsKICAgIHZhciBwYXJzZXIgPSBjb250ZXh0LnBhcnNlcjsKICAgICsrcGFyc2VyLmxlZnRyaWdodERlcHRoOwogICAgdmFyIGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlKTsKICAgIC0tcGFyc2VyLmxlZnRyaWdodERlcHRoOwogICAgcGFyc2VyLmV4cGVjdCgiXFxyaWdodCIsIGZhbHNlKTsKICAgIHZhciByaWdodCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksICJsZWZ0cmlnaHQtcmlnaHQiKTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJsZWZ0cmlnaHQiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgYm9keSwKICAgICAgbGVmdDogZGVsaW0udGV4dCwKICAgICAgcmlnaHQ6IHJpZ2h0LmRlbGltLAogICAgICByaWdodENvbG9yOiByaWdodC5jb2xvcgogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICAgIGFzc2VydFBhcnNlZChncm91cCk7CiAgICB2YXIgaW5uZXIyID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSwgWyJtb3BlbiIsICJtY2xvc2UiXSk7CiAgICB2YXIgaW5uZXJIZWlnaHQgPSAwOwogICAgdmFyIGlubmVyRGVwdGggPSAwOwogICAgdmFyIGhhZE1pZGRsZSA9IGZhbHNlOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbm5lcjIubGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKGlubmVyMltpXS5pc01pZGRsZSkgewogICAgICAgIGhhZE1pZGRsZSA9IHRydWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaW5uZXJIZWlnaHQgPSBNYXRoLm1heChpbm5lcjJbaV0uaGVpZ2h0LCBpbm5lckhlaWdodCk7CiAgICAgICAgaW5uZXJEZXB0aCA9IE1hdGgubWF4KGlubmVyMltpXS5kZXB0aCwgaW5uZXJEZXB0aCk7CiAgICAgIH0KICAgIH0KICAgIGlubmVySGVpZ2h0ICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgICBpbm5lckRlcHRoICo9IG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgICB2YXIgbGVmdERlbGltOwogICAgaWYgKGdyb3VwLmxlZnQgPT09ICIuIikgewogICAgICBsZWZ0RGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbIm1vcGVuIl0pOwogICAgfSBlbHNlIHsKICAgICAgbGVmdERlbGltID0gZGVsaW1pdGVyLmxlZnRSaWdodERlbGltKGdyb3VwLmxlZnQsIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBvcHRpb25zLCBncm91cC5tb2RlLCBbIm1vcGVuIl0pOwogICAgfQogICAgaW5uZXIyLnVuc2hpZnQobGVmdERlbGltKTsKICAgIGlmIChoYWRNaWRkbGUpIHsKICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGlubmVyMi5sZW5ndGg7IF9pKyspIHsKICAgICAgICB2YXIgbWlkZGxlRGVsaW0gPSBpbm5lcjJbX2ldOwogICAgICAgIHZhciBpc01pZGRsZSA9IG1pZGRsZURlbGltLmlzTWlkZGxlOwogICAgICAgIGlmIChpc01pZGRsZSkgewogICAgICAgICAgaW5uZXIyW19pXSA9IGRlbGltaXRlci5sZWZ0UmlnaHREZWxpbShpc01pZGRsZS5kZWxpbSwgaW5uZXJIZWlnaHQsIGlubmVyRGVwdGgsIGlzTWlkZGxlLm9wdGlvbnMsIGdyb3VwLm1vZGUsIFtdKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHZhciByaWdodERlbGltOwogICAgaWYgKGdyb3VwLnJpZ2h0ID09PSAiLiIpIHsKICAgICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFsibWNsb3NlIl0pOwogICAgfSBlbHNlIHsKICAgICAgdmFyIGNvbG9yT3B0aW9ucyA9IGdyb3VwLnJpZ2h0Q29sb3IgPyBvcHRpb25zLndpdGhDb2xvcihncm91cC5yaWdodENvbG9yKSA6IG9wdGlvbnM7CiAgICAgIHJpZ2h0RGVsaW0gPSBkZWxpbWl0ZXIubGVmdFJpZ2h0RGVsaW0oZ3JvdXAucmlnaHQsIGlubmVySGVpZ2h0LCBpbm5lckRlcHRoLCBjb2xvck9wdGlvbnMsIGdyb3VwLm1vZGUsIFsibWNsb3NlIl0pOwogICAgfQogICAgaW5uZXIyLnB1c2gocmlnaHREZWxpbSk7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtaW5uZXIiXSwgaW5uZXIyLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgYXNzZXJ0UGFyc2VkKGdyb3VwKTsKICAgIHZhciBpbm5lcjIgPSBidWlsZEV4cHJlc3Npb24yKGdyb3VwLmJvZHksIG9wdGlvbnMpOwogICAgaWYgKGdyb3VwLmxlZnQgIT09ICIuIikgewogICAgICB2YXIgbGVmdE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibW8iLCBbbWFrZVRleHQoZ3JvdXAubGVmdCwgZ3JvdXAubW9kZSldKTsKICAgICAgbGVmdE5vZGUuc2V0QXR0cmlidXRlKCJmZW5jZSIsICJ0cnVlIik7CiAgICAgIGlubmVyMi51bnNoaWZ0KGxlZnROb2RlKTsKICAgIH0KICAgIGlmIChncm91cC5yaWdodCAhPT0gIi4iKSB7CiAgICAgIHZhciByaWdodE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibW8iLCBbbWFrZVRleHQoZ3JvdXAucmlnaHQsIGdyb3VwLm1vZGUpXSk7CiAgICAgIHJpZ2h0Tm9kZS5zZXRBdHRyaWJ1dGUoImZlbmNlIiwgInRydWUiKTsKICAgICAgaWYgKGdyb3VwLnJpZ2h0Q29sb3IpIHsKICAgICAgICByaWdodE5vZGUuc2V0QXR0cmlidXRlKCJtYXRoY29sb3IiLCBncm91cC5yaWdodENvbG9yKTsKICAgICAgfQogICAgICBpbm5lcjIucHVzaChyaWdodE5vZGUpOwogICAgfQogICAgcmV0dXJuIG1ha2VSb3coaW5uZXIyKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogIm1pZGRsZSIsCiAgbmFtZXM6IFsiXFxtaWRkbGUiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIHByaW1pdGl2ZTogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKGNvbnRleHQsIGFyZ3MpID0+IHsKICAgIHZhciBkZWxpbSA9IGNoZWNrRGVsaW1pdGVyKGFyZ3NbMF0sIGNvbnRleHQpOwogICAgaWYgKCFjb250ZXh0LnBhcnNlci5sZWZ0cmlnaHREZXB0aCkgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiXFxtaWRkbGUgd2l0aG91dCBwcmVjZWRpbmcgXFxsZWZ0IiwgZGVsaW0pOwogICAgfQogICAgcmV0dXJuIHsKICAgICAgdHlwZTogIm1pZGRsZSIsCiAgICAgIG1vZGU6IGNvbnRleHQucGFyc2VyLm1vZGUsCiAgICAgIGRlbGltOiBkZWxpbS50ZXh0CiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIG1pZGRsZURlbGltOwogICAgaWYgKGdyb3VwLmRlbGltID09PSAiLiIpIHsKICAgICAgbWlkZGxlRGVsaW0gPSBtYWtlTnVsbERlbGltaXRlcihvcHRpb25zLCBbXSk7CiAgICB9IGVsc2UgewogICAgICBtaWRkbGVEZWxpbSA9IGRlbGltaXRlci5zaXplZERlbGltKGdyb3VwLmRlbGltLCAxLCBvcHRpb25zLCBncm91cC5tb2RlLCBbXSk7CiAgICAgIHZhciBpc01pZGRsZSA9IHsKICAgICAgICBkZWxpbTogZ3JvdXAuZGVsaW0sCiAgICAgICAgb3B0aW9ucwogICAgICB9OwogICAgICBtaWRkbGVEZWxpbS5pc01pZGRsZSA9IGlzTWlkZGxlOwogICAgfQogICAgcmV0dXJuIG1pZGRsZURlbGltOwogIH0sCiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgICB2YXIgdGV4dE5vZGUgPSBncm91cC5kZWxpbSA9PT0gIlxcdmVydCIgfHwgZ3JvdXAuZGVsaW0gPT09ICJ8IiA/IG1ha2VUZXh0KCJ8IiwgInRleHQiKSA6IG1ha2VUZXh0KGdyb3VwLmRlbGltLCBncm91cC5tb2RlKTsKICAgIHZhciBtaWRkbGVOb2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1vIiwgW3RleHROb2RlXSk7CiAgICBtaWRkbGVOb2RlLnNldEF0dHJpYnV0ZSgiZmVuY2UiLCAidHJ1ZSIpOwogICAgbWlkZGxlTm9kZS5zZXRBdHRyaWJ1dGUoImxzcGFjZSIsICIwLjA1ZW0iKTsKICAgIG1pZGRsZU5vZGUuc2V0QXR0cmlidXRlKCJyc3BhY2UiLCAiMC4wNWVtIik7CiAgICByZXR1cm4gbWlkZGxlTm9kZTsKICB9Cn0pOwp2YXIgaHRtbEJ1aWxkZXIkNyA9IChncm91cCwgb3B0aW9ucykgPT4gewogIHZhciBpbm5lcjIgPSBidWlsZENvbW1vbi53cmFwRnJhZ21lbnQoYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcHRpb25zKTsKICB2YXIgbGFiZWwgPSBncm91cC5sYWJlbC5zbGljZSgxKTsKICB2YXIgc2NhbGUgPSBvcHRpb25zLnNpemVNdWx0aXBsaWVyOwogIHZhciBpbWc7CiAgdmFyIGltZ1NoaWZ0ID0gMDsKICB2YXIgaXNTaW5nbGVDaGFyID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goZ3JvdXAuYm9keSk7CiAgaWYgKGxhYmVsID09PSAic291dCIpIHsKICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsic3RyZXRjaHkiLCAic291dCJdKTsKICAgIGltZy5oZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3MgLyBzY2FsZTsKICAgIGltZ1NoaWZ0ID0gLTAuNSAqIG9wdGlvbnMuZm9udE1ldHJpY3MoKS54SGVpZ2h0OwogIH0gZWxzZSBpZiAobGFiZWwgPT09ICJwaGFzZSIpIHsKICAgIHZhciBsaW5lV2VpZ2h0ID0gY2FsY3VsYXRlU2l6ZSh7CiAgICAgIG51bWJlcjogMC42LAogICAgICB1bml0OiAicHQiCiAgICB9LCBvcHRpb25zKTsKICAgIHZhciBjbGVhcmFuY2UgPSBjYWxjdWxhdGVTaXplKHsKICAgICAgbnVtYmVyOiAwLjM1LAogICAgICB1bml0OiAiZXgiCiAgICB9LCBvcHRpb25zKTsKICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdCYXNlU2l6aW5nKCk7CiAgICBzY2FsZSA9IHNjYWxlIC8gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcjsKICAgIHZhciBhbmdsZUhlaWdodCA9IGlubmVyMi5oZWlnaHQgKyBpbm5lcjIuZGVwdGggKyBsaW5lV2VpZ2h0ICsgY2xlYXJhbmNlOwogICAgaW5uZXIyLnN0eWxlLnBhZGRpbmdMZWZ0ID0gbWFrZUVtKGFuZ2xlSGVpZ2h0IC8gMiArIGxpbmVXZWlnaHQpOwogICAgdmFyIHZpZXdCb3hIZWlnaHQgPSBNYXRoLmZsb29yKDFlMyAqIGFuZ2xlSGVpZ2h0ICogc2NhbGUpOwogICAgdmFyIHBhdGgyID0gcGhhc2VQYXRoKHZpZXdCb3hIZWlnaHQpOwogICAgdmFyIHN2Z05vZGUgPSBuZXcgU3ZnTm9kZShbbmV3IFBhdGhOb2RlKCJwaGFzZSIsIHBhdGgyKV0sIHsKICAgICAgIndpZHRoIjogIjQwMGVtIiwKICAgICAgImhlaWdodCI6IG1ha2VFbSh2aWV3Qm94SGVpZ2h0IC8gMWUzKSwKICAgICAgInZpZXdCb3giOiAiMCAwIDQwMDAwMCAiICsgdmlld0JveEhlaWdodCwKICAgICAgInByZXNlcnZlQXNwZWN0UmF0aW8iOiAieE1pbllNaW4gc2xpY2UiCiAgICB9KTsKICAgIGltZyA9IGJ1aWxkQ29tbW9uLm1ha2VTdmdTcGFuKFsiaGlkZS10YWlsIl0sIFtzdmdOb2RlXSwgb3B0aW9ucyk7CiAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKGFuZ2xlSGVpZ2h0KTsKICAgIGltZ1NoaWZ0ID0gaW5uZXIyLmRlcHRoICsgbGluZVdlaWdodCArIGNsZWFyYW5jZTsKICB9IGVsc2UgewogICAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7CiAgICAgIGlmICghaXNTaW5nbGVDaGFyKSB7CiAgICAgICAgaW5uZXIyLmNsYXNzZXMucHVzaCgiY2FuY2VsLXBhZCIpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGxhYmVsID09PSAiYW5nbCIpIHsKICAgICAgaW5uZXIyLmNsYXNzZXMucHVzaCgiYW5nbHBhZCIpOwogICAgfSBlbHNlIHsKICAgICAgaW5uZXIyLmNsYXNzZXMucHVzaCgiYm94cGFkIik7CiAgICB9CiAgICB2YXIgdG9wUGFkID0gMDsKICAgIHZhciBib3R0b21QYWQgPSAwOwogICAgdmFyIHJ1bGVUaGlja25lc3MgPSAwOwogICAgaWYgKC9ib3gvLnRlc3QobGFiZWwpKSB7CiAgICAgIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heCgKICAgICAgICBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHJ1bGUsCiAgICAgICAgLy8gZGVmYXVsdAogICAgICAgIG9wdGlvbnMubWluUnVsZVRoaWNrbmVzcwogICAgICAgIC8vIFVzZXIgb3ZlcnJpZGUuCiAgICAgICk7CiAgICAgIHRvcFBhZCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5mYm94c2VwICsgKGxhYmVsID09PSAiY29sb3Jib3giID8gMCA6IHJ1bGVUaGlja25lc3MpOwogICAgICBib3R0b21QYWQgPSB0b3BQYWQ7CiAgICB9IGVsc2UgaWYgKGxhYmVsID09PSAiYW5nbCIpIHsKICAgICAgcnVsZVRoaWNrbmVzcyA9IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzcywgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzKTsKICAgICAgdG9wUGFkID0gNCAqIHJ1bGVUaGlja25lc3M7CiAgICAgIGJvdHRvbVBhZCA9IE1hdGgubWF4KDAsIDAuMjUgLSBpbm5lcjIuZGVwdGgpOwogICAgfSBlbHNlIHsKICAgICAgdG9wUGFkID0gaXNTaW5nbGVDaGFyID8gMC4yIDogMDsKICAgICAgYm90dG9tUGFkID0gdG9wUGFkOwogICAgfQogICAgaW1nID0gc3RyZXRjaHkuZW5jbG9zZVNwYW4oaW5uZXIyLCBsYWJlbCwgdG9wUGFkLCBib3R0b21QYWQsIG9wdGlvbnMpOwogICAgaWYgKC9mYm94fGJveGVkfGZjb2xvcmJveC8udGVzdChsYWJlbCkpIHsKICAgICAgaW1nLnN0eWxlLmJvcmRlclN0eWxlID0gInNvbGlkIjsKICAgICAgaW1nLnN0eWxlLmJvcmRlcldpZHRoID0gbWFrZUVtKHJ1bGVUaGlja25lc3MpOwogICAgfSBlbHNlIGlmIChsYWJlbCA9PT0gImFuZ2wiICYmIHJ1bGVUaGlja25lc3MgIT09IDAuMDQ5KSB7CiAgICAgIGltZy5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTsKICAgICAgaW1nLnN0eWxlLmJvcmRlclJpZ2h0V2lkdGggPSBtYWtlRW0ocnVsZVRoaWNrbmVzcyk7CiAgICB9CiAgICBpbWdTaGlmdCA9IGlubmVyMi5kZXB0aCArIGJvdHRvbVBhZDsKICAgIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHsKICAgICAgaW1nLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGdyb3VwLmJhY2tncm91bmRDb2xvcjsKICAgICAgaWYgKGdyb3VwLmJvcmRlckNvbG9yKSB7CiAgICAgICAgaW1nLnN0eWxlLmJvcmRlckNvbG9yID0gZ3JvdXAuYm9yZGVyQ29sb3I7CiAgICAgIH0KICAgIH0KICB9CiAgdmFyIHZsaXN0OwogIGlmIChncm91cC5iYWNrZ3JvdW5kQ29sb3IpIHsKICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgcG9zaXRpb25UeXBlOiAiaW5kaXZpZHVhbFNoaWZ0IiwKICAgICAgY2hpbGRyZW46IFsKICAgICAgICAvLyBQdXQgdGhlIGNvbG9yIGJhY2tncm91bmQgYmVoaW5kIGlubmVyOwogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICAgIGVsZW06IGltZywKICAgICAgICAgIHNoaWZ0OiBpbWdTaGlmdAogICAgICAgIH0sCiAgICAgICAgewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogaW5uZXIyLAogICAgICAgICAgc2hpZnQ6IDAKICAgICAgICB9CiAgICAgIF0KICAgIH0sIG9wdGlvbnMpOwogIH0gZWxzZSB7CiAgICB2YXIgY2xhc3NlcyA9IC9jYW5jZWx8cGhhc2UvLnRlc3QobGFiZWwpID8gWyJzdmctYWxpZ24iXSA6IFtdOwogICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJpbmRpdmlkdWFsU2hpZnQiLAogICAgICBjaGlsZHJlbjogWwogICAgICAgIC8vIFdyaXRlIHRoZSBcY2FuY2VsIHN0cm9rZSBvbiB0b3Agb2YgaW5uZXIuCiAgICAgICAgewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogaW5uZXIyLAogICAgICAgICAgc2hpZnQ6IDAKICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICAgIGVsZW06IGltZywKICAgICAgICAgIHNoaWZ0OiBpbWdTaGlmdCwKICAgICAgICAgIHdyYXBwZXJDbGFzc2VzOiBjbGFzc2VzCiAgICAgICAgfQogICAgICBdCiAgICB9LCBvcHRpb25zKTsKICB9CiAgaWYgKC9jYW5jZWwvLnRlc3QobGFiZWwpKSB7CiAgICB2bGlzdC5oZWlnaHQgPSBpbm5lcjIuaGVpZ2h0OwogICAgdmxpc3QuZGVwdGggPSBpbm5lcjIuZGVwdGg7CiAgfQogIGlmICgvY2FuY2VsLy50ZXN0KGxhYmVsKSAmJiAhaXNTaW5nbGVDaGFyKSB7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3JkIiwgImNhbmNlbC1sYXAiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7CiAgfSBlbHNlIHsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7CiAgfQp9Owp2YXIgbWF0aG1sQnVpbGRlciQ2ID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgdmFyIGZib3hzZXAgPSAwOwogIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoZ3JvdXAubGFiZWwuaW5kZXhPZigiY29sb3Jib3giKSA+IC0xID8gIm1wYWRkZWQiIDogIm1lbmNsb3NlIiwgW2J1aWxkR3JvdXAyKGdyb3VwLmJvZHksIG9wdGlvbnMpXSk7CiAgc3dpdGNoIChncm91cC5sYWJlbCkgewogICAgY2FzZSAiXFxjYW5jZWwiOgogICAgICBub2RlLnNldEF0dHJpYnV0ZSgibm90YXRpb24iLCAidXBkaWFnb25hbHN0cmlrZSIpOwogICAgICBicmVhazsKICAgIGNhc2UgIlxcYmNhbmNlbCI6CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJub3RhdGlvbiIsICJkb3duZGlhZ29uYWxzdHJpa2UiKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJcXHBoYXNlIjoKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIm5vdGF0aW9uIiwgInBoYXNvcmFuZ2xlIik7CiAgICAgIGJyZWFrOwogICAgY2FzZSAiXFxzb3V0IjoKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIm5vdGF0aW9uIiwgImhvcml6b250YWxzdHJpa2UiKTsKICAgICAgYnJlYWs7CiAgICBjYXNlICJcXGZib3giOgogICAgICBub2RlLnNldEF0dHJpYnV0ZSgibm90YXRpb24iLCAiYm94Iik7CiAgICAgIGJyZWFrOwogICAgY2FzZSAiXFxhbmdsIjoKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIm5vdGF0aW9uIiwgImFjdHVhcmlhbCIpOwogICAgICBicmVhazsKICAgIGNhc2UgIlxcZmNvbG9yYm94IjoKICAgIGNhc2UgIlxcY29sb3Jib3giOgogICAgICBmYm94c2VwID0gb3B0aW9ucy5mb250TWV0cmljcygpLmZib3hzZXAgKiBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTsKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIndpZHRoIiwgIisiICsgMiAqIGZib3hzZXAgKyAicHQiKTsKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoImhlaWdodCIsICIrIiArIDIgKiBmYm94c2VwICsgInB0Iik7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJsc3BhY2UiLCBmYm94c2VwICsgInB0Iik7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJ2b2Zmc2V0IiwgZmJveHNlcCArICJwdCIpOwogICAgICBpZiAoZ3JvdXAubGFiZWwgPT09ICJcXGZjb2xvcmJveCIpIHsKICAgICAgICB2YXIgdGhrID0gTWF0aC5tYXgoCiAgICAgICAgICBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZmJveHJ1bGUsCiAgICAgICAgICAvLyBkZWZhdWx0CiAgICAgICAgICBvcHRpb25zLm1pblJ1bGVUaGlja25lc3MKICAgICAgICAgIC8vIHVzZXIgb3ZlcnJpZGUKICAgICAgICApOwogICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJzdHlsZSIsICJib3JkZXI6ICIgKyB0aGsgKyAiZW0gc29saWQgIiArIFN0cmluZyhncm91cC5ib3JkZXJDb2xvcikpOwogICAgICB9CiAgICAgIGJyZWFrOwogICAgY2FzZSAiXFx4Y2FuY2VsIjoKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIm5vdGF0aW9uIiwgInVwZGlhZ29uYWxzdHJpa2UgZG93bmRpYWdvbmFsc3RyaWtlIik7CiAgICAgIGJyZWFrOwogIH0KICBpZiAoZ3JvdXAuYmFja2dyb3VuZENvbG9yKSB7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgibWF0aGJhY2tncm91bmQiLCBncm91cC5iYWNrZ3JvdW5kQ29sb3IpOwogIH0KICByZXR1cm4gbm9kZTsKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJlbmNsb3NlIiwKICBuYW1lczogWyJcXGNvbG9yYm94Il0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDIsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLAogICAgYXJnVHlwZXM6IFsiY29sb3IiLCAidGV4dCJdCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmOwogICAgdmFyIGNvbG9yID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgImNvbG9yLXRva2VuIikuY29sb3I7CiAgICB2YXIgYm9keSA9IGFyZ3NbMV07CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiZW5jbG9zZSIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBsYWJlbDogZnVuY05hbWUsCiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsCiAgICAgIGJvZHkKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNywKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDYKfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiZW5jbG9zZSIsCiAgbmFtZXM6IFsiXFxmY29sb3Jib3giXSwKICBwcm9wczogewogICAgbnVtQXJnczogMywKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBhcmdUeXBlczogWyJjb2xvciIsICJjb2xvciIsICJ0ZXh0Il0KICB9LAogIGhhbmRsZXIoX3JlZjIsIGFyZ3MsIG9wdEFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmMjsKICAgIHZhciBib3JkZXJDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sICJjb2xvci10b2tlbiIpLmNvbG9yOwogICAgdmFyIGJhY2tncm91bmRDb2xvciA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMV0sICJjb2xvci10b2tlbiIpLmNvbG9yOwogICAgdmFyIGJvZHkgPSBhcmdzWzJdOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImVuY2xvc2UiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbGFiZWw6IGZ1bmNOYW1lLAogICAgICBiYWNrZ3JvdW5kQ29sb3IsCiAgICAgIGJvcmRlckNvbG9yLAogICAgICBib2R5CiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDcsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ2Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImVuY2xvc2UiLAogIG5hbWVzOiBbIlxcZmJveCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYXJnVHlwZXM6IFsiaGJveCJdLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmMywgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjM7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiZW5jbG9zZSIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBsYWJlbDogIlxcZmJveCIsCiAgICAgIGJvZHk6IGFyZ3NbMF0KICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJlbmNsb3NlIiwKICBuYW1lczogWyJcXGNhbmNlbCIsICJcXGJjYW5jZWwiLCAiXFx4Y2FuY2VsIiwgIlxcc291dCIsICJcXHBoYXNlIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEKICB9LAogIGhhbmRsZXIoX3JlZjQsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmNDsKICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJlbmNsb3NlIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGxhYmVsOiBmdW5jTmFtZSwKICAgICAgYm9keQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ3LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNgp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJlbmNsb3NlIiwKICBuYW1lczogWyJcXGFuZ2wiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIGFyZ1R5cGVzOiBbImhib3giXSwKICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlCiAgfSwKICBoYW5kbGVyKF9yZWY1LCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmNTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJlbmNsb3NlIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGxhYmVsOiAiXFxhbmdsIiwKICAgICAgYm9keTogYXJnc1swXQogICAgfTsKICB9Cn0pOwp2YXIgX2Vudmlyb25tZW50cyA9IHt9OwpmdW5jdGlvbiBkZWZpbmVFbnZpcm9ubWVudChfcmVmKSB7CiAgdmFyIHsKICAgIHR5cGUsCiAgICBuYW1lcywKICAgIHByb3BzLAogICAgaGFuZGxlciwKICAgIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlcjMsCiAgICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyMwogIH0gPSBfcmVmOwogIHZhciBkYXRhID0gewogICAgdHlwZSwKICAgIG51bUFyZ3M6IHByb3BzLm51bUFyZ3MgfHwgMCwKICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlLAogICAgbnVtT3B0aW9uYWxBcmdzOiAwLAogICAgaGFuZGxlcgogIH07CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkgewogICAgX2Vudmlyb25tZW50c1tuYW1lc1tpXV0gPSBkYXRhOwogIH0KICBpZiAoaHRtbEJ1aWxkZXIzKSB7CiAgICBfaHRtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBodG1sQnVpbGRlcjM7CiAgfQogIGlmIChtYXRobWxCdWlsZGVyMykgewogICAgX21hdGhtbEdyb3VwQnVpbGRlcnNbdHlwZV0gPSBtYXRobWxCdWlsZGVyMzsKICB9Cn0KdmFyIF9tYWNyb3MgPSB7fTsKZnVuY3Rpb24gZGVmaW5lTWFjcm8obmFtZSwgYm9keSkgewogIF9tYWNyb3NbbmFtZV0gPSBib2R5Owp9CmZ1bmN0aW9uIGdldEhMaW5lcyhwYXJzZXIpIHsKICB2YXIgaGxpbmVJbmZvID0gW107CiAgcGFyc2VyLmNvbnN1bWVTcGFjZXMoKTsKICB2YXIgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDsKICBpZiAobnh0ID09PSAiXFxyZWxheCIpIHsKICAgIHBhcnNlci5jb25zdW1lKCk7CiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpOwogICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDsKICB9CiAgd2hpbGUgKG54dCA9PT0gIlxcaGxpbmUiIHx8IG54dCA9PT0gIlxcaGRhc2hsaW5lIikgewogICAgcGFyc2VyLmNvbnN1bWUoKTsKICAgIGhsaW5lSW5mby5wdXNoKG54dCA9PT0gIlxcaGRhc2hsaW5lIik7CiAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpOwogICAgbnh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDsKICB9CiAgcmV0dXJuIGhsaW5lSW5mbzsKfQp2YXIgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQgPSAoY29udGV4dCkgPT4gewogIHZhciBzZXR0aW5ncyA9IGNvbnRleHQucGFyc2VyLnNldHRpbmdzOwogIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHsKICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJ7IiArIGNvbnRleHQuZW52TmFtZSArICJ9IGNhbiBiZSB1c2VkIG9ubHkgaW4gZGlzcGxheSBtb2RlLiIpOwogIH0KfTsKZnVuY3Rpb24gZ2V0QXV0b1RhZyhuYW1lKSB7CiAgaWYgKG5hbWUuaW5kZXhPZigiZWQiKSA9PT0gLTEpIHsKICAgIHJldHVybiBuYW1lLmluZGV4T2YoIioiKSA9PT0gLTE7CiAgfQp9CmZ1bmN0aW9uIHBhcnNlQXJyYXkocGFyc2VyLCBfcmVmLCBzdHlsZSkgewogIHZhciB7CiAgICBoc2tpcEJlZm9yZUFuZEFmdGVyLAogICAgYWRkSm90LAogICAgY29scywKICAgIGFycmF5c3RyZXRjaCwKICAgIGNvbFNlcGFyYXRpb25UeXBlLAogICAgYXV0b1RhZywKICAgIHNpbmdsZVJvdywKICAgIGVtcHR5U2luZ2xlUm93LAogICAgbWF4TnVtQ29scywKICAgIGxlcW5vCiAgfSA9IF9yZWY7CiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7CiAgaWYgKCFzaW5nbGVSb3cpIHsKICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldCgiXFxjciIsICJcXFxcXFxyZWxheCIpOwogIH0KICBpZiAoIWFycmF5c3RyZXRjaCkgewogICAgdmFyIHN0cmV0Y2ggPSBwYXJzZXIuZ3VsbGV0LmV4cGFuZE1hY3JvQXNUZXh0KCJcXGFycmF5c3RyZXRjaCIpOwogICAgaWYgKHN0cmV0Y2ggPT0gbnVsbCkgewogICAgICBhcnJheXN0cmV0Y2ggPSAxOwogICAgfSBlbHNlIHsKICAgICAgYXJyYXlzdHJldGNoID0gcGFyc2VGbG9hdChzdHJldGNoKTsKICAgICAgaWYgKCFhcnJheXN0cmV0Y2ggfHwgYXJyYXlzdHJldGNoIDwgMCkgewogICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIFxcYXJyYXlzdHJldGNoOiAiICsgc3RyZXRjaCk7CiAgICAgIH0KICAgIH0KICB9CiAgcGFyc2VyLmd1bGxldC5iZWdpbkdyb3VwKCk7CiAgdmFyIHJvdyA9IFtdOwogIHZhciBib2R5ID0gW3Jvd107CiAgdmFyIHJvd0dhcHMgPSBbXTsKICB2YXIgaExpbmVzQmVmb3JlUm93ID0gW107CiAgdmFyIHRhZ3MgPSBhdXRvVGFnICE9IG51bGwgPyBbXSA6IHZvaWQgMDsKICBmdW5jdGlvbiBiZWdpblJvdygpIHsKICAgIGlmIChhdXRvVGFnKSB7CiAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldCgiXFxAZXFuc3ciLCAiMSIsIHRydWUpOwogICAgfQogIH0KICBmdW5jdGlvbiBlbmRSb3coKSB7CiAgICBpZiAodGFncykgewogICAgICBpZiAocGFyc2VyLmd1bGxldC5tYWNyb3MuZ2V0KCJcXGRmQHRhZyIpKSB7CiAgICAgICAgdGFncy5wdXNoKHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKCJcXGRmQHRhZyIpXSkpOwogICAgICAgIHBhcnNlci5ndWxsZXQubWFjcm9zLnNldCgiXFxkZkB0YWciLCB2b2lkIDAsIHRydWUpOwogICAgICB9IGVsc2UgewogICAgICAgIHRhZ3MucHVzaChCb29sZWFuKGF1dG9UYWcpICYmIHBhcnNlci5ndWxsZXQubWFjcm9zLmdldCgiXFxAZXFuc3ciKSA9PT0gIjEiKTsKICAgICAgfQogICAgfQogIH0KICBiZWdpblJvdygpOwogIGhMaW5lc0JlZm9yZVJvdy5wdXNoKGdldEhMaW5lcyhwYXJzZXIpKTsKICB3aGlsZSAodHJ1ZSkgewogICAgdmFyIGNlbGwgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBzaW5nbGVSb3cgPyAiXFxlbmQiIDogIlxcXFwiKTsKICAgIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTsKICAgIHBhcnNlci5ndWxsZXQuYmVnaW5Hcm91cCgpOwogICAgY2VsbCA9IHsKICAgICAgdHlwZTogIm9yZGdyb3VwIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGJvZHk6IGNlbGwKICAgIH07CiAgICBpZiAoc3R5bGUpIHsKICAgICAgY2VsbCA9IHsKICAgICAgICB0eXBlOiAic3R5bGluZyIsCiAgICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgICAgc3R5bGUsCiAgICAgICAgYm9keTogW2NlbGxdCiAgICAgIH07CiAgICB9CiAgICByb3cucHVzaChjZWxsKTsKICAgIHZhciBuZXh0ID0gcGFyc2VyLmZldGNoKCkudGV4dDsKICAgIGlmIChuZXh0ID09PSAiJiIpIHsKICAgICAgaWYgKG1heE51bUNvbHMgJiYgcm93Lmxlbmd0aCA9PT0gbWF4TnVtQ29scykgewogICAgICAgIGlmIChzaW5nbGVSb3cgfHwgY29sU2VwYXJhdGlvblR5cGUpIHsKICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJUb28gbWFueSB0YWIgY2hhcmFjdGVyczogJiIsIHBhcnNlci5uZXh0VG9rZW4pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KCJ0ZXh0RW52IiwgIlRvbyBmZXcgY29sdW1ucyBzcGVjaWZpZWQgaW4gdGhlIHthcnJheX0gY29sdW1uIGFyZ3VtZW50LiIpOwogICAgICAgIH0KICAgICAgfQogICAgICBwYXJzZXIuY29uc3VtZSgpOwogICAgfSBlbHNlIGlmIChuZXh0ID09PSAiXFxlbmQiKSB7CiAgICAgIGVuZFJvdygpOwogICAgICBpZiAocm93Lmxlbmd0aCA9PT0gMSAmJiBjZWxsLnR5cGUgPT09ICJzdHlsaW5nIiAmJiBjZWxsLmJvZHlbMF0uYm9keS5sZW5ndGggPT09IDAgJiYgKGJvZHkubGVuZ3RoID4gMSB8fCAhZW1wdHlTaW5nbGVSb3cpKSB7CiAgICAgICAgYm9keS5wb3AoKTsKICAgICAgfQogICAgICBpZiAoaExpbmVzQmVmb3JlUm93Lmxlbmd0aCA8IGJvZHkubGVuZ3RoICsgMSkgewogICAgICAgIGhMaW5lc0JlZm9yZVJvdy5wdXNoKFtdKTsKICAgICAgfQogICAgICBicmVhazsKICAgIH0gZWxzZSBpZiAobmV4dCA9PT0gIlxcXFwiKSB7CiAgICAgIHBhcnNlci5jb25zdW1lKCk7CiAgICAgIHZhciBzaXplID0gdm9pZCAwOwogICAgICBpZiAocGFyc2VyLmd1bGxldC5mdXR1cmUoKS50ZXh0ICE9PSAiICIpIHsKICAgICAgICBzaXplID0gcGFyc2VyLnBhcnNlU2l6ZUdyb3VwKHRydWUpOwogICAgICB9CiAgICAgIHJvd0dhcHMucHVzaChzaXplID8gc2l6ZS52YWx1ZSA6IG51bGwpOwogICAgICBlbmRSb3coKTsKICAgICAgaExpbmVzQmVmb3JlUm93LnB1c2goZ2V0SExpbmVzKHBhcnNlcikpOwogICAgICByb3cgPSBbXTsKICAgICAgYm9keS5wdXNoKHJvdyk7CiAgICAgIGJlZ2luUm93KCk7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiRXhwZWN0ZWQgJiBvciBcXFxcIG9yIFxcY3Igb3IgXFxlbmQiLCBwYXJzZXIubmV4dFRva2VuKTsKICAgIH0KICB9CiAgcGFyc2VyLmd1bGxldC5lbmRHcm91cCgpOwogIHBhcnNlci5ndWxsZXQuZW5kR3JvdXAoKTsKICByZXR1cm4gewogICAgdHlwZTogImFycmF5IiwKICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgYWRkSm90LAogICAgYXJyYXlzdHJldGNoLAogICAgYm9keSwKICAgIGNvbHMsCiAgICByb3dHYXBzLAogICAgaHNraXBCZWZvcmVBbmRBZnRlciwKICAgIGhMaW5lc0JlZm9yZVJvdywKICAgIGNvbFNlcGFyYXRpb25UeXBlLAogICAgdGFncywKICAgIGxlcW5vCiAgfTsKfQpmdW5jdGlvbiBkQ2VsbFN0eWxlKGVudk5hbWUpIHsKICBpZiAoZW52TmFtZS5zbGljZSgwLCAxKSA9PT0gImQiKSB7CiAgICByZXR1cm4gImRpc3BsYXkiOwogIH0gZWxzZSB7CiAgICByZXR1cm4gInRleHQiOwogIH0KfQp2YXIgaHRtbEJ1aWxkZXIkNiA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgdmFyIHI7CiAgdmFyIGM7CiAgdmFyIG5yID0gZ3JvdXAuYm9keS5sZW5ndGg7CiAgdmFyIGhMaW5lc0JlZm9yZVJvdyA9IGdyb3VwLmhMaW5lc0JlZm9yZVJvdzsKICB2YXIgbmMgPSAwOwogIHZhciBib2R5ID0gbmV3IEFycmF5KG5yKTsKICB2YXIgaGxpbmVzID0gW107CiAgdmFyIHJ1bGVUaGlja25lc3MgPSBNYXRoLm1heCgKICAgIC8vIEZyb20gTGFUZVggXHNob3d0aGVcYXJyYXlydWxld2lkdGguIEVxdWFscyAwLjA0IGVtLgogICAgb3B0aW9ucy5mb250TWV0cmljcygpLmFycmF5UnVsZVdpZHRoLAogICAgb3B0aW9ucy5taW5SdWxlVGhpY2tuZXNzCiAgICAvLyBVc2VyIG92ZXJyaWRlLgogICk7CiAgdmFyIHB0ID0gMSAvIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5wdFBlckVtOwogIHZhciBhcnJheWNvbHNlcCA9IDUgKiBwdDsKICBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgJiYgZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09ICJzbWFsbCIpIHsKICAgIHZhciBsb2NhbE11bHRpcGxpZXIgPSBvcHRpb25zLmhhdmluZ1N0eWxlKFN0eWxlJDEuU0NSSVBUKS5zaXplTXVsdGlwbGllcjsKICAgIGFycmF5Y29sc2VwID0gMC4yNzc4ICogKGxvY2FsTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXIpOwogIH0KICB2YXIgYmFzZWxpbmVza2lwID0gZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09ICJDRCIgPyBjYWxjdWxhdGVTaXplKHsKICAgIG51bWJlcjogMywKICAgIHVuaXQ6ICJleCIKICB9LCBvcHRpb25zKSA6IDEyICogcHQ7CiAgdmFyIGpvdCA9IDMgKiBwdDsKICB2YXIgYXJyYXlza2lwID0gZ3JvdXAuYXJyYXlzdHJldGNoICogYmFzZWxpbmVza2lwOwogIHZhciBhcnN0cnV0SGVpZ2h0ID0gMC43ICogYXJyYXlza2lwOwogIHZhciBhcnN0cnV0RGVwdGggPSAwLjMgKiBhcnJheXNraXA7CiAgdmFyIHRvdGFsSGVpZ2h0ID0gMDsKICBmdW5jdGlvbiBzZXRITGluZVBvcyhobGluZXNJbkdhcCkgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBobGluZXNJbkdhcC5sZW5ndGg7ICsraSkgewogICAgICBpZiAoaSA+IDApIHsKICAgICAgICB0b3RhbEhlaWdodCArPSAwLjI1OwogICAgICB9CiAgICAgIGhsaW5lcy5wdXNoKHsKICAgICAgICBwb3M6IHRvdGFsSGVpZ2h0LAogICAgICAgIGlzRGFzaGVkOiBobGluZXNJbkdhcFtpXQogICAgICB9KTsKICAgIH0KICB9CiAgc2V0SExpbmVQb3MoaExpbmVzQmVmb3JlUm93WzBdKTsKICBmb3IgKHIgPSAwOyByIDwgZ3JvdXAuYm9keS5sZW5ndGg7ICsrcikgewogICAgdmFyIGlucm93ID0gZ3JvdXAuYm9keVtyXTsKICAgIHZhciBoZWlnaHQgPSBhcnN0cnV0SGVpZ2h0OwogICAgdmFyIGRlcHRoID0gYXJzdHJ1dERlcHRoOwogICAgaWYgKG5jIDwgaW5yb3cubGVuZ3RoKSB7CiAgICAgIG5jID0gaW5yb3cubGVuZ3RoOwogICAgfQogICAgdmFyIG91dHJvdyA9IG5ldyBBcnJheShpbnJvdy5sZW5ndGgpOwogICAgZm9yIChjID0gMDsgYyA8IGlucm93Lmxlbmd0aDsgKytjKSB7CiAgICAgIHZhciBlbHQgPSBidWlsZEdyb3VwJDEoaW5yb3dbY10sIG9wdGlvbnMpOwogICAgICBpZiAoZGVwdGggPCBlbHQuZGVwdGgpIHsKICAgICAgICBkZXB0aCA9IGVsdC5kZXB0aDsKICAgICAgfQogICAgICBpZiAoaGVpZ2h0IDwgZWx0LmhlaWdodCkgewogICAgICAgIGhlaWdodCA9IGVsdC5oZWlnaHQ7CiAgICAgIH0KICAgICAgb3V0cm93W2NdID0gZWx0OwogICAgfQogICAgdmFyIHJvd0dhcCA9IGdyb3VwLnJvd0dhcHNbcl07CiAgICB2YXIgZ2FwID0gMDsKICAgIGlmIChyb3dHYXApIHsKICAgICAgZ2FwID0gY2FsY3VsYXRlU2l6ZShyb3dHYXAsIG9wdGlvbnMpOwogICAgICBpZiAoZ2FwID4gMCkgewogICAgICAgIGdhcCArPSBhcnN0cnV0RGVwdGg7CiAgICAgICAgaWYgKGRlcHRoIDwgZ2FwKSB7CiAgICAgICAgICBkZXB0aCA9IGdhcDsKICAgICAgICB9CiAgICAgICAgZ2FwID0gMDsKICAgICAgfQogICAgfQogICAgaWYgKGdyb3VwLmFkZEpvdCkgewogICAgICBkZXB0aCArPSBqb3Q7CiAgICB9CiAgICBvdXRyb3cuaGVpZ2h0ID0gaGVpZ2h0OwogICAgb3V0cm93LmRlcHRoID0gZGVwdGg7CiAgICB0b3RhbEhlaWdodCArPSBoZWlnaHQ7CiAgICBvdXRyb3cucG9zID0gdG90YWxIZWlnaHQ7CiAgICB0b3RhbEhlaWdodCArPSBkZXB0aCArIGdhcDsKICAgIGJvZHlbcl0gPSBvdXRyb3c7CiAgICBzZXRITGluZVBvcyhoTGluZXNCZWZvcmVSb3dbciArIDFdKTsKICB9CiAgdmFyIG9mZnNldCA9IHRvdGFsSGVpZ2h0IC8gMiArIG9wdGlvbnMuZm9udE1ldHJpY3MoKS5heGlzSGVpZ2h0OwogIHZhciBjb2xEZXNjcmlwdGlvbnMgPSBncm91cC5jb2xzIHx8IFtdOwogIHZhciBjb2xzID0gW107CiAgdmFyIGNvbFNlcDsKICB2YXIgY29sRGVzY3JOdW07CiAgdmFyIHRhZ1NwYW5zID0gW107CiAgaWYgKGdyb3VwLnRhZ3MgJiYgZ3JvdXAudGFncy5zb21lKCh0YWcyKSA9PiB0YWcyKSkgewogICAgZm9yIChyID0gMDsgciA8IG5yOyArK3IpIHsKICAgICAgdmFyIHJ3ID0gYm9keVtyXTsKICAgICAgdmFyIHNoaWZ0ID0gcncucG9zIC0gb2Zmc2V0OwogICAgICB2YXIgdGFnID0gZ3JvdXAudGFnc1tyXTsKICAgICAgdmFyIHRhZ1NwYW4gPSB2b2lkIDA7CiAgICAgIGlmICh0YWcgPT09IHRydWUpIHsKICAgICAgICB0YWdTcGFuID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJlcW4tbnVtIl0sIFtdLCBvcHRpb25zKTsKICAgICAgfSBlbHNlIGlmICh0YWcgPT09IGZhbHNlKSB7CiAgICAgICAgdGFnU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbXSwgb3B0aW9ucyk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGFnU3BhbiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBidWlsZEV4cHJlc3Npb24kMSh0YWcsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTsKICAgICAgfQogICAgICB0YWdTcGFuLmRlcHRoID0gcncuZGVwdGg7CiAgICAgIHRhZ1NwYW4uaGVpZ2h0ID0gcncuaGVpZ2h0OwogICAgICB0YWdTcGFucy5wdXNoKHsKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogdGFnU3BhbiwKICAgICAgICBzaGlmdAogICAgICB9KTsKICAgIH0KICB9CiAgZm9yICgKICAgIGMgPSAwLCBjb2xEZXNjck51bSA9IDA7CiAgICAvLyBDb250aW51ZSB3aGlsZSBlaXRoZXIgdGhlcmUgYXJlIG1vcmUgY29sdW1ucyBvciBtb3JlIGNvbHVtbgogICAgLy8gZGVzY3JpcHRpb25zLCBzbyB0cmFpbGluZyBzZXBhcmF0b3JzIGRvbid0IGdldCBsb3N0LgogICAgYyA8IG5jIHx8IGNvbERlc2NyTnVtIDwgY29sRGVzY3JpcHRpb25zLmxlbmd0aDsKICAgICsrYywgKytjb2xEZXNjck51bQogICkgewogICAgdmFyIGNvbERlc2NyID0gY29sRGVzY3JpcHRpb25zW2NvbERlc2NyTnVtXSB8fCB7fTsKICAgIHZhciBmaXJzdFNlcGFyYXRvciA9IHRydWU7CiAgICB3aGlsZSAoY29sRGVzY3IudHlwZSA9PT0gInNlcGFyYXRvciIpIHsKICAgICAgaWYgKCFmaXJzdFNlcGFyYXRvcikgewogICAgICAgIGNvbFNlcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsiYXJyYXljb2xzZXAiXSwgW10pOwogICAgICAgIGNvbFNlcC5zdHlsZS53aWR0aCA9IG1ha2VFbShvcHRpb25zLmZvbnRNZXRyaWNzKCkuZG91YmxlUnVsZVNlcCk7CiAgICAgICAgY29scy5wdXNoKGNvbFNlcCk7CiAgICAgIH0KICAgICAgaWYgKGNvbERlc2NyLnNlcGFyYXRvciA9PT0gInwiIHx8IGNvbERlc2NyLnNlcGFyYXRvciA9PT0gIjoiKSB7CiAgICAgICAgdmFyIGxpbmVUeXBlID0gY29sRGVzY3Iuc2VwYXJhdG9yID09PSAifCIgPyAic29saWQiIDogImRhc2hlZCI7CiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsidmVydGljYWwtc2VwYXJhdG9yIl0sIFtdLCBvcHRpb25zKTsKICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuaGVpZ2h0ID0gbWFrZUVtKHRvdGFsSGVpZ2h0KTsKICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IG1ha2VFbShydWxlVGhpY2tuZXNzKTsKICAgICAgICBzZXBhcmF0b3Iuc3R5bGUuYm9yZGVyUmlnaHRTdHlsZSA9IGxpbmVUeXBlOwogICAgICAgIHNlcGFyYXRvci5zdHlsZS5tYXJnaW4gPSAiMCAiICsgbWFrZUVtKC1ydWxlVGhpY2tuZXNzIC8gMik7CiAgICAgICAgdmFyIF9zaGlmdCA9IHRvdGFsSGVpZ2h0IC0gb2Zmc2V0OwogICAgICAgIGlmIChfc2hpZnQpIHsKICAgICAgICAgIHNlcGFyYXRvci5zdHlsZS52ZXJ0aWNhbEFsaWduID0gbWFrZUVtKC1fc2hpZnQpOwogICAgICAgIH0KICAgICAgICBjb2xzLnB1c2goc2VwYXJhdG9yKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiSW52YWxpZCBzZXBhcmF0b3IgdHlwZTogIiArIGNvbERlc2NyLnNlcGFyYXRvcik7CiAgICAgIH0KICAgICAgY29sRGVzY3JOdW0rKzsKICAgICAgY29sRGVzY3IgPSBjb2xEZXNjcmlwdGlvbnNbY29sRGVzY3JOdW1dIHx8IHt9OwogICAgICBmaXJzdFNlcGFyYXRvciA9IGZhbHNlOwogICAgfQogICAgaWYgKGMgPj0gbmMpIHsKICAgICAgY29udGludWU7CiAgICB9CiAgICB2YXIgc2Vwd2lkdGggPSB2b2lkIDA7CiAgICBpZiAoYyA+IDAgfHwgZ3JvdXAuaHNraXBCZWZvcmVBbmRBZnRlcikgewogICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnByZWdhcCwgYXJyYXljb2xzZXApOwogICAgICBpZiAoc2Vwd2lkdGggIT09IDApIHsKICAgICAgICBjb2xTZXAgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbImFycmF5Y29sc2VwIl0sIFtdKTsKICAgICAgICBjb2xTZXAuc3R5bGUud2lkdGggPSBtYWtlRW0oc2Vwd2lkdGgpOwogICAgICAgIGNvbHMucHVzaChjb2xTZXApOwogICAgICB9CiAgICB9CiAgICB2YXIgY29sID0gW107CiAgICBmb3IgKHIgPSAwOyByIDwgbnI7ICsrcikgewogICAgICB2YXIgcm93ID0gYm9keVtyXTsKICAgICAgdmFyIGVsZW0gPSByb3dbY107CiAgICAgIGlmICghZWxlbSkgewogICAgICAgIGNvbnRpbnVlOwogICAgICB9CiAgICAgIHZhciBfc2hpZnQyID0gcm93LnBvcyAtIG9mZnNldDsKICAgICAgZWxlbS5kZXB0aCA9IHJvdy5kZXB0aDsKICAgICAgZWxlbS5oZWlnaHQgPSByb3cuaGVpZ2h0OwogICAgICBjb2wucHVzaCh7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW0sCiAgICAgICAgc2hpZnQ6IF9zaGlmdDIKICAgICAgfSk7CiAgICB9CiAgICBjb2wgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJpbmRpdmlkdWFsU2hpZnQiLAogICAgICBjaGlsZHJlbjogY29sCiAgICB9LCBvcHRpb25zKTsKICAgIGNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsiY29sLWFsaWduLSIgKyAoY29sRGVzY3IuYWxpZ24gfHwgImMiKV0sIFtjb2xdKTsKICAgIGNvbHMucHVzaChjb2wpOwogICAgaWYgKGMgPCBuYyAtIDEgfHwgZ3JvdXAuaHNraXBCZWZvcmVBbmRBZnRlcikgewogICAgICBzZXB3aWR0aCA9IHV0aWxzLmRlZmx0KGNvbERlc2NyLnBvc3RnYXAsIGFycmF5Y29sc2VwKTsKICAgICAgaWYgKHNlcHdpZHRoICE9PSAwKSB7CiAgICAgICAgY29sU2VwID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJhcnJheWNvbHNlcCJdLCBbXSk7CiAgICAgICAgY29sU2VwLnN0eWxlLndpZHRoID0gbWFrZUVtKHNlcHdpZHRoKTsKICAgICAgICBjb2xzLnB1c2goY29sU2VwKTsKICAgICAgfQogICAgfQogIH0KICBib2R5ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtdGFibGUiXSwgY29scyk7CiAgaWYgKGhsaW5lcy5sZW5ndGggPiAwKSB7CiAgICB2YXIgbGluZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbigiaGxpbmUiLCBvcHRpb25zLCBydWxlVGhpY2tuZXNzKTsKICAgIHZhciBkYXNoZXMgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oImhkYXNobGluZSIsIG9wdGlvbnMsIHJ1bGVUaGlja25lc3MpOwogICAgdmFyIHZMaXN0RWxlbXMgPSBbewogICAgICB0eXBlOiAiZWxlbSIsCiAgICAgIGVsZW06IGJvZHksCiAgICAgIHNoaWZ0OiAwCiAgICB9XTsKICAgIHdoaWxlIChobGluZXMubGVuZ3RoID4gMCkgewogICAgICB2YXIgaGxpbmUgPSBobGluZXMucG9wKCk7CiAgICAgIHZhciBsaW5lU2hpZnQgPSBobGluZS5wb3MgLSBvZmZzZXQ7CiAgICAgIGlmIChobGluZS5pc0Rhc2hlZCkgewogICAgICAgIHZMaXN0RWxlbXMucHVzaCh7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiBkYXNoZXMsCiAgICAgICAgICBzaGlmdDogbGluZVNoaWZ0CiAgICAgICAgfSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdkxpc3RFbGVtcy5wdXNoKHsKICAgICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICAgIGVsZW06IGxpbmUsCiAgICAgICAgICBzaGlmdDogbGluZVNoaWZ0CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICAgIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJpbmRpdmlkdWFsU2hpZnQiLAogICAgICBjaGlsZHJlbjogdkxpc3RFbGVtcwogICAgfSwgb3B0aW9ucyk7CiAgfQogIGlmICh0YWdTcGFucy5sZW5ndGggPT09IDApIHsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiXSwgW2JvZHldLCBvcHRpb25zKTsKICB9IGVsc2UgewogICAgdmFyIGVxbk51bUNvbCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImluZGl2aWR1YWxTaGlmdCIsCiAgICAgIGNoaWxkcmVuOiB0YWdTcGFucwogICAgfSwgb3B0aW9ucyk7CiAgICBlcW5OdW1Db2wgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbInRhZyJdLCBbZXFuTnVtQ29sXSwgb3B0aW9ucyk7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KFtib2R5LCBlcW5OdW1Db2xdKTsKICB9Cn07CnZhciBhbGlnbk1hcCA9IHsKICBjOiAiY2VudGVyICIsCiAgbDogImxlZnQgIiwKICByOiAicmlnaHQgIgp9Owp2YXIgbWF0aG1sQnVpbGRlciQ1ID0gZnVuY3Rpb24gbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogIHZhciB0YmwgPSBbXTsKICB2YXIgZ2x1ZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtdGQiLCBbXSwgWyJtdHItZ2x1ZSJdKTsKICB2YXIgdGFnID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm10ZCIsIFtdLCBbIm1tbC1lcW4tbnVtIl0pOwogIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAuYm9keS5sZW5ndGg7IGkrKykgewogICAgdmFyIHJ3ID0gZ3JvdXAuYm9keVtpXTsKICAgIHZhciByb3cgPSBbXTsKICAgIGZvciAodmFyIGogPSAwOyBqIDwgcncubGVuZ3RoOyBqKyspIHsKICAgICAgcm93LnB1c2gobmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm10ZCIsIFtidWlsZEdyb3VwMihyd1tqXSwgb3B0aW9ucyldKSk7CiAgICB9CiAgICBpZiAoZ3JvdXAudGFncyAmJiBncm91cC50YWdzW2ldKSB7CiAgICAgIHJvdy51bnNoaWZ0KGdsdWUpOwogICAgICByb3cucHVzaChnbHVlKTsKICAgICAgaWYgKGdyb3VwLmxlcW5vKSB7CiAgICAgICAgcm93LnVuc2hpZnQodGFnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICByb3cucHVzaCh0YWcpOwogICAgICB9CiAgICB9CiAgICB0YmwucHVzaChuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXRyIiwgcm93KSk7CiAgfQogIHZhciB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtdGFibGUiLCB0YmwpOwogIHZhciBnYXAgPSBncm91cC5hcnJheXN0cmV0Y2ggPT09IDAuNSA/IDAuMSA6IDAuMTYgKyBncm91cC5hcnJheXN0cmV0Y2ggLSAxICsgKGdyb3VwLmFkZEpvdCA/IDAuMDkgOiAwKTsKICB0YWJsZS5zZXRBdHRyaWJ1dGUoInJvd3NwYWNpbmciLCBtYWtlRW0oZ2FwKSk7CiAgdmFyIG1lbmNsb3NlID0gIiI7CiAgdmFyIGFsaWduID0gIiI7CiAgaWYgKGdyb3VwLmNvbHMgJiYgZ3JvdXAuY29scy5sZW5ndGggPiAwKSB7CiAgICB2YXIgY29scyA9IGdyb3VwLmNvbHM7CiAgICB2YXIgY29sdW1uTGluZXMgPSAiIjsKICAgIHZhciBwcmV2VHlwZVdhc0FsaWduID0gZmFsc2U7CiAgICB2YXIgaVN0YXJ0ID0gMDsKICAgIHZhciBpRW5kID0gY29scy5sZW5ndGg7CiAgICBpZiAoY29sc1swXS50eXBlID09PSAic2VwYXJhdG9yIikgewogICAgICBtZW5jbG9zZSArPSAidG9wICI7CiAgICAgIGlTdGFydCA9IDE7CiAgICB9CiAgICBpZiAoY29sc1tjb2xzLmxlbmd0aCAtIDFdLnR5cGUgPT09ICJzZXBhcmF0b3IiKSB7CiAgICAgIG1lbmNsb3NlICs9ICJib3R0b20gIjsKICAgICAgaUVuZCAtPSAxOwogICAgfQogICAgZm9yICh2YXIgX2kgPSBpU3RhcnQ7IF9pIDwgaUVuZDsgX2krKykgewogICAgICBpZiAoY29sc1tfaV0udHlwZSA9PT0gImFsaWduIikgewogICAgICAgIGFsaWduICs9IGFsaWduTWFwW2NvbHNbX2ldLmFsaWduXTsKICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikgewogICAgICAgICAgY29sdW1uTGluZXMgKz0gIm5vbmUgIjsKICAgICAgICB9CiAgICAgICAgcHJldlR5cGVXYXNBbGlnbiA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoY29sc1tfaV0udHlwZSA9PT0gInNlcGFyYXRvciIpIHsKICAgICAgICBpZiAocHJldlR5cGVXYXNBbGlnbikgewogICAgICAgICAgY29sdW1uTGluZXMgKz0gY29sc1tfaV0uc2VwYXJhdG9yID09PSAifCIgPyAic29saWQgIiA6ICJkYXNoZWQgIjsKICAgICAgICAgIHByZXZUeXBlV2FzQWxpZ24gPSBmYWxzZTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHRhYmxlLnNldEF0dHJpYnV0ZSgiY29sdW1uYWxpZ24iLCBhbGlnbi50cmltKCkpOwogICAgaWYgKC9bc2RdLy50ZXN0KGNvbHVtbkxpbmVzKSkgewogICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoImNvbHVtbmxpbmVzIiwgY29sdW1uTGluZXMudHJpbSgpKTsKICAgIH0KICB9CiAgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSAiYWxpZ24iKSB7CiAgICB2YXIgX2NvbHMgPSBncm91cC5jb2xzIHx8IFtdOwogICAgdmFyIHNwYWNpbmcyID0gIiI7CiAgICBmb3IgKHZhciBfaTIgPSAxOyBfaTIgPCBfY29scy5sZW5ndGg7IF9pMisrKSB7CiAgICAgIHNwYWNpbmcyICs9IF9pMiAlIDIgPyAiMGVtICIgOiAiMWVtICI7CiAgICB9CiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoImNvbHVtbnNwYWNpbmciLCBzcGFjaW5nMi50cmltKCkpOwogIH0gZWxzZSBpZiAoZ3JvdXAuY29sU2VwYXJhdGlvblR5cGUgPT09ICJhbGlnbmF0IiB8fCBncm91cC5jb2xTZXBhcmF0aW9uVHlwZSA9PT0gImdhdGhlciIpIHsKICAgIHRhYmxlLnNldEF0dHJpYnV0ZSgiY29sdW1uc3BhY2luZyIsICIwZW0iKTsKICB9IGVsc2UgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSAic21hbGwiKSB7CiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoImNvbHVtbnNwYWNpbmciLCAiMC4yNzc4ZW0iKTsKICB9IGVsc2UgaWYgKGdyb3VwLmNvbFNlcGFyYXRpb25UeXBlID09PSAiQ0QiKSB7CiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoImNvbHVtbnNwYWNpbmciLCAiMC41ZW0iKTsKICB9IGVsc2UgewogICAgdGFibGUuc2V0QXR0cmlidXRlKCJjb2x1bW5zcGFjaW5nIiwgIjFlbSIpOwogIH0KICB2YXIgcm93TGluZXMgPSAiIjsKICB2YXIgaGxpbmVzID0gZ3JvdXAuaExpbmVzQmVmb3JlUm93OwogIG1lbmNsb3NlICs9IGhsaW5lc1swXS5sZW5ndGggPiAwID8gImxlZnQgIiA6ICIiOwogIG1lbmNsb3NlICs9IGhsaW5lc1tobGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoID4gMCA/ICJyaWdodCAiIDogIiI7CiAgZm9yICh2YXIgX2kzID0gMTsgX2kzIDwgaGxpbmVzLmxlbmd0aCAtIDE7IF9pMysrKSB7CiAgICByb3dMaW5lcyArPSBobGluZXNbX2kzXS5sZW5ndGggPT09IDAgPyAibm9uZSAiIDogaGxpbmVzW19pM11bMF0gPyAiZGFzaGVkICIgOiAic29saWQgIjsKICB9CiAgaWYgKC9bc2RdLy50ZXN0KHJvd0xpbmVzKSkgewogICAgdGFibGUuc2V0QXR0cmlidXRlKCJyb3dsaW5lcyIsIHJvd0xpbmVzLnRyaW0oKSk7CiAgfQogIGlmIChtZW5jbG9zZSAhPT0gIiIpIHsKICAgIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1lbmNsb3NlIiwgW3RhYmxlXSk7CiAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoIm5vdGF0aW9uIiwgbWVuY2xvc2UudHJpbSgpKTsKICB9CiAgaWYgKGdyb3VwLmFycmF5c3RyZXRjaCAmJiBncm91cC5hcnJheXN0cmV0Y2ggPCAxKSB7CiAgICB0YWJsZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtc3R5bGUiLCBbdGFibGVdKTsKICAgIHRhYmxlLnNldEF0dHJpYnV0ZSgic2NyaXB0bGV2ZWwiLCAiMSIpOwogIH0KICByZXR1cm4gdGFibGU7Cn07CnZhciBhbGlnbmVkSGFuZGxlciA9IGZ1bmN0aW9uIGFsaWduZWRIYW5kbGVyMihjb250ZXh0LCBhcmdzKSB7CiAgaWYgKGNvbnRleHQuZW52TmFtZS5pbmRleE9mKCJlZCIpID09PSAtMSkgewogICAgdmFsaWRhdGVBbXNFbnZpcm9ubWVudENvbnRleHQoY29udGV4dCk7CiAgfQogIHZhciBjb2xzID0gW107CiAgdmFyIHNlcGFyYXRpb25UeXBlID0gY29udGV4dC5lbnZOYW1lLmluZGV4T2YoImF0IikgPiAtMSA/ICJhbGlnbmF0IiA6ICJhbGlnbiI7CiAgdmFyIGlzU3BsaXQgPSBjb250ZXh0LmVudk5hbWUgPT09ICJzcGxpdCI7CiAgdmFyIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHsKICAgIGNvbHMsCiAgICBhZGRKb3Q6IHRydWUsCiAgICBhdXRvVGFnOiBpc1NwbGl0ID8gdm9pZCAwIDogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLAogICAgZW1wdHlTaW5nbGVSb3c6IHRydWUsCiAgICBjb2xTZXBhcmF0aW9uVHlwZTogc2VwYXJhdGlvblR5cGUsCiAgICBtYXhOdW1Db2xzOiBpc1NwbGl0ID8gMiA6IHZvaWQgMCwKICAgIGxlcW5vOiBjb250ZXh0LnBhcnNlci5zZXR0aW5ncy5sZXFubwogIH0sICJkaXNwbGF5Iik7CiAgdmFyIG51bU1hdGhzOwogIHZhciBudW1Db2xzID0gMDsKICB2YXIgZW1wdHlHcm91cCA9IHsKICAgIHR5cGU6ICJvcmRncm91cCIsCiAgICBtb2RlOiBjb250ZXh0Lm1vZGUsCiAgICBib2R5OiBbXQogIH07CiAgaWYgKGFyZ3NbMF0gJiYgYXJnc1swXS50eXBlID09PSAib3JkZ3JvdXAiKSB7CiAgICB2YXIgYXJnMCA9ICIiOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzWzBdLmJvZHkubGVuZ3RoOyBpKyspIHsKICAgICAgdmFyIHRleHRvcmQyID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXS5ib2R5W2ldLCAidGV4dG9yZCIpOwogICAgICBhcmcwICs9IHRleHRvcmQyLnRleHQ7CiAgICB9CiAgICBudW1NYXRocyA9IE51bWJlcihhcmcwKTsKICAgIG51bUNvbHMgPSBudW1NYXRocyAqIDI7CiAgfQogIHZhciBpc0FsaWduZWQgPSAhbnVtQ29sczsKICByZXMuYm9keS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykgewogICAgZm9yICh2YXIgX2k0ID0gMTsgX2k0IDwgcm93Lmxlbmd0aDsgX2k0ICs9IDIpIHsKICAgICAgdmFyIHN0eWxpbmcgPSBhc3NlcnROb2RlVHlwZShyb3dbX2k0XSwgInN0eWxpbmciKTsKICAgICAgdmFyIG9yZGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bGluZy5ib2R5WzBdLCAib3JkZ3JvdXAiKTsKICAgICAgb3JkZ3JvdXAuYm9keS51bnNoaWZ0KGVtcHR5R3JvdXApOwogICAgfQogICAgaWYgKCFpc0FsaWduZWQpIHsKICAgICAgdmFyIGN1ck1hdGhzID0gcm93Lmxlbmd0aCAvIDI7CiAgICAgIGlmIChudW1NYXRocyA8IGN1ck1hdGhzKSB7CiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlRvbyBtYW55IG1hdGggaW4gYSByb3c6ICIgKyAoImV4cGVjdGVkICIgKyBudW1NYXRocyArICIsIGJ1dCBnb3QgIiArIGN1ck1hdGhzKSwgcm93WzBdKTsKICAgICAgfQogICAgfSBlbHNlIGlmIChudW1Db2xzIDwgcm93Lmxlbmd0aCkgewogICAgICBudW1Db2xzID0gcm93Lmxlbmd0aDsKICAgIH0KICB9KTsKICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBudW1Db2xzOyArK19pNSkgewogICAgdmFyIGFsaWduID0gInIiOwogICAgdmFyIHByZWdhcCA9IDA7CiAgICBpZiAoX2k1ICUgMiA9PT0gMSkgewogICAgICBhbGlnbiA9ICJsIjsKICAgIH0gZWxzZSBpZiAoX2k1ID4gMCAmJiBpc0FsaWduZWQpIHsKICAgICAgcHJlZ2FwID0gMTsKICAgIH0KICAgIGNvbHNbX2k1XSA9IHsKICAgICAgdHlwZTogImFsaWduIiwKICAgICAgYWxpZ24sCiAgICAgIHByZWdhcCwKICAgICAgcG9zdGdhcDogMAogICAgfTsKICB9CiAgcmVzLmNvbFNlcGFyYXRpb25UeXBlID0gaXNBbGlnbmVkID8gImFsaWduIiA6ICJhbGlnbmF0IjsKICByZXR1cm4gcmVzOwp9OwpkZWZpbmVFbnZpcm9ubWVudCh7CiAgdHlwZTogImFycmF5IiwKICBuYW1lczogWyJhcnJheSIsICJkYXJyYXkiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMQogIH0sCiAgaGFuZGxlcihjb250ZXh0LCBhcmdzKSB7CiAgICB2YXIgc3ltTm9kZSA9IGNoZWNrU3ltYm9sTm9kZVR5cGUoYXJnc1swXSk7CiAgICB2YXIgY29sYWxpZ24gPSBzeW1Ob2RlID8gW2FyZ3NbMF1dIDogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgIm9yZGdyb3VwIikuYm9keTsKICAgIHZhciBjb2xzID0gY29sYWxpZ24ubWFwKGZ1bmN0aW9uKG5kZSkgewogICAgICB2YXIgbm9kZSA9IGFzc2VydFN5bWJvbE5vZGVUeXBlKG5kZSk7CiAgICAgIHZhciBjYSA9IG5vZGUudGV4dDsKICAgICAgaWYgKCJsY3IiLmluZGV4T2YoY2EpICE9PSAtMSkgewogICAgICAgIHJldHVybiB7CiAgICAgICAgICB0eXBlOiAiYWxpZ24iLAogICAgICAgICAgYWxpZ246IGNhCiAgICAgICAgfTsKICAgICAgfSBlbHNlIGlmIChjYSA9PT0gInwiKSB7CiAgICAgICAgcmV0dXJuIHsKICAgICAgICAgIHR5cGU6ICJzZXBhcmF0b3IiLAogICAgICAgICAgc2VwYXJhdG9yOiAifCIKICAgICAgICB9OwogICAgICB9IGVsc2UgaWYgKGNhID09PSAiOiIpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogInNlcGFyYXRvciIsCiAgICAgICAgICBzZXBhcmF0b3I6ICI6IgogICAgICAgIH07CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVua25vd24gY29sdW1uIGFsaWdubWVudDogIiArIGNhLCBuZGUpOwogICAgfSk7CiAgICB2YXIgcmVzID0gewogICAgICBjb2xzLAogICAgICBoc2tpcEJlZm9yZUFuZEFmdGVyOiB0cnVlLAogICAgICAvLyBcQHByZWFtYmxlIGluIGx0dGFiLmR0eAogICAgICBtYXhOdW1Db2xzOiBjb2xzLmxlbmd0aAogICAgfTsKICAgIHJldHVybiBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCByZXMsIGRDZWxsU3R5bGUoY29udGV4dC5lbnZOYW1lKSk7CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNiwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDUKfSk7CmRlZmluZUVudmlyb25tZW50KHsKICB0eXBlOiAiYXJyYXkiLAogIG5hbWVzOiBbIm1hdHJpeCIsICJwbWF0cml4IiwgImJtYXRyaXgiLCAiQm1hdHJpeCIsICJ2bWF0cml4IiwgIlZtYXRyaXgiLCAibWF0cml4KiIsICJwbWF0cml4KiIsICJibWF0cml4KiIsICJCbWF0cml4KiIsICJ2bWF0cml4KiIsICJWbWF0cml4KiJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyKGNvbnRleHQpIHsKICAgIHZhciBkZWxpbWl0ZXJzMiA9IHsKICAgICAgIm1hdHJpeCI6IG51bGwsCiAgICAgICJwbWF0cml4IjogWyIoIiwgIikiXSwKICAgICAgImJtYXRyaXgiOiBbIlsiLCAiXSJdLAogICAgICAiQm1hdHJpeCI6IFsiXFx7IiwgIlxcfSJdLAogICAgICAidm1hdHJpeCI6IFsifCIsICJ8Il0sCiAgICAgICJWbWF0cml4IjogWyJcXFZlcnQiLCAiXFxWZXJ0Il0KICAgIH1bY29udGV4dC5lbnZOYW1lLnJlcGxhY2UoIioiLCAiIildOwogICAgdmFyIGNvbEFsaWduID0gImMiOwogICAgdmFyIHBheWxvYWQgPSB7CiAgICAgIGhza2lwQmVmb3JlQW5kQWZ0ZXI6IGZhbHNlLAogICAgICBjb2xzOiBbewogICAgICAgIHR5cGU6ICJhbGlnbiIsCiAgICAgICAgYWxpZ246IGNvbEFsaWduCiAgICAgIH1dCiAgICB9OwogICAgaWYgKGNvbnRleHQuZW52TmFtZS5jaGFyQXQoY29udGV4dC5lbnZOYW1lLmxlbmd0aCAtIDEpID09PSAiKiIpIHsKICAgICAgdmFyIHBhcnNlciA9IGNvbnRleHQucGFyc2VyOwogICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpOwogICAgICBpZiAocGFyc2VyLmZldGNoKCkudGV4dCA9PT0gIlsiKSB7CiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTsKICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpOwogICAgICAgIGNvbEFsaWduID0gcGFyc2VyLmZldGNoKCkudGV4dDsKICAgICAgICBpZiAoImxjciIuaW5kZXhPZihjb2xBbGlnbikgPT09IC0xKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiRXhwZWN0ZWQgbCBvciBjIG9yIHIiLCBwYXJzZXIubmV4dFRva2VuKTsKICAgICAgICB9CiAgICAgICAgcGFyc2VyLmNvbnN1bWUoKTsKICAgICAgICBwYXJzZXIuY29uc3VtZVNwYWNlcygpOwogICAgICAgIHBhcnNlci5leHBlY3QoIl0iKTsKICAgICAgICBwYXJzZXIuY29uc3VtZSgpOwogICAgICAgIHBheWxvYWQuY29scyA9IFt7CiAgICAgICAgICB0eXBlOiAiYWxpZ24iLAogICAgICAgICAgYWxpZ246IGNvbEFsaWduCiAgICAgICAgfV07CiAgICAgIH0KICAgIH0KICAgIHZhciByZXMgPSBwYXJzZUFycmF5KGNvbnRleHQucGFyc2VyLCBwYXlsb2FkLCBkQ2VsbFN0eWxlKGNvbnRleHQuZW52TmFtZSkpOwogICAgdmFyIG51bUNvbHMgPSBNYXRoLm1heCgwLCAuLi5yZXMuYm9keS5tYXAoKHJvdykgPT4gcm93Lmxlbmd0aCkpOwogICAgcmVzLmNvbHMgPSBuZXcgQXJyYXkobnVtQ29scykuZmlsbCh7CiAgICAgIHR5cGU6ICJhbGlnbiIsCiAgICAgIGFsaWduOiBjb2xBbGlnbgogICAgfSk7CiAgICByZXR1cm4gZGVsaW1pdGVyczIgPyB7CiAgICAgIHR5cGU6ICJsZWZ0cmlnaHQiLAogICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsCiAgICAgIGJvZHk6IFtyZXNdLAogICAgICBsZWZ0OiBkZWxpbWl0ZXJzMlswXSwKICAgICAgcmlnaHQ6IGRlbGltaXRlcnMyWzFdLAogICAgICByaWdodENvbG9yOiB2b2lkIDAKICAgICAgLy8gXHJpZ2h0IHVuaW5mbHVlbmNlZCBieSBcY29sb3IgaW4gYXJyYXkKICAgIH0gOiByZXM7CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNiwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDUKfSk7CmRlZmluZUVudmlyb25tZW50KHsKICB0eXBlOiAiYXJyYXkiLAogIG5hbWVzOiBbInNtYWxsbWF0cml4Il0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAKICB9LAogIGhhbmRsZXIoY29udGV4dCkgewogICAgdmFyIHBheWxvYWQgPSB7CiAgICAgIGFycmF5c3RyZXRjaDogMC41CiAgICB9OwogICAgdmFyIHJlcyA9IHBhcnNlQXJyYXkoY29udGV4dC5wYXJzZXIsIHBheWxvYWQsICJzY3JpcHQiKTsKICAgIHJlcy5jb2xTZXBhcmF0aW9uVHlwZSA9ICJzbWFsbCI7CiAgICByZXR1cm4gcmVzOwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1Cn0pOwpkZWZpbmVFbnZpcm9ubWVudCh7CiAgdHlwZTogImFycmF5IiwKICBuYW1lczogWyJzdWJhcnJheSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxCiAgfSwKICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHsKICAgIHZhciBzeW1Ob2RlID0gY2hlY2tTeW1ib2xOb2RlVHlwZShhcmdzWzBdKTsKICAgIHZhciBjb2xhbGlnbiA9IHN5bU5vZGUgPyBbYXJnc1swXV0gOiBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCAib3JkZ3JvdXAiKS5ib2R5OwogICAgdmFyIGNvbHMgPSBjb2xhbGlnbi5tYXAoZnVuY3Rpb24obmRlKSB7CiAgICAgIHZhciBub2RlID0gYXNzZXJ0U3ltYm9sTm9kZVR5cGUobmRlKTsKICAgICAgdmFyIGNhID0gbm9kZS50ZXh0OwogICAgICBpZiAoImxjIi5pbmRleE9mKGNhKSAhPT0gLTEpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogImFsaWduIiwKICAgICAgICAgIGFsaWduOiBjYQogICAgICAgIH07CiAgICAgIH0KICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVua25vd24gY29sdW1uIGFsaWdubWVudDogIiArIGNhLCBuZGUpOwogICAgfSk7CiAgICBpZiAoY29scy5sZW5ndGggPiAxKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtbiIpOwogICAgfQogICAgdmFyIHJlcyA9IHsKICAgICAgY29scywKICAgICAgaHNraXBCZWZvcmVBbmRBZnRlcjogZmFsc2UsCiAgICAgIGFycmF5c3RyZXRjaDogMC41CiAgICB9OwogICAgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCAic2NyaXB0Iik7CiAgICBpZiAocmVzLmJvZHkubGVuZ3RoID4gMCAmJiByZXMuYm9keVswXS5sZW5ndGggPiAxKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJ7c3ViYXJyYXl9IGNhbiBjb250YWluIG9ubHkgb25lIGNvbHVtbiIpOwogICAgfQogICAgcmV0dXJuIHJlczsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ2LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNQp9KTsKZGVmaW5lRW52aXJvbm1lbnQoewogIHR5cGU6ICJhcnJheSIsCiAgbmFtZXM6IFsiY2FzZXMiLCAiZGNhc2VzIiwgInJjYXNlcyIsICJkcmNhc2VzIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAKICB9LAogIGhhbmRsZXIoY29udGV4dCkgewogICAgdmFyIHBheWxvYWQgPSB7CiAgICAgIGFycmF5c3RyZXRjaDogMS4yLAogICAgICBjb2xzOiBbewogICAgICAgIHR5cGU6ICJhbGlnbiIsCiAgICAgICAgYWxpZ246ICJsIiwKICAgICAgICBwcmVnYXA6IDAsCiAgICAgICAgLy8gVE9ETyhrZXZpbmIpIGdldCB0aGUgY3VycmVudCBzdHlsZS4KICAgICAgICAvLyBGb3Igbm93IHdlIHVzZSB0aGUgbWV0cmljcyBmb3IgVEVYVCBzdHlsZSB3aGljaCBpcyB3aGF0IHdlIHdlcmUKICAgICAgICAvLyBkb2luZyBiZWZvcmUuICBCZWZvcmUgYXR0ZW1wdGluZyB0byBnZXQgdGhlIGN1cnJlbnQgc3R5bGUgd2UKICAgICAgICAvLyBzaG91bGQgbG9vayBhdCBUZVgncyBiZWhhdmlvciBlc3BlY2lhbGx5IGZvciBcb3ZlciBhbmQgbWF0cmljZXMuCiAgICAgICAgcG9zdGdhcDogMQogICAgICAgIC8qIDFlbSBxdWFkICovCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAiYWxpZ24iLAogICAgICAgIGFsaWduOiAibCIsCiAgICAgICAgcHJlZ2FwOiAwLAogICAgICAgIHBvc3RnYXA6IDAKICAgICAgfV0KICAgIH07CiAgICB2YXIgcmVzID0gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcGF5bG9hZCwgZENlbGxTdHlsZShjb250ZXh0LmVudk5hbWUpKTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJsZWZ0cmlnaHQiLAogICAgICBtb2RlOiBjb250ZXh0Lm1vZGUsCiAgICAgIGJvZHk6IFtyZXNdLAogICAgICBsZWZ0OiBjb250ZXh0LmVudk5hbWUuaW5kZXhPZigiciIpID4gLTEgPyAiLiIgOiAiXFx7IiwKICAgICAgcmlnaHQ6IGNvbnRleHQuZW52TmFtZS5pbmRleE9mKCJyIikgPiAtMSA/ICJcXH0iIDogIi4iLAogICAgICByaWdodENvbG9yOiB2b2lkIDAKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNiwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDUKfSk7CmRlZmluZUVudmlyb25tZW50KHsKICB0eXBlOiAiYXJyYXkiLAogIG5hbWVzOiBbImFsaWduIiwgImFsaWduKiIsICJhbGlnbmVkIiwgInNwbGl0Il0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAKICB9LAogIGhhbmRsZXI6IGFsaWduZWRIYW5kbGVyLAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ2LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNQp9KTsKZGVmaW5lRW52aXJvbm1lbnQoewogIHR5cGU6ICJhcnJheSIsCiAgbmFtZXM6IFsiZ2F0aGVyZWQiLCAiZ2F0aGVyIiwgImdhdGhlcioiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMAogIH0sCiAgaGFuZGxlcihjb250ZXh0KSB7CiAgICBpZiAodXRpbHMuY29udGFpbnMoWyJnYXRoZXIiLCAiZ2F0aGVyKiJdLCBjb250ZXh0LmVudk5hbWUpKSB7CiAgICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpOwogICAgfQogICAgdmFyIHJlcyA9IHsKICAgICAgY29sczogW3sKICAgICAgICB0eXBlOiAiYWxpZ24iLAogICAgICAgIGFsaWduOiAiYyIKICAgICAgfV0sCiAgICAgIGFkZEpvdDogdHJ1ZSwKICAgICAgY29sU2VwYXJhdGlvblR5cGU6ICJnYXRoZXIiLAogICAgICBhdXRvVGFnOiBnZXRBdXRvVGFnKGNvbnRleHQuZW52TmFtZSksCiAgICAgIGVtcHR5U2luZ2xlUm93OiB0cnVlLAogICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm8KICAgIH07CiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCAiZGlzcGxheSIpOwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1Cn0pOwpkZWZpbmVFbnZpcm9ubWVudCh7CiAgdHlwZTogImFycmF5IiwKICBuYW1lczogWyJhbGlnbmF0IiwgImFsaWduYXQqIiwgImFsaWduZWRhdCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxCiAgfSwKICBoYW5kbGVyOiBhbGlnbmVkSGFuZGxlciwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNiwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDUKfSk7CmRlZmluZUVudmlyb25tZW50KHsKICB0eXBlOiAiYXJyYXkiLAogIG5hbWVzOiBbImVxdWF0aW9uIiwgImVxdWF0aW9uKiJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyKGNvbnRleHQpIHsKICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpOwogICAgdmFyIHJlcyA9IHsKICAgICAgYXV0b1RhZzogZ2V0QXV0b1RhZyhjb250ZXh0LmVudk5hbWUpLAogICAgICBlbXB0eVNpbmdsZVJvdzogdHJ1ZSwKICAgICAgc2luZ2xlUm93OiB0cnVlLAogICAgICBtYXhOdW1Db2xzOiAxLAogICAgICBsZXFubzogY29udGV4dC5wYXJzZXIuc2V0dGluZ3MubGVxbm8KICAgIH07CiAgICByZXR1cm4gcGFyc2VBcnJheShjb250ZXh0LnBhcnNlciwgcmVzLCAiZGlzcGxheSIpOwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1Cn0pOwpkZWZpbmVFbnZpcm9ubWVudCh7CiAgdHlwZTogImFycmF5IiwKICBuYW1lczogWyJDRCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyKGNvbnRleHQpIHsKICAgIHZhbGlkYXRlQW1zRW52aXJvbm1lbnRDb250ZXh0KGNvbnRleHQpOwogICAgcmV0dXJuIHBhcnNlQ0QoY29udGV4dC5wYXJzZXIpOwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDYsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQ1Cn0pOwpkZWZpbmVNYWNybygiXFxub251bWJlciIsICJcXGdkZWZcXEBlcW5zd3swfSIpOwpkZWZpbmVNYWNybygiXFxub3RhZyIsICJcXG5vbnVtYmVyIik7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAidGV4dCIsCiAgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGlzIGlzLgogIG5hbWVzOiBbIlxcaGxpbmUiLCAiXFxoZGFzaGxpbmUiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMCwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlCiAgfSwKICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHsKICAgIHRocm93IG5ldyBQYXJzZUVycm9yKGNvbnRleHQuZnVuY05hbWUgKyAiIHZhbGlkIG9ubHkgd2l0aGluIGFycmF5IGVudmlyb25tZW50Iik7CiAgfQp9KTsKdmFyIGVudmlyb25tZW50cyA9IF9lbnZpcm9ubWVudHM7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiZW52aXJvbm1lbnQiLAogIG5hbWVzOiBbIlxcYmVnaW4iLCAiXFxlbmQiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIGFyZ1R5cGVzOiBbInRleHQiXQogIH0sCiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjsKICAgIHZhciBuYW1lR3JvdXAgPSBhcmdzWzBdOwogICAgaWYgKG5hbWVHcm91cC50eXBlICE9PSAib3JkZ3JvdXAiKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIGVudmlyb25tZW50IG5hbWUiLCBuYW1lR3JvdXApOwogICAgfQogICAgdmFyIGVudk5hbWUgPSAiIjsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZUdyb3VwLmJvZHkubGVuZ3RoOyArK2kpIHsKICAgICAgZW52TmFtZSArPSBhc3NlcnROb2RlVHlwZShuYW1lR3JvdXAuYm9keVtpXSwgInRleHRvcmQiKS50ZXh0OwogICAgfQogICAgaWYgKGZ1bmNOYW1lID09PSAiXFxiZWdpbiIpIHsKICAgICAgaWYgKCFlbnZpcm9ubWVudHMuaGFzT3duUHJvcGVydHkoZW52TmFtZSkpIHsKICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiTm8gc3VjaCBlbnZpcm9ubWVudDogIiArIGVudk5hbWUsIG5hbWVHcm91cCk7CiAgICAgIH0KICAgICAgdmFyIGVudiA9IGVudmlyb25tZW50c1tlbnZOYW1lXTsKICAgICAgdmFyIHsKICAgICAgICBhcmdzOiBfYXJncywKICAgICAgICBvcHRBcmdzCiAgICAgIH0gPSBwYXJzZXIucGFyc2VBcmd1bWVudHMoIlxcYmVnaW57IiArIGVudk5hbWUgKyAifSIsIGVudik7CiAgICAgIHZhciBjb250ZXh0ID0gewogICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICAgIGVudk5hbWUsCiAgICAgICAgcGFyc2VyCiAgICAgIH07CiAgICAgIHZhciByZXN1bHQgPSBlbnYuaGFuZGxlcihjb250ZXh0LCBfYXJncywgb3B0QXJncyk7CiAgICAgIHBhcnNlci5leHBlY3QoIlxcZW5kIiwgZmFsc2UpOwogICAgICB2YXIgZW5kTmFtZVRva2VuID0gcGFyc2VyLm5leHRUb2tlbjsKICAgICAgdmFyIGVuZCA9IGFzc2VydE5vZGVUeXBlKHBhcnNlci5wYXJzZUZ1bmN0aW9uKCksICJlbnZpcm9ubWVudCIpOwogICAgICBpZiAoZW5kLm5hbWUgIT09IGVudk5hbWUpIHsKICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiTWlzbWF0Y2g6IFxcYmVnaW57IiArIGVudk5hbWUgKyAifSBtYXRjaGVkIGJ5IFxcZW5keyIgKyBlbmQubmFtZSArICJ9IiwgZW5kTmFtZVRva2VuKTsKICAgICAgfQogICAgICByZXR1cm4gcmVzdWx0OwogICAgfQogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImVudmlyb25tZW50IiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIG5hbWU6IGVudk5hbWUsCiAgICAgIG5hbWVHcm91cAogICAgfTsKICB9Cn0pOwp2YXIgaHRtbEJ1aWxkZXIkNSA9IChncm91cCwgb3B0aW9ucykgPT4gewogIHZhciBmb250ID0gZ3JvdXAuZm9udDsKICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7CiAgcmV0dXJuIGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBuZXdPcHRpb25zKTsKfTsKdmFyIG1hdGhtbEJ1aWxkZXIkNCA9IChncm91cCwgb3B0aW9ucykgPT4gewogIHZhciBmb250ID0gZ3JvdXAuZm9udDsKICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMud2l0aEZvbnQoZm9udCk7CiAgcmV0dXJuIGJ1aWxkR3JvdXAyKGdyb3VwLmJvZHksIG5ld09wdGlvbnMpOwp9Owp2YXIgZm9udEFsaWFzZXMgPSB7CiAgIlxcQmJiIjogIlxcbWF0aGJiIiwKICAiXFxib2xkIjogIlxcbWF0aGJmIiwKICAiXFxmcmFrIjogIlxcbWF0aGZyYWsiLAogICJcXGJtIjogIlxcYm9sZHN5bWJvbCIKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJmb250IiwKICBuYW1lczogWwogICAgLy8gc3R5bGVzLCBleGNlcHQgXGJvbGRzeW1ib2wgZGVmaW5lZCBiZWxvdwogICAgIlxcbWF0aHJtIiwKICAgICJcXG1hdGhpdCIsCiAgICAiXFxtYXRoYmYiLAogICAgIlxcbWF0aG5vcm1hbCIsCiAgICAiXFxtYXRoc2ZpdCIsCiAgICAvLyBmYW1pbGllcwogICAgIlxcbWF0aGJiIiwKICAgICJcXG1hdGhjYWwiLAogICAgIlxcbWF0aGZyYWsiLAogICAgIlxcbWF0aHNjciIsCiAgICAiXFxtYXRoc2YiLAogICAgIlxcbWF0aHR0IiwKICAgIC8vIGFsaWFzZXMsIGV4Y2VwdCBcYm0gZGVmaW5lZCBiZWxvdwogICAgIlxcQmJiIiwKICAgICJcXGJvbGQiLAogICAgIlxcZnJhayIKICBdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYWxsb3dlZEluQXJndW1lbnQ6IHRydWUKICB9LAogIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjsKICAgIHZhciBib2R5ID0gbm9ybWFsaXplQXJndW1lbnQoYXJnc1swXSk7CiAgICB2YXIgZnVuYyA9IGZ1bmNOYW1lOwogICAgaWYgKGZ1bmMgaW4gZm9udEFsaWFzZXMpIHsKICAgICAgZnVuYyA9IGZvbnRBbGlhc2VzW2Z1bmNdOwogICAgfQogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImZvbnQiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgZm9udDogZnVuYy5zbGljZSgxKSwKICAgICAgYm9keQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ1LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNAp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJtY2xhc3MiLAogIG5hbWVzOiBbIlxcYm9sZHN5bWJvbCIsICJcXGJtIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEKICB9LAogIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4gewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjI7CiAgICB2YXIgYm9keSA9IGFyZ3NbMF07CiAgICB2YXIgaXNDaGFyYWN0ZXJCb3gzID0gdXRpbHMuaXNDaGFyYWN0ZXJCb3goYm9keSk7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAibWNsYXNzIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIG1jbGFzczogYmlucmVsQ2xhc3MoYm9keSksCiAgICAgIGJvZHk6IFt7CiAgICAgICAgdHlwZTogImZvbnQiLAogICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICAgIGZvbnQ6ICJib2xkc3ltYm9sIiwKICAgICAgICBib2R5CiAgICAgIH1dLAogICAgICBpc0NoYXJhY3RlckJveDogaXNDaGFyYWN0ZXJCb3gzCiAgICB9OwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiZm9udCIsCiAgbmFtZXM6IFsiXFxybSIsICJcXHNmIiwgIlxcdHQiLCAiXFxiZiIsICJcXGl0IiwgIlxcY2FsIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyOiAoX3JlZjMsIGFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUsCiAgICAgIGJyZWFrT25Ub2tlblRleHQKICAgIH0gPSBfcmVmMzsKICAgIHZhciB7CiAgICAgIG1vZGUKICAgIH0gPSBwYXJzZXI7CiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24odHJ1ZSwgYnJlYWtPblRva2VuVGV4dCk7CiAgICB2YXIgc3R5bGUgPSAibWF0aCIgKyBmdW5jTmFtZS5zbGljZSgxKTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJmb250IiwKICAgICAgbW9kZSwKICAgICAgZm9udDogc3R5bGUsCiAgICAgIGJvZHk6IHsKICAgICAgICB0eXBlOiAib3JkZ3JvdXAiLAogICAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICAgIGJvZHkKICAgICAgfQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ1LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkNAp9KTsKdmFyIGFkanVzdFN0eWxlID0gKHNpemUsIG9yaWdpbmFsU3R5bGUpID0+IHsKICB2YXIgc3R5bGUgPSBvcmlnaW5hbFN0eWxlOwogIGlmIChzaXplID09PSAiZGlzcGxheSIpIHsKICAgIHN0eWxlID0gc3R5bGUuaWQgPj0gU3R5bGUkMS5TQ1JJUFQuaWQgPyBzdHlsZS50ZXh0KCkgOiBTdHlsZSQxLkRJU1BMQVk7CiAgfSBlbHNlIGlmIChzaXplID09PSAidGV4dCIgJiYgc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUpIHsKICAgIHN0eWxlID0gU3R5bGUkMS5URVhUOwogIH0gZWxzZSBpZiAoc2l6ZSA9PT0gInNjcmlwdCIpIHsKICAgIHN0eWxlID0gU3R5bGUkMS5TQ1JJUFQ7CiAgfSBlbHNlIGlmIChzaXplID09PSAic2NyaXB0c2NyaXB0IikgewogICAgc3R5bGUgPSBTdHlsZSQxLlNDUklQVFNDUklQVDsKICB9CiAgcmV0dXJuIHN0eWxlOwp9Owp2YXIgaHRtbEJ1aWxkZXIkNCA9IChncm91cCwgb3B0aW9ucykgPT4gewogIHZhciBzdHlsZSA9IGFkanVzdFN0eWxlKGdyb3VwLnNpemUsIG9wdGlvbnMuc3R5bGUpOwogIHZhciBuc3R5bGUgPSBzdHlsZS5mcmFjTnVtKCk7CiAgdmFyIGRzdHlsZSA9IHN0eWxlLmZyYWNEZW4oKTsKICB2YXIgbmV3T3B0aW9uczsKICBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuc3R5bGUpOwogIHZhciBudW1lcm0gPSBidWlsZEdyb3VwJDEoZ3JvdXAubnVtZXIsIG5ld09wdGlvbnMsIG9wdGlvbnMpOwogIGlmIChncm91cC5jb250aW51ZWQpIHsKICAgIHZhciBoU3RydXQgPSA4LjUgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTsKICAgIHZhciBkU3RydXQgPSAzLjUgLyBvcHRpb25zLmZvbnRNZXRyaWNzKCkucHRQZXJFbTsKICAgIG51bWVybS5oZWlnaHQgPSBudW1lcm0uaGVpZ2h0IDwgaFN0cnV0ID8gaFN0cnV0IDogbnVtZXJtLmhlaWdodDsKICAgIG51bWVybS5kZXB0aCA9IG51bWVybS5kZXB0aCA8IGRTdHJ1dCA/IGRTdHJ1dCA6IG51bWVybS5kZXB0aDsKICB9CiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoZHN0eWxlKTsKICB2YXIgZGVub21tID0gYnVpbGRHcm91cCQxKGdyb3VwLmRlbm9tLCBuZXdPcHRpb25zLCBvcHRpb25zKTsKICB2YXIgcnVsZTsKICB2YXIgcnVsZVdpZHRoOwogIHZhciBydWxlU3BhY2luZzsKICBpZiAoZ3JvdXAuaGFzQmFyTGluZSkgewogICAgaWYgKGdyb3VwLmJhclNpemUpIHsKICAgICAgcnVsZVdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC5iYXJTaXplLCBvcHRpb25zKTsKICAgICAgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VMaW5lU3BhbigiZnJhYy1saW5lIiwgb3B0aW9ucywgcnVsZVdpZHRoKTsKICAgIH0gZWxzZSB7CiAgICAgIHJ1bGUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oImZyYWMtbGluZSIsIG9wdGlvbnMpOwogICAgfQogICAgcnVsZVdpZHRoID0gcnVsZS5oZWlnaHQ7CiAgICBydWxlU3BhY2luZyA9IHJ1bGUuaGVpZ2h0OwogIH0gZWxzZSB7CiAgICBydWxlID0gbnVsbDsKICAgIHJ1bGVXaWR0aCA9IDA7CiAgICBydWxlU3BhY2luZyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWZhdWx0UnVsZVRoaWNrbmVzczsKICB9CiAgdmFyIG51bVNoaWZ0OwogIHZhciBjbGVhcmFuY2U7CiAgdmFyIGRlbm9tU2hpZnQ7CiAgaWYgKHN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplIHx8IGdyb3VwLnNpemUgPT09ICJkaXNwbGF5IikgewogICAgbnVtU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkubnVtMTsKICAgIGlmIChydWxlV2lkdGggPiAwKSB7CiAgICAgIGNsZWFyYW5jZSA9IDMgKiBydWxlU3BhY2luZzsKICAgIH0gZWxzZSB7CiAgICAgIGNsZWFyYW5jZSA9IDcgKiBydWxlU3BhY2luZzsKICAgIH0KICAgIGRlbm9tU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVub20xOwogIH0gZWxzZSB7CiAgICBpZiAocnVsZVdpZHRoID4gMCkgewogICAgICBudW1TaGlmdCA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5udW0yOwogICAgICBjbGVhcmFuY2UgPSBydWxlU3BhY2luZzsKICAgIH0gZWxzZSB7CiAgICAgIG51bVNoaWZ0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLm51bTM7CiAgICAgIGNsZWFyYW5jZSA9IDMgKiBydWxlU3BhY2luZzsKICAgIH0KICAgIGRlbm9tU2hpZnQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVub20yOwogIH0KICB2YXIgZnJhYzsKICBpZiAoIXJ1bGUpIHsKICAgIHZhciBjYW5kaWRhdGVDbGVhcmFuY2UgPSBudW1TaGlmdCAtIG51bWVybS5kZXB0aCAtIChkZW5vbW0uaGVpZ2h0IC0gZGVub21TaGlmdCk7CiAgICBpZiAoY2FuZGlkYXRlQ2xlYXJhbmNlIDwgY2xlYXJhbmNlKSB7CiAgICAgIG51bVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpOwogICAgICBkZW5vbVNoaWZ0ICs9IDAuNSAqIChjbGVhcmFuY2UgLSBjYW5kaWRhdGVDbGVhcmFuY2UpOwogICAgfQogICAgZnJhYyA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImluZGl2aWR1YWxTaGlmdCIsCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBkZW5vbW0sCiAgICAgICAgc2hpZnQ6IGRlbm9tU2hpZnQKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBudW1lcm0sCiAgICAgICAgc2hpZnQ6IC1udW1TaGlmdAogICAgICB9XQogICAgfSwgb3B0aW9ucyk7CiAgfSBlbHNlIHsKICAgIHZhciBheGlzSGVpZ2h0ID0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7CiAgICBpZiAobnVtU2hpZnQgLSBudW1lcm0uZGVwdGggLSAoYXhpc0hlaWdodCArIDAuNSAqIHJ1bGVXaWR0aCkgPCBjbGVhcmFuY2UpIHsKICAgICAgbnVtU2hpZnQgKz0gY2xlYXJhbmNlIC0gKG51bVNoaWZ0IC0gbnVtZXJtLmRlcHRoIC0gKGF4aXNIZWlnaHQgKyAwLjUgKiBydWxlV2lkdGgpKTsKICAgIH0KICAgIGlmIChheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KSA8IGNsZWFyYW5jZSkgewogICAgICBkZW5vbVNoaWZ0ICs9IGNsZWFyYW5jZSAtIChheGlzSGVpZ2h0IC0gMC41ICogcnVsZVdpZHRoIC0gKGRlbm9tbS5oZWlnaHQgLSBkZW5vbVNoaWZ0KSk7CiAgICB9CiAgICB2YXIgbWlkU2hpZnQgPSAtKGF4aXNIZWlnaHQgLSAwLjUgKiBydWxlV2lkdGgpOwogICAgZnJhYyA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImluZGl2aWR1YWxTaGlmdCIsCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBkZW5vbW0sCiAgICAgICAgc2hpZnQ6IGRlbm9tU2hpZnQKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBydWxlLAogICAgICAgIHNoaWZ0OiBtaWRTaGlmdAogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IG51bWVybSwKICAgICAgICBzaGlmdDogLW51bVNoaWZ0CiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICB9CiAgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUpOwogIGZyYWMuaGVpZ2h0ICo9IG5ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyOwogIGZyYWMuZGVwdGggKj0gbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgdmFyIGRlbGltU2l6ZTsKICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUpIHsKICAgIGRlbGltU2l6ZSA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5kZWxpbTE7CiAgfSBlbHNlIGlmIChzdHlsZS5zaXplID09PSBTdHlsZSQxLlNDUklQVFNDUklQVC5zaXplKSB7CiAgICBkZWxpbVNpemUgPSBvcHRpb25zLmhhdmluZ1N0eWxlKFN0eWxlJDEuU0NSSVBUKS5mb250TWV0cmljcygpLmRlbGltMjsKICB9IGVsc2UgewogICAgZGVsaW1TaXplID0gb3B0aW9ucy5mb250TWV0cmljcygpLmRlbGltMjsKICB9CiAgdmFyIGxlZnREZWxpbTsKICB2YXIgcmlnaHREZWxpbTsKICBpZiAoZ3JvdXAubGVmdERlbGltID09IG51bGwpIHsKICAgIGxlZnREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFsibW9wZW4iXSk7CiAgfSBlbHNlIHsKICAgIGxlZnREZWxpbSA9IGRlbGltaXRlci5jdXN0b21TaXplZERlbGltKGdyb3VwLmxlZnREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgWyJtb3BlbiJdKTsKICB9CiAgaWYgKGdyb3VwLmNvbnRpbnVlZCkgewogICAgcmlnaHREZWxpbSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdKTsKICB9IGVsc2UgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gPT0gbnVsbCkgewogICAgcmlnaHREZWxpbSA9IG1ha2VOdWxsRGVsaW1pdGVyKG9wdGlvbnMsIFsibWNsb3NlIl0pOwogIH0gZWxzZSB7CiAgICByaWdodERlbGltID0gZGVsaW1pdGVyLmN1c3RvbVNpemVkRGVsaW0oZ3JvdXAucmlnaHREZWxpbSwgZGVsaW1TaXplLCB0cnVlLCBvcHRpb25zLmhhdmluZ1N0eWxlKHN0eWxlKSwgZ3JvdXAubW9kZSwgWyJtY2xvc2UiXSk7CiAgfQogIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiXS5jb25jYXQobmV3T3B0aW9ucy5zaXppbmdDbGFzc2VzKG9wdGlvbnMpKSwgW2xlZnREZWxpbSwgYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtZnJhYyJdLCBbZnJhY10pLCByaWdodERlbGltXSwgb3B0aW9ucyk7Cn07CnZhciBtYXRobWxCdWlsZGVyJDMgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtZnJhYyIsIFtidWlsZEdyb3VwMihncm91cC5udW1lciwgb3B0aW9ucyksIGJ1aWxkR3JvdXAyKGdyb3VwLmRlbm9tLCBvcHRpb25zKV0pOwogIGlmICghZ3JvdXAuaGFzQmFyTGluZSkgewogICAgbm9kZS5zZXRBdHRyaWJ1dGUoImxpbmV0aGlja25lc3MiLCAiMHB4Iik7CiAgfSBlbHNlIGlmIChncm91cC5iYXJTaXplKSB7CiAgICB2YXIgcnVsZVdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC5iYXJTaXplLCBvcHRpb25zKTsKICAgIG5vZGUuc2V0QXR0cmlidXRlKCJsaW5ldGhpY2tuZXNzIiwgbWFrZUVtKHJ1bGVXaWR0aCkpOwogIH0KICB2YXIgc3R5bGUgPSBhZGp1c3RTdHlsZShncm91cC5zaXplLCBvcHRpb25zLnN0eWxlKTsKICBpZiAoc3R5bGUuc2l6ZSAhPT0gb3B0aW9ucy5zdHlsZS5zaXplKSB7CiAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1zdHlsZSIsIFtub2RlXSk7CiAgICB2YXIgaXNEaXNwbGF5ID0gc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUgPyAidHJ1ZSIgOiAiZmFsc2UiOwogICAgbm9kZS5zZXRBdHRyaWJ1dGUoImRpc3BsYXlzdHlsZSIsIGlzRGlzcGxheSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgic2NyaXB0bGV2ZWwiLCAiMCIpOwogIH0KICBpZiAoZ3JvdXAubGVmdERlbGltICE9IG51bGwgfHwgZ3JvdXAucmlnaHREZWxpbSAhPSBudWxsKSB7CiAgICB2YXIgd2l0aERlbGltcyA9IFtdOwogICAgaWYgKGdyb3VwLmxlZnREZWxpbSAhPSBudWxsKSB7CiAgICAgIHZhciBsZWZ0T3AgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibW8iLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoZ3JvdXAubGVmdERlbGltLnJlcGxhY2UoIlxcIiwgIiIpKV0pOwogICAgICBsZWZ0T3Auc2V0QXR0cmlidXRlKCJmZW5jZSIsICJ0cnVlIik7CiAgICAgIHdpdGhEZWxpbXMucHVzaChsZWZ0T3ApOwogICAgfQogICAgd2l0aERlbGltcy5wdXNoKG5vZGUpOwogICAgaWYgKGdyb3VwLnJpZ2h0RGVsaW0gIT0gbnVsbCkgewogICAgICB2YXIgcmlnaHRPcCA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtbyIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZShncm91cC5yaWdodERlbGltLnJlcGxhY2UoIlxcIiwgIiIpKV0pOwogICAgICByaWdodE9wLnNldEF0dHJpYnV0ZSgiZmVuY2UiLCAidHJ1ZSIpOwogICAgICB3aXRoRGVsaW1zLnB1c2gocmlnaHRPcCk7CiAgICB9CiAgICByZXR1cm4gbWFrZVJvdyh3aXRoRGVsaW1zKTsKICB9CiAgcmV0dXJuIG5vZGU7Cn07CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiZ2VuZnJhYyIsCiAgbmFtZXM6IFsKICAgICJcXGRmcmFjIiwKICAgICJcXGZyYWMiLAogICAgIlxcdGZyYWMiLAogICAgIlxcZGJpbm9tIiwKICAgICJcXGJpbm9tIiwKICAgICJcXHRiaW5vbSIsCiAgICAiXFxcXGF0b3BmcmFjIiwKICAgIC8vIGNhbuKAmXQgYmUgZW50ZXJlZCBkaXJlY3RseQogICAgIlxcXFxicmFjZWZyYWMiLAogICAgIlxcXFxicmFja2ZyYWMiCiAgICAvLyBkaXR0bwogIF0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDIsCiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmOwogICAgdmFyIG51bWVyID0gYXJnc1swXTsKICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07CiAgICB2YXIgaGFzQmFyTGluZTsKICAgIHZhciBsZWZ0RGVsaW0gPSBudWxsOwogICAgdmFyIHJpZ2h0RGVsaW0gPSBudWxsOwogICAgdmFyIHNpemUgPSAiYXV0byI7CiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7CiAgICAgIGNhc2UgIlxcZGZyYWMiOgogICAgICBjYXNlICJcXGZyYWMiOgogICAgICBjYXNlICJcXHRmcmFjIjoKICAgICAgICBoYXNCYXJMaW5lID0gdHJ1ZTsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiXFxcXGF0b3BmcmFjIjoKICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcZGJpbm9tIjoKICAgICAgY2FzZSAiXFxiaW5vbSI6CiAgICAgIGNhc2UgIlxcdGJpbm9tIjoKICAgICAgICBoYXNCYXJMaW5lID0gZmFsc2U7CiAgICAgICAgbGVmdERlbGltID0gIigiOwogICAgICAgIHJpZ2h0RGVsaW0gPSAiKSI7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcXFxicmFjZWZyYWMiOgogICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTsKICAgICAgICBsZWZ0RGVsaW0gPSAiXFx7IjsKICAgICAgICByaWdodERlbGltID0gIlxcfSI7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcXFxicmFja2ZyYWMiOgogICAgICAgIGhhc0JhckxpbmUgPSBmYWxzZTsKICAgICAgICBsZWZ0RGVsaW0gPSAiWyI7CiAgICAgICAgcmlnaHREZWxpbSA9ICJdIjsKICAgICAgICBicmVhazsKICAgICAgZGVmYXVsdDoKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoIlVucmVjb2duaXplZCBnZW5mcmFjIGNvbW1hbmQiKTsKICAgIH0KICAgIHN3aXRjaCAoZnVuY05hbWUpIHsKICAgICAgY2FzZSAiXFxkZnJhYyI6CiAgICAgIGNhc2UgIlxcZGJpbm9tIjoKICAgICAgICBzaXplID0gImRpc3BsYXkiOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJcXHRmcmFjIjoKICAgICAgY2FzZSAiXFx0Ymlub20iOgogICAgICAgIHNpemUgPSAidGV4dCI7CiAgICAgICAgYnJlYWs7CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiZ2VuZnJhYyIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBjb250aW51ZWQ6IGZhbHNlLAogICAgICBudW1lciwKICAgICAgZGVub20sCiAgICAgIGhhc0JhckxpbmUsCiAgICAgIGxlZnREZWxpbSwKICAgICAgcmlnaHREZWxpbSwKICAgICAgc2l6ZSwKICAgICAgYmFyU2l6ZTogbnVsbAogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ0LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMwp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJnZW5mcmFjIiwKICBuYW1lczogWyJcXGNmcmFjIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDIKICB9LAogIGhhbmRsZXI6IChfcmVmMiwgYXJncykgPT4gewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWYyOwogICAgdmFyIG51bWVyID0gYXJnc1swXTsKICAgIHZhciBkZW5vbSA9IGFyZ3NbMV07CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiZ2VuZnJhYyIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBjb250aW51ZWQ6IHRydWUsCiAgICAgIG51bWVyLAogICAgICBkZW5vbSwKICAgICAgaGFzQmFyTGluZTogdHJ1ZSwKICAgICAgbGVmdERlbGltOiBudWxsLAogICAgICByaWdodERlbGltOiBudWxsLAogICAgICBzaXplOiAiZGlzcGxheSIsCiAgICAgIGJhclNpemU6IG51bGwKICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJpbmZpeCIsCiAgbmFtZXM6IFsiXFxvdmVyIiwgIlxcY2hvb3NlIiwgIlxcYXRvcCIsICJcXGJyYWNlIiwgIlxcYnJhY2siXSwKICBwcm9wczogewogICAgbnVtQXJnczogMCwKICAgIGluZml4OiB0cnVlCiAgfSwKICBoYW5kbGVyKF9yZWYzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lLAogICAgICB0b2tlbgogICAgfSA9IF9yZWYzOwogICAgdmFyIHJlcGxhY2VXaXRoOwogICAgc3dpdGNoIChmdW5jTmFtZSkgewogICAgICBjYXNlICJcXG92ZXIiOgogICAgICAgIHJlcGxhY2VXaXRoID0gIlxcZnJhYyI7CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcY2hvb3NlIjoKICAgICAgICByZXBsYWNlV2l0aCA9ICJcXGJpbm9tIjsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiXFxhdG9wIjoKICAgICAgICByZXBsYWNlV2l0aCA9ICJcXFxcYXRvcGZyYWMiOwogICAgICAgIGJyZWFrOwogICAgICBjYXNlICJcXGJyYWNlIjoKICAgICAgICByZXBsYWNlV2l0aCA9ICJcXFxcYnJhY2VmcmFjIjsKICAgICAgICBicmVhazsKICAgICAgY2FzZSAiXFxicmFjayI6CiAgICAgICAgcmVwbGFjZVdpdGggPSAiXFxcXGJyYWNrZnJhYyI7CiAgICAgICAgYnJlYWs7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJVbnJlY29nbml6ZWQgaW5maXggZ2VuZnJhYyBjb21tYW5kIik7CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiaW5maXgiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgcmVwbGFjZVdpdGgsCiAgICAgIHRva2VuCiAgICB9OwogIH0KfSk7CnZhciBzdHlsQXJyYXkgPSBbImRpc3BsYXkiLCAidGV4dCIsICJzY3JpcHQiLCAic2NyaXB0c2NyaXB0Il07CnZhciBkZWxpbUZyb21WYWx1ZSA9IGZ1bmN0aW9uIGRlbGltRnJvbVZhbHVlMihkZWxpbVN0cmluZykgewogIHZhciBkZWxpbSA9IG51bGw7CiAgaWYgKGRlbGltU3RyaW5nLmxlbmd0aCA+IDApIHsKICAgIGRlbGltID0gZGVsaW1TdHJpbmc7CiAgICBkZWxpbSA9IGRlbGltID09PSAiLiIgPyBudWxsIDogZGVsaW07CiAgfQogIHJldHVybiBkZWxpbTsKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJnZW5mcmFjIiwKICBuYW1lczogWyJcXGdlbmZyYWMiXSwKICBwcm9wczogewogICAgbnVtQXJnczogNiwKICAgIGFsbG93ZWRJbkFyZ3VtZW50OiB0cnVlLAogICAgYXJnVHlwZXM6IFsibWF0aCIsICJtYXRoIiwgInNpemUiLCAidGV4dCIsICJtYXRoIiwgIm1hdGgiXQogIH0sCiAgaGFuZGxlcihfcmVmNCwgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjQ7CiAgICB2YXIgbnVtZXIgPSBhcmdzWzRdOwogICAgdmFyIGRlbm9tID0gYXJnc1s1XTsKICAgIHZhciBsZWZ0Tm9kZSA9IG5vcm1hbGl6ZUFyZ3VtZW50KGFyZ3NbMF0pOwogICAgdmFyIGxlZnREZWxpbSA9IGxlZnROb2RlLnR5cGUgPT09ICJhdG9tIiAmJiBsZWZ0Tm9kZS5mYW1pbHkgPT09ICJvcGVuIiA/IGRlbGltRnJvbVZhbHVlKGxlZnROb2RlLnRleHQpIDogbnVsbDsKICAgIHZhciByaWdodE5vZGUgPSBub3JtYWxpemVBcmd1bWVudChhcmdzWzFdKTsKICAgIHZhciByaWdodERlbGltID0gcmlnaHROb2RlLnR5cGUgPT09ICJhdG9tIiAmJiByaWdodE5vZGUuZmFtaWx5ID09PSAiY2xvc2UiID8gZGVsaW1Gcm9tVmFsdWUocmlnaHROb2RlLnRleHQpIDogbnVsbDsKICAgIHZhciBiYXJOb2RlID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1syXSwgInNpemUiKTsKICAgIHZhciBoYXNCYXJMaW5lOwogICAgdmFyIGJhclNpemUgPSBudWxsOwogICAgaWYgKGJhck5vZGUuaXNCbGFuaykgewogICAgICBoYXNCYXJMaW5lID0gdHJ1ZTsKICAgIH0gZWxzZSB7CiAgICAgIGJhclNpemUgPSBiYXJOb2RlLnZhbHVlOwogICAgICBoYXNCYXJMaW5lID0gYmFyU2l6ZS5udW1iZXIgPiAwOwogICAgfQogICAgdmFyIHNpemUgPSAiYXV0byI7CiAgICB2YXIgc3R5bCA9IGFyZ3NbM107CiAgICBpZiAoc3R5bC50eXBlID09PSAib3JkZ3JvdXAiKSB7CiAgICAgIGlmIChzdHlsLmJvZHkubGVuZ3RoID4gMCkgewogICAgICAgIHZhciB0ZXh0T3JkID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bC5ib2R5WzBdLCAidGV4dG9yZCIpOwogICAgICAgIHNpemUgPSBzdHlsQXJyYXlbTnVtYmVyKHRleHRPcmQudGV4dCldOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBzdHlsID0gYXNzZXJ0Tm9kZVR5cGUoc3R5bCwgInRleHRvcmQiKTsKICAgICAgc2l6ZSA9IHN0eWxBcnJheVtOdW1iZXIoc3R5bC50ZXh0KV07CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiZ2VuZnJhYyIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBudW1lciwKICAgICAgZGVub20sCiAgICAgIGNvbnRpbnVlZDogZmFsc2UsCiAgICAgIGhhc0JhckxpbmUsCiAgICAgIGJhclNpemUsCiAgICAgIGxlZnREZWxpbSwKICAgICAgcmlnaHREZWxpbSwKICAgICAgc2l6ZQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQ0LAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMwp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJpbmZpeCIsCiAgbmFtZXM6IFsiXFxhYm92ZSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYXJnVHlwZXM6IFsic2l6ZSJdLAogICAgaW5maXg6IHRydWUKICB9LAogIGhhbmRsZXIoX3JlZjUsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUsCiAgICAgIHRva2VuCiAgICB9ID0gX3JlZjU7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiaW5maXgiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgcmVwbGFjZVdpdGg6ICJcXFxcYWJvdmVmcmFjIiwKICAgICAgc2l6ZTogYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgInNpemUiKS52YWx1ZSwKICAgICAgdG9rZW4KICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJnZW5mcmFjIiwKICBuYW1lczogWyJcXFxcYWJvdmVmcmFjIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDMsCiAgICBhcmdUeXBlczogWyJtYXRoIiwgInNpemUiLCAibWF0aCJdCiAgfSwKICBoYW5kbGVyOiAoX3JlZjYsIGFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmNjsKICAgIHZhciBudW1lciA9IGFyZ3NbMF07CiAgICB2YXIgYmFyU2l6ZSA9IGFzc2VydChhc3NlcnROb2RlVHlwZShhcmdzWzFdLCAiaW5maXgiKS5zaXplKTsKICAgIHZhciBkZW5vbSA9IGFyZ3NbMl07CiAgICB2YXIgaGFzQmFyTGluZSA9IGJhclNpemUubnVtYmVyID4gMDsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJnZW5mcmFjIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIG51bWVyLAogICAgICBkZW5vbSwKICAgICAgY29udGludWVkOiBmYWxzZSwKICAgICAgaGFzQmFyTGluZSwKICAgICAgYmFyU2l6ZSwKICAgICAgbGVmdERlbGltOiBudWxsLAogICAgICByaWdodERlbGltOiBudWxsLAogICAgICBzaXplOiAiYXV0byIKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkNCwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDMKfSk7CnZhciBodG1sQnVpbGRlciQzID0gKGdycCwgb3B0aW9ucykgPT4gewogIHZhciBzdHlsZSA9IG9wdGlvbnMuc3R5bGU7CiAgdmFyIHN1cFN1Ykdyb3VwOwogIHZhciBncm91cDsKICBpZiAoZ3JwLnR5cGUgPT09ICJzdXBzdWIiKSB7CiAgICBzdXBTdWJHcm91cCA9IGdycC5zdXAgPyBidWlsZEdyb3VwJDEoZ3JwLnN1cCwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdXAoKSksIG9wdGlvbnMpIDogYnVpbGRHcm91cCQxKGdycC5zdWIsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3ViKCkpLCBvcHRpb25zKTsKICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLmJhc2UsICJob3JpekJyYWNlIik7CiAgfSBlbHNlIHsKICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCAiaG9yaXpCcmFjZSIpOwogIH0KICB2YXIgYm9keSA9IGJ1aWxkR3JvdXAkMShncm91cC5iYXNlLCBvcHRpb25zLmhhdmluZ0Jhc2VTdHlsZShTdHlsZSQxLkRJU1BMQVkpKTsKICB2YXIgYnJhY2VCb2R5ID0gc3RyZXRjaHkuc3ZnU3Bhbihncm91cCwgb3B0aW9ucyk7CiAgdmFyIHZsaXN0OwogIGlmIChncm91cC5pc092ZXIpIHsKICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgcG9zaXRpb25UeXBlOiAiZmlyc3RCYXNlbGluZSIsCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBib2R5CiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZTogMC4xCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogYnJhY2VCb2R5CiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICAgIHZsaXN0LmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzFdLmNsYXNzZXMucHVzaCgic3ZnLWFsaWduIik7CiAgfSBlbHNlIHsKICAgIHZsaXN0ID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgcG9zaXRpb25UeXBlOiAiYm90dG9tIiwKICAgICAgcG9zaXRpb25EYXRhOiBib2R5LmRlcHRoICsgMC4xICsgYnJhY2VCb2R5LmhlaWdodCwKICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGJyYWNlQm9keQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImtlcm4iLAogICAgICAgIHNpemU6IDAuMQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGJvZHkKICAgICAgfV0KICAgIH0sIG9wdGlvbnMpOwogICAgdmxpc3QuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2xhc3Nlcy5wdXNoKCJzdmctYWxpZ24iKTsKICB9CiAgaWYgKHN1cFN1Ykdyb3VwKSB7CiAgICB2YXIgdlNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiLCBncm91cC5pc092ZXIgPyAibW92ZXIiIDogIm11bmRlciJdLCBbdmxpc3RdLCBvcHRpb25zKTsKICAgIGlmIChncm91cC5pc092ZXIpIHsKICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICAgIHBvc2l0aW9uVHlwZTogImZpcnN0QmFzZWxpbmUiLAogICAgICAgIGNoaWxkcmVuOiBbewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogdlNwYW4KICAgICAgICB9LCB7CiAgICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgICBzaXplOiAwLjIKICAgICAgICB9LCB7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiBzdXBTdWJHcm91cAogICAgICAgIH1dCiAgICAgIH0sIG9wdGlvbnMpOwogICAgfSBlbHNlIHsKICAgICAgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICAgIHBvc2l0aW9uVHlwZTogImJvdHRvbSIsCiAgICAgICAgcG9zaXRpb25EYXRhOiB2U3Bhbi5kZXB0aCArIDAuMiArIHN1cFN1Ykdyb3VwLmhlaWdodCArIHN1cFN1Ykdyb3VwLmRlcHRoLAogICAgICAgIGNoaWxkcmVuOiBbewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogc3VwU3ViR3JvdXAKICAgICAgICB9LCB7CiAgICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgICBzaXplOiAwLjIKICAgICAgICB9LCB7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiB2U3BhbgogICAgICAgIH1dCiAgICAgIH0sIG9wdGlvbnMpOwogICAgfQogIH0KICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3JkIiwgZ3JvdXAuaXNPdmVyID8gIm1vdmVyIiA6ICJtdW5kZXIiXSwgW3ZsaXN0XSwgb3B0aW9ucyk7Cn07CnZhciBtYXRobWxCdWlsZGVyJDIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgYWNjZW50Tm9kZSA9IHN0cmV0Y2h5Lm1hdGhNTG5vZGUoZ3JvdXAubGFiZWwpOwogIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZShncm91cC5pc092ZXIgPyAibW92ZXIiIDogIm11bmRlciIsIFtidWlsZEdyb3VwMihncm91cC5iYXNlLCBvcHRpb25zKSwgYWNjZW50Tm9kZV0pOwp9OwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImhvcml6QnJhY2UiLAogIG5hbWVzOiBbIlxcb3ZlcmJyYWNlIiwgIlxcdW5kZXJicmFjZSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImhvcml6QnJhY2UiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbGFiZWw6IGZ1bmNOYW1lLAogICAgICBpc092ZXI6IC9eXFxvdmVyLy50ZXN0KGZ1bmNOYW1lKSwKICAgICAgYmFzZTogYXJnc1swXQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQzLAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMgp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJocmVmIiwKICBuYW1lczogWyJcXGhyZWYiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMiwKICAgIGFyZ1R5cGVzOiBbInVybCIsICJvcmlnaW5hbCJdLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgYm9keSA9IGFyZ3NbMV07CiAgICB2YXIgaHJlZiA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sICJ1cmwiKS51cmw7CiAgICBpZiAoIXBhcnNlci5zZXR0aW5ncy5pc1RydXN0ZWQoewogICAgICBjb21tYW5kOiAiXFxocmVmIiwKICAgICAgdXJsOiBocmVmCiAgICB9KSkgewogICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKCJcXGhyZWYiKTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJocmVmIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGhyZWYsCiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgZmFsc2UpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VBbmNob3IoZ3JvdXAuaHJlZiwgW10sIGVsZW1lbnRzLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIG1hdGgyID0gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG9wdGlvbnMpOwogICAgaWYgKCEobWF0aDIgaW5zdGFuY2VvZiBNYXRoTm9kZSkpIHsKICAgICAgbWF0aDIgPSBuZXcgTWF0aE5vZGUoIm1yb3ciLCBbbWF0aDJdKTsKICAgIH0KICAgIG1hdGgyLnNldEF0dHJpYnV0ZSgiaHJlZiIsIGdyb3VwLmhyZWYpOwogICAgcmV0dXJuIG1hdGgyOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiaHJlZiIsCiAgbmFtZXM6IFsiXFx1cmwiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIGFyZ1R5cGVzOiBbInVybCJdLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmMjsKICAgIHZhciBocmVmID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgInVybCIpLnVybDsKICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7CiAgICAgIGNvbW1hbmQ6ICJcXHVybCIsCiAgICAgIHVybDogaHJlZgogICAgfSkpIHsKICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZCgiXFx1cmwiKTsKICAgIH0KICAgIHZhciBjaGFycyA9IFtdOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBocmVmLmxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBjID0gaHJlZltpXTsKICAgICAgaWYgKGMgPT09ICJ+IikgewogICAgICAgIGMgPSAiXFx0ZXh0YXNjaWl0aWxkZSI7CiAgICAgIH0KICAgICAgY2hhcnMucHVzaCh7CiAgICAgICAgdHlwZTogInRleHRvcmQiLAogICAgICAgIG1vZGU6ICJ0ZXh0IiwKICAgICAgICB0ZXh0OiBjCiAgICAgIH0pOwogICAgfQogICAgdmFyIGJvZHkgPSB7CiAgICAgIHR5cGU6ICJ0ZXh0IiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGZvbnQ6ICJcXHRleHR0dCIsCiAgICAgIGJvZHk6IGNoYXJzCiAgICB9OwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImhyZWYiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgaHJlZiwKICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSkKICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJoYm94IiwKICBuYW1lczogWyJcXGhib3giXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIGFyZ1R5cGVzOiBbInRleHQiXSwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBwcmltaXRpdmU6IHRydWUKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJoYm94IiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGFyZ3NbMF0pCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoZWxlbWVudHMpOwogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcm93IiwgYnVpbGRFeHByZXNzaW9uMihncm91cC5ib2R5LCBvcHRpb25zKSk7CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJodG1sIiwKICBuYW1lczogWyJcXGh0bWxDbGFzcyIsICJcXGh0bWxJZCIsICJcXGh0bWxTdHlsZSIsICJcXGh0bWxEYXRhIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDIsCiAgICBhcmdUeXBlczogWyJyYXciLCAib3JpZ2luYWwiXSwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUKICB9LAogIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lLAogICAgICB0b2tlbgogICAgfSA9IF9yZWY7CiAgICB2YXIgdmFsdWUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCAicmF3Iikuc3RyaW5nOwogICAgdmFyIGJvZHkgPSBhcmdzWzFdOwogICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHsKICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdCgiaHRtbEV4dGVuc2lvbiIsICJIVE1MIGV4dGVuc2lvbiBpcyBkaXNhYmxlZCBvbiBzdHJpY3QgbW9kZSIpOwogICAgfQogICAgdmFyIHRydXN0Q29udGV4dDsKICAgIHZhciBhdHRyaWJ1dGVzID0ge307CiAgICBzd2l0Y2ggKGZ1bmNOYW1lKSB7CiAgICAgIGNhc2UgIlxcaHRtbENsYXNzIjoKICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gdmFsdWU7CiAgICAgICAgdHJ1c3RDb250ZXh0ID0gewogICAgICAgICAgY29tbWFuZDogIlxcaHRtbENsYXNzIiwKICAgICAgICAgIGNsYXNzOiB2YWx1ZQogICAgICAgIH07CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcaHRtbElkIjoKICAgICAgICBhdHRyaWJ1dGVzLmlkID0gdmFsdWU7CiAgICAgICAgdHJ1c3RDb250ZXh0ID0gewogICAgICAgICAgY29tbWFuZDogIlxcaHRtbElkIiwKICAgICAgICAgIGlkOiB2YWx1ZQogICAgICAgIH07CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcaHRtbFN0eWxlIjoKICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gdmFsdWU7CiAgICAgICAgdHJ1c3RDb250ZXh0ID0gewogICAgICAgICAgY29tbWFuZDogIlxcaHRtbFN0eWxlIiwKICAgICAgICAgIHN0eWxlOiB2YWx1ZQogICAgICAgIH07CiAgICAgICAgYnJlYWs7CiAgICAgIGNhc2UgIlxcaHRtbERhdGEiOiB7CiAgICAgICAgdmFyIGRhdGEgPSB2YWx1ZS5zcGxpdCgiLCIpOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykgewogICAgICAgICAgdmFyIGtleVZhbCA9IGRhdGFbaV0uc3BsaXQoIj0iKTsKICAgICAgICAgIGlmIChrZXlWYWwubGVuZ3RoICE9PSAyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJFcnJvciBwYXJzaW5nIGtleS12YWx1ZSBmb3IgXFxodG1sRGF0YSIpOwogICAgICAgICAgfQogICAgICAgICAgYXR0cmlidXRlc1siZGF0YS0iICsga2V5VmFsWzBdLnRyaW0oKV0gPSBrZXlWYWxbMV0udHJpbSgpOwogICAgICAgIH0KICAgICAgICB0cnVzdENvbnRleHQgPSB7CiAgICAgICAgICBjb21tYW5kOiAiXFxodG1sRGF0YSIsCiAgICAgICAgICBhdHRyaWJ1dGVzCiAgICAgICAgfTsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBkZWZhdWx0OgogICAgICAgIHRocm93IG5ldyBFcnJvcigiVW5yZWNvZ25pemVkIGh0bWwgY29tbWFuZCIpOwogICAgfQogICAgaWYgKCFwYXJzZXIuc2V0dGluZ3MuaXNUcnVzdGVkKHRydXN0Q29udGV4dCkpIHsKICAgICAgcmV0dXJuIHBhcnNlci5mb3JtYXRVbnN1cHBvcnRlZENtZChmdW5jTmFtZSk7CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiaHRtbCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBhdHRyaWJ1dGVzLAogICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICAgIHZhciBlbGVtZW50cyA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKTsKICAgIHZhciBjbGFzc2VzID0gWyJlbmNsb3NpbmciXTsKICAgIGlmIChncm91cC5hdHRyaWJ1dGVzLmNsYXNzKSB7CiAgICAgIGNsYXNzZXMucHVzaCguLi5ncm91cC5hdHRyaWJ1dGVzLmNsYXNzLnRyaW0oKS5zcGxpdCgvXHMrLykpOwogICAgfQogICAgdmFyIHNwYW4gPSBidWlsZENvbW1vbi5tYWtlU3BhbihjbGFzc2VzLCBlbGVtZW50cywgb3B0aW9ucyk7CiAgICBmb3IgKHZhciBhdHRyIGluIGdyb3VwLmF0dHJpYnV0ZXMpIHsKICAgICAgaWYgKGF0dHIgIT09ICJjbGFzcyIgJiYgZ3JvdXAuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkgewogICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGF0dHIsIGdyb3VwLmF0dHJpYnV0ZXNbYXR0cl0pOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gc3BhbjsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImh0bWxtYXRobWwiLAogIG5hbWVzOiBbIlxcaHRtbEBtYXRobWwiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMiwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUKICB9LAogIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImh0bWxtYXRobWwiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgaHRtbDogb3JkYXJndW1lbnQoYXJnc1swXSksCiAgICAgIG1hdGhtbDogb3JkYXJndW1lbnQoYXJnc1sxXSkKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgICB2YXIgZWxlbWVudHMgPSBidWlsZEV4cHJlc3Npb24kMShncm91cC5odG1sLCBvcHRpb25zLCBmYWxzZSk7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgcmV0dXJuIGJ1aWxkRXhwcmVzc2lvblJvdyhncm91cC5tYXRobWwsIG9wdGlvbnMpOwogIH0KfSk7CnZhciBzaXplRGF0YSA9IGZ1bmN0aW9uIHNpemVEYXRhMihzdHIpIHsKICBpZiAoL15bLStdPyAqKFxkKyhcLlxkKik/fFwuXGQrKSQvLnRlc3Qoc3RyKSkgewogICAgcmV0dXJuIHsKICAgICAgbnVtYmVyOiArc3RyLAogICAgICB1bml0OiAiYnAiCiAgICB9OwogIH0gZWxzZSB7CiAgICB2YXIgbWF0Y2ggPSAvKFstK10/KSAqKFxkKyg/OlwuXGQqKT98XC5cZCspICooW2Etel17Mn0pLy5leGVjKHN0cik7CiAgICBpZiAoIW1hdGNoKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIHNpemU6ICciICsgc3RyICsgIicgaW4gXFxpbmNsdWRlZ3JhcGhpY3MiKTsKICAgIH0KICAgIHZhciBkYXRhID0gewogICAgICBudW1iZXI6ICsobWF0Y2hbMV0gKyBtYXRjaFsyXSksCiAgICAgIC8vIHNpZ24gKyBtYWduaXR1ZGUsIGNhc3QgdG8gbnVtYmVyCiAgICAgIHVuaXQ6IG1hdGNoWzNdCiAgICB9OwogICAgaWYgKCF2YWxpZFVuaXQoZGF0YSkpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkludmFsaWQgdW5pdDogJyIgKyBkYXRhLnVuaXQgKyAiJyBpbiBcXGluY2x1ZGVncmFwaGljcy4iKTsKICAgIH0KICAgIHJldHVybiBkYXRhOwogIH0KfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJpbmNsdWRlZ3JhcGhpY3MiLAogIG5hbWVzOiBbIlxcaW5jbHVkZWdyYXBoaWNzIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBudW1PcHRpb25hbEFyZ3M6IDEsCiAgICBhcmdUeXBlczogWyJyYXciLCAidXJsIl0sCiAgICBhbGxvd2VkSW5UZXh0OiBmYWxzZQogIH0sCiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgd2lkdGggPSB7CiAgICAgIG51bWJlcjogMCwKICAgICAgdW5pdDogImVtIgogICAgfTsKICAgIHZhciBoZWlnaHQgPSB7CiAgICAgIG51bWJlcjogMC45LAogICAgICB1bml0OiAiZW0iCiAgICB9OwogICAgdmFyIHRvdGFsaGVpZ2h0ID0gewogICAgICBudW1iZXI6IDAsCiAgICAgIHVuaXQ6ICJlbSIKICAgIH07CiAgICB2YXIgYWx0ID0gIiI7CiAgICBpZiAob3B0QXJnc1swXSkgewogICAgICB2YXIgYXR0cmlidXRlU3RyID0gYXNzZXJ0Tm9kZVR5cGUob3B0QXJnc1swXSwgInJhdyIpLnN0cmluZzsKICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVTdHIuc3BsaXQoIiwiKTsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIGtleVZhbCA9IGF0dHJpYnV0ZXNbaV0uc3BsaXQoIj0iKTsKICAgICAgICBpZiAoa2V5VmFsLmxlbmd0aCA9PT0gMikgewogICAgICAgICAgdmFyIHN0ciA9IGtleVZhbFsxXS50cmltKCk7CiAgICAgICAgICBzd2l0Y2ggKGtleVZhbFswXS50cmltKCkpIHsKICAgICAgICAgICAgY2FzZSAiYWx0IjoKICAgICAgICAgICAgICBhbHQgPSBzdHI7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgIndpZHRoIjoKICAgICAgICAgICAgICB3aWR0aCA9IHNpemVEYXRhKHN0cik7CiAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgImhlaWdodCI6CiAgICAgICAgICAgICAgaGVpZ2h0ID0gc2l6ZURhdGEoc3RyKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSAidG90YWxoZWlnaHQiOgogICAgICAgICAgICAgIHRvdGFsaGVpZ2h0ID0gc2l6ZURhdGEoc3RyKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiSW52YWxpZCBrZXk6ICciICsga2V5VmFsWzBdICsgIicgaW4gXFxpbmNsdWRlZ3JhcGhpY3MuIik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICB2YXIgc3JjID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1swXSwgInVybCIpLnVybDsKICAgIGlmIChhbHQgPT09ICIiKSB7CiAgICAgIGFsdCA9IHNyYzsKICAgICAgYWx0ID0gYWx0LnJlcGxhY2UoL14uKltcXC9dLywgIiIpOwogICAgICBhbHQgPSBhbHQuc3Vic3RyaW5nKDAsIGFsdC5sYXN0SW5kZXhPZigiLiIpKTsKICAgIH0KICAgIGlmICghcGFyc2VyLnNldHRpbmdzLmlzVHJ1c3RlZCh7CiAgICAgIGNvbW1hbmQ6ICJcXGluY2x1ZGVncmFwaGljcyIsCiAgICAgIHVybDogc3JjCiAgICB9KSkgewogICAgICByZXR1cm4gcGFyc2VyLmZvcm1hdFVuc3VwcG9ydGVkQ21kKCJcXGluY2x1ZGVncmFwaGljcyIpOwogICAgfQogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImluY2x1ZGVncmFwaGljcyIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBhbHQsCiAgICAgIHdpZHRoLAogICAgICBoZWlnaHQsCiAgICAgIHRvdGFsaGVpZ2h0LAogICAgICBzcmMKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpOwogICAgdmFyIGRlcHRoID0gMDsKICAgIGlmIChncm91cC50b3RhbGhlaWdodC5udW1iZXIgPiAwKSB7CiAgICAgIGRlcHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7CiAgICB9CiAgICB2YXIgd2lkdGggPSAwOwogICAgaWYgKGdyb3VwLndpZHRoLm51bWJlciA+IDApIHsKICAgICAgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTsKICAgIH0KICAgIHZhciBzdHlsZSA9IHsKICAgICAgaGVpZ2h0OiBtYWtlRW0oaGVpZ2h0ICsgZGVwdGgpCiAgICB9OwogICAgaWYgKHdpZHRoID4gMCkgewogICAgICBzdHlsZS53aWR0aCA9IG1ha2VFbSh3aWR0aCk7CiAgICB9CiAgICBpZiAoZGVwdGggPiAwKSB7CiAgICAgIHN0eWxlLnZlcnRpY2FsQWxpZ24gPSBtYWtlRW0oLWRlcHRoKTsKICAgIH0KICAgIHZhciBub2RlID0gbmV3IEltZyhncm91cC5zcmMsIGdyb3VwLmFsdCwgc3R5bGUpOwogICAgbm9kZS5oZWlnaHQgPSBoZWlnaHQ7CiAgICBub2RlLmRlcHRoID0gZGVwdGg7CiAgICByZXR1cm4gbm9kZTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibWdseXBoIiwgW10pOwogICAgbm9kZS5zZXRBdHRyaWJ1dGUoImFsdCIsIGdyb3VwLmFsdCk7CiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpOwogICAgdmFyIGRlcHRoID0gMDsKICAgIGlmIChncm91cC50b3RhbGhlaWdodC5udW1iZXIgPiAwKSB7CiAgICAgIGRlcHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC50b3RhbGhlaWdodCwgb3B0aW9ucykgLSBoZWlnaHQ7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJ2YWxpZ24iLCBtYWtlRW0oLWRlcHRoKSk7CiAgICB9CiAgICBub2RlLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IiwgbWFrZUVtKGhlaWdodCArIGRlcHRoKSk7CiAgICBpZiAoZ3JvdXAud2lkdGgubnVtYmVyID4gMCkgewogICAgICB2YXIgd2lkdGggPSBjYWxjdWxhdGVTaXplKGdyb3VwLndpZHRoLCBvcHRpb25zKTsKICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoIndpZHRoIiwgbWFrZUVtKHdpZHRoKSk7CiAgICB9CiAgICBub2RlLnNldEF0dHJpYnV0ZSgic3JjIiwgZ3JvdXAuc3JjKTsKICAgIHJldHVybiBub2RlOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAia2VybiIsCiAgbmFtZXM6IFsiXFxrZXJuIiwgIlxcbWtlcm4iLCAiXFxoc2tpcCIsICJcXG1za2lwIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhcmdUeXBlczogWyJzaXplIl0sCiAgICBwcmltaXRpdmU6IHRydWUsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmOwogICAgdmFyIHNpemUgPSBhc3NlcnROb2RlVHlwZShhcmdzWzBdLCAic2l6ZSIpOwogICAgaWYgKHBhcnNlci5zZXR0aW5ncy5zdHJpY3QpIHsKICAgICAgdmFyIG1hdGhGdW5jdGlvbiA9IGZ1bmNOYW1lWzFdID09PSAibSI7CiAgICAgIHZhciBtdVVuaXQgPSBzaXplLnZhbHVlLnVuaXQgPT09ICJtdSI7CiAgICAgIGlmIChtYXRoRnVuY3Rpb24pIHsKICAgICAgICBpZiAoIW11VW5pdCkgewogICAgICAgICAgcGFyc2VyLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdCgibWF0aFZzVGV4dFVuaXRzIiwgIkxhVGVYJ3MgIiArIGZ1bmNOYW1lICsgIiBzdXBwb3J0cyBvbmx5IG11IHVuaXRzLCAiICsgKCJub3QgIiArIHNpemUudmFsdWUudW5pdCArICIgdW5pdHMiKSk7CiAgICAgICAgfQogICAgICAgIGlmIChwYXJzZXIubW9kZSAhPT0gIm1hdGgiKSB7CiAgICAgICAgICBwYXJzZXIuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KCJtYXRoVnNUZXh0VW5pdHMiLCAiTGFUZVgncyAiICsgZnVuY05hbWUgKyAiIHdvcmtzIG9ubHkgaW4gbWF0aCBtb2RlIik7CiAgICAgICAgfQogICAgICB9IGVsc2UgewogICAgICAgIGlmIChtdVVuaXQpIHsKICAgICAgICAgIHBhcnNlci5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoIm1hdGhWc1RleHRVbml0cyIsICJMYVRlWCdzICIgKyBmdW5jTmFtZSArICIgZG9lc24ndCBzdXBwb3J0IG11IHVuaXRzIik7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAia2VybiIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBkaW1lbnNpb246IHNpemUudmFsdWUKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VHbHVlKGdyb3VwLmRpbWVuc2lvbiwgb3B0aW9ucyk7CiAgfSwKICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgZGltZW5zaW9uID0gY2FsY3VsYXRlU2l6ZShncm91cC5kaW1lbnNpb24sIG9wdGlvbnMpOwogICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLlNwYWNlTm9kZShkaW1lbnNpb24pOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAibGFwIiwKICBuYW1lczogWyJcXG1hdGhsbGFwIiwgIlxcbWF0aHJsYXAiLCAiXFxtYXRoY2xhcCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlciwKICAgICAgZnVuY05hbWUKICAgIH0gPSBfcmVmOwogICAgdmFyIGJvZHkgPSBhcmdzWzBdOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImxhcCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBhbGlnbm1lbnQ6IGZ1bmNOYW1lLnNsaWNlKDUpLAogICAgICBib2R5CiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGlubmVyMjsKICAgIGlmIChncm91cC5hbGlnbm1lbnQgPT09ICJjbGFwIikgewogICAgICBpbm5lcjIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbXSwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zKV0pOwogICAgICBpbm5lcjIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbImlubmVyIl0sIFtpbm5lcjJdLCBvcHRpb25zKTsKICAgIH0gZWxzZSB7CiAgICAgIGlubmVyMiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsiaW5uZXIiXSwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zKV0pOwogICAgfQogICAgdmFyIGZpeCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsiZml4Il0sIFtdKTsKICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW2dyb3VwLmFsaWdubWVudF0sIFtpbm5lcjIsIGZpeF0sIG9wdGlvbnMpOwogICAgdmFyIHN0cnV0ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJzdHJ1dCJdKTsKICAgIHN0cnV0LnN0eWxlLmhlaWdodCA9IG1ha2VFbShub2RlLmhlaWdodCArIG5vZGUuZGVwdGgpOwogICAgaWYgKG5vZGUuZGVwdGgpIHsKICAgICAgc3RydXQuc3R5bGUudmVydGljYWxBbGlnbiA9IG1ha2VFbSgtbm9kZS5kZXB0aCk7CiAgICB9CiAgICBub2RlLmNoaWxkcmVuLnVuc2hpZnQoc3RydXQpOwogICAgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsidGhpbmJveCJdLCBbbm9kZV0sIG9wdGlvbnMpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9yZCIsICJ2Ym94Il0sIFtub2RlXSwgb3B0aW9ucyk7CiAgfSwKICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1wYWRkZWQiLCBbYnVpbGRHcm91cDIoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTsKICAgIGlmIChncm91cC5hbGlnbm1lbnQgIT09ICJybGFwIikgewogICAgICB2YXIgb2Zmc2V0ID0gZ3JvdXAuYWxpZ25tZW50ID09PSAibGxhcCIgPyAiLTEiIDogIi0wLjUiOwogICAgICBub2RlLnNldEF0dHJpYnV0ZSgibHNwYWNlIiwgb2Zmc2V0ICsgIndpZHRoIik7CiAgICB9CiAgICBub2RlLnNldEF0dHJpYnV0ZSgid2lkdGgiLCAiMHB4Iik7CiAgICByZXR1cm4gbm9kZTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogInN0eWxpbmciLAogIG5hbWVzOiBbIlxcKCIsICIkIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlLAogICAgYWxsb3dlZEluTWF0aDogZmFsc2UKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncykgewogICAgdmFyIHsKICAgICAgZnVuY05hbWUsCiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgb3V0ZXJNb2RlID0gcGFyc2VyLm1vZGU7CiAgICBwYXJzZXIuc3dpdGNoTW9kZSgibWF0aCIpOwogICAgdmFyIGNsb3NlMiA9IGZ1bmNOYW1lID09PSAiXFwoIiA/ICJcXCkiIDogIiQiOwogICAgdmFyIGJvZHkgPSBwYXJzZXIucGFyc2VFeHByZXNzaW9uKGZhbHNlLCBjbG9zZTIpOwogICAgcGFyc2VyLmV4cGVjdChjbG9zZTIpOwogICAgcGFyc2VyLnN3aXRjaE1vZGUob3V0ZXJNb2RlKTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJzdHlsaW5nIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIHN0eWxlOiAidGV4dCIsCiAgICAgIGJvZHkKICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJ0ZXh0IiwKICAvLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoaXMgaXMuCiAgbmFtZXM6IFsiXFwpIiwgIlxcXSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZSwKICAgIGFsbG93ZWRJbk1hdGg6IGZhbHNlCiAgfSwKICBoYW5kbGVyKGNvbnRleHQsIGFyZ3MpIHsKICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJNaXNtYXRjaGVkICIgKyBjb250ZXh0LmZ1bmNOYW1lKTsKICB9Cn0pOwp2YXIgY2hvb3NlTWF0aFN0eWxlID0gKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgc3dpdGNoIChvcHRpb25zLnN0eWxlLnNpemUpIHsKICAgIGNhc2UgU3R5bGUkMS5ESVNQTEFZLnNpemU6CiAgICAgIHJldHVybiBncm91cC5kaXNwbGF5OwogICAgY2FzZSBTdHlsZSQxLlRFWFQuc2l6ZToKICAgICAgcmV0dXJuIGdyb3VwLnRleHQ7CiAgICBjYXNlIFN0eWxlJDEuU0NSSVBULnNpemU6CiAgICAgIHJldHVybiBncm91cC5zY3JpcHQ7CiAgICBjYXNlIFN0eWxlJDEuU0NSSVBUU0NSSVBULnNpemU6CiAgICAgIHJldHVybiBncm91cC5zY3JpcHRzY3JpcHQ7CiAgICBkZWZhdWx0OgogICAgICByZXR1cm4gZ3JvdXAudGV4dDsKICB9Cn07CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAibWF0aGNob2ljZSIsCiAgbmFtZXM6IFsiXFxtYXRoY2hvaWNlIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDQsCiAgICBwcmltaXRpdmU6IHRydWUKICB9LAogIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogIm1hdGhjaG9pY2UiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgZGlzcGxheTogb3JkYXJndW1lbnQoYXJnc1swXSksCiAgICAgIHRleHQ6IG9yZGFyZ3VtZW50KGFyZ3NbMV0pLAogICAgICBzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbMl0pLAogICAgICBzY3JpcHRzY3JpcHQ6IG9yZGFyZ3VtZW50KGFyZ3NbM10pCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGJvZHkgPSBjaG9vc2VNYXRoU3R5bGUoZ3JvdXAsIG9wdGlvbnMpOwogICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoYm9keSwgb3B0aW9ucywgZmFsc2UpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VGcmFnbWVudChlbGVtZW50cyk7CiAgfSwKICBtYXRobWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICAgIHZhciBib2R5ID0gY2hvb3NlTWF0aFN0eWxlKGdyb3VwLCBvcHRpb25zKTsKICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coYm9keSwgb3B0aW9ucyk7CiAgfQp9KTsKdmFyIGFzc2VtYmxlU3VwU3ViID0gKGJhc2UsIHN1cEdyb3VwLCBzdWJHcm91cCwgb3B0aW9ucywgc3R5bGUsIHNsYW50LCBiYXNlU2hpZnQpID0+IHsKICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtiYXNlXSk7CiAgdmFyIHN1YklzU2luZ2xlQ2hhcmFjdGVyID0gc3ViR3JvdXAgJiYgdXRpbHMuaXNDaGFyYWN0ZXJCb3goc3ViR3JvdXApOwogIHZhciBzdWIyOwogIHZhciBzdXAyOwogIGlmIChzdXBHcm91cCkgewogICAgdmFyIGVsZW0gPSBidWlsZEdyb3VwJDEoc3VwR3JvdXAsIG9wdGlvbnMuaGF2aW5nU3R5bGUoc3R5bGUuc3VwKCkpLCBvcHRpb25zKTsKICAgIHN1cDIgPSB7CiAgICAgIGVsZW0sCiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcxLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nMyAtIGVsZW0uZGVwdGgpCiAgICB9OwogIH0KICBpZiAoc3ViR3JvdXApIHsKICAgIHZhciBfZWxlbSA9IGJ1aWxkR3JvdXAkMShzdWJHcm91cCwgb3B0aW9ucy5oYXZpbmdTdHlsZShzdHlsZS5zdWIoKSksIG9wdGlvbnMpOwogICAgc3ViMiA9IHsKICAgICAgZWxlbTogX2VsZW0sCiAgICAgIGtlcm46IE1hdGgubWF4KG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmcyLCBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNCAtIF9lbGVtLmhlaWdodCkKICAgIH07CiAgfQogIHZhciBmaW5hbEdyb3VwOwogIGlmIChzdXAyICYmIHN1YjIpIHsKICAgIHZhciBib3R0b20gPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNSArIHN1YjIuZWxlbS5oZWlnaHQgKyBzdWIyLmVsZW0uZGVwdGggKyBzdWIyLmtlcm4gKyBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0OwogICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImJvdHRvbSIsCiAgICAgIHBvc2l0aW9uRGF0YTogYm90dG9tLAogICAgICBjaGlsZHJlbjogW3sKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZTogb3B0aW9ucy5mb250TWV0cmljcygpLmJpZ09wU3BhY2luZzUKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBzdWIyLmVsZW0sCiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKC1zbGFudCkKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJrZXJuIiwKICAgICAgICBzaXplOiBzdWIyLmtlcm4KICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBiYXNlCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZTogc3VwMi5rZXJuCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogc3VwMi5lbGVtLAogICAgICAgIG1hcmdpbkxlZnQ6IG1ha2VFbShzbGFudCkKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJrZXJuIiwKICAgICAgICBzaXplOiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNQogICAgICB9XQogICAgfSwgb3B0aW9ucyk7CiAgfSBlbHNlIGlmIChzdWIyKSB7CiAgICB2YXIgdG9wID0gYmFzZS5oZWlnaHQgLSBiYXNlU2hpZnQ7CiAgICBmaW5hbEdyb3VwID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgcG9zaXRpb25UeXBlOiAidG9wIiwKICAgICAgcG9zaXRpb25EYXRhOiB0b3AsCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJrZXJuIiwKICAgICAgICBzaXplOiBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYmlnT3BTcGFjaW5nNQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IHN1YjIuZWxlbSwKICAgICAgICBtYXJnaW5MZWZ0OiBtYWtlRW0oLXNsYW50KQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImtlcm4iLAogICAgICAgIHNpemU6IHN1YjIua2VybgogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGJhc2UKICAgICAgfV0KICAgIH0sIG9wdGlvbnMpOwogIH0gZWxzZSBpZiAoc3VwMikgewogICAgdmFyIF9ib3R0b20gPSBiYXNlLmRlcHRoICsgYmFzZVNoaWZ0OwogICAgZmluYWxHcm91cCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogImJvdHRvbSIsCiAgICAgIHBvc2l0aW9uRGF0YTogX2JvdHRvbSwKICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGJhc2UKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJrZXJuIiwKICAgICAgICBzaXplOiBzdXAyLmtlcm4KICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBzdXAyLmVsZW0sCiAgICAgICAgbWFyZ2luTGVmdDogbWFrZUVtKHNsYW50KQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImtlcm4iLAogICAgICAgIHNpemU6IG9wdGlvbnMuZm9udE1ldHJpY3MoKS5iaWdPcFNwYWNpbmc1CiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICB9IGVsc2UgewogICAgcmV0dXJuIGJhc2U7CiAgfQogIHZhciBwYXJ0cyA9IFtmaW5hbEdyb3VwXTsKICBpZiAoc3ViMiAmJiBzbGFudCAhPT0gMCAmJiAhc3ViSXNTaW5nbGVDaGFyYWN0ZXIpIHsKICAgIHZhciBzcGFjZXIgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1zcGFjZSJdLCBbXSwgb3B0aW9ucyk7CiAgICBzcGFjZXIuc3R5bGUubWFyZ2luUmlnaHQgPSBtYWtlRW0oc2xhbnQpOwogICAgcGFydHMudW5zaGlmdChzcGFjZXIpOwogIH0KICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3AiLCAib3AtbGltaXRzIl0sIHBhcnRzLCBvcHRpb25zKTsKfTsKdmFyIG5vU3VjY2Vzc29yID0gWyJcXHNtYWxsaW50Il07CnZhciBodG1sQnVpbGRlciQyID0gKGdycCwgb3B0aW9ucykgPT4gewogIHZhciBzdXBHcm91cDsKICB2YXIgc3ViR3JvdXA7CiAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlOwogIHZhciBncm91cDsKICBpZiAoZ3JwLnR5cGUgPT09ICJzdXBzdWIiKSB7CiAgICBzdXBHcm91cCA9IGdycC5zdXA7CiAgICBzdWJHcm91cCA9IGdycC5zdWI7CiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCAib3AiKTsKICAgIGhhc0xpbWl0cyA9IHRydWU7CiAgfSBlbHNlIHsKICAgIGdyb3VwID0gYXNzZXJ0Tm9kZVR5cGUoZ3JwLCAib3AiKTsKICB9CiAgdmFyIHN0eWxlID0gb3B0aW9ucy5zdHlsZTsKICB2YXIgbGFyZ2UgPSBmYWxzZTsKICBpZiAoc3R5bGUuc2l6ZSA9PT0gU3R5bGUkMS5ESVNQTEFZLnNpemUgJiYgZ3JvdXAuc3ltYm9sICYmICF1dGlscy5jb250YWlucyhub1N1Y2Nlc3NvciwgZ3JvdXAubmFtZSkpIHsKICAgIGxhcmdlID0gdHJ1ZTsKICB9CiAgdmFyIGJhc2U7CiAgaWYgKGdyb3VwLnN5bWJvbCkgewogICAgdmFyIGZvbnROYW1lID0gbGFyZ2UgPyAiU2l6ZTItUmVndWxhciIgOiAiU2l6ZTEtUmVndWxhciI7CiAgICB2YXIgc3Rhc2ggPSAiIjsKICAgIGlmIChncm91cC5uYW1lID09PSAiXFxvaWludCIgfHwgZ3JvdXAubmFtZSA9PT0gIlxcb2lpaW50IikgewogICAgICBzdGFzaCA9IGdyb3VwLm5hbWUuc2xpY2UoMSk7CiAgICAgIGdyb3VwLm5hbWUgPSBzdGFzaCA9PT0gIm9paW50IiA/ICJcXGlpbnQiIDogIlxcaWlpbnQiOwogICAgfQogICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTeW1ib2woZ3JvdXAubmFtZSwgZm9udE5hbWUsICJtYXRoIiwgb3B0aW9ucywgWyJtb3AiLCAib3Atc3ltYm9sIiwgbGFyZ2UgPyAibGFyZ2Utb3AiIDogInNtYWxsLW9wIl0pOwogICAgaWYgKHN0YXNoLmxlbmd0aCA+IDApIHsKICAgICAgdmFyIGl0YWxpYyA9IGJhc2UuaXRhbGljOwogICAgICB2YXIgb3ZhbCA9IGJ1aWxkQ29tbW9uLnN0YXRpY1N2ZyhzdGFzaCArICJTaXplIiArIChsYXJnZSA/ICIyIiA6ICIxIiksIG9wdGlvbnMpOwogICAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgICBwb3NpdGlvblR5cGU6ICJpbmRpdmlkdWFsU2hpZnQiLAogICAgICAgIGNoaWxkcmVuOiBbewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogYmFzZSwKICAgICAgICAgIHNoaWZ0OiAwCiAgICAgICAgfSwgewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogb3ZhbCwKICAgICAgICAgIHNoaWZ0OiBsYXJnZSA/IDAuMDggOiAwCiAgICAgICAgfV0KICAgICAgfSwgb3B0aW9ucyk7CiAgICAgIGdyb3VwLm5hbWUgPSAiXFwiICsgc3Rhc2g7CiAgICAgIGJhc2UuY2xhc3Nlcy51bnNoaWZ0KCJtb3AiKTsKICAgICAgYmFzZS5pdGFsaWMgPSBpdGFsaWM7CiAgICB9CiAgfSBlbHNlIGlmIChncm91cC5ib2R5KSB7CiAgICB2YXIgaW5uZXIyID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7CiAgICBpZiAoaW5uZXIyLmxlbmd0aCA9PT0gMSAmJiBpbm5lcjJbMF0gaW5zdGFuY2VvZiBTeW1ib2xOb2RlKSB7CiAgICAgIGJhc2UgPSBpbm5lcjJbMF07CiAgICAgIGJhc2UuY2xhc3Nlc1swXSA9ICJtb3AiOwogICAgfSBlbHNlIHsKICAgICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9wIl0sIGlubmVyMiwgb3B0aW9ucyk7CiAgICB9CiAgfSBlbHNlIHsKICAgIHZhciBvdXRwdXQgPSBbXTsKICAgIGZvciAodmFyIGkgPSAxOyBpIDwgZ3JvdXAubmFtZS5sZW5ndGg7IGkrKykgewogICAgICBvdXRwdXQucHVzaChidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLm5hbWVbaV0sIGdyb3VwLm1vZGUsIG9wdGlvbnMpKTsKICAgIH0KICAgIGJhc2UgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcCJdLCBvdXRwdXQsIG9wdGlvbnMpOwogIH0KICB2YXIgYmFzZVNoaWZ0ID0gMDsKICB2YXIgc2xhbnQgPSAwOwogIGlmICgoYmFzZSBpbnN0YW5jZW9mIFN5bWJvbE5vZGUgfHwgZ3JvdXAubmFtZSA9PT0gIlxcb2lpbnQiIHx8IGdyb3VwLm5hbWUgPT09ICJcXG9paWludCIpICYmICFncm91cC5zdXBwcmVzc0Jhc2VTaGlmdCkgewogICAgYmFzZVNoaWZ0ID0gKGJhc2UuaGVpZ2h0IC0gYmFzZS5kZXB0aCkgLyAyIC0gb3B0aW9ucy5mb250TWV0cmljcygpLmF4aXNIZWlnaHQ7CiAgICBzbGFudCA9IGJhc2UuaXRhbGljOwogIH0KICBpZiAoaGFzTGltaXRzKSB7CiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBzdHlsZSwgc2xhbnQsIGJhc2VTaGlmdCk7CiAgfSBlbHNlIHsKICAgIGlmIChiYXNlU2hpZnQpIHsKICAgICAgYmFzZS5zdHlsZS5wb3NpdGlvbiA9ICJyZWxhdGl2ZSI7CiAgICAgIGJhc2Uuc3R5bGUudG9wID0gbWFrZUVtKGJhc2VTaGlmdCk7CiAgICB9CiAgICByZXR1cm4gYmFzZTsKICB9Cn07CnZhciBtYXRobWxCdWlsZGVyJDEgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgbm9kZTsKICBpZiAoZ3JvdXAuc3ltYm9sKSB7CiAgICBub2RlID0gbmV3IE1hdGhOb2RlKCJtbyIsIFttYWtlVGV4dChncm91cC5uYW1lLCBncm91cC5tb2RlKV0pOwogICAgaWYgKHV0aWxzLmNvbnRhaW5zKG5vU3VjY2Vzc29yLCBncm91cC5uYW1lKSkgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgibGFyZ2VvcCIsICJmYWxzZSIpOwogICAgfQogIH0gZWxzZSBpZiAoZ3JvdXAuYm9keSkgewogICAgbm9kZSA9IG5ldyBNYXRoTm9kZSgibW8iLCBidWlsZEV4cHJlc3Npb24yKGdyb3VwLmJvZHksIG9wdGlvbnMpKTsKICB9IGVsc2UgewogICAgbm9kZSA9IG5ldyBNYXRoTm9kZSgibWkiLCBbbmV3IFRleHROb2RlKGdyb3VwLm5hbWUuc2xpY2UoMSkpXSk7CiAgICB2YXIgb3BlcmF0b3IgPSBuZXcgTWF0aE5vZGUoIm1vIiwgW21ha2VUZXh0KCLigaEiLCAidGV4dCIpXSk7CiAgICBpZiAoZ3JvdXAucGFyZW50SXNTdXBTdWIpIHsKICAgICAgbm9kZSA9IG5ldyBNYXRoTm9kZSgibXJvdyIsIFtub2RlLCBvcGVyYXRvcl0pOwogICAgfSBlbHNlIHsKICAgICAgbm9kZSA9IG5ld0RvY3VtZW50RnJhZ21lbnQoW25vZGUsIG9wZXJhdG9yXSk7CiAgICB9CiAgfQogIHJldHVybiBub2RlOwp9Owp2YXIgc2luZ2xlQ2hhckJpZ09wcyA9IHsKICAi4oiPIjogIlxccHJvZCIsCiAgIuKIkCI6ICJcXGNvcHJvZCIsCiAgIuKIkSI6ICJcXHN1bSIsCiAgIuKLgCI6ICJcXGJpZ3dlZGdlIiwKICAi4ouBIjogIlxcYmlndmVlIiwKICAi4ouCIjogIlxcYmlnY2FwIiwKICAi4ouDIjogIlxcYmlnY3VwIiwKICAi4qiAIjogIlxcYmlnb2RvdCIsCiAgIuKogSI6ICJcXGJpZ29wbHVzIiwKICAi4qiCIjogIlxcYmlnb3RpbWVzIiwKICAi4qiEIjogIlxcYmlndXBsdXMiLAogICLiqIYiOiAiXFxiaWdzcWN1cCIKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJvcCIsCiAgbmFtZXM6IFsiXFxjb3Byb2QiLCAiXFxiaWd2ZWUiLCAiXFxiaWd3ZWRnZSIsICJcXGJpZ3VwbHVzIiwgIlxcYmlnY2FwIiwgIlxcYmlnY3VwIiwgIlxcaW50b3AiLCAiXFxwcm9kIiwgIlxcc3VtIiwgIlxcYmlnb3RpbWVzIiwgIlxcYmlnb3BsdXMiLCAiXFxiaWdvZG90IiwgIlxcYmlnc3FjdXAiLCAiXFxzbWFsbGludCIsICLiiI8iLCAi4oiQIiwgIuKIkSIsICLii4AiLCAi4ouBIiwgIuKLgiIsICLii4MiLCAi4qiAIiwgIuKogSIsICLiqIIiLCAi4qiEIiwgIuKohiJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4gewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWY7CiAgICB2YXIgZk5hbWUgPSBmdW5jTmFtZTsKICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHsKICAgICAgZk5hbWUgPSBzaW5nbGVDaGFyQmlnT3BzW2ZOYW1lXTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJvcCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBsaW1pdHM6IHRydWUsCiAgICAgIHBhcmVudElzU3VwU3ViOiBmYWxzZSwKICAgICAgc3ltYm9sOiB0cnVlLAogICAgICBuYW1lOiBmTmFtZQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQyLAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJvcCIsCiAgbmFtZXM6IFsiXFxtYXRob3AiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMSwKICAgIHByaW1pdGl2ZTogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYyLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmMjsKICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJvcCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBsaW1pdHM6IGZhbHNlLAogICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsCiAgICAgIHN5bWJvbDogZmFsc2UsCiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDIsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxCn0pOwp2YXIgc2luZ2xlQ2hhckludGVncmFscyA9IHsKICAi4oirIjogIlxcaW50IiwKICAi4oisIjogIlxcaWludCIsCiAgIuKIrSI6ICJcXGlpaW50IiwKICAi4oiuIjogIlxcb2ludCIsCiAgIuKIryI6ICJcXG9paW50IiwKICAi4oiwIjogIlxcb2lpaW50Igp9OwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogIm9wIiwKICBuYW1lczogWyJcXGFyY3NpbiIsICJcXGFyY2NvcyIsICJcXGFyY3RhbiIsICJcXGFyY3RnIiwgIlxcYXJjY3RnIiwgIlxcYXJnIiwgIlxcY2giLCAiXFxjb3MiLCAiXFxjb3NlYyIsICJcXGNvc2giLCAiXFxjb3QiLCAiXFxjb3RnIiwgIlxcY290aCIsICJcXGNzYyIsICJcXGN0ZyIsICJcXGN0aCIsICJcXGRlZyIsICJcXGRpbSIsICJcXGV4cCIsICJcXGhvbSIsICJcXGtlciIsICJcXGxnIiwgIlxcbG4iLCAiXFxsb2ciLCAiXFxzZWMiLCAiXFxzaW4iLCAiXFxzaW5oIiwgIlxcc2giLCAiXFx0YW4iLCAiXFx0YW5oIiwgIlxcdGciLCAiXFx0aCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyKF9yZWYzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjM7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAib3AiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbGltaXRzOiBmYWxzZSwKICAgICAgcGFyZW50SXNTdXBTdWI6IGZhbHNlLAogICAgICBzeW1ib2w6IGZhbHNlLAogICAgICBuYW1lOiBmdW5jTmFtZQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiBodG1sQnVpbGRlciQyLAogIG1hdGhtbEJ1aWxkZXI6IG1hdGhtbEJ1aWxkZXIkMQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJvcCIsCiAgbmFtZXM6IFsiXFxkZXQiLCAiXFxnY2QiLCAiXFxpbmYiLCAiXFxsaW0iLCAiXFxtYXgiLCAiXFxtaW4iLCAiXFxQciIsICJcXHN1cCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyKF9yZWY0KSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjQ7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAib3AiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgbGltaXRzOiB0cnVlLAogICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsCiAgICAgIHN5bWJvbDogZmFsc2UsCiAgICAgIG5hbWU6IGZ1bmNOYW1lCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IGh0bWxCdWlsZGVyJDIsCiAgbWF0aG1sQnVpbGRlcjogbWF0aG1sQnVpbGRlciQxCn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogIm9wIiwKICBuYW1lczogWyJcXGludCIsICJcXGlpbnQiLCAiXFxpaWludCIsICJcXG9pbnQiLCAiXFxvaWludCIsICJcXG9paWludCIsICLiiKsiLCAi4oisIiwgIuKIrSIsICLiiK4iLCAi4oivIiwgIuKIsCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwCiAgfSwKICBoYW5kbGVyKF9yZWY1KSB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjU7CiAgICB2YXIgZk5hbWUgPSBmdW5jTmFtZTsKICAgIGlmIChmTmFtZS5sZW5ndGggPT09IDEpIHsKICAgICAgZk5hbWUgPSBzaW5nbGVDaGFySW50ZWdyYWxzW2ZOYW1lXTsKICAgIH0KICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJvcCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBsaW1pdHM6IGZhbHNlLAogICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UsCiAgICAgIHN5bWJvbDogdHJ1ZSwKICAgICAgbmFtZTogZk5hbWUKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMiwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyJDEKfSk7CnZhciBodG1sQnVpbGRlciQxID0gKGdycCwgb3B0aW9ucykgPT4gewogIHZhciBzdXBHcm91cDsKICB2YXIgc3ViR3JvdXA7CiAgdmFyIGhhc0xpbWl0cyA9IGZhbHNlOwogIHZhciBncm91cDsKICBpZiAoZ3JwLnR5cGUgPT09ICJzdXBzdWIiKSB7CiAgICBzdXBHcm91cCA9IGdycC5zdXA7CiAgICBzdWJHcm91cCA9IGdycC5zdWI7CiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycC5iYXNlLCAib3BlcmF0b3JuYW1lIik7CiAgICBoYXNMaW1pdHMgPSB0cnVlOwogIH0gZWxzZSB7CiAgICBncm91cCA9IGFzc2VydE5vZGVUeXBlKGdycCwgIm9wZXJhdG9ybmFtZSIpOwogIH0KICB2YXIgYmFzZTsKICBpZiAoZ3JvdXAuYm9keS5sZW5ndGggPiAwKSB7CiAgICB2YXIgYm9keSA9IGdyb3VwLmJvZHkubWFwKChjaGlsZDIpID0+IHsKICAgICAgdmFyIGNoaWxkVGV4dCA9IGNoaWxkMi50ZXh0OwogICAgICBpZiAodHlwZW9mIGNoaWxkVGV4dCA9PT0gInN0cmluZyIpIHsKICAgICAgICByZXR1cm4gewogICAgICAgICAgdHlwZTogInRleHRvcmQiLAogICAgICAgICAgbW9kZTogY2hpbGQyLm1vZGUsCiAgICAgICAgICB0ZXh0OiBjaGlsZFRleHQKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIHJldHVybiBjaGlsZDI7CiAgICAgIH0KICAgIH0pOwogICAgdmFyIGV4cHJlc3Npb24gPSBidWlsZEV4cHJlc3Npb24kMShib2R5LCBvcHRpb25zLndpdGhGb250KCJtYXRocm0iKSwgdHJ1ZSk7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cHJlc3Npb24ubGVuZ3RoOyBpKyspIHsKICAgICAgdmFyIGNoaWxkID0gZXhwcmVzc2lvbltpXTsKICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sTm9kZSkgewogICAgICAgIGNoaWxkLnRleHQgPSBjaGlsZC50ZXh0LnJlcGxhY2UoL1x1MjIxMi8sICItIikucmVwbGFjZSgvXHUyMjE3LywgIioiKTsKICAgICAgfQogICAgfQogICAgYmFzZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9wIl0sIGV4cHJlc3Npb24sIG9wdGlvbnMpOwogIH0gZWxzZSB7CiAgICBiYXNlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3AiXSwgW10sIG9wdGlvbnMpOwogIH0KICBpZiAoaGFzTGltaXRzKSB7CiAgICByZXR1cm4gYXNzZW1ibGVTdXBTdWIoYmFzZSwgc3VwR3JvdXAsIHN1Ykdyb3VwLCBvcHRpb25zLCBvcHRpb25zLnN0eWxlLCAwLCAwKTsKICB9IGVsc2UgewogICAgcmV0dXJuIGJhc2U7CiAgfQp9Owp2YXIgbWF0aG1sQnVpbGRlcjIgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgZXhwcmVzc2lvbiA9IGJ1aWxkRXhwcmVzc2lvbjIoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoRm9udCgibWF0aHJtIikpOwogIHZhciBpc0FsbFN0cmluZyA9IHRydWU7CiAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHByZXNzaW9uLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgbm9kZSA9IGV4cHJlc3Npb25baV07CiAgICBpZiAobm9kZSBpbnN0YW5jZW9mIG1hdGhNTFRyZWUuU3BhY2VOb2RlKSA7CiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5NYXRoTm9kZSkgewogICAgICBzd2l0Y2ggKG5vZGUudHlwZSkgewogICAgICAgIGNhc2UgIm1pIjoKICAgICAgICBjYXNlICJtbiI6CiAgICAgICAgY2FzZSAibXMiOgogICAgICAgIGNhc2UgIm1zcGFjZSI6CiAgICAgICAgY2FzZSAibXRleHQiOgogICAgICAgICAgYnJlYWs7CiAgICAgICAgY2FzZSAibW8iOiB7CiAgICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdOwogICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIGNoaWxkIGluc3RhbmNlb2YgbWF0aE1MVHJlZS5UZXh0Tm9kZSkgewogICAgICAgICAgICBjaGlsZC50ZXh0ID0gY2hpbGQudGV4dC5yZXBsYWNlKC9cdTIyMTIvLCAiLSIpLnJlcGxhY2UoL1x1MjIxNy8sICIqIik7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgICAgYnJlYWs7CiAgICAgICAgfQogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICBpc0FsbFN0cmluZyA9IGZhbHNlOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICBpc0FsbFN0cmluZyA9IGZhbHNlOwogICAgfQogIH0KICBpZiAoaXNBbGxTdHJpbmcpIHsKICAgIHZhciB3b3JkID0gZXhwcmVzc2lvbi5tYXAoKG5vZGUyKSA9PiBub2RlMi50b1RleHQoKSkuam9pbigiIik7CiAgICBleHByZXNzaW9uID0gW25ldyBtYXRoTUxUcmVlLlRleHROb2RlKHdvcmQpXTsKICB9CiAgdmFyIGlkZW50aWZpZXIgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibWkiLCBleHByZXNzaW9uKTsKICBpZGVudGlmaWVyLnNldEF0dHJpYnV0ZSgibWF0aHZhcmlhbnQiLCAibm9ybWFsIik7CiAgdmFyIG9wZXJhdG9yID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1vIiwgW21ha2VUZXh0KCLigaEiLCAidGV4dCIpXSk7CiAgaWYgKGdyb3VwLnBhcmVudElzU3VwU3ViKSB7CiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1yb3ciLCBbaWRlbnRpZmllciwgb3BlcmF0b3JdKTsKICB9IGVsc2UgewogICAgcmV0dXJuIG1hdGhNTFRyZWUubmV3RG9jdW1lbnRGcmFnbWVudChbaWRlbnRpZmllciwgb3BlcmF0b3JdKTsKICB9Cn07CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAib3BlcmF0b3JuYW1lIiwKICBuYW1lczogWyJcXG9wZXJhdG9ybmFtZUAiLCAiXFxvcGVyYXRvcm5hbWV3aXRobGltaXRzIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEKICB9LAogIGhhbmRsZXI6IChfcmVmLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIsCiAgICAgIGZ1bmNOYW1lCiAgICB9ID0gX3JlZjsKICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJvcGVyYXRvcm5hbWUiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgYm9keTogb3JkYXJndW1lbnQoYm9keSksCiAgICAgIGFsd2F5c0hhbmRsZVN1cFN1YjogZnVuY05hbWUgPT09ICJcXG9wZXJhdG9ybmFtZXdpdGhsaW1pdHMiLAogICAgICBsaW1pdHM6IGZhbHNlLAogICAgICBwYXJlbnRJc1N1cFN1YjogZmFsc2UKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIkMSwKICBtYXRobWxCdWlsZGVyOiBtYXRobWxCdWlsZGVyMgp9KTsKZGVmaW5lTWFjcm8oIlxcb3BlcmF0b3JuYW1lIiwgIlxcQGlmc3Rhclxcb3BlcmF0b3JuYW1ld2l0aGxpbWl0c1xcb3BlcmF0b3JuYW1lQCIpOwpkZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHsKICB0eXBlOiAib3JkZ3JvdXAiLAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICBpZiAoZ3JvdXAuc2VtaXNpbXBsZSkgewogICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIGZhbHNlKSk7CiAgICB9CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3JkIl0sIGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHJldHVybiBidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAuYm9keSwgb3B0aW9ucywgdHJ1ZSk7CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJvdmVybGluZSIsCiAgbmFtZXM6IFsiXFxvdmVybGluZSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgYm9keSA9IGFyZ3NbMF07CiAgICByZXR1cm4gewogICAgICB0eXBlOiAib3ZlcmxpbmUiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgYm9keQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgaW5uZXJHcm91cCA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsKICAgIHZhciBsaW5lID0gYnVpbGRDb21tb24ubWFrZUxpbmVTcGFuKCJvdmVybGluZS1saW5lIiwgb3B0aW9ucyk7CiAgICB2YXIgZGVmYXVsdFJ1bGVUaGlja25lc3MgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3M7CiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJmaXJzdEJhc2VsaW5lIiwKICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGlubmVyR3JvdXAKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJrZXJuIiwKICAgICAgICBzaXplOiAzICogZGVmYXVsdFJ1bGVUaGlja25lc3MKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBsaW5lCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZTogZGVmYXVsdFJ1bGVUaGlja25lc3MKICAgICAgfV0KICAgIH0sIG9wdGlvbnMpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9yZCIsICJvdmVybGluZSJdLCBbdmxpc3RdLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtbyIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSgi4oC+IildKTsKICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZSgic3RyZXRjaHkiLCAidHJ1ZSIpOwogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibW92ZXIiLCBbYnVpbGRHcm91cDIoZ3JvdXAuYm9keSwgb3B0aW9ucyksIG9wZXJhdG9yXSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgiYWNjZW50IiwgInRydWUiKTsKICAgIHJldHVybiBub2RlOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAicGhhbnRvbSIsCiAgbmFtZXM6IFsiXFxwaGFudG9tIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4gewogICAgdmFyIHsKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjsKICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJwaGFudG9tIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGJvZHk6IG9yZGFyZ3VtZW50KGJvZHkpCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGVsZW1lbnRzID0gYnVpbGRFeHByZXNzaW9uJDEoZ3JvdXAuYm9keSwgb3B0aW9ucy53aXRoUGhhbnRvbSgpLCBmYWxzZSk7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZUZyYWdtZW50KGVsZW1lbnRzKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGlubmVyMiA9IGJ1aWxkRXhwcmVzc2lvbjIoZ3JvdXAuYm9keSwgb3B0aW9ucyk7CiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1waGFudG9tIiwgaW5uZXIyKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogImhwaGFudG9tIiwKICBuYW1lczogWyJcXGhwaGFudG9tIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyOiAoX3JlZjIsIGFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWYyOwogICAgdmFyIGJvZHkgPSBhcmdzWzBdOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImhwaGFudG9tIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIGJvZHkKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgICB2YXIgbm9kZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFtdLCBbYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMud2l0aFBoYW50b20oKSldKTsKICAgIG5vZGUuaGVpZ2h0ID0gMDsKICAgIG5vZGUuZGVwdGggPSAwOwogICAgaWYgKG5vZGUuY2hpbGRyZW4pIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwOwogICAgICAgIG5vZGUuY2hpbGRyZW5baV0uZGVwdGggPSAwOwogICAgICB9CiAgICB9CiAgICBub2RlID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgcG9zaXRpb25UeXBlOiAiZmlyc3RCYXNlbGluZSIsCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBub2RlCiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiXSwgW25vZGVdLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGlubmVyMiA9IGJ1aWxkRXhwcmVzc2lvbjIob3JkYXJndW1lbnQoZ3JvdXAuYm9keSksIG9wdGlvbnMpOwogICAgdmFyIHBoYW50b20gPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXBoYW50b20iLCBpbm5lcjIpOwogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXBhZGRlZCIsIFtwaGFudG9tXSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgiaGVpZ2h0IiwgIjBweCIpOwogICAgbm9kZS5zZXRBdHRyaWJ1dGUoImRlcHRoIiwgIjBweCIpOwogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJ2cGhhbnRvbSIsCiAgbmFtZXM6IFsiXFx2cGhhbnRvbSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYzLCBhcmdzKSA9PiB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmMzsKICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJ2cGhhbnRvbSIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBib2R5CiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIGlubmVyMiA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsiaW5uZXIiXSwgW2J1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zLndpdGhQaGFudG9tKCkpXSk7CiAgICB2YXIgZml4ID0gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJmaXgiXSwgW10pOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9yZCIsICJybGFwIl0sIFtpbm5lcjIsIGZpeF0sIG9wdGlvbnMpOwogIH0sCiAgbWF0aG1sQnVpbGRlcjogKGdyb3VwLCBvcHRpb25zKSA9PiB7CiAgICB2YXIgaW5uZXIyID0gYnVpbGRFeHByZXNzaW9uMihvcmRhcmd1bWVudChncm91cC5ib2R5KSwgb3B0aW9ucyk7CiAgICB2YXIgcGhhbnRvbSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcGhhbnRvbSIsIGlubmVyMik7CiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcGFkZGVkIiwgW3BoYW50b21dKTsKICAgIG5vZGUuc2V0QXR0cmlidXRlKCJ3aWR0aCIsICIwcHgiKTsKICAgIHJldHVybiBub2RlOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAicmFpc2Vib3giLAogIG5hbWVzOiBbIlxccmFpc2Vib3giXSwKICBwcm9wczogewogICAgbnVtQXJnczogMiwKICAgIGFyZ1R5cGVzOiBbInNpemUiLCAiaGJveCJdLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmOwogICAgdmFyIGFtb3VudCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sICJzaXplIikudmFsdWU7CiAgICB2YXIgYm9keSA9IGFyZ3NbMV07CiAgICByZXR1cm4gewogICAgICB0eXBlOiAicmFpc2Vib3giLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgZHk6IGFtb3VudCwKICAgICAgYm9keQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgYm9keSA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zKTsKICAgIHZhciBkeSA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuZHksIG9wdGlvbnMpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgIHBvc2l0aW9uVHlwZTogInNoaWZ0IiwKICAgICAgcG9zaXRpb25EYXRhOiAtZHksCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBib2R5CiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1wYWRkZWQiLCBbYnVpbGRHcm91cDIoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTsKICAgIHZhciBkeSA9IGdyb3VwLmR5Lm51bWJlciArIGdyb3VwLmR5LnVuaXQ7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgidm9mZnNldCIsIGR5KTsKICAgIHJldHVybiBub2RlOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAiaW50ZXJuYWwiLAogIG5hbWVzOiBbIlxccmVsYXgiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMCwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogImludGVybmFsIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUKICAgIH07CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJydWxlIiwKICBuYW1lczogWyJcXHJ1bGUiXSwKICBwcm9wczogewogICAgbnVtQXJnczogMiwKICAgIG51bU9wdGlvbmFsQXJnczogMSwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUsCiAgICBhbGxvd2VkSW5NYXRoOiB0cnVlLAogICAgYXJnVHlwZXM6IFsic2l6ZSIsICJzaXplIiwgInNpemUiXQogIH0sCiAgaGFuZGxlcihfcmVmLCBhcmdzLCBvcHRBcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmOwogICAgdmFyIHNoaWZ0ID0gb3B0QXJnc1swXTsKICAgIHZhciB3aWR0aCA9IGFzc2VydE5vZGVUeXBlKGFyZ3NbMF0sICJzaXplIik7CiAgICB2YXIgaGVpZ2h0ID0gYXNzZXJ0Tm9kZVR5cGUoYXJnc1sxXSwgInNpemUiKTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJydWxlIiwKICAgICAgbW9kZTogcGFyc2VyLm1vZGUsCiAgICAgIHNoaWZ0OiBzaGlmdCAmJiBhc3NlcnROb2RlVHlwZShzaGlmdCwgInNpemUiKS52YWx1ZSwKICAgICAgd2lkdGg6IHdpZHRoLnZhbHVlLAogICAgICBoZWlnaHQ6IGhlaWdodC52YWx1ZQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgcnVsZSA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9yZCIsICJydWxlIl0sIFtdLCBvcHRpb25zKTsKICAgIHZhciB3aWR0aCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAud2lkdGgsIG9wdGlvbnMpOwogICAgdmFyIGhlaWdodCA9IGNhbGN1bGF0ZVNpemUoZ3JvdXAuaGVpZ2h0LCBvcHRpb25zKTsKICAgIHZhciBzaGlmdCA9IGdyb3VwLnNoaWZ0ID8gY2FsY3VsYXRlU2l6ZShncm91cC5zaGlmdCwgb3B0aW9ucykgOiAwOwogICAgcnVsZS5zdHlsZS5ib3JkZXJSaWdodFdpZHRoID0gbWFrZUVtKHdpZHRoKTsKICAgIHJ1bGUuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBtYWtlRW0oaGVpZ2h0KTsKICAgIHJ1bGUuc3R5bGUuYm90dG9tID0gbWFrZUVtKHNoaWZ0KTsKICAgIHJ1bGUud2lkdGggPSB3aWR0aDsKICAgIHJ1bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgc2hpZnQ7CiAgICBydWxlLmRlcHRoID0gLXNoaWZ0OwogICAgcnVsZS5tYXhGb250U2l6ZSA9IGhlaWdodCAqIDEuMTI1ICogb3B0aW9ucy5zaXplTXVsdGlwbGllcjsKICAgIHJldHVybiBydWxlOwogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIHdpZHRoID0gY2FsY3VsYXRlU2l6ZShncm91cC53aWR0aCwgb3B0aW9ucyk7CiAgICB2YXIgaGVpZ2h0ID0gY2FsY3VsYXRlU2l6ZShncm91cC5oZWlnaHQsIG9wdGlvbnMpOwogICAgdmFyIHNoaWZ0ID0gZ3JvdXAuc2hpZnQgPyBjYWxjdWxhdGVTaXplKGdyb3VwLnNoaWZ0LCBvcHRpb25zKSA6IDA7CiAgICB2YXIgY29sb3IgPSBvcHRpb25zLmNvbG9yICYmIG9wdGlvbnMuZ2V0Q29sb3IoKSB8fCAiYmxhY2siOwogICAgdmFyIHJ1bGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXNwYWNlIik7CiAgICBydWxlLnNldEF0dHJpYnV0ZSgibWF0aGJhY2tncm91bmQiLCBjb2xvcik7CiAgICBydWxlLnNldEF0dHJpYnV0ZSgid2lkdGgiLCBtYWtlRW0od2lkdGgpKTsKICAgIHJ1bGUuc2V0QXR0cmlidXRlKCJoZWlnaHQiLCBtYWtlRW0oaGVpZ2h0KSk7CiAgICB2YXIgd3JhcHBlciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcGFkZGVkIiwgW3J1bGVdKTsKICAgIGlmIChzaGlmdCA+PSAwKSB7CiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCJoZWlnaHQiLCBtYWtlRW0oc2hpZnQpKTsKICAgIH0gZWxzZSB7CiAgICAgIHdyYXBwZXIuc2V0QXR0cmlidXRlKCJoZWlnaHQiLCBtYWtlRW0oc2hpZnQpKTsKICAgICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoImRlcHRoIiwgbWFrZUVtKC1zaGlmdCkpOwogICAgfQogICAgd3JhcHBlci5zZXRBdHRyaWJ1dGUoInZvZmZzZXQiLCBtYWtlRW0oc2hpZnQpKTsKICAgIHJldHVybiB3cmFwcGVyOwogIH0KfSk7CmZ1bmN0aW9uIHNpemluZ0dyb3VwKHZhbHVlLCBvcHRpb25zLCBiYXNlT3B0aW9ucykgewogIHZhciBpbm5lcjIgPSBidWlsZEV4cHJlc3Npb24kMSh2YWx1ZSwgb3B0aW9ucywgZmFsc2UpOwogIHZhciBtdWx0aXBsaWVyID0gb3B0aW9ucy5zaXplTXVsdGlwbGllciAvIGJhc2VPcHRpb25zLnNpemVNdWx0aXBsaWVyOwogIGZvciAodmFyIGkgPSAwOyBpIDwgaW5uZXIyLmxlbmd0aDsgaSsrKSB7CiAgICB2YXIgcG9zID0gaW5uZXIyW2ldLmNsYXNzZXMuaW5kZXhPZigic2l6aW5nIik7CiAgICBpZiAocG9zIDwgMCkgewogICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShpbm5lcjJbaV0uY2xhc3Nlcywgb3B0aW9ucy5zaXppbmdDbGFzc2VzKGJhc2VPcHRpb25zKSk7CiAgICB9IGVsc2UgaWYgKGlubmVyMltpXS5jbGFzc2VzW3BvcyArIDFdID09PSAicmVzZXQtc2l6ZSIgKyBvcHRpb25zLnNpemUpIHsKICAgICAgaW5uZXIyW2ldLmNsYXNzZXNbcG9zICsgMV0gPSAicmVzZXQtc2l6ZSIgKyBiYXNlT3B0aW9ucy5zaXplOwogICAgfQogICAgaW5uZXIyW2ldLmhlaWdodCAqPSBtdWx0aXBsaWVyOwogICAgaW5uZXIyW2ldLmRlcHRoICo9IG11bHRpcGxpZXI7CiAgfQogIHJldHVybiBidWlsZENvbW1vbi5tYWtlRnJhZ21lbnQoaW5uZXIyKTsKfQp2YXIgc2l6ZUZ1bmNzID0gWyJcXHRpbnkiLCAiXFxzaXhwdHNpemUiLCAiXFxzY3JpcHRzaXplIiwgIlxcZm9vdG5vdGVzaXplIiwgIlxcc21hbGwiLCAiXFxub3JtYWxzaXplIiwgIlxcbGFyZ2UiLCAiXFxMYXJnZSIsICJcXExBUkdFIiwgIlxcaHVnZSIsICJcXEh1Z2UiXTsKdmFyIGh0bWxCdWlsZGVyMiA9IChncm91cCwgb3B0aW9ucykgPT4gewogIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTaXplKGdyb3VwLnNpemUpOwogIHJldHVybiBzaXppbmdHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKTsKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJzaXppbmciLAogIG5hbWVzOiBzaXplRnVuY3MsCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDAsCiAgICBhbGxvd2VkSW5UZXh0OiB0cnVlCiAgfSwKICBoYW5kbGVyOiAoX3JlZiwgYXJncykgPT4gewogICAgdmFyIHsKICAgICAgYnJlYWtPblRva2VuVGV4dCwKICAgICAgZnVuY05hbWUsCiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgYm9keSA9IHBhcnNlci5wYXJzZUV4cHJlc3Npb24oZmFsc2UsIGJyZWFrT25Ub2tlblRleHQpOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogInNpemluZyIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICAvLyBGaWd1cmUgb3V0IHdoYXQgc2l6ZSB0byB1c2UgYmFzZWQgb24gdGhlIGxpc3Qgb2YgZnVuY3Rpb25zIGFib3ZlCiAgICAgIHNpemU6IHNpemVGdW5jcy5pbmRleE9mKGZ1bmNOYW1lKSArIDEsCiAgICAgIGJvZHkKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcjogaHRtbEJ1aWxkZXIyLAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1NpemUoZ3JvdXAuc2l6ZSk7CiAgICB2YXIgaW5uZXIyID0gYnVpbGRFeHByZXNzaW9uMihncm91cC5ib2R5LCBuZXdPcHRpb25zKTsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1zdHlsZSIsIGlubmVyMik7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgibWF0aHNpemUiLCBtYWtlRW0obmV3T3B0aW9ucy5zaXplTXVsdGlwbGllcikpOwogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJzbWFzaCIsCiAgbmFtZXM6IFsiXFxzbWFzaCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgbnVtT3B0aW9uYWxBcmdzOiAxLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcjogKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpID0+IHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgc21hc2hIZWlnaHQgPSBmYWxzZTsKICAgIHZhciBzbWFzaERlcHRoID0gZmFsc2U7CiAgICB2YXIgdGJBcmcgPSBvcHRBcmdzWzBdICYmIGFzc2VydE5vZGVUeXBlKG9wdEFyZ3NbMF0sICJvcmRncm91cCIpOwogICAgaWYgKHRiQXJnKSB7CiAgICAgIHZhciBsZXR0ZXIgPSAiIjsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YkFyZy5ib2R5Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgdmFyIG5vZGUgPSB0YkFyZy5ib2R5W2ldOwogICAgICAgIGxldHRlciA9IG5vZGUudGV4dDsKICAgICAgICBpZiAobGV0dGVyID09PSAidCIpIHsKICAgICAgICAgIHNtYXNoSGVpZ2h0ID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgaWYgKGxldHRlciA9PT0gImIiKSB7CiAgICAgICAgICBzbWFzaERlcHRoID0gdHJ1ZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc21hc2hIZWlnaHQgPSBmYWxzZTsKICAgICAgICAgIHNtYXNoRGVwdGggPSBmYWxzZTsKICAgICAgICAgIGJyZWFrOwogICAgICAgIH0KICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgc21hc2hIZWlnaHQgPSB0cnVlOwogICAgICBzbWFzaERlcHRoID0gdHJ1ZTsKICAgIH0KICAgIHZhciBib2R5ID0gYXJnc1swXTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJzbWFzaCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBib2R5LAogICAgICBzbWFzaEhlaWdodCwKICAgICAgc21hc2hEZXB0aAogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyOiAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICAgIHZhciBub2RlID0gYnVpbGRDb21tb24ubWFrZVNwYW4oW10sIFtidWlsZEdyb3VwJDEoZ3JvdXAuYm9keSwgb3B0aW9ucyldKTsKICAgIGlmICghZ3JvdXAuc21hc2hIZWlnaHQgJiYgIWdyb3VwLnNtYXNoRGVwdGgpIHsKICAgICAgcmV0dXJuIG5vZGU7CiAgICB9CiAgICBpZiAoZ3JvdXAuc21hc2hIZWlnaHQpIHsKICAgICAgbm9kZS5oZWlnaHQgPSAwOwogICAgICBpZiAobm9kZS5jaGlsZHJlbikgewogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykgewogICAgICAgICAgbm9kZS5jaGlsZHJlbltpXS5oZWlnaHQgPSAwOwogICAgICAgIH0KICAgICAgfQogICAgfQogICAgaWYgKGdyb3VwLnNtYXNoRGVwdGgpIHsKICAgICAgbm9kZS5kZXB0aCA9IDA7CiAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7CiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBfaSsrKSB7CiAgICAgICAgICBub2RlLmNoaWxkcmVuW19pXS5kZXB0aCA9IDA7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICB2YXIgc21hc2hlZE5vZGUgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJmaXJzdEJhc2VsaW5lIiwKICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IG5vZGUKICAgICAgfV0KICAgIH0sIG9wdGlvbnMpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9yZCJdLCBbc21hc2hlZE5vZGVdLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXI6IChncm91cCwgb3B0aW9ucykgPT4gewogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXBhZGRlZCIsIFtidWlsZEdyb3VwMihncm91cC5ib2R5LCBvcHRpb25zKV0pOwogICAgaWYgKGdyb3VwLnNtYXNoSGVpZ2h0KSB7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJoZWlnaHQiLCAiMHB4Iik7CiAgICB9CiAgICBpZiAoZ3JvdXAuc21hc2hEZXB0aCkgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgiZGVwdGgiLCAiMHB4Iik7CiAgICB9CiAgICByZXR1cm4gbm9kZTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogInNxcnQiLAogIG5hbWVzOiBbIlxcc3FydCJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgbnVtT3B0aW9uYWxBcmdzOiAxCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MsIG9wdEFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICB2YXIgaW5kZXggPSBvcHRBcmdzWzBdOwogICAgdmFyIGJvZHkgPSBhcmdzWzBdOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogInNxcnQiLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgYm9keSwKICAgICAgaW5kZXgKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIGlubmVyMiA9IGJ1aWxkR3JvdXAkMShncm91cC5ib2R5LCBvcHRpb25zLmhhdmluZ0NyYW1wZWRTdHlsZSgpKTsKICAgIGlmIChpbm5lcjIuaGVpZ2h0ID09PSAwKSB7CiAgICAgIGlubmVyMi5oZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkueEhlaWdodDsKICAgIH0KICAgIGlubmVyMiA9IGJ1aWxkQ29tbW9uLndyYXBGcmFnbWVudChpbm5lcjIsIG9wdGlvbnMpOwogICAgdmFyIG1ldHJpY3MgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCk7CiAgICB2YXIgdGhldGEgPSBtZXRyaWNzLmRlZmF1bHRSdWxlVGhpY2tuZXNzOwogICAgdmFyIHBoaSA9IHRoZXRhOwogICAgaWYgKG9wdGlvbnMuc3R5bGUuaWQgPCBTdHlsZSQxLlRFWFQuaWQpIHsKICAgICAgcGhpID0gb3B0aW9ucy5mb250TWV0cmljcygpLnhIZWlnaHQ7CiAgICB9CiAgICB2YXIgbGluZUNsZWFyYW5jZSA9IHRoZXRhICsgcGhpIC8gNDsKICAgIHZhciBtaW5EZWxpbWl0ZXJIZWlnaHQgPSBpbm5lcjIuaGVpZ2h0ICsgaW5uZXIyLmRlcHRoICsgbGluZUNsZWFyYW5jZSArIHRoZXRhOwogICAgdmFyIHsKICAgICAgc3BhbjogaW1nLAogICAgICBydWxlV2lkdGgsCiAgICAgIGFkdmFuY2VXaWR0aAogICAgfSA9IGRlbGltaXRlci5zcXJ0SW1hZ2UobWluRGVsaW1pdGVySGVpZ2h0LCBvcHRpb25zKTsKICAgIHZhciBkZWxpbURlcHRoID0gaW1nLmhlaWdodCAtIHJ1bGVXaWR0aDsKICAgIGlmIChkZWxpbURlcHRoID4gaW5uZXIyLmhlaWdodCArIGlubmVyMi5kZXB0aCArIGxpbmVDbGVhcmFuY2UpIHsKICAgICAgbGluZUNsZWFyYW5jZSA9IChsaW5lQ2xlYXJhbmNlICsgZGVsaW1EZXB0aCAtIGlubmVyMi5oZWlnaHQgLSBpbm5lcjIuZGVwdGgpIC8gMjsKICAgIH0KICAgIHZhciBpbWdTaGlmdCA9IGltZy5oZWlnaHQgLSBpbm5lcjIuaGVpZ2h0IC0gbGluZUNsZWFyYW5jZSAtIHJ1bGVXaWR0aDsKICAgIGlubmVyMi5zdHlsZS5wYWRkaW5nTGVmdCA9IG1ha2VFbShhZHZhbmNlV2lkdGgpOwogICAgdmFyIGJvZHkgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJmaXJzdEJhc2VsaW5lIiwKICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGlubmVyMiwKICAgICAgICB3cmFwcGVyQ2xhc3NlczogWyJzdmctYWxpZ24iXQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImtlcm4iLAogICAgICAgIHNpemU6IC0oaW5uZXIyLmhlaWdodCArIGltZ1NoaWZ0KQogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IGltZwogICAgICB9LCB7CiAgICAgICAgdHlwZTogImtlcm4iLAogICAgICAgIHNpemU6IHJ1bGVXaWR0aAogICAgICB9XQogICAgfSwgb3B0aW9ucyk7CiAgICBpZiAoIWdyb3VwLmluZGV4KSB7CiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiLCAic3FydCJdLCBbYm9keV0sIG9wdGlvbnMpOwogICAgfSBlbHNlIHsKICAgICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKFN0eWxlJDEuU0NSSVBUU0NSSVBUKTsKICAgICAgdmFyIHJvb3RtID0gYnVpbGRHcm91cCQxKGdyb3VwLmluZGV4LCBuZXdPcHRpb25zLCBvcHRpb25zKTsKICAgICAgdmFyIHRvU2hpZnQgPSAwLjYgKiAoYm9keS5oZWlnaHQgLSBib2R5LmRlcHRoKTsKICAgICAgdmFyIHJvb3RWTGlzdCA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgICAgcG9zaXRpb25UeXBlOiAic2hpZnQiLAogICAgICAgIHBvc2l0aW9uRGF0YTogLXRvU2hpZnQsCiAgICAgICAgY2hpbGRyZW46IFt7CiAgICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgICBlbGVtOiByb290bQogICAgICAgIH1dCiAgICAgIH0sIG9wdGlvbnMpOwogICAgICB2YXIgcm9vdFZMaXN0V3JhcCA9IGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsicm9vdCJdLCBbcm9vdFZMaXN0XSk7CiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiLCAic3FydCJdLCBbcm9vdFZMaXN0V3JhcCwgYm9keV0sIG9wdGlvbnMpOwogICAgfQogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIHsKICAgICAgYm9keSwKICAgICAgaW5kZXgKICAgIH0gPSBncm91cDsKICAgIHJldHVybiBpbmRleCA/IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtcm9vdCIsIFtidWlsZEdyb3VwMihib2R5LCBvcHRpb25zKSwgYnVpbGRHcm91cDIoaW5kZXgsIG9wdGlvbnMpXSkgOiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXNxcnQiLCBbYnVpbGRHcm91cDIoYm9keSwgb3B0aW9ucyldKTsKICB9Cn0pOwp2YXIgc3R5bGVNYXAgPSB7CiAgImRpc3BsYXkiOiBTdHlsZSQxLkRJU1BMQVksCiAgInRleHQiOiBTdHlsZSQxLlRFWFQsCiAgInNjcmlwdCI6IFN0eWxlJDEuU0NSSVBULAogICJzY3JpcHRzY3JpcHQiOiBTdHlsZSQxLlNDUklQVFNDUklQVAp9OwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogInN0eWxpbmciLAogIG5hbWVzOiBbIlxcZGlzcGxheXN0eWxlIiwgIlxcdGV4dHN0eWxlIiwgIlxcc2NyaXB0c3R5bGUiLCAiXFxzY3JpcHRzY3JpcHRzdHlsZSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZSwKICAgIHByaW1pdGl2ZTogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBicmVha09uVG9rZW5UZXh0LAogICAgICBmdW5jTmFtZSwKICAgICAgcGFyc2VyCiAgICB9ID0gX3JlZjsKICAgIHZhciBib2R5ID0gcGFyc2VyLnBhcnNlRXhwcmVzc2lvbih0cnVlLCBicmVha09uVG9rZW5UZXh0KTsKICAgIHZhciBzdHlsZSA9IGZ1bmNOYW1lLnNsaWNlKDEsIGZ1bmNOYW1lLmxlbmd0aCAtIDUpOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogInN0eWxpbmciLAogICAgICBtb2RlOiBwYXJzZXIubW9kZSwKICAgICAgLy8gRmlndXJlIG91dCB3aGF0IHN0eWxlIHRvIHVzZSBieSBwdWxsaW5nIG91dCB0aGUgc3R5bGUgZnJvbQogICAgICAvLyB0aGUgZnVuY3Rpb24gbmFtZQogICAgICBzdHlsZSwKICAgICAgYm9keQogICAgfTsKICB9LAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgbmV3U3R5bGUgPSBzdHlsZU1hcFtncm91cC5zdHlsZV07CiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnMuaGF2aW5nU3R5bGUobmV3U3R5bGUpLndpdGhGb250KCIiKTsKICAgIHJldHVybiBzaXppbmdHcm91cChncm91cC5ib2R5LCBuZXdPcHRpb25zLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBuZXdTdHlsZSA9IHN0eWxlTWFwW2dyb3VwLnN0eWxlXTsKICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShuZXdTdHlsZSk7CiAgICB2YXIgaW5uZXIyID0gYnVpbGRFeHByZXNzaW9uMihncm91cC5ib2R5LCBuZXdPcHRpb25zKTsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1zdHlsZSIsIGlubmVyMik7CiAgICB2YXIgc3R5bGVBdHRyaWJ1dGVzID0gewogICAgICAiZGlzcGxheSI6IFsiMCIsICJ0cnVlIl0sCiAgICAgICJ0ZXh0IjogWyIwIiwgImZhbHNlIl0sCiAgICAgICJzY3JpcHQiOiBbIjEiLCAiZmFsc2UiXSwKICAgICAgInNjcmlwdHNjcmlwdCI6IFsiMiIsICJmYWxzZSJdCiAgICB9OwogICAgdmFyIGF0dHIgPSBzdHlsZUF0dHJpYnV0ZXNbZ3JvdXAuc3R5bGVdOwogICAgbm9kZS5zZXRBdHRyaWJ1dGUoInNjcmlwdGxldmVsIiwgYXR0clswXSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgiZGlzcGxheXN0eWxlIiwgYXR0clsxXSk7CiAgICByZXR1cm4gbm9kZTsKICB9Cn0pOwp2YXIgaHRtbEJ1aWxkZXJEZWxlZ2F0ZSA9IGZ1bmN0aW9uIGh0bWxCdWlsZGVyRGVsZWdhdGUyKGdyb3VwLCBvcHRpb25zKSB7CiAgdmFyIGJhc2UgPSBncm91cC5iYXNlOwogIGlmICghYmFzZSkgewogICAgcmV0dXJuIG51bGw7CiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09ICJvcCIpIHsKICAgIHZhciBkZWxlZ2F0ZSA9IGJhc2UubGltaXRzICYmIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKTsKICAgIHJldHVybiBkZWxlZ2F0ZSA/IGh0bWxCdWlsZGVyJDIgOiBudWxsOwogIH0gZWxzZSBpZiAoYmFzZS50eXBlID09PSAib3BlcmF0b3JuYW1lIikgewogICAgdmFyIF9kZWxlZ2F0ZSA9IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViICYmIChvcHRpb25zLnN0eWxlLnNpemUgPT09IFN0eWxlJDEuRElTUExBWS5zaXplIHx8IGJhc2UubGltaXRzKTsKICAgIHJldHVybiBfZGVsZWdhdGUgPyBodG1sQnVpbGRlciQxIDogbnVsbDsKICB9IGVsc2UgaWYgKGJhc2UudHlwZSA9PT0gImFjY2VudCIpIHsKICAgIHJldHVybiB1dGlscy5pc0NoYXJhY3RlckJveChiYXNlLmJhc2UpID8gaHRtbEJ1aWxkZXIkYSA6IG51bGw7CiAgfSBlbHNlIGlmIChiYXNlLnR5cGUgPT09ICJob3JpekJyYWNlIikgewogICAgdmFyIGlzU3VwID0gIWdyb3VwLnN1YjsKICAgIHJldHVybiBpc1N1cCA9PT0gYmFzZS5pc092ZXIgPyBodG1sQnVpbGRlciQzIDogbnVsbDsKICB9IGVsc2UgewogICAgcmV0dXJuIG51bGw7CiAgfQp9OwpkZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHsKICB0eXBlOiAic3Vwc3ViIiwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIGJ1aWxkZXJEZWxlZ2F0ZSA9IGh0bWxCdWlsZGVyRGVsZWdhdGUoZ3JvdXAsIG9wdGlvbnMpOwogICAgaWYgKGJ1aWxkZXJEZWxlZ2F0ZSkgewogICAgICByZXR1cm4gYnVpbGRlckRlbGVnYXRlKGdyb3VwLCBvcHRpb25zKTsKICAgIH0KICAgIHZhciB7CiAgICAgIGJhc2U6IHZhbHVlQmFzZSwKICAgICAgc3VwOiB2YWx1ZVN1cCwKICAgICAgc3ViOiB2YWx1ZVN1YgogICAgfSA9IGdyb3VwOwogICAgdmFyIGJhc2UgPSBidWlsZEdyb3VwJDEodmFsdWVCYXNlLCBvcHRpb25zKTsKICAgIHZhciBzdXBtOwogICAgdmFyIHN1Ym07CiAgICB2YXIgbWV0cmljcyA9IG9wdGlvbnMuZm9udE1ldHJpY3MoKTsKICAgIHZhciBzdXBTaGlmdCA9IDA7CiAgICB2YXIgc3ViU2hpZnQgPSAwOwogICAgdmFyIGlzQ2hhcmFjdGVyQm94MyA9IHZhbHVlQmFzZSAmJiB1dGlscy5pc0NoYXJhY3RlckJveCh2YWx1ZUJhc2UpOwogICAgaWYgKHZhbHVlU3VwKSB7CiAgICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnN1cCgpKTsKICAgICAgc3VwbSA9IGJ1aWxkR3JvdXAkMSh2YWx1ZVN1cCwgbmV3T3B0aW9ucywgb3B0aW9ucyk7CiAgICAgIGlmICghaXNDaGFyYWN0ZXJCb3gzKSB7CiAgICAgICAgc3VwU2hpZnQgPSBiYXNlLmhlaWdodCAtIG5ld09wdGlvbnMuZm9udE1ldHJpY3MoKS5zdXBEcm9wICogbmV3T3B0aW9ucy5zaXplTXVsdGlwbGllciAvIG9wdGlvbnMuc2l6ZU11bHRpcGxpZXI7CiAgICAgIH0KICAgIH0KICAgIGlmICh2YWx1ZVN1YikgewogICAgICB2YXIgX25ld09wdGlvbnMgPSBvcHRpb25zLmhhdmluZ1N0eWxlKG9wdGlvbnMuc3R5bGUuc3ViKCkpOwogICAgICBzdWJtID0gYnVpbGRHcm91cCQxKHZhbHVlU3ViLCBfbmV3T3B0aW9ucywgb3B0aW9ucyk7CiAgICAgIGlmICghaXNDaGFyYWN0ZXJCb3gzKSB7CiAgICAgICAgc3ViU2hpZnQgPSBiYXNlLmRlcHRoICsgX25ld09wdGlvbnMuZm9udE1ldHJpY3MoKS5zdWJEcm9wICogX25ld09wdGlvbnMuc2l6ZU11bHRpcGxpZXIgLyBvcHRpb25zLnNpemVNdWx0aXBsaWVyOwogICAgICB9CiAgICB9CiAgICB2YXIgbWluU3VwU2hpZnQ7CiAgICBpZiAob3B0aW9ucy5zdHlsZSA9PT0gU3R5bGUkMS5ESVNQTEFZKSB7CiAgICAgIG1pblN1cFNoaWZ0ID0gbWV0cmljcy5zdXAxOwogICAgfSBlbHNlIGlmIChvcHRpb25zLnN0eWxlLmNyYW1wZWQpIHsKICAgICAgbWluU3VwU2hpZnQgPSBtZXRyaWNzLnN1cDM7CiAgICB9IGVsc2UgewogICAgICBtaW5TdXBTaGlmdCA9IG1ldHJpY3Muc3VwMjsKICAgIH0KICAgIHZhciBtdWx0aXBsaWVyID0gb3B0aW9ucy5zaXplTXVsdGlwbGllcjsKICAgIHZhciBtYXJnaW5SaWdodCA9IG1ha2VFbSgwLjUgLyBtZXRyaWNzLnB0UGVyRW0gLyBtdWx0aXBsaWVyKTsKICAgIHZhciBtYXJnaW5MZWZ0ID0gbnVsbDsKICAgIGlmIChzdWJtKSB7CiAgICAgIHZhciBpc09paW50ID0gZ3JvdXAuYmFzZSAmJiBncm91cC5iYXNlLnR5cGUgPT09ICJvcCIgJiYgZ3JvdXAuYmFzZS5uYW1lICYmIChncm91cC5iYXNlLm5hbWUgPT09ICJcXG9paW50IiB8fCBncm91cC5iYXNlLm5hbWUgPT09ICJcXG9paWludCIpOwogICAgICBpZiAoYmFzZSBpbnN0YW5jZW9mIFN5bWJvbE5vZGUgfHwgaXNPaWludCkgewogICAgICAgIG1hcmdpbkxlZnQgPSBtYWtlRW0oLWJhc2UuaXRhbGljKTsKICAgICAgfQogICAgfQogICAgdmFyIHN1cHN1YjsKICAgIGlmIChzdXBtICYmIHN1Ym0pIHsKICAgICAgc3VwU2hpZnQgPSBNYXRoLm1heChzdXBTaGlmdCwgbWluU3VwU2hpZnQsIHN1cG0uZGVwdGggKyAwLjI1ICogbWV0cmljcy54SGVpZ2h0KTsKICAgICAgc3ViU2hpZnQgPSBNYXRoLm1heChzdWJTaGlmdCwgbWV0cmljcy5zdWIyKTsKICAgICAgdmFyIHJ1bGVXaWR0aCA9IG1ldHJpY3MuZGVmYXVsdFJ1bGVUaGlja25lc3M7CiAgICAgIHZhciBtYXhXaWR0aCA9IDQgKiBydWxlV2lkdGg7CiAgICAgIGlmIChzdXBTaGlmdCAtIHN1cG0uZGVwdGggLSAoc3VibS5oZWlnaHQgLSBzdWJTaGlmdCkgPCBtYXhXaWR0aCkgewogICAgICAgIHN1YlNoaWZ0ID0gbWF4V2lkdGggLSAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoKSArIHN1Ym0uaGVpZ2h0OwogICAgICAgIHZhciBwc2kgPSAwLjggKiBtZXRyaWNzLnhIZWlnaHQgLSAoc3VwU2hpZnQgLSBzdXBtLmRlcHRoKTsKICAgICAgICBpZiAocHNpID4gMCkgewogICAgICAgICAgc3VwU2hpZnQgKz0gcHNpOwogICAgICAgICAgc3ViU2hpZnQgLT0gcHNpOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgdmxpc3RFbGVtID0gW3sKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogc3VibSwKICAgICAgICBzaGlmdDogc3ViU2hpZnQsCiAgICAgICAgbWFyZ2luUmlnaHQsCiAgICAgICAgbWFyZ2luTGVmdAogICAgICB9LCB7CiAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgIGVsZW06IHN1cG0sCiAgICAgICAgc2hpZnQ6IC1zdXBTaGlmdCwKICAgICAgICBtYXJnaW5SaWdodAogICAgICB9XTsKICAgICAgc3Vwc3ViID0gYnVpbGRDb21tb24ubWFrZVZMaXN0KHsKICAgICAgICBwb3NpdGlvblR5cGU6ICJpbmRpdmlkdWFsU2hpZnQiLAogICAgICAgIGNoaWxkcmVuOiB2bGlzdEVsZW0KICAgICAgfSwgb3B0aW9ucyk7CiAgICB9IGVsc2UgaWYgKHN1Ym0pIHsKICAgICAgc3ViU2hpZnQgPSBNYXRoLm1heChzdWJTaGlmdCwgbWV0cmljcy5zdWIxLCBzdWJtLmhlaWdodCAtIDAuOCAqIG1ldHJpY3MueEhlaWdodCk7CiAgICAgIHZhciBfdmxpc3RFbGVtID0gW3sKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogc3VibSwKICAgICAgICBtYXJnaW5MZWZ0LAogICAgICAgIG1hcmdpblJpZ2h0CiAgICAgIH1dOwogICAgICBzdXBzdWIgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICAgIHBvc2l0aW9uVHlwZTogInNoaWZ0IiwKICAgICAgICBwb3NpdGlvbkRhdGE6IHN1YlNoaWZ0LAogICAgICAgIGNoaWxkcmVuOiBfdmxpc3RFbGVtCiAgICAgIH0sIG9wdGlvbnMpOwogICAgfSBlbHNlIGlmIChzdXBtKSB7CiAgICAgIHN1cFNoaWZ0ID0gTWF0aC5tYXgoc3VwU2hpZnQsIG1pblN1cFNoaWZ0LCBzdXBtLmRlcHRoICsgMC4yNSAqIG1ldHJpY3MueEhlaWdodCk7CiAgICAgIHN1cHN1YiA9IGJ1aWxkQ29tbW9uLm1ha2VWTGlzdCh7CiAgICAgICAgcG9zaXRpb25UeXBlOiAic2hpZnQiLAogICAgICAgIHBvc2l0aW9uRGF0YTogLXN1cFNoaWZ0LAogICAgICAgIGNoaWxkcmVuOiBbewogICAgICAgICAgdHlwZTogImVsZW0iLAogICAgICAgICAgZWxlbTogc3VwbSwKICAgICAgICAgIG1hcmdpblJpZ2h0CiAgICAgICAgfV0KICAgICAgfSwgb3B0aW9ucyk7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgRXJyb3IoInN1cHN1YiBtdXN0IGhhdmUgZWl0aGVyIHN1cCBvciBzdWIuIik7CiAgICB9CiAgICB2YXIgbWNsYXNzID0gZ2V0VHlwZU9mRG9tVHJlZShiYXNlLCAicmlnaHQiKSB8fCAibW9yZCI7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oW21jbGFzc10sIFtiYXNlLCBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1zdXBzdWIiXSwgW3N1cHN1Yl0pXSwgb3B0aW9ucyk7CiAgfSwKICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgaXNCcmFjZSA9IGZhbHNlOwogICAgdmFyIGlzT3ZlcjsKICAgIHZhciBpc1N1cDsKICAgIGlmIChncm91cC5iYXNlICYmIGdyb3VwLmJhc2UudHlwZSA9PT0gImhvcml6QnJhY2UiKSB7CiAgICAgIGlzU3VwID0gISFncm91cC5zdXA7CiAgICAgIGlmIChpc1N1cCA9PT0gZ3JvdXAuYmFzZS5pc092ZXIpIHsKICAgICAgICBpc0JyYWNlID0gdHJ1ZTsKICAgICAgICBpc092ZXIgPSBncm91cC5iYXNlLmlzT3ZlcjsKICAgICAgfQogICAgfQogICAgaWYgKGdyb3VwLmJhc2UgJiYgKGdyb3VwLmJhc2UudHlwZSA9PT0gIm9wIiB8fCBncm91cC5iYXNlLnR5cGUgPT09ICJvcGVyYXRvcm5hbWUiKSkgewogICAgICBncm91cC5iYXNlLnBhcmVudElzU3VwU3ViID0gdHJ1ZTsKICAgIH0KICAgIHZhciBjaGlsZHJlbiA9IFtidWlsZEdyb3VwMihncm91cC5iYXNlLCBvcHRpb25zKV07CiAgICBpZiAoZ3JvdXAuc3ViKSB7CiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cDIoZ3JvdXAuc3ViLCBvcHRpb25zKSk7CiAgICB9CiAgICBpZiAoZ3JvdXAuc3VwKSB7CiAgICAgIGNoaWxkcmVuLnB1c2goYnVpbGRHcm91cDIoZ3JvdXAuc3VwLCBvcHRpb25zKSk7CiAgICB9CiAgICB2YXIgbm9kZVR5cGU7CiAgICBpZiAoaXNCcmFjZSkgewogICAgICBub2RlVHlwZSA9IGlzT3ZlciA/ICJtb3ZlciIgOiAibXVuZGVyIjsKICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1YikgewogICAgICB2YXIgYmFzZSA9IGdyb3VwLmJhc2U7CiAgICAgIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gIm9wIiAmJiBiYXNlLmxpbWl0cyAmJiAob3B0aW9ucy5zdHlsZSA9PT0gU3R5bGUkMS5ESVNQTEFZIHx8IGJhc2UuYWx3YXlzSGFuZGxlU3VwU3ViKSkgewogICAgICAgIG5vZGVUeXBlID0gIm1vdmVyIjsKICAgICAgfSBlbHNlIGlmIChiYXNlICYmIGJhc2UudHlwZSA9PT0gIm9wZXJhdG9ybmFtZSIgJiYgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKGJhc2UubGltaXRzIHx8IG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSkpIHsKICAgICAgICBub2RlVHlwZSA9ICJtb3ZlciI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbm9kZVR5cGUgPSAibXN1cCI7CiAgICAgIH0KICAgIH0gZWxzZSBpZiAoIWdyb3VwLnN1cCkgewogICAgICB2YXIgX2Jhc2UgPSBncm91cC5iYXNlOwogICAgICBpZiAoX2Jhc2UgJiYgX2Jhc2UudHlwZSA9PT0gIm9wIiAmJiBfYmFzZS5saW1pdHMgJiYgKG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSB8fCBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpKSB7CiAgICAgICAgbm9kZVR5cGUgPSAibXVuZGVyIjsKICAgICAgfSBlbHNlIGlmIChfYmFzZSAmJiBfYmFzZS50eXBlID09PSAib3BlcmF0b3JuYW1lIiAmJiBfYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKF9iYXNlLmxpbWl0cyB8fCBvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpKSB7CiAgICAgICAgbm9kZVR5cGUgPSAibXVuZGVyIjsKICAgICAgfSBlbHNlIHsKICAgICAgICBub2RlVHlwZSA9ICJtc3ViIjsKICAgICAgfQogICAgfSBlbHNlIHsKICAgICAgdmFyIF9iYXNlMiA9IGdyb3VwLmJhc2U7CiAgICAgIGlmIChfYmFzZTIgJiYgX2Jhc2UyLnR5cGUgPT09ICJvcCIgJiYgX2Jhc2UyLmxpbWl0cyAmJiBvcHRpb25zLnN0eWxlID09PSBTdHlsZSQxLkRJU1BMQVkpIHsKICAgICAgICBub2RlVHlwZSA9ICJtdW5kZXJvdmVyIjsKICAgICAgfSBlbHNlIGlmIChfYmFzZTIgJiYgX2Jhc2UyLnR5cGUgPT09ICJvcGVyYXRvcm5hbWUiICYmIF9iYXNlMi5hbHdheXNIYW5kbGVTdXBTdWIgJiYgKG9wdGlvbnMuc3R5bGUgPT09IFN0eWxlJDEuRElTUExBWSB8fCBfYmFzZTIubGltaXRzKSkgewogICAgICAgIG5vZGVUeXBlID0gIm11bmRlcm92ZXIiOwogICAgICB9IGVsc2UgewogICAgICAgIG5vZGVUeXBlID0gIm1zdWJzdXAiOwogICAgICB9CiAgICB9CiAgICByZXR1cm4gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUobm9kZVR5cGUsIGNoaWxkcmVuKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHsKICB0eXBlOiAiYXRvbSIsCiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYXRoc3ltKGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMsIFsibSIgKyBncm91cC5mYW1pbHldKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1vIiwgW21ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUpXSk7CiAgICBpZiAoZ3JvdXAuZmFtaWx5ID09PSAiYmluIikgewogICAgICB2YXIgdmFyaWFudCA9IGdldFZhcmlhbnQoZ3JvdXAsIG9wdGlvbnMpOwogICAgICBpZiAodmFyaWFudCA9PT0gImJvbGQtaXRhbGljIikgewogICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJtYXRodmFyaWFudCIsIHZhcmlhbnQpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGdyb3VwLmZhbWlseSA9PT0gInB1bmN0IikgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgic2VwYXJhdG9yIiwgInRydWUiKTsKICAgIH0gZWxzZSBpZiAoZ3JvdXAuZmFtaWx5ID09PSAib3BlbiIgfHwgZ3JvdXAuZmFtaWx5ID09PSAiY2xvc2UiKSB7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJzdHJldGNoeSIsICJmYWxzZSIpOwogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKdmFyIGRlZmF1bHRWYXJpYW50ID0gewogICJtaSI6ICJpdGFsaWMiLAogICJtbiI6ICJub3JtYWwiLAogICJtdGV4dCI6ICJub3JtYWwiCn07CmRlZmluZUZ1bmN0aW9uQnVpbGRlcnMoewogIHR5cGU6ICJtYXRob3JkIiwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VPcmQoZ3JvdXAsIG9wdGlvbnMsICJtYXRob3JkIik7CiAgfSwKICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgbm9kZSA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtaSIsIFttYWtlVGV4dChncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0pOwogICAgdmFyIHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB8fCAiaXRhbGljIjsKICAgIGlmICh2YXJpYW50ICE9PSBkZWZhdWx0VmFyaWFudFtub2RlLnR5cGVdKSB7CiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCJtYXRodmFyaWFudCIsIHZhcmlhbnQpOwogICAgfQogICAgcmV0dXJuIG5vZGU7CiAgfQp9KTsKZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7CiAgdHlwZTogInRleHRvcmQiLAogIGh0bWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgInRleHRvcmQiKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciB0ZXh0MiA9IG1ha2VUZXh0KGdyb3VwLnRleHQsIGdyb3VwLm1vZGUsIG9wdGlvbnMpOwogICAgdmFyIHZhcmlhbnQgPSBnZXRWYXJpYW50KGdyb3VwLCBvcHRpb25zKSB8fCAibm9ybWFsIjsKICAgIHZhciBub2RlOwogICAgaWYgKGdyb3VwLm1vZGUgPT09ICJ0ZXh0IikgewogICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm10ZXh0IiwgW3RleHQyXSk7CiAgICB9IGVsc2UgaWYgKC9bMC05XS8udGVzdChncm91cC50ZXh0KSkgewogICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1uIiwgW3RleHQyXSk7CiAgICB9IGVsc2UgaWYgKGdyb3VwLnRleHQgPT09ICJcXHByaW1lIikgewogICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1vIiwgW3RleHQyXSk7CiAgICB9IGVsc2UgewogICAgICBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm1pIiwgW3RleHQyXSk7CiAgICB9CiAgICBpZiAodmFyaWFudCAhPT0gZGVmYXVsdFZhcmlhbnRbbm9kZS50eXBlXSkgewogICAgICBub2RlLnNldEF0dHJpYnV0ZSgibWF0aHZhcmlhbnQiLCB2YXJpYW50KTsKICAgIH0KICAgIHJldHVybiBub2RlOwogIH0KfSk7CnZhciBjc3NTcGFjZSA9IHsKICAiXFxub2JyZWFrIjogIm5vYnJlYWsiLAogICJcXGFsbG93YnJlYWsiOiAiYWxsb3dicmVhayIKfTsKdmFyIHJlZ3VsYXJTcGFjZSA9IHsKICAiICI6IHt9LAogICJcXCAiOiB7fSwKICAifiI6IHsKICAgIGNsYXNzTmFtZTogIm5vYnJlYWsiCiAgfSwKICAiXFxzcGFjZSI6IHt9LAogICJcXG5vYnJlYWtzcGFjZSI6IHsKICAgIGNsYXNzTmFtZTogIm5vYnJlYWsiCiAgfQp9OwpkZWZpbmVGdW5jdGlvbkJ1aWxkZXJzKHsKICB0eXBlOiAic3BhY2luZyIsCiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIGlmIChyZWd1bGFyU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHsKICAgICAgdmFyIGNsYXNzTmFtZSA9IHJlZ3VsYXJTcGFjZVtncm91cC50ZXh0XS5jbGFzc05hbWUgfHwgIiI7CiAgICAgIGlmIChncm91cC5tb2RlID09PSAidGV4dCIpIHsKICAgICAgICB2YXIgb3JkID0gYnVpbGRDb21tb24ubWFrZU9yZChncm91cCwgb3B0aW9ucywgInRleHRvcmQiKTsKICAgICAgICBvcmQuY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7CiAgICAgICAgcmV0dXJuIG9yZDsKICAgICAgfSBlbHNlIHsKICAgICAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtc3BhY2UiLCBjbGFzc05hbWVdLCBbYnVpbGRDb21tb24ubWF0aHN5bShncm91cC50ZXh0LCBncm91cC5tb2RlLCBvcHRpb25zKV0sIG9wdGlvbnMpOwogICAgICB9CiAgICB9IGVsc2UgaWYgKGNzc1NwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7CiAgICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1zcGFjZSIsIGNzc1NwYWNlW2dyb3VwLnRleHRdXSwgW10sIG9wdGlvbnMpOwogICAgfSBlbHNlIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoJ1Vua25vd24gdHlwZSBvZiBzcGFjZSAiJyArIGdyb3VwLnRleHQgKyAnIicpOwogICAgfQogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIG5vZGU7CiAgICBpZiAocmVndWxhclNwYWNlLmhhc093blByb3BlcnR5KGdyb3VwLnRleHQpKSB7CiAgICAgIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXRleHQiLCBbbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUoIsKgIildKTsKICAgIH0gZWxzZSBpZiAoY3NzU3BhY2UuaGFzT3duUHJvcGVydHkoZ3JvdXAudGV4dCkpIHsKICAgICAgcmV0dXJuIG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtc3BhY2UiKTsKICAgIH0gZWxzZSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCdVbmtub3duIHR5cGUgb2Ygc3BhY2UgIicgKyBncm91cC50ZXh0ICsgJyInKTsKICAgIH0KICAgIHJldHVybiBub2RlOwogIH0KfSk7CnZhciBwYWQgPSAoKSA9PiB7CiAgdmFyIHBhZE5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXRkIiwgW10pOwogIHBhZE5vZGUuc2V0QXR0cmlidXRlKCJ3aWR0aCIsICI1MCUiKTsKICByZXR1cm4gcGFkTm9kZTsKfTsKZGVmaW5lRnVuY3Rpb25CdWlsZGVycyh7CiAgdHlwZTogInRhZyIsCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIHRhYmxlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm10YWJsZSIsIFtuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXRyIiwgW3BhZCgpLCBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXRkIiwgW2J1aWxkRXhwcmVzc2lvblJvdyhncm91cC5ib2R5LCBvcHRpb25zKV0pLCBwYWQoKSwgbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm10ZCIsIFtidWlsZEV4cHJlc3Npb25Sb3coZ3JvdXAudGFnLCBvcHRpb25zKV0pXSldKTsKICAgIHRhYmxlLnNldEF0dHJpYnV0ZSgid2lkdGgiLCAiMTAwJSIpOwogICAgcmV0dXJuIHRhYmxlOwogIH0KfSk7CnZhciB0ZXh0Rm9udEZhbWlsaWVzID0gewogICJcXHRleHQiOiB2b2lkIDAsCiAgIlxcdGV4dHJtIjogInRleHRybSIsCiAgIlxcdGV4dHNmIjogInRleHRzZiIsCiAgIlxcdGV4dHR0IjogInRleHR0dCIsCiAgIlxcdGV4dG5vcm1hbCI6ICJ0ZXh0cm0iCn07CnZhciB0ZXh0Rm9udFdlaWdodHMgPSB7CiAgIlxcdGV4dGJmIjogInRleHRiZiIsCiAgIlxcdGV4dG1kIjogInRleHRtZCIKfTsKdmFyIHRleHRGb250U2hhcGVzID0gewogICJcXHRleHRpdCI6ICJ0ZXh0aXQiLAogICJcXHRleHR1cCI6ICJ0ZXh0dXAiCn07CnZhciBvcHRpb25zV2l0aEZvbnQgPSAoZ3JvdXAsIG9wdGlvbnMpID0+IHsKICB2YXIgZm9udCA9IGdyb3VwLmZvbnQ7CiAgaWYgKCFmb250KSB7CiAgICByZXR1cm4gb3B0aW9uczsKICB9IGVsc2UgaWYgKHRleHRGb250RmFtaWxpZXNbZm9udF0pIHsKICAgIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udEZhbWlseSh0ZXh0Rm9udEZhbWlsaWVzW2ZvbnRdKTsKICB9IGVsc2UgaWYgKHRleHRGb250V2VpZ2h0c1tmb250XSkgewogICAgcmV0dXJuIG9wdGlvbnMud2l0aFRleHRGb250V2VpZ2h0KHRleHRGb250V2VpZ2h0c1tmb250XSk7CiAgfSBlbHNlIGlmIChmb250ID09PSAiXFxlbXBoIikgewogICAgcmV0dXJuIG9wdGlvbnMuZm9udFNoYXBlID09PSAidGV4dGl0IiA/IG9wdGlvbnMud2l0aFRleHRGb250U2hhcGUoInRleHR1cCIpIDogb3B0aW9ucy53aXRoVGV4dEZvbnRTaGFwZSgidGV4dGl0Iik7CiAgfQogIHJldHVybiBvcHRpb25zLndpdGhUZXh0Rm9udFNoYXBlKHRleHRGb250U2hhcGVzW2ZvbnRdKTsKfTsKZGVmaW5lRnVuY3Rpb24oewogIHR5cGU6ICJ0ZXh0IiwKICBuYW1lczogWwogICAgLy8gRm9udCBmYW1pbGllcwogICAgIlxcdGV4dCIsCiAgICAiXFx0ZXh0cm0iLAogICAgIlxcdGV4dHNmIiwKICAgICJcXHRleHR0dCIsCiAgICAiXFx0ZXh0bm9ybWFsIiwKICAgIC8vIEZvbnQgd2VpZ2h0cwogICAgIlxcdGV4dGJmIiwKICAgICJcXHRleHRtZCIsCiAgICAvLyBGb250IFNoYXBlcwogICAgIlxcdGV4dGl0IiwKICAgICJcXHRleHR1cCIsCiAgICAiXFxlbXBoIgogIF0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhcmdUeXBlczogWyJ0ZXh0Il0sCiAgICBhbGxvd2VkSW5Bcmd1bWVudDogdHJ1ZSwKICAgIGFsbG93ZWRJblRleHQ6IHRydWUKICB9LAogIGhhbmRsZXIoX3JlZiwgYXJncykgewogICAgdmFyIHsKICAgICAgcGFyc2VyLAogICAgICBmdW5jTmFtZQogICAgfSA9IF9yZWY7CiAgICB2YXIgYm9keSA9IGFyZ3NbMF07CiAgICByZXR1cm4gewogICAgICB0eXBlOiAidGV4dCIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBib2R5OiBvcmRhcmd1bWVudChib2R5KSwKICAgICAgZm9udDogZnVuY05hbWUKICAgIH07CiAgfSwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIG5ld09wdGlvbnMgPSBvcHRpb25zV2l0aEZvbnQoZ3JvdXAsIG9wdGlvbnMpOwogICAgdmFyIGlubmVyMiA9IGJ1aWxkRXhwcmVzc2lvbiQxKGdyb3VwLmJvZHksIG5ld09wdGlvbnMsIHRydWUpOwogICAgcmV0dXJuIGJ1aWxkQ29tbW9uLm1ha2VTcGFuKFsibW9yZCIsICJ0ZXh0Il0sIGlubmVyMiwgbmV3T3B0aW9ucyk7CiAgfSwKICBtYXRobWxCdWlsZGVyKGdyb3VwLCBvcHRpb25zKSB7CiAgICB2YXIgbmV3T3B0aW9ucyA9IG9wdGlvbnNXaXRoRm9udChncm91cCwgb3B0aW9ucyk7CiAgICByZXR1cm4gYnVpbGRFeHByZXNzaW9uUm93KGdyb3VwLmJvZHksIG5ld09wdGlvbnMpOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAidW5kZXJsaW5lIiwKICBuYW1lczogWyJcXHVuZGVybGluZSJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAxLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcihfcmVmLCBhcmdzKSB7CiAgICB2YXIgewogICAgICBwYXJzZXIKICAgIH0gPSBfcmVmOwogICAgcmV0dXJuIHsKICAgICAgdHlwZTogInVuZGVybGluZSIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBib2R5OiBhcmdzWzBdCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBpbm5lckdyb3VwID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpOwogICAgdmFyIGxpbmUgPSBidWlsZENvbW1vbi5tYWtlTGluZVNwYW4oInVuZGVybGluZS1saW5lIiwgb3B0aW9ucyk7CiAgICB2YXIgZGVmYXVsdFJ1bGVUaGlja25lc3MgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuZGVmYXVsdFJ1bGVUaGlja25lc3M7CiAgICB2YXIgdmxpc3QgPSBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJ0b3AiLAogICAgICBwb3NpdGlvbkRhdGE6IGlubmVyR3JvdXAuaGVpZ2h0LAogICAgICBjaGlsZHJlbjogW3sKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZTogZGVmYXVsdFJ1bGVUaGlja25lc3MKICAgICAgfSwgewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBsaW5lCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAia2VybiIsCiAgICAgICAgc2l6ZTogMyAqIGRlZmF1bHRSdWxlVGhpY2tuZXNzCiAgICAgIH0sIHsKICAgICAgICB0eXBlOiAiZWxlbSIsCiAgICAgICAgZWxlbTogaW5uZXJHcm91cAogICAgICB9XQogICAgfSwgb3B0aW9ucyk7CiAgICByZXR1cm4gYnVpbGRDb21tb24ubWFrZVNwYW4oWyJtb3JkIiwgInVuZGVybGluZSJdLCBbdmxpc3RdLCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBvcGVyYXRvciA9IG5ldyBtYXRoTUxUcmVlLk1hdGhOb2RlKCJtbyIsIFtuZXcgbWF0aE1MVHJlZS5UZXh0Tm9kZSgi4oC+IildKTsKICAgIG9wZXJhdG9yLnNldEF0dHJpYnV0ZSgic3RyZXRjaHkiLCAidHJ1ZSIpOwogICAgdmFyIG5vZGUgPSBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXVuZGVyIiwgW2J1aWxkR3JvdXAyKGdyb3VwLmJvZHksIG9wdGlvbnMpLCBvcGVyYXRvcl0pOwogICAgbm9kZS5zZXRBdHRyaWJ1dGUoImFjY2VudHVuZGVyIiwgInRydWUiKTsKICAgIHJldHVybiBub2RlOwogIH0KfSk7CmRlZmluZUZ1bmN0aW9uKHsKICB0eXBlOiAidmNlbnRlciIsCiAgbmFtZXM6IFsiXFx2Y2VudGVyIl0sCiAgcHJvcHM6IHsKICAgIG51bUFyZ3M6IDEsCiAgICBhcmdUeXBlczogWyJvcmlnaW5hbCJdLAogICAgLy8gSW4gTGFUZVgsIFx2Y2VudGVyIGNhbiBhY3Qgb25seSBvbiBhIGJveC4KICAgIGFsbG93ZWRJblRleHQ6IGZhbHNlCiAgfSwKICBoYW5kbGVyKF9yZWYsIGFyZ3MpIHsKICAgIHZhciB7CiAgICAgIHBhcnNlcgogICAgfSA9IF9yZWY7CiAgICByZXR1cm4gewogICAgICB0eXBlOiAidmNlbnRlciIsCiAgICAgIG1vZGU6IHBhcnNlci5tb2RlLAogICAgICBib2R5OiBhcmdzWzBdCiAgICB9OwogIH0sCiAgaHRtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHZhciBib2R5ID0gYnVpbGRHcm91cCQxKGdyb3VwLmJvZHksIG9wdGlvbnMpOwogICAgdmFyIGF4aXNIZWlnaHQgPSBvcHRpb25zLmZvbnRNZXRyaWNzKCkuYXhpc0hlaWdodDsKICAgIHZhciBkeSA9IDAuNSAqIChib2R5LmhlaWdodCAtIGF4aXNIZWlnaHQgLSAoYm9keS5kZXB0aCArIGF4aXNIZWlnaHQpKTsKICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlVkxpc3QoewogICAgICBwb3NpdGlvblR5cGU6ICJzaGlmdCIsCiAgICAgIHBvc2l0aW9uRGF0YTogZHksCiAgICAgIGNoaWxkcmVuOiBbewogICAgICAgIHR5cGU6ICJlbGVtIiwKICAgICAgICBlbGVtOiBib2R5CiAgICAgIH1dCiAgICB9LCBvcHRpb25zKTsKICB9LAogIG1hdGhtbEJ1aWxkZXIoZ3JvdXAsIG9wdGlvbnMpIHsKICAgIHJldHVybiBuZXcgbWF0aE1MVHJlZS5NYXRoTm9kZSgibXBhZGRlZCIsIFtidWlsZEdyb3VwMihncm91cC5ib2R5LCBvcHRpb25zKV0sIFsidmNlbnRlciJdKTsKICB9Cn0pOwpkZWZpbmVGdW5jdGlvbih7CiAgdHlwZTogInZlcmIiLAogIG5hbWVzOiBbIlxcdmVyYiJdLAogIHByb3BzOiB7CiAgICBudW1BcmdzOiAwLAogICAgYWxsb3dlZEluVGV4dDogdHJ1ZQogIH0sCiAgaGFuZGxlcihjb250ZXh0LCBhcmdzLCBvcHRBcmdzKSB7CiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiXFx2ZXJiIGVuZGVkIGJ5IGVuZCBvZiBsaW5lIGluc3RlYWQgb2YgbWF0Y2hpbmcgZGVsaW1pdGVyIik7CiAgfSwKICBodG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIHRleHQyID0gbWFrZVZlcmIoZ3JvdXApOwogICAgdmFyIGJvZHkgPSBbXTsKICAgIHZhciBuZXdPcHRpb25zID0gb3B0aW9ucy5oYXZpbmdTdHlsZShvcHRpb25zLnN0eWxlLnRleHQoKSk7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQyLmxlbmd0aDsgaSsrKSB7CiAgICAgIHZhciBjID0gdGV4dDJbaV07CiAgICAgIGlmIChjID09PSAifiIpIHsKICAgICAgICBjID0gIlxcdGV4dGFzY2lpdGlsZGUiOwogICAgICB9CiAgICAgIGJvZHkucHVzaChidWlsZENvbW1vbi5tYWtlU3ltYm9sKGMsICJUeXBld3JpdGVyLVJlZ3VsYXIiLCBncm91cC5tb2RlLCBuZXdPcHRpb25zLCBbIm1vcmQiLCAidGV4dHR0Il0pKTsKICAgIH0KICAgIHJldHVybiBidWlsZENvbW1vbi5tYWtlU3BhbihbIm1vcmQiLCAidGV4dCJdLmNvbmNhdChuZXdPcHRpb25zLnNpemluZ0NsYXNzZXMob3B0aW9ucykpLCBidWlsZENvbW1vbi50cnlDb21iaW5lQ2hhcnMoYm9keSksIG5ld09wdGlvbnMpOwogIH0sCiAgbWF0aG1sQnVpbGRlcihncm91cCwgb3B0aW9ucykgewogICAgdmFyIHRleHQyID0gbmV3IG1hdGhNTFRyZWUuVGV4dE5vZGUobWFrZVZlcmIoZ3JvdXApKTsKICAgIHZhciBub2RlID0gbmV3IG1hdGhNTFRyZWUuTWF0aE5vZGUoIm10ZXh0IiwgW3RleHQyXSk7CiAgICBub2RlLnNldEF0dHJpYnV0ZSgibWF0aHZhcmlhbnQiLCAibW9ub3NwYWNlIik7CiAgICByZXR1cm4gbm9kZTsKICB9Cn0pOwp2YXIgbWFrZVZlcmIgPSAoZ3JvdXApID0+IGdyb3VwLmJvZHkucmVwbGFjZSgvIC9nLCBncm91cC5zdGFyID8gIuKQoyIgOiAiwqAiKTsKdmFyIGZ1bmN0aW9ucyA9IF9mdW5jdGlvbnM7CnZhciBzcGFjZVJlZ2V4U3RyaW5nID0gIlsgXHJcbgldIjsKdmFyIGNvbnRyb2xXb3JkUmVnZXhTdHJpbmcgPSAiXFxcXFthLXpBLVpAXSsiOwp2YXIgY29udHJvbFN5bWJvbFJlZ2V4U3RyaW5nID0gIlxcXFxbXlx1RDgwMC1cdURGRkZdIjsKdmFyIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nID0gIigiICsgY29udHJvbFdvcmRSZWdleFN0cmluZyArICIpIiArIHNwYWNlUmVnZXhTdHJpbmcgKyAiKiI7CnZhciBjb250cm9sU3BhY2VSZWdleFN0cmluZyA9ICJcXFxcKFxufFsgXHIJXStcbj8pWyBccgldKiI7CnZhciBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgPSAiW8yALc2vXSI7CnZhciBjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtzRW5kUmVnZXggPSBuZXcgUmVnRXhwKGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya1N0cmluZyArICIrJCIpOwp2YXIgdG9rZW5SZWdleFN0cmluZyA9ICIoIiArIHNwYWNlUmVnZXhTdHJpbmcgKyAiKyl8IiArIC8vIHdoaXRlc3BhY2UKKGNvbnRyb2xTcGFjZVJlZ2V4U3RyaW5nICsgInwiKSArIC8vIFx3aGl0ZXNwYWNlCiIoWyEtXFxbXFxdLeKAp+KAqi3tn7/vpIAt77+/XSIgKyAvLyBzaW5nbGUgY29kZXBvaW50Cihjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgKyAiKiIpICsgLy8gLi4ucGx1cyBhY2NlbnRzCiJ8W1x1RDgwMC1cdURCRkZdW1x1REMwMC1cdURGRkZdIiArIC8vIHN1cnJvZ2F0ZSBwYWlyCihjb21iaW5pbmdEaWFjcml0aWNhbE1hcmtTdHJpbmcgKyAiKiIpICsgLy8gLi4ucGx1cyBhY2NlbnRzCiJ8XFxcXHZlcmJcXCooW15dKS4qP1xcNHxcXFxcdmVyYihbXiphLXpBLVpdKS4qP1xcNSIgKyAvLyBcdmVyYiB1bnN0YXJyZWQKKCJ8IiArIGNvbnRyb2xXb3JkV2hpdGVzcGFjZVJlZ2V4U3RyaW5nKSArIC8vIFxtYWNyb05hbWUgKyBzcGFjZXMKKCJ8IiArIGNvbnRyb2xTeW1ib2xSZWdleFN0cmluZyArICIpIik7CnZhciBMZXhlciA9IGNsYXNzIHsKICAvLyBDYXRlZ29yeSBjb2Rlcy4gVGhlIGxleGVyIG9ubHkgc3VwcG9ydHMgY29tbWVudCBjaGFyYWN0ZXJzICgxNCkgZm9yIG5vdy4KICAvLyBNYWNyb0V4cGFuZGVyIGFkZGl0aW9uYWxseSBkaXN0aW5ndWlzaGVzIGFjdGl2ZSAoMTMpLgogIGNvbnN0cnVjdG9yKGlucHV0LCBzZXR0aW5ncykgewogICAgdGhpcy5pbnB1dCA9IHZvaWQgMDsKICAgIHRoaXMuc2V0dGluZ3MgPSB2b2lkIDA7CiAgICB0aGlzLnRva2VuUmVnZXggPSB2b2lkIDA7CiAgICB0aGlzLmNhdGNvZGVzID0gdm9pZCAwOwogICAgdGhpcy5pbnB1dCA9IGlucHV0OwogICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzOwogICAgdGhpcy50b2tlblJlZ2V4ID0gbmV3IFJlZ0V4cCh0b2tlblJlZ2V4U3RyaW5nLCAiZyIpOwogICAgdGhpcy5jYXRjb2RlcyA9IHsKICAgICAgIiUiOiAxNCwKICAgICAgLy8gY29tbWVudCBjaGFyYWN0ZXIKICAgICAgIn4iOiAxMwogICAgICAvLyBhY3RpdmUgY2hhcmFjdGVyCiAgICB9OwogIH0KICBzZXRDYXRjb2RlKGNoYXIsIGNvZGUpIHsKICAgIHRoaXMuY2F0Y29kZXNbY2hhcl0gPSBjb2RlOwogIH0KICAvKioKICAgKiBUaGlzIGZ1bmN0aW9uIGxleGVzIGEgc2luZ2xlIHRva2VuLgogICAqLwogIGxleCgpIHsKICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXQ7CiAgICB2YXIgcG9zID0gdGhpcy50b2tlblJlZ2V4Lmxhc3RJbmRleDsKICAgIGlmIChwb3MgPT09IGlucHV0Lmxlbmd0aCkgewogICAgICByZXR1cm4gbmV3IFRva2VuKCJFT0YiLCBuZXcgU291cmNlTG9jYXRpb24odGhpcywgcG9zLCBwb3MpKTsKICAgIH0KICAgIHZhciBtYXRjaCA9IHRoaXMudG9rZW5SZWdleC5leGVjKGlucHV0KTsKICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5pbmRleCAhPT0gcG9zKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJVbmV4cGVjdGVkIGNoYXJhY3RlcjogJyIgKyBpbnB1dFtwb3NdICsgIiciLCBuZXcgVG9rZW4oaW5wdXRbcG9zXSwgbmV3IFNvdXJjZUxvY2F0aW9uKHRoaXMsIHBvcywgcG9zICsgMSkpKTsKICAgIH0KICAgIHZhciB0ZXh0MiA9IG1hdGNoWzZdIHx8IG1hdGNoWzNdIHx8IChtYXRjaFsyXSA/ICJcXCAiIDogIiAiKTsKICAgIGlmICh0aGlzLmNhdGNvZGVzW3RleHQyXSA9PT0gMTQpIHsKICAgICAgdmFyIG5sSW5kZXggPSBpbnB1dC5pbmRleE9mKCJcbiIsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpOwogICAgICBpZiAobmxJbmRleCA9PT0gLTEpIHsKICAgICAgICB0aGlzLnRva2VuUmVnZXgubGFzdEluZGV4ID0gaW5wdXQubGVuZ3RoOwogICAgICAgIHRoaXMuc2V0dGluZ3MucmVwb3J0Tm9uc3RyaWN0KCJjb21tZW50QXRFbmQiLCAiJSBjb21tZW50IGhhcyBubyB0ZXJtaW5hdGluZyBuZXdsaW5lOyBMYVRlWCB3b3VsZCBmYWlsIGJlY2F1c2Ugb2YgY29tbWVudGluZyB0aGUgZW5kIG9mIG1hdGggbW9kZSAoZS5nLiAkKSIpOwogICAgICB9IGVsc2UgewogICAgICAgIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXggPSBubEluZGV4ICsgMTsKICAgICAgfQogICAgICByZXR1cm4gdGhpcy5sZXgoKTsKICAgIH0KICAgIHJldHVybiBuZXcgVG9rZW4odGV4dDIsIG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBwb3MsIHRoaXMudG9rZW5SZWdleC5sYXN0SW5kZXgpKTsKICB9Cn07CnZhciBOYW1lc3BhY2UgPSBjbGFzcyB7CiAgLyoqCiAgICogQm90aCBhcmd1bWVudHMgYXJlIG9wdGlvbmFsLiAgVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBvZgogICAqIGJ1aWx0LWluIG1hcHBpbmdzIHdoaWNoIG5ldmVyIGNoYW5nZS4gIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYW4gb2JqZWN0CiAgICogb2YgaW5pdGlhbCAoZ2xvYmFsLWxldmVsKSBtYXBwaW5ncywgd2hpY2ggd2lsbCBjb25zdGFudGx5IGNoYW5nZQogICAqIGFjY29yZGluZyB0byBhbnkgZ2xvYmFsL3RvcC1sZXZlbCBgc2V0YHMgZG9uZS4KICAgKi8KICBjb25zdHJ1Y3RvcihidWlsdGlucywgZ2xvYmFsTWFjcm9zKSB7CiAgICBpZiAoYnVpbHRpbnMgPT09IHZvaWQgMCkgewogICAgICBidWlsdGlucyA9IHt9OwogICAgfQogICAgaWYgKGdsb2JhbE1hY3JvcyA9PT0gdm9pZCAwKSB7CiAgICAgIGdsb2JhbE1hY3JvcyA9IHt9OwogICAgfQogICAgdGhpcy5jdXJyZW50ID0gdm9pZCAwOwogICAgdGhpcy5idWlsdGlucyA9IHZvaWQgMDsKICAgIHRoaXMudW5kZWZTdGFjayA9IHZvaWQgMDsKICAgIHRoaXMuY3VycmVudCA9IGdsb2JhbE1hY3JvczsKICAgIHRoaXMuYnVpbHRpbnMgPSBidWlsdGluczsKICAgIHRoaXMudW5kZWZTdGFjayA9IFtdOwogIH0KICAvKioKICAgKiBTdGFydCBhIG5ldyBuZXN0ZWQgZ3JvdXAsIGFmZmVjdGluZyBmdXR1cmUgbG9jYWwgYHNldGBzLgogICAqLwogIGJlZ2luR3JvdXAoKSB7CiAgICB0aGlzLnVuZGVmU3RhY2sucHVzaCh7fSk7CiAgfQogIC8qKgogICAqIEVuZCBjdXJyZW50IG5lc3RlZCBncm91cCwgcmVzdG9yaW5nIHZhbHVlcyBiZWZvcmUgdGhlIGdyb3VwIGJlZ2FuLgogICAqLwogIGVuZEdyb3VwKCkgewogICAgaWYgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPT09IDApIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVuYmFsYW5jZWQgbmFtZXNwYWNlIGRlc3RydWN0aW9uOiBhdHRlbXB0IHRvIHBvcCBnbG9iYWwgbmFtZXNwYWNlOyBwbGVhc2UgcmVwb3J0IHRoaXMgYXMgYSBidWciKTsKICAgIH0KICAgIHZhciB1bmRlZnMgPSB0aGlzLnVuZGVmU3RhY2sucG9wKCk7CiAgICBmb3IgKHZhciB1bmRlZiBpbiB1bmRlZnMpIHsKICAgICAgaWYgKHVuZGVmcy5oYXNPd25Qcm9wZXJ0eSh1bmRlZikpIHsKICAgICAgICBpZiAodW5kZWZzW3VuZGVmXSA9PSBudWxsKSB7CiAgICAgICAgICBkZWxldGUgdGhpcy5jdXJyZW50W3VuZGVmXTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5jdXJyZW50W3VuZGVmXSA9IHVuZGVmc1t1bmRlZl07CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgfQogIC8qKgogICAqIEVuZHMgYWxsIGN1cnJlbnRseSBuZXN0ZWQgZ3JvdXBzIChpZiBhbnkpLCByZXN0b3JpbmcgdmFsdWVzIGJlZm9yZSB0aGUKICAgKiBncm91cHMgYmVnYW4uICBVc2VmdWwgaW4gY2FzZSBvZiBhbiBlcnJvciBpbiB0aGUgbWlkZGxlIG9mIHBhcnNpbmcuCiAgICovCiAgZW5kR3JvdXBzKCkgewogICAgd2hpbGUgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPiAwKSB7CiAgICAgIHRoaXMuZW5kR3JvdXAoKTsKICAgIH0KICB9CiAgLyoqCiAgICogRGV0ZWN0IHdoZXRoZXIgYG5hbWVgIGhhcyBhIGRlZmluaXRpb24uICBFcXVpdmFsZW50IHRvCiAgICogYGdldChuYW1lKSAhPSBudWxsYC4KICAgKi8KICBoYXMobmFtZSkgewogICAgcmV0dXJuIHRoaXMuY3VycmVudC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCB0aGlzLmJ1aWx0aW5zLmhhc093blByb3BlcnR5KG5hbWUpOwogIH0KICAvKioKICAgKiBHZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyB2YWx1ZS4KICAgKgogICAqIE5vdGU6IERvIG5vdCB1c2UgYGlmIChuYW1lc3BhY2UuZ2V0KC4uLikpYCB0byBkZXRlY3Qgd2hldGhlciBhIG1hY3JvCiAgICogaXMgZGVmaW5lZCwgYXMgdGhlIGRlZmluaXRpb24gbWF5IGJlIHRoZSBlbXB0eSBzdHJpbmcgd2hpY2ggZXZhbHVhdGVzCiAgICogdG8gYGZhbHNlYCBpbiBKYXZhU2NyaXB0LiAgVXNlIGBpZiAobmFtZXNwYWNlLmdldCguLi4pICE9IG51bGwpYCBvcgogICAqIGBpZiAobmFtZXNwYWNlLmhhcyguLi4pKWAuCiAgICovCiAgZ2V0KG5hbWUpIHsKICAgIGlmICh0aGlzLmN1cnJlbnQuaGFzT3duUHJvcGVydHkobmFtZSkpIHsKICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFtuYW1lXTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiB0aGlzLmJ1aWx0aW5zW25hbWVdOwogICAgfQogIH0KICAvKioKICAgKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBuYW1lLCBhbmQgb3B0aW9uYWxseSBzZXQgaXQgZ2xvYmFsbHkgdG9vLgogICAqIExvY2FsIHNldCgpIHNldHMgdGhlIGN1cnJlbnQgdmFsdWUgYW5kICh3aGVuIGFwcHJvcHJpYXRlKSBhZGRzIGFuIHVuZG8KICAgKiBvcGVyYXRpb24gdG8gdGhlIHVuZG8gc3RhY2suICBHbG9iYWwgc2V0KCkgbWF5IGNoYW5nZSB0aGUgdW5kbwogICAqIG9wZXJhdGlvbiBhdCBldmVyeSBsZXZlbCwgc28gdGFrZXMgdGltZSBsaW5lYXIgaW4gdGhlaXIgbnVtYmVyLgogICAqIEEgdmFsdWUgb2YgdW5kZWZpbmVkIG1lYW5zIHRvIGRlbGV0ZSBleGlzdGluZyBkZWZpbml0aW9ucy4KICAgKi8KICBzZXQobmFtZSwgdmFsdWUsIGdsb2JhbCkgewogICAgaWYgKGdsb2JhbCA9PT0gdm9pZCAwKSB7CiAgICAgIGdsb2JhbCA9IGZhbHNlOwogICAgfQogICAgaWYgKGdsb2JhbCkgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5kZWZTdGFjay5sZW5ndGg7IGkrKykgewogICAgICAgIGRlbGV0ZSB0aGlzLnVuZGVmU3RhY2tbaV1bbmFtZV07CiAgICAgIH0KICAgICAgaWYgKHRoaXMudW5kZWZTdGFjay5sZW5ndGggPiAwKSB7CiAgICAgICAgdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXVtuYW1lXSA9IHZhbHVlOwogICAgICB9CiAgICB9IGVsc2UgewogICAgICB2YXIgdG9wID0gdGhpcy51bmRlZlN0YWNrW3RoaXMudW5kZWZTdGFjay5sZW5ndGggLSAxXTsKICAgICAgaWYgKHRvcCAmJiAhdG9wLmhhc093blByb3BlcnR5KG5hbWUpKSB7CiAgICAgICAgdG9wW25hbWVdID0gdGhpcy5jdXJyZW50W25hbWVdOwogICAgICB9CiAgICB9CiAgICBpZiAodmFsdWUgPT0gbnVsbCkgewogICAgICBkZWxldGUgdGhpcy5jdXJyZW50W25hbWVdOwogICAgfSBlbHNlIHsKICAgICAgdGhpcy5jdXJyZW50W25hbWVdID0gdmFsdWU7CiAgICB9CiAgfQp9Owp2YXIgbWFjcm9zID0gX21hY3JvczsKZGVmaW5lTWFjcm8oIlxcbm9leHBhbmQiLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIHQgPSBjb250ZXh0LnBvcFRva2VuKCk7CiAgaWYgKGNvbnRleHQuaXNFeHBhbmRhYmxlKHQudGV4dCkpIHsKICAgIHQubm9leHBhbmQgPSB0cnVlOwogICAgdC50cmVhdEFzUmVsYXggPSB0cnVlOwogIH0KICByZXR1cm4gewogICAgdG9rZW5zOiBbdF0sCiAgICBudW1BcmdzOiAwCiAgfTsKfSk7CmRlZmluZU1hY3JvKCJcXGV4cGFuZGFmdGVyIiwgZnVuY3Rpb24oY29udGV4dCkgewogIHZhciB0ID0gY29udGV4dC5wb3BUb2tlbigpOwogIGNvbnRleHQuZXhwYW5kT25jZSh0cnVlKTsKICByZXR1cm4gewogICAgdG9rZW5zOiBbdF0sCiAgICBudW1BcmdzOiAwCiAgfTsKfSk7CmRlZmluZU1hY3JvKCJcXEBmaXJzdG9mdHdvIiwgZnVuY3Rpb24oY29udGV4dCkgewogIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygyKTsKICByZXR1cm4gewogICAgdG9rZW5zOiBhcmdzWzBdLAogICAgbnVtQXJnczogMAogIH07Cn0pOwpkZWZpbmVNYWNybygiXFxAc2Vjb25kb2Z0d28iLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpOwogIHJldHVybiB7CiAgICB0b2tlbnM6IGFyZ3NbMV0sCiAgICBudW1BcmdzOiAwCiAgfTsKfSk7CmRlZmluZU1hY3JvKCJcXEBpZm5leHRjaGFyIiwgZnVuY3Rpb24oY29udGV4dCkgewogIHZhciBhcmdzID0gY29udGV4dC5jb25zdW1lQXJncygzKTsKICBjb250ZXh0LmNvbnN1bWVTcGFjZXMoKTsKICB2YXIgbmV4dFRva2VuID0gY29udGV4dC5mdXR1cmUoKTsKICBpZiAoYXJnc1swXS5sZW5ndGggPT09IDEgJiYgYXJnc1swXVswXS50ZXh0ID09PSBuZXh0VG9rZW4udGV4dCkgewogICAgcmV0dXJuIHsKICAgICAgdG9rZW5zOiBhcmdzWzFdLAogICAgICBudW1BcmdzOiAwCiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gewogICAgICB0b2tlbnM6IGFyZ3NbMl0sCiAgICAgIG51bUFyZ3M6IDAKICAgIH07CiAgfQp9KTsKZGVmaW5lTWFjcm8oIlxcQGlmc3RhciIsICJcXEBpZm5leHRjaGFyICp7XFxAZmlyc3RvZnR3b3sjMX19Iik7CmRlZmluZU1hY3JvKCJcXFRleHRPck1hdGgiLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIGFyZ3MgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDIpOwogIGlmIChjb250ZXh0Lm1vZGUgPT09ICJ0ZXh0IikgewogICAgcmV0dXJuIHsKICAgICAgdG9rZW5zOiBhcmdzWzBdLAogICAgICBudW1BcmdzOiAwCiAgICB9OwogIH0gZWxzZSB7CiAgICByZXR1cm4gewogICAgICB0b2tlbnM6IGFyZ3NbMV0sCiAgICAgIG51bUFyZ3M6IDAKICAgIH07CiAgfQp9KTsKdmFyIGRpZ2l0VG9OdW1iZXIgPSB7CiAgIjAiOiAwLAogICIxIjogMSwKICAiMiI6IDIsCiAgIjMiOiAzLAogICI0IjogNCwKICAiNSI6IDUsCiAgIjYiOiA2LAogICI3IjogNywKICAiOCI6IDgsCiAgIjkiOiA5LAogICJhIjogMTAsCiAgIkEiOiAxMCwKICAiYiI6IDExLAogICJCIjogMTEsCiAgImMiOiAxMiwKICAiQyI6IDEyLAogICJkIjogMTMsCiAgIkQiOiAxMywKICAiZSI6IDE0LAogICJFIjogMTQsCiAgImYiOiAxNSwKICAiRiI6IDE1Cn07CmRlZmluZU1hY3JvKCJcXGNoYXIiLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpOwogIHZhciBiYXNlOwogIHZhciBudW1iZXIgPSAiIjsKICBpZiAodG9rZW4udGV4dCA9PT0gIiciKSB7CiAgICBiYXNlID0gODsKICAgIHRva2VuID0gY29udGV4dC5wb3BUb2tlbigpOwogIH0gZWxzZSBpZiAodG9rZW4udGV4dCA9PT0gJyInKSB7CiAgICBiYXNlID0gMTY7CiAgICB0b2tlbiA9IGNvbnRleHQucG9wVG9rZW4oKTsKICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09ICJgIikgewogICAgdG9rZW4gPSBjb250ZXh0LnBvcFRva2VuKCk7CiAgICBpZiAodG9rZW4udGV4dFswXSA9PT0gIlxcIikgewogICAgICBudW1iZXIgPSB0b2tlbi50ZXh0LmNoYXJDb2RlQXQoMSk7CiAgICB9IGVsc2UgaWYgKHRva2VuLnRleHQgPT09ICJFT0YiKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJcXGNoYXJgIG1pc3NpbmcgYXJndW1lbnQiKTsKICAgIH0gZWxzZSB7CiAgICAgIG51bWJlciA9IHRva2VuLnRleHQuY2hhckNvZGVBdCgwKTsKICAgIH0KICB9IGVsc2UgewogICAgYmFzZSA9IDEwOwogIH0KICBpZiAoYmFzZSkgewogICAgbnVtYmVyID0gZGlnaXRUb051bWJlclt0b2tlbi50ZXh0XTsKICAgIGlmIChudW1iZXIgPT0gbnVsbCB8fCBudW1iZXIgPj0gYmFzZSkgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiSW52YWxpZCBiYXNlLSIgKyBiYXNlICsgIiBkaWdpdCAiICsgdG9rZW4udGV4dCk7CiAgICB9CiAgICB2YXIgZGlnaXQ7CiAgICB3aGlsZSAoKGRpZ2l0ID0gZGlnaXRUb051bWJlcltjb250ZXh0LmZ1dHVyZSgpLnRleHRdKSAhPSBudWxsICYmIGRpZ2l0IDwgYmFzZSkgewogICAgICBudW1iZXIgKj0gYmFzZTsKICAgICAgbnVtYmVyICs9IGRpZ2l0OwogICAgICBjb250ZXh0LnBvcFRva2VuKCk7CiAgICB9CiAgfQogIHJldHVybiAiXFxAY2hhcnsiICsgbnVtYmVyICsgIn0iOwp9KTsKdmFyIG5ld2NvbW1hbmQgPSAoY29udGV4dCwgZXhpc3RzT0ssIG5vbmV4aXN0c09LLCBza2lwSWZFeGlzdHMpID0+IHsKICB2YXIgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zOwogIGlmIChhcmcubGVuZ3RoICE9PSAxKSB7CiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiXFxuZXdjb21tYW5kJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIG1hY3JvIG5hbWUiKTsKICB9CiAgdmFyIG5hbWUgPSBhcmdbMF0udGV4dDsKICB2YXIgZXhpc3RzID0gY29udGV4dC5pc0RlZmluZWQobmFtZSk7CiAgaWYgKGV4aXN0cyAmJiAhZXhpc3RzT0spIHsKICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJcXG5ld2NvbW1hbmR7IiArIG5hbWUgKyAifSBhdHRlbXB0aW5nIHRvIHJlZGVmaW5lICIgKyAobmFtZSArICI7IHVzZSBcXHJlbmV3Y29tbWFuZCIpKTsKICB9CiAgaWYgKCFleGlzdHMgJiYgIW5vbmV4aXN0c09LKSB7CiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiXFxyZW5ld2NvbW1hbmR7IiArIG5hbWUgKyAifSB3aGVuIGNvbW1hbmQgIiArIG5hbWUgKyAiIGRvZXMgbm90IHlldCBleGlzdDsgdXNlIFxcbmV3Y29tbWFuZCIpOwogIH0KICB2YXIgbnVtQXJncyA9IDA7CiAgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zOwogIGlmIChhcmcubGVuZ3RoID09PSAxICYmIGFyZ1swXS50ZXh0ID09PSAiWyIpIHsKICAgIHZhciBhcmdUZXh0ID0gIiI7CiAgICB2YXIgdG9rZW4gPSBjb250ZXh0LmV4cGFuZE5leHRUb2tlbigpOwogICAgd2hpbGUgKHRva2VuLnRleHQgIT09ICJdIiAmJiB0b2tlbi50ZXh0ICE9PSAiRU9GIikgewogICAgICBhcmdUZXh0ICs9IHRva2VuLnRleHQ7CiAgICAgIHRva2VuID0gY29udGV4dC5leHBhbmROZXh0VG9rZW4oKTsKICAgIH0KICAgIGlmICghYXJnVGV4dC5tYXRjaCgvXlxzKlswLTldK1xzKiQvKSkgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzOiAiICsgYXJnVGV4dCk7CiAgICB9CiAgICBudW1BcmdzID0gcGFyc2VJbnQoYXJnVGV4dCk7CiAgICBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7CiAgfQogIGlmICghKGV4aXN0cyAmJiBza2lwSWZFeGlzdHMpKSB7CiAgICBjb250ZXh0Lm1hY3Jvcy5zZXQobmFtZSwgewogICAgICB0b2tlbnM6IGFyZywKICAgICAgbnVtQXJncwogICAgfSk7CiAgfQogIHJldHVybiAiIjsKfTsKZGVmaW5lTWFjcm8oIlxcbmV3Y29tbWFuZCIsIChjb250ZXh0KSA9PiBuZXdjb21tYW5kKGNvbnRleHQsIGZhbHNlLCB0cnVlLCBmYWxzZSkpOwpkZWZpbmVNYWNybygiXFxyZW5ld2NvbW1hbmQiLCAoY29udGV4dCkgPT4gbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCBmYWxzZSwgZmFsc2UpKTsKZGVmaW5lTWFjcm8oIlxccHJvdmlkZWNvbW1hbmQiLCAoY29udGV4dCkgPT4gbmV3Y29tbWFuZChjb250ZXh0LCB0cnVlLCB0cnVlLCB0cnVlKSk7CmRlZmluZU1hY3JvKCJcXG1lc3NhZ2UiLCAoY29udGV4dCkgPT4gewogIHZhciBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdOwogIGNvbnNvbGUubG9nKGFyZy5yZXZlcnNlKCkubWFwKCh0b2tlbikgPT4gdG9rZW4udGV4dCkuam9pbigiIikpOwogIHJldHVybiAiIjsKfSk7CmRlZmluZU1hY3JvKCJcXGVycm1lc3NhZ2UiLCAoY29udGV4dCkgPT4gewogIHZhciBhcmcgPSBjb250ZXh0LmNvbnN1bWVBcmdzKDEpWzBdOwogIGNvbnNvbGUuZXJyb3IoYXJnLnJldmVyc2UoKS5tYXAoKHRva2VuKSA9PiB0b2tlbi50ZXh0KS5qb2luKCIiKSk7CiAgcmV0dXJuICIiOwp9KTsKZGVmaW5lTWFjcm8oIlxcc2hvdyIsIChjb250ZXh0KSA9PiB7CiAgdmFyIHRvayA9IGNvbnRleHQucG9wVG9rZW4oKTsKICB2YXIgbmFtZSA9IHRvay50ZXh0OwogIGNvbnNvbGUubG9nKHRvaywgY29udGV4dC5tYWNyb3MuZ2V0KG5hbWUpLCBmdW5jdGlvbnNbbmFtZV0sIHN5bWJvbHMubWF0aFtuYW1lXSwgc3ltYm9scy50ZXh0W25hbWVdKTsKICByZXR1cm4gIiI7Cn0pOwpkZWZpbmVNYWNybygiXFxiZ3JvdXAiLCAieyIpOwpkZWZpbmVNYWNybygiXFxlZ3JvdXAiLCAifSIpOwpkZWZpbmVNYWNybygifiIsICJcXG5vYnJlYWtzcGFjZSIpOwpkZWZpbmVNYWNybygiXFxscSIsICJgIik7CmRlZmluZU1hY3JvKCJcXHJxIiwgIiciKTsKZGVmaW5lTWFjcm8oIlxcYWEiLCAiXFxyIGEiKTsKZGVmaW5lTWFjcm8oIlxcQUEiLCAiXFxyIEEiKTsKZGVmaW5lTWFjcm8oIlxcdGV4dGNvcHlyaWdodCIsICJcXGh0bWxAbWF0aG1se1xcdGV4dGNpcmNsZWR7Y319e1xcY2hhcmDCqX0iKTsKZGVmaW5lTWFjcm8oIlxcY29weXJpZ2h0IiwgIlxcVGV4dE9yTWF0aHtcXHRleHRjb3B5cmlnaHR9e1xcdGV4dHtcXHRleHRjb3B5cmlnaHR9fSIpOwpkZWZpbmVNYWNybygiXFx0ZXh0cmVnaXN0ZXJlZCIsICJcXGh0bWxAbWF0aG1se1xcdGV4dGNpcmNsZWR7XFxzY3JpcHRzaXplIFJ9fXtcXGNoYXJgwq59Iik7CmRlZmluZU1hY3JvKCLihKwiLCAiXFxtYXRoc2Nye0J9Iik7CmRlZmluZU1hY3JvKCLihLAiLCAiXFxtYXRoc2Nye0V9Iik7CmRlZmluZU1hY3JvKCLihLEiLCAiXFxtYXRoc2Nye0Z9Iik7CmRlZmluZU1hY3JvKCLihIsiLCAiXFxtYXRoc2Nye0h9Iik7CmRlZmluZU1hY3JvKCLihJAiLCAiXFxtYXRoc2Nye0l9Iik7CmRlZmluZU1hY3JvKCLihJIiLCAiXFxtYXRoc2Nye0x9Iik7CmRlZmluZU1hY3JvKCLihLMiLCAiXFxtYXRoc2Nye019Iik7CmRlZmluZU1hY3JvKCLihJsiLCAiXFxtYXRoc2Nye1J9Iik7CmRlZmluZU1hY3JvKCLihK0iLCAiXFxtYXRoZnJha3tDfSIpOwpkZWZpbmVNYWNybygi4oSMIiwgIlxcbWF0aGZyYWt7SH0iKTsKZGVmaW5lTWFjcm8oIuKEqCIsICJcXG1hdGhmcmFre1p9Iik7CmRlZmluZU1hY3JvKCJcXEJiYmsiLCAiXFxCYmJ7a30iKTsKZGVmaW5lTWFjcm8oIsK3IiwgIlxcY2RvdHAiKTsKZGVmaW5lTWFjcm8oIlxcbGxhcCIsICJcXG1hdGhsbGFwe1xcdGV4dHJteyMxfX0iKTsKZGVmaW5lTWFjcm8oIlxccmxhcCIsICJcXG1hdGhybGFwe1xcdGV4dHJteyMxfX0iKTsKZGVmaW5lTWFjcm8oIlxcY2xhcCIsICJcXG1hdGhjbGFwe1xcdGV4dHJteyMxfX0iKTsKZGVmaW5lTWFjcm8oIlxcbWF0aHN0cnV0IiwgIlxcdnBoYW50b217KH0iKTsKZGVmaW5lTWFjcm8oIlxcdW5kZXJiYXIiLCAiXFx1bmRlcmxpbmV7XFx0ZXh0eyMxfX0iKTsKZGVmaW5lTWFjcm8oIlxcbm90IiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcbWF0aHJsYXBcXEBub3R9fXtcXGNoYXIiMzM4fScpOwpkZWZpbmVNYWNybygiXFxuZXEiLCAiXFxodG1sQG1hdGhtbHtcXG1hdGhyZWx7XFxub3Q9fX17XFxtYXRocmVse1xcY2hhcmDiiaB9fSIpOwpkZWZpbmVNYWNybygiXFxuZSIsICJcXG5lcSIpOwpkZWZpbmVNYWNybygi4omgIiwgIlxcbmVxIik7CmRlZmluZU1hY3JvKCJcXG5vdGluIiwgIlxcaHRtbEBtYXRobWx7XFxtYXRocmVse3tcXGlufVxcbWF0aGxsYXB7L1xcbXNraXAxbXV9fX17XFxtYXRocmVse1xcY2hhcmDiiIl9fSIpOwpkZWZpbmVNYWNybygi4oiJIiwgIlxcbm90aW4iKTsKZGVmaW5lTWFjcm8oIuKJmCIsICJcXGh0bWxAbWF0aG1se1xcbWF0aHJlbHs9XFxrZXJuey0xZW19XFxyYWlzZWJveHswLjRlbX17JFxcc2NyaXB0c2l6ZVxcZnJvd24kfX19e1xcbWF0aHJlbHtcXGNoYXJg4omYfX0iKTsKZGVmaW5lTWFjcm8oIuKJmSIsICJcXGh0bWxAbWF0aG1se1xcc3RhY2tyZWx7XFx0aW55XFx3ZWRnZX17PX19e1xcbWF0aHJlbHtcXGNoYXJg4omYfX0iKTsKZGVmaW5lTWFjcm8oIuKJmiIsICJcXGh0bWxAbWF0aG1se1xcc3RhY2tyZWx7XFx0aW55XFx2ZWV9ez19fXtcXG1hdGhyZWx7XFxjaGFyYOKJmn19Iik7CmRlZmluZU1hY3JvKCLiiZsiLCAiXFxodG1sQG1hdGhtbHtcXHN0YWNrcmVse1xcc2NyaXB0c2l6ZVxcc3Rhcn17PX19e1xcbWF0aHJlbHtcXGNoYXJg4ombfX0iKTsKZGVmaW5lTWFjcm8oIuKJnSIsICJcXGh0bWxAbWF0aG1se1xcc3RhY2tyZWx7XFx0aW55XFxtYXRocm17ZGVmfX17PX19e1xcbWF0aHJlbHtcXGNoYXJg4omdfX0iKTsKZGVmaW5lTWFjcm8oIuKJniIsICJcXGh0bWxAbWF0aG1se1xcc3RhY2tyZWx7XFx0aW55XFxtYXRocm17bX19ez19fXtcXG1hdGhyZWx7XFxjaGFyYOKJnn19Iik7CmRlZmluZU1hY3JvKCLiiZ8iLCAiXFxodG1sQG1hdGhtbHtcXHN0YWNrcmVse1xcdGlueT99ez19fXtcXG1hdGhyZWx7XFxjaGFyYOKJn319Iik7CmRlZmluZU1hY3JvKCLin4IiLCAiXFxwZXJwIik7CmRlZmluZU1hY3JvKCLigLwiLCAiXFxtYXRoY2xvc2V7IVxcbWtlcm4tMC44bXUhfSIpOwpkZWZpbmVNYWNybygi4oiMIiwgIlxcbm90bmkiKTsKZGVmaW5lTWFjcm8oIuKMnCIsICJcXHVsY29ybmVyIik7CmRlZmluZU1hY3JvKCLijJ0iLCAiXFx1cmNvcm5lciIpOwpkZWZpbmVNYWNybygi4oyeIiwgIlxcbGxjb3JuZXIiKTsKZGVmaW5lTWFjcm8oIuKMnyIsICJcXGxyY29ybmVyIik7CmRlZmluZU1hY3JvKCLCqSIsICJcXGNvcHlyaWdodCIpOwpkZWZpbmVNYWNybygiwq4iLCAiXFx0ZXh0cmVnaXN0ZXJlZCIpOwpkZWZpbmVNYWNybygi77iPIiwgIlxcdGV4dHJlZ2lzdGVyZWQiKTsKZGVmaW5lTWFjcm8oIlxcdWxjb3JuZXIiLCAnXFxodG1sQG1hdGhtbHtcXEB1bGNvcm5lcn17XFxtYXRob3B7XFxjaGFyIjIzMWN9fScpOwpkZWZpbmVNYWNybygiXFx1cmNvcm5lciIsICdcXGh0bWxAbWF0aG1se1xcQHVyY29ybmVyfXtcXG1hdGhvcHtcXGNoYXIiMjMxZH19Jyk7CmRlZmluZU1hY3JvKCJcXGxsY29ybmVyIiwgJ1xcaHRtbEBtYXRobWx7XFxAbGxjb3JuZXJ9e1xcbWF0aG9we1xcY2hhciIyMzFlfX0nKTsKZGVmaW5lTWFjcm8oIlxcbHJjb3JuZXIiLCAnXFxodG1sQG1hdGhtbHtcXEBscmNvcm5lcn17XFxtYXRob3B7XFxjaGFyIjIzMWZ9fScpOwpkZWZpbmVNYWNybygiXFx2ZG90cyIsICJ7XFx2YXJ2ZG90c1xccnVsZXswcHR9ezE1cHR9fSIpOwpkZWZpbmVNYWNybygi4ouuIiwgIlxcdmRvdHMiKTsKZGVmaW5lTWFjcm8oIlxcdmFyR2FtbWEiLCAiXFxtYXRoaXR7XFxHYW1tYX0iKTsKZGVmaW5lTWFjcm8oIlxcdmFyRGVsdGEiLCAiXFxtYXRoaXR7XFxEZWx0YX0iKTsKZGVmaW5lTWFjcm8oIlxcdmFyVGhldGEiLCAiXFxtYXRoaXR7XFxUaGV0YX0iKTsKZGVmaW5lTWFjcm8oIlxcdmFyTGFtYmRhIiwgIlxcbWF0aGl0e1xcTGFtYmRhfSIpOwpkZWZpbmVNYWNybygiXFx2YXJYaSIsICJcXG1hdGhpdHtcXFhpfSIpOwpkZWZpbmVNYWNybygiXFx2YXJQaSIsICJcXG1hdGhpdHtcXFBpfSIpOwpkZWZpbmVNYWNybygiXFx2YXJTaWdtYSIsICJcXG1hdGhpdHtcXFNpZ21hfSIpOwpkZWZpbmVNYWNybygiXFx2YXJVcHNpbG9uIiwgIlxcbWF0aGl0e1xcVXBzaWxvbn0iKTsKZGVmaW5lTWFjcm8oIlxcdmFyUGhpIiwgIlxcbWF0aGl0e1xcUGhpfSIpOwpkZWZpbmVNYWNybygiXFx2YXJQc2kiLCAiXFxtYXRoaXR7XFxQc2l9Iik7CmRlZmluZU1hY3JvKCJcXHZhck9tZWdhIiwgIlxcbWF0aGl0e1xcT21lZ2F9Iik7CmRlZmluZU1hY3JvKCJcXHN1YnN0YWNrIiwgIlxcYmVnaW57c3ViYXJyYXl9e2N9IzFcXGVuZHtzdWJhcnJheX0iKTsKZGVmaW5lTWFjcm8oIlxcY29sb24iLCAiXFxub2JyZWFrXFxtc2tpcDJtdVxcbWF0aHB1bmN0e31cXG1hdGhjaG9pY2V7XFxta2Vybi0zbXV9e1xcbWtlcm4tM211fXt9e317On1cXG1za2lwNm11XFxyZWxheCIpOwpkZWZpbmVNYWNybygiXFxib3hlZCIsICJcXGZib3h7JFxcZGlzcGxheXN0eWxleyMxfSR9Iik7CmRlZmluZU1hY3JvKCJcXGlmZiIsICJcXERPVFNCXFw7XFxMb25nbGVmdHJpZ2h0YXJyb3dcXDsiKTsKZGVmaW5lTWFjcm8oIlxcaW1wbGllcyIsICJcXERPVFNCXFw7XFxMb25ncmlnaHRhcnJvd1xcOyIpOwpkZWZpbmVNYWNybygiXFxpbXBsaWVkYnkiLCAiXFxET1RTQlxcO1xcTG9uZ2xlZnRhcnJvd1xcOyIpOwpkZWZpbmVNYWNybygiXFxkZGRvdCIsICJ7XFxvdmVyc2V0e1xccmFpc2Vib3h7LTAuMWV4fXtcXG5vcm1hbHNpemUgLi4ufX17IzF9fSIpOwpkZWZpbmVNYWNybygiXFxkZGRkb3QiLCAie1xcb3ZlcnNldHtcXHJhaXNlYm94ey0wLjFleH17XFxub3JtYWxzaXplIC4uLi59fXsjMX19Iik7CnZhciBkb3RzQnlUb2tlbiA9IHsKICAiLCI6ICJcXGRvdHNjIiwKICAiXFxub3QiOiAiXFxkb3RzYiIsCiAgLy8gXGtleWJpbkAgY2hlY2tzIGZvciB0aGUgZm9sbG93aW5nOgogICIrIjogIlxcZG90c2IiLAogICI9IjogIlxcZG90c2IiLAogICI8IjogIlxcZG90c2IiLAogICI+IjogIlxcZG90c2IiLAogICItIjogIlxcZG90c2IiLAogICIqIjogIlxcZG90c2IiLAogICI6IjogIlxcZG90c2IiLAogIC8vIFN5bWJvbHMgd2hvc2UgZGVmaW5pdGlvbiBzdGFydHMgd2l0aCBcRE9UU0I6CiAgIlxcRE9UU0IiOiAiXFxkb3RzYiIsCiAgIlxcY29wcm9kIjogIlxcZG90c2IiLAogICJcXGJpZ3ZlZSI6ICJcXGRvdHNiIiwKICAiXFxiaWd3ZWRnZSI6ICJcXGRvdHNiIiwKICAiXFxiaWd1cGx1cyI6ICJcXGRvdHNiIiwKICAiXFxiaWdjYXAiOiAiXFxkb3RzYiIsCiAgIlxcYmlnY3VwIjogIlxcZG90c2IiLAogICJcXHByb2QiOiAiXFxkb3RzYiIsCiAgIlxcc3VtIjogIlxcZG90c2IiLAogICJcXGJpZ290aW1lcyI6ICJcXGRvdHNiIiwKICAiXFxiaWdvcGx1cyI6ICJcXGRvdHNiIiwKICAiXFxiaWdvZG90IjogIlxcZG90c2IiLAogICJcXGJpZ3NxY3VwIjogIlxcZG90c2IiLAogICJcXEFuZCI6ICJcXGRvdHNiIiwKICAiXFxsb25ncmlnaHRhcnJvdyI6ICJcXGRvdHNiIiwKICAiXFxMb25ncmlnaHRhcnJvdyI6ICJcXGRvdHNiIiwKICAiXFxsb25nbGVmdGFycm93IjogIlxcZG90c2IiLAogICJcXExvbmdsZWZ0YXJyb3ciOiAiXFxkb3RzYiIsCiAgIlxcbG9uZ2xlZnRyaWdodGFycm93IjogIlxcZG90c2IiLAogICJcXExvbmdsZWZ0cmlnaHRhcnJvdyI6ICJcXGRvdHNiIiwKICAiXFxtYXBzdG8iOiAiXFxkb3RzYiIsCiAgIlxcbG9uZ21hcHN0byI6ICJcXGRvdHNiIiwKICAiXFxob29rcmlnaHRhcnJvdyI6ICJcXGRvdHNiIiwKICAiXFxkb3RlcSI6ICJcXGRvdHNiIiwKICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXG1hdGhiaW46CiAgIlxcbWF0aGJpbiI6ICJcXGRvdHNiIiwKICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXG1hdGhyZWw6CiAgIlxcbWF0aHJlbCI6ICJcXGRvdHNiIiwKICAiXFxyZWxiYXIiOiAiXFxkb3RzYiIsCiAgIlxcUmVsYmFyIjogIlxcZG90c2IiLAogICJcXHhyaWdodGFycm93IjogIlxcZG90c2IiLAogICJcXHhsZWZ0YXJyb3ciOiAiXFxkb3RzYiIsCiAgLy8gU3ltYm9scyB3aG9zZSBkZWZpbml0aW9uIHN0YXJ0cyB3aXRoIFxET1RTSToKICAiXFxET1RTSSI6ICJcXGRvdHNpIiwKICAiXFxpbnQiOiAiXFxkb3RzaSIsCiAgIlxcb2ludCI6ICJcXGRvdHNpIiwKICAiXFxpaW50IjogIlxcZG90c2kiLAogICJcXGlpaW50IjogIlxcZG90c2kiLAogICJcXGlpaWludCI6ICJcXGRvdHNpIiwKICAiXFxpZG90c2ludCI6ICJcXGRvdHNpIiwKICAvLyBTeW1ib2xzIHdob3NlIGRlZmluaXRpb24gc3RhcnRzIHdpdGggXERPVFNYOgogICJcXERPVFNYIjogIlxcZG90c3giCn07CmRlZmluZU1hY3JvKCJcXGRvdHMiLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIHRoZWRvdHMgPSAiXFxkb3RzbyI7CiAgdmFyIG5leHQgPSBjb250ZXh0LmV4cGFuZEFmdGVyRnV0dXJlKCkudGV4dDsKICBpZiAobmV4dCBpbiBkb3RzQnlUb2tlbikgewogICAgdGhlZG90cyA9IGRvdHNCeVRva2VuW25leHRdOwogIH0gZWxzZSBpZiAobmV4dC5zbGljZSgwLCA0KSA9PT0gIlxcbm90IikgewogICAgdGhlZG90cyA9ICJcXGRvdHNiIjsKICB9IGVsc2UgaWYgKG5leHQgaW4gc3ltYm9scy5tYXRoKSB7CiAgICBpZiAodXRpbHMuY29udGFpbnMoWyJiaW4iLCAicmVsIl0sIHN5bWJvbHMubWF0aFtuZXh0XS5ncm91cCkpIHsKICAgICAgdGhlZG90cyA9ICJcXGRvdHNiIjsKICAgIH0KICB9CiAgcmV0dXJuIHRoZWRvdHM7Cn0pOwp2YXIgc3BhY2VBZnRlckRvdHMgPSB7CiAgLy8gXHJpZ2h0ZGVsaW1AIGNoZWNrcyBmb3IgdGhlIGZvbGxvd2luZzoKICAiKSI6IHRydWUsCiAgIl0iOiB0cnVlLAogICJcXHJicmFjayI6IHRydWUsCiAgIlxcfSI6IHRydWUsCiAgIlxccmJyYWNlIjogdHJ1ZSwKICAiXFxyYW5nbGUiOiB0cnVlLAogICJcXHJjZWlsIjogdHJ1ZSwKICAiXFxyZmxvb3IiOiB0cnVlLAogICJcXHJncm91cCI6IHRydWUsCiAgIlxccm1vdXN0YWNoZSI6IHRydWUsCiAgIlxccmlnaHQiOiB0cnVlLAogICJcXGJpZ3IiOiB0cnVlLAogICJcXGJpZ2dyIjogdHJ1ZSwKICAiXFxCaWdyIjogdHJ1ZSwKICAiXFxCaWdnciI6IHRydWUsCiAgLy8gXGV4dHJhQCBhbHNvIHRlc3RzIGZvciB0aGUgZm9sbG93aW5nOgogICIkIjogdHJ1ZSwKICAvLyBcZXh0cmFwQCBjaGVja3MgZm9yIHRoZSBmb2xsb3dpbmc6CiAgIjsiOiB0cnVlLAogICIuIjogdHJ1ZSwKICAiLCI6IHRydWUKfTsKZGVmaW5lTWFjcm8oIlxcZG90c28iLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7CiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMpIHsKICAgIHJldHVybiAiXFxsZG90c1xcLCI7CiAgfSBlbHNlIHsKICAgIHJldHVybiAiXFxsZG90cyI7CiAgfQp9KTsKZGVmaW5lTWFjcm8oIlxcZG90c2MiLCBmdW5jdGlvbihjb250ZXh0KSB7CiAgdmFyIG5leHQgPSBjb250ZXh0LmZ1dHVyZSgpLnRleHQ7CiAgaWYgKG5leHQgaW4gc3BhY2VBZnRlckRvdHMgJiYgbmV4dCAhPT0gIiwiKSB7CiAgICByZXR1cm4gIlxcbGRvdHNcXCwiOwogIH0gZWxzZSB7CiAgICByZXR1cm4gIlxcbGRvdHMiOwogIH0KfSk7CmRlZmluZU1hY3JvKCJcXGNkb3RzIiwgZnVuY3Rpb24oY29udGV4dCkgewogIHZhciBuZXh0ID0gY29udGV4dC5mdXR1cmUoKS50ZXh0OwogIGlmIChuZXh0IGluIHNwYWNlQWZ0ZXJEb3RzKSB7CiAgICByZXR1cm4gIlxcQGNkb3RzXFwsIjsKICB9IGVsc2UgewogICAgcmV0dXJuICJcXEBjZG90cyI7CiAgfQp9KTsKZGVmaW5lTWFjcm8oIlxcZG90c2IiLCAiXFxjZG90cyIpOwpkZWZpbmVNYWNybygiXFxkb3RzbSIsICJcXGNkb3RzIik7CmRlZmluZU1hY3JvKCJcXGRvdHNpIiwgIlxcIVxcY2RvdHMiKTsKZGVmaW5lTWFjcm8oIlxcZG90c3giLCAiXFxsZG90c1xcLCIpOwpkZWZpbmVNYWNybygiXFxET1RTSSIsICJcXHJlbGF4Iik7CmRlZmluZU1hY3JvKCJcXERPVFNCIiwgIlxccmVsYXgiKTsKZGVmaW5lTWFjcm8oIlxcRE9UU1giLCAiXFxyZWxheCIpOwpkZWZpbmVNYWNybygiXFx0bXNwYWNlIiwgIlxcVGV4dE9yTWF0aHtcXGtlcm4jMSMzfXtcXG1za2lwIzEjMn1cXHJlbGF4Iik7CmRlZmluZU1hY3JvKCJcXCwiLCAiXFx0bXNwYWNlK3szbXV9ey4xNjY3ZW19Iik7CmRlZmluZU1hY3JvKCJcXHRoaW5zcGFjZSIsICJcXCwiKTsKZGVmaW5lTWFjcm8oIlxcPiIsICJcXG1za2lwezRtdX0iKTsKZGVmaW5lTWFjcm8oIlxcOiIsICJcXHRtc3BhY2UrezRtdX17LjIyMjJlbX0iKTsKZGVmaW5lTWFjcm8oIlxcbWVkc3BhY2UiLCAiXFw6Iik7CmRlZmluZU1hY3JvKCJcXDsiLCAiXFx0bXNwYWNlK3s1bXV9ey4yNzc3ZW19Iik7CmRlZmluZU1hY3JvKCJcXHRoaWNrc3BhY2UiLCAiXFw7Iik7CmRlZmluZU1hY3JvKCJcXCEiLCAiXFx0bXNwYWNlLXszbXV9ey4xNjY3ZW19Iik7CmRlZmluZU1hY3JvKCJcXG5lZ3RoaW5zcGFjZSIsICJcXCEiKTsKZGVmaW5lTWFjcm8oIlxcbmVnbWVkc3BhY2UiLCAiXFx0bXNwYWNlLXs0bXV9ey4yMjIyZW19Iik7CmRlZmluZU1hY3JvKCJcXG5lZ3RoaWNrc3BhY2UiLCAiXFx0bXNwYWNlLXs1bXV9ey4yNzdlbX0iKTsKZGVmaW5lTWFjcm8oIlxcZW5zcGFjZSIsICJcXGtlcm4uNWVtICIpOwpkZWZpbmVNYWNybygiXFxlbnNraXAiLCAiXFxoc2tpcC41ZW1cXHJlbGF4Iik7CmRlZmluZU1hY3JvKCJcXHF1YWQiLCAiXFxoc2tpcDFlbVxccmVsYXgiKTsKZGVmaW5lTWFjcm8oIlxccXF1YWQiLCAiXFxoc2tpcDJlbVxccmVsYXgiKTsKZGVmaW5lTWFjcm8oIlxcdGFnIiwgIlxcQGlmc3RhclxcdGFnQGxpdGVyYWxcXHRhZ0BwYXJlbiIpOwpkZWZpbmVNYWNybygiXFx0YWdAcGFyZW4iLCAiXFx0YWdAbGl0ZXJhbHsoeyMxfSl9Iik7CmRlZmluZU1hY3JvKCJcXHRhZ0BsaXRlcmFsIiwgKGNvbnRleHQpID0+IHsKICBpZiAoY29udGV4dC5tYWNyb3MuZ2V0KCJcXGRmQHRhZyIpKSB7CiAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiTXVsdGlwbGUgXFx0YWciKTsKICB9CiAgcmV0dXJuICJcXGdkZWZcXGRmQHRhZ3tcXHRleHR7IzF9fSI7Cn0pOwpkZWZpbmVNYWNybygiXFxibW9kIiwgIlxcbWF0aGNob2ljZXtcXG1za2lwMW11fXtcXG1za2lwMW11fXtcXG1za2lwNW11fXtcXG1za2lwNW11fVxcbWF0aGJpbntcXHJtIG1vZH1cXG1hdGhjaG9pY2V7XFxtc2tpcDFtdX17XFxtc2tpcDFtdX17XFxtc2tpcDVtdX17XFxtc2tpcDVtdX0iKTsKZGVmaW5lTWFjcm8oIlxccG9kIiwgIlxcYWxsb3dicmVha1xcbWF0aGNob2ljZXtcXG1rZXJuMThtdX17XFxta2VybjhtdX17XFxta2VybjhtdX17XFxta2VybjhtdX0oIzEpIik7CmRlZmluZU1hY3JvKCJcXHBtb2QiLCAiXFxwb2R7e1xccm0gbW9kfVxcbWtlcm42bXUjMX0iKTsKZGVmaW5lTWFjcm8oIlxcbW9kIiwgIlxcYWxsb3dicmVha1xcbWF0aGNob2ljZXtcXG1rZXJuMThtdX17XFxta2VybjEybXV9e1xcbWtlcm4xMm11fXtcXG1rZXJuMTJtdX17XFxybSBtb2R9XFwsXFwsIzEiKTsKZGVmaW5lTWFjcm8oIlxcbmV3bGluZSIsICJcXFxcXFxyZWxheCIpOwpkZWZpbmVNYWNybygiXFxUZVgiLCAiXFx0ZXh0cm17XFxodG1sQG1hdGhtbHtUXFxrZXJuLS4xNjY3ZW1cXHJhaXNlYm94ey0uNWV4fXtFfVxca2Vybi0uMTI1ZW1YfXtUZVh9fSIpOwp2YXIgbGF0ZXhSYWlzZUEgPSBtYWtlRW0oZm9udE1ldHJpY3NEYXRhWyJNYWluLVJlZ3VsYXIiXVsiVCIuY2hhckNvZGVBdCgwKV1bMV0gLSAwLjcgKiBmb250TWV0cmljc0RhdGFbIk1haW4tUmVndWxhciJdWyJBIi5jaGFyQ29kZUF0KDApXVsxXSk7CmRlZmluZU1hY3JvKCJcXExhVGVYIiwgIlxcdGV4dHJte1xcaHRtbEBtYXRobWx7IiArICgiTFxca2Vybi0uMzZlbVxccmFpc2Vib3h7IiArIGxhdGV4UmFpc2VBICsgIn17XFxzY3JpcHRzdHlsZSBBfSIpICsgIlxca2Vybi0uMTVlbVxcVGVYfXtMYVRlWH19Iik7CmRlZmluZU1hY3JvKCJcXEthVGVYIiwgIlxcdGV4dHJte1xcaHRtbEBtYXRobWx7IiArICgiS1xca2Vybi0uMTdlbVxccmFpc2Vib3h7IiArIGxhdGV4UmFpc2VBICsgIn17XFxzY3JpcHRzdHlsZSBBfSIpICsgIlxca2Vybi0uMTVlbVxcVGVYfXtLYVRlWH19Iik7CmRlZmluZU1hY3JvKCJcXGhzcGFjZSIsICJcXEBpZnN0YXJcXEBoc3BhY2VyXFxAaHNwYWNlIik7CmRlZmluZU1hY3JvKCJcXEBoc3BhY2UiLCAiXFxoc2tpcCAjMVxccmVsYXgiKTsKZGVmaW5lTWFjcm8oIlxcQGhzcGFjZXIiLCAiXFxydWxlezBwdH17MHB0fVxcaHNraXAgIzFcXHJlbGF4Iik7CmRlZmluZU1hY3JvKCJcXG9yZGluYXJ5Y29sb24iLCAiOiIpOwpkZWZpbmVNYWNybygiXFx2Y2VudGNvbG9uIiwgIlxcbWF0aHJlbHtcXG1hdGhvcFxcb3JkaW5hcnljb2xvbn0iKTsKZGVmaW5lTWFjcm8oIlxcZGJsY29sb24iLCAnXFxodG1sQG1hdGhtbHtcXG1hdGhyZWx7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tLjltdX1cXHZjZW50Y29sb259fXtcXG1hdGhvcHtcXGNoYXIiMjIzN319Jyk7CmRlZmluZU1hY3JvKCJcXGNvbG9uZXFxIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fT19fXtcXG1hdGhvcHtcXGNoYXIiMjI1NH19Jyk7CmRlZmluZU1hY3JvKCJcXENvbG9uZXFxIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX09fX17XFxtYXRob3B7XFxjaGFyIjIyMzdcXGNoYXIiM2R9fScpOwpkZWZpbmVNYWNybygiXFxjb2xvbmVxIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcbWF0aHJlbHstfX19e1xcbWF0aG9we1xcY2hhciIzYVxcY2hhciIyMjEyfX0nKTsKZGVmaW5lTWFjcm8oIlxcQ29sb25lcSIsICdcXGh0bWxAbWF0aG1se1xcbWF0aHJlbHtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxtYXRocmVsey19fX17XFxtYXRob3B7XFxjaGFyIjIyMzdcXGNoYXIiMjIxMn19Jyk7CmRlZmluZU1hY3JvKCJcXGVxcWNvbG9uIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVsez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHZjZW50Y29sb259fXtcXG1hdGhvcHtcXGNoYXIiMjI1NX19Jyk7CmRlZmluZU1hY3JvKCJcXEVxcWNvbG9uIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVsez1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufX17XFxtYXRob3B7XFxjaGFyIjNkXFxjaGFyIjIyMzd9fScpOwpkZWZpbmVNYWNybygiXFxlcWNvbG9uIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcbWF0aHJlbHstfVxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcdmNlbnRjb2xvbn19e1xcbWF0aG9we1xcY2hhciIyMjM5fX0nKTsKZGVmaW5lTWFjcm8oIlxcRXFjb2xvbiIsICdcXGh0bWxAbWF0aG1se1xcbWF0aHJlbHtcXG1hdGhyZWx7LX1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXGRibGNvbG9ufX17XFxtYXRob3B7XFxjaGFyIjIyMTJcXGNoYXIiMjIzN319Jyk7CmRlZmluZU1hY3JvKCJcXGNvbG9uYXBwcm94IiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcdmNlbnRjb2xvblxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcYXBwcm94fX17XFxtYXRob3B7XFxjaGFyIjNhXFxjaGFyIjIyNDh9fScpOwpkZWZpbmVNYWNybygiXFxDb2xvbmFwcHJveCIsICdcXGh0bWxAbWF0aG1se1xcbWF0aHJlbHtcXGRibGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxhcHByb3h9fXtcXG1hdGhvcHtcXGNoYXIiMjIzN1xcY2hhciIyMjQ4fX0nKTsKZGVmaW5lTWFjcm8oIlxcY29sb25zaW0iLCAnXFxodG1sQG1hdGhtbHtcXG1hdGhyZWx7XFx2Y2VudGNvbG9uXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxzaW19fXtcXG1hdGhvcHtcXGNoYXIiM2FcXGNoYXIiMjIzY319Jyk7CmRlZmluZU1hY3JvKCJcXENvbG9uc2ltIiwgJ1xcaHRtbEBtYXRobWx7XFxtYXRocmVse1xcZGJsY29sb25cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHNpbX19e1xcbWF0aG9we1xcY2hhciIyMjM3XFxjaGFyIjIyM2N9fScpOwpkZWZpbmVNYWNybygi4oi3IiwgIlxcZGJsY29sb24iKTsKZGVmaW5lTWFjcm8oIuKIuSIsICJcXGVxY29sb24iKTsKZGVmaW5lTWFjcm8oIuKJlCIsICJcXGNvbG9uZXFxIik7CmRlZmluZU1hY3JvKCLiiZUiLCAiXFxlcXFjb2xvbiIpOwpkZWZpbmVNYWNybygi4qm0IiwgIlxcQ29sb25lcXEiKTsKZGVmaW5lTWFjcm8oIlxccmF0aW8iLCAiXFx2Y2VudGNvbG9uIik7CmRlZmluZU1hY3JvKCJcXGNvbG9uY29sb24iLCAiXFxkYmxjb2xvbiIpOwpkZWZpbmVNYWNybygiXFxjb2xvbmVxdWFscyIsICJcXGNvbG9uZXFxIik7CmRlZmluZU1hY3JvKCJcXGNvbG9uY29sb25lcXVhbHMiLCAiXFxDb2xvbmVxcSIpOwpkZWZpbmVNYWNybygiXFxlcXVhbHNjb2xvbiIsICJcXGVxcWNvbG9uIik7CmRlZmluZU1hY3JvKCJcXGVxdWFsc2NvbG9uY29sb24iLCAiXFxFcXFjb2xvbiIpOwpkZWZpbmVNYWNybygiXFxjb2xvbm1pbnVzIiwgIlxcY29sb25lcSIpOwpkZWZpbmVNYWNybygiXFxjb2xvbmNvbG9ubWludXMiLCAiXFxDb2xvbmVxIik7CmRlZmluZU1hY3JvKCJcXG1pbnVzY29sb24iLCAiXFxlcWNvbG9uIik7CmRlZmluZU1hY3JvKCJcXG1pbnVzY29sb25jb2xvbiIsICJcXEVxY29sb24iKTsKZGVmaW5lTWFjcm8oIlxcY29sb25jb2xvbmFwcHJveCIsICJcXENvbG9uYXBwcm94Iik7CmRlZmluZU1hY3JvKCJcXGNvbG9uY29sb25zaW0iLCAiXFxDb2xvbnNpbSIpOwpkZWZpbmVNYWNybygiXFxzaW1jb2xvbiIsICJcXG1hdGhyZWx7XFxzaW1cXG1hdGhyZWx7XFxta2Vybi0xLjJtdX1cXHZjZW50Y29sb259Iik7CmRlZmluZU1hY3JvKCJcXHNpbWNvbG9uY29sb24iLCAiXFxtYXRocmVse1xcc2ltXFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFxkYmxjb2xvbn0iKTsKZGVmaW5lTWFjcm8oIlxcYXBwcm94Y29sb24iLCAiXFxtYXRocmVse1xcYXBwcm94XFxtYXRocmVse1xcbWtlcm4tMS4ybXV9XFx2Y2VudGNvbG9ufSIpOwpkZWZpbmVNYWNybygiXFxhcHByb3hjb2xvbmNvbG9uIiwgIlxcbWF0aHJlbHtcXGFwcHJveFxcbWF0aHJlbHtcXG1rZXJuLTEuMm11fVxcZGJsY29sb259Iik7CmRlZmluZU1hY3JvKCJcXG5vdG5pIiwgIlxcaHRtbEBtYXRobWx7XFxub3RcXG5pfXtcXG1hdGhyZWx7XFxjaGFyYOKIjH19Iik7CmRlZmluZU1hY3JvKCJcXGxpbXN1cCIsICJcXERPVFNCXFxvcGVyYXRvcm5hbWUqe2xpbVxcLHN1cH0iKTsKZGVmaW5lTWFjcm8oIlxcbGltaW5mIiwgIlxcRE9UU0JcXG9wZXJhdG9ybmFtZSp7bGltXFwsaW5mfSIpOwpkZWZpbmVNYWNybygiXFxpbmpsaW0iLCAiXFxET1RTQlxcb3BlcmF0b3JuYW1lKntpbmpcXCxsaW19Iik7CmRlZmluZU1hY3JvKCJcXHByb2psaW0iLCAiXFxET1RTQlxcb3BlcmF0b3JuYW1lKntwcm9qXFwsbGltfSIpOwpkZWZpbmVNYWNybygiXFx2YXJsaW1zdXAiLCAiXFxET1RTQlxcb3BlcmF0b3JuYW1lKntcXG92ZXJsaW5le2xpbX19Iik7CmRlZmluZU1hY3JvKCJcXHZhcmxpbWluZiIsICJcXERPVFNCXFxvcGVyYXRvcm5hbWUqe1xcdW5kZXJsaW5le2xpbX19Iik7CmRlZmluZU1hY3JvKCJcXHZhcmluamxpbSIsICJcXERPVFNCXFxvcGVyYXRvcm5hbWUqe1xcdW5kZXJyaWdodGFycm93e2xpbX19Iik7CmRlZmluZU1hY3JvKCJcXHZhcnByb2psaW0iLCAiXFxET1RTQlxcb3BlcmF0b3JuYW1lKntcXHVuZGVybGVmdGFycm93e2xpbX19Iik7CmRlZmluZU1hY3JvKCJcXGd2ZXJ0bmVxcSIsICJcXGh0bWxAbWF0aG1se1xcQGd2ZXJ0bmVxcX174ompfSIpOwpkZWZpbmVNYWNybygiXFxsdmVydG5lcXEiLCAiXFxodG1sQG1hdGhtbHtcXEBsdmVydG5lcXF9e+KJqH0iKTsKZGVmaW5lTWFjcm8oIlxcbmdlcXEiLCAiXFxodG1sQG1hdGhtbHtcXEBuZ2VxcX174omxfSIpOwpkZWZpbmVNYWNybygiXFxuZ2Vxc2xhbnQiLCAiXFxodG1sQG1hdGhtbHtcXEBuZ2Vxc2xhbnR9e+KJsX0iKTsKZGVmaW5lTWFjcm8oIlxcbmxlcXEiLCAiXFxodG1sQG1hdGhtbHtcXEBubGVxcX174omwfSIpOwpkZWZpbmVNYWNybygiXFxubGVxc2xhbnQiLCAiXFxodG1sQG1hdGhtbHtcXEBubGVxc2xhbnR9e+KJsH0iKTsKZGVmaW5lTWFjcm8oIlxcbnNob3J0bWlkIiwgIlxcaHRtbEBtYXRobWx7XFxAbnNob3J0bWlkfXviiKR9Iik7CmRlZmluZU1hY3JvKCJcXG5zaG9ydHBhcmFsbGVsIiwgIlxcaHRtbEBtYXRobWx7XFxAbnNob3J0cGFyYWxsZWx9e+KIpn0iKTsKZGVmaW5lTWFjcm8oIlxcbnN1YnNldGVxcSIsICJcXGh0bWxAbWF0aG1se1xcQG5zdWJzZXRlcXF9e+KKiH0iKTsKZGVmaW5lTWFjcm8oIlxcbnN1cHNldGVxcSIsICJcXGh0bWxAbWF0aG1se1xcQG5zdXBzZXRlcXF9e+KKiX0iKTsKZGVmaW5lTWFjcm8oIlxcdmFyc3Vic2V0bmVxIiwgIlxcaHRtbEBtYXRobWx7XFxAdmFyc3Vic2V0bmVxfXviiop9Iik7CmRlZmluZU1hY3JvKCJcXHZhcnN1YnNldG5lcXEiLCAiXFxodG1sQG1hdGhtbHtcXEB2YXJzdWJzZXRuZXFxfXviq4t9Iik7CmRlZmluZU1hY3JvKCJcXHZhcnN1cHNldG5lcSIsICJcXGh0bWxAbWF0aG1se1xcQHZhcnN1cHNldG5lcX174oqLfSIpOwpkZWZpbmVNYWNybygiXFx2YXJzdXBzZXRuZXFxIiwgIlxcaHRtbEBtYXRobWx7XFxAdmFyc3Vwc2V0bmVxcX174quMfSIpOwpkZWZpbmVNYWNybygiXFxpbWF0aCIsICJcXGh0bWxAbWF0aG1se1xcQGltYXRofXvEsX0iKTsKZGVmaW5lTWFjcm8oIlxcam1hdGgiLCAiXFxodG1sQG1hdGhtbHtcXEBqbWF0aH17yLd9Iik7CmRlZmluZU1hY3JvKCJcXGxsYnJhY2tldCIsICJcXGh0bWxAbWF0aG1se1xcbWF0aG9wZW57W1xcbWtlcm4tMy4ybXVbfX17XFxtYXRob3BlbntcXGNoYXJg4p+mfX0iKTsKZGVmaW5lTWFjcm8oIlxccnJicmFja2V0IiwgIlxcaHRtbEBtYXRobWx7XFxtYXRoY2xvc2V7XVxcbWtlcm4tMy4ybXVdfX17XFxtYXRoY2xvc2V7XFxjaGFyYOKfp319Iik7CmRlZmluZU1hY3JvKCLin6YiLCAiXFxsbGJyYWNrZXQiKTsKZGVmaW5lTWFjcm8oIuKfpyIsICJcXHJyYnJhY2tldCIpOwpkZWZpbmVNYWNybygiXFxsQnJhY2UiLCAiXFxodG1sQG1hdGhtbHtcXG1hdGhvcGVue1xce1xcbWtlcm4tMy4ybXVbfX17XFxtYXRob3BlbntcXGNoYXJg4qaDfX0iKTsKZGVmaW5lTWFjcm8oIlxcckJyYWNlIiwgIlxcaHRtbEBtYXRobWx7XFxtYXRoY2xvc2V7XVxcbWtlcm4tMy4ybXVcXH19fXtcXG1hdGhjbG9zZXtcXGNoYXJg4qaEfX0iKTsKZGVmaW5lTWFjcm8oIuKmgyIsICJcXGxCcmFjZSIpOwpkZWZpbmVNYWNybygi4qaEIiwgIlxcckJyYWNlIik7CmRlZmluZU1hY3JvKCJcXG1pbnVzbyIsICJcXG1hdGhiaW57XFxodG1sQG1hdGhtbHt7XFxtYXRocmxhcHtcXG1hdGhjaG9pY2V7XFxrZXJuezAuMTQ1ZW19fXtcXGtlcm57MC4xNDVlbX19e1xca2VybnswLjEwMTVlbX19e1xca2VybnswLjA3MjVlbX19XFxjaXJjfXstfX19e1xcY2hhcmDiprV9fSIpOwpkZWZpbmVNYWNybygi4qa1IiwgIlxcbWludXNvIik7CmRlZmluZU1hY3JvKCJcXGRhcnIiLCAiXFxkb3duYXJyb3ciKTsKZGVmaW5lTWFjcm8oIlxcZEFyciIsICJcXERvd25hcnJvdyIpOwpkZWZpbmVNYWNybygiXFxEYXJyIiwgIlxcRG93bmFycm93Iik7CmRlZmluZU1hY3JvKCJcXGxhbmciLCAiXFxsYW5nbGUiKTsKZGVmaW5lTWFjcm8oIlxccmFuZyIsICJcXHJhbmdsZSIpOwpkZWZpbmVNYWNybygiXFx1YXJyIiwgIlxcdXBhcnJvdyIpOwpkZWZpbmVNYWNybygiXFx1QXJyIiwgIlxcVXBhcnJvdyIpOwpkZWZpbmVNYWNybygiXFxVYXJyIiwgIlxcVXBhcnJvdyIpOwpkZWZpbmVNYWNybygiXFxOIiwgIlxcbWF0aGJie059Iik7CmRlZmluZU1hY3JvKCJcXFIiLCAiXFxtYXRoYmJ7Un0iKTsKZGVmaW5lTWFjcm8oIlxcWiIsICJcXG1hdGhiYntafSIpOwpkZWZpbmVNYWNybygiXFxhbGVmIiwgIlxcYWxlcGgiKTsKZGVmaW5lTWFjcm8oIlxcYWxlZnN5bSIsICJcXGFsZXBoIik7CmRlZmluZU1hY3JvKCJcXEFscGhhIiwgIlxcbWF0aHJte0F9Iik7CmRlZmluZU1hY3JvKCJcXEJldGEiLCAiXFxtYXRocm17Qn0iKTsKZGVmaW5lTWFjcm8oIlxcYnVsbCIsICJcXGJ1bGxldCIpOwpkZWZpbmVNYWNybygiXFxDaGkiLCAiXFxtYXRocm17WH0iKTsKZGVmaW5lTWFjcm8oIlxcY2x1YnMiLCAiXFxjbHVic3VpdCIpOwpkZWZpbmVNYWNybygiXFxjbnVtcyIsICJcXG1hdGhiYntDfSIpOwpkZWZpbmVNYWNybygiXFxDb21wbGV4IiwgIlxcbWF0aGJie0N9Iik7CmRlZmluZU1hY3JvKCJcXERhZ2dlciIsICJcXGRkYWdnZXIiKTsKZGVmaW5lTWFjcm8oIlxcZGlhbW9uZHMiLCAiXFxkaWFtb25kc3VpdCIpOwpkZWZpbmVNYWNybygiXFxlbXB0eSIsICJcXGVtcHR5c2V0Iik7CmRlZmluZU1hY3JvKCJcXEVwc2lsb24iLCAiXFxtYXRocm17RX0iKTsKZGVmaW5lTWFjcm8oIlxcRXRhIiwgIlxcbWF0aHJte0h9Iik7CmRlZmluZU1hY3JvKCJcXGV4aXN0IiwgIlxcZXhpc3RzIik7CmRlZmluZU1hY3JvKCJcXGhhcnIiLCAiXFxsZWZ0cmlnaHRhcnJvdyIpOwpkZWZpbmVNYWNybygiXFxoQXJyIiwgIlxcTGVmdHJpZ2h0YXJyb3ciKTsKZGVmaW5lTWFjcm8oIlxcSGFyciIsICJcXExlZnRyaWdodGFycm93Iik7CmRlZmluZU1hY3JvKCJcXGhlYXJ0cyIsICJcXGhlYXJ0c3VpdCIpOwpkZWZpbmVNYWNybygiXFxpbWFnZSIsICJcXEltIik7CmRlZmluZU1hY3JvKCJcXGluZmluIiwgIlxcaW5mdHkiKTsKZGVmaW5lTWFjcm8oIlxcSW90YSIsICJcXG1hdGhybXtJfSIpOwpkZWZpbmVNYWNybygiXFxpc2luIiwgIlxcaW4iKTsKZGVmaW5lTWFjcm8oIlxcS2FwcGEiLCAiXFxtYXRocm17S30iKTsKZGVmaW5lTWFjcm8oIlxcbGFyciIsICJcXGxlZnRhcnJvdyIpOwpkZWZpbmVNYWNybygiXFxsQXJyIiwgIlxcTGVmdGFycm93Iik7CmRlZmluZU1hY3JvKCJcXExhcnIiLCAiXFxMZWZ0YXJyb3ciKTsKZGVmaW5lTWFjcm8oIlxcbHJhcnIiLCAiXFxsZWZ0cmlnaHRhcnJvdyIpOwpkZWZpbmVNYWNybygiXFxsckFyciIsICJcXExlZnRyaWdodGFycm93Iik7CmRlZmluZU1hY3JvKCJcXExyYXJyIiwgIlxcTGVmdHJpZ2h0YXJyb3ciKTsKZGVmaW5lTWFjcm8oIlxcTXUiLCAiXFxtYXRocm17TX0iKTsKZGVmaW5lTWFjcm8oIlxcbmF0bnVtcyIsICJcXG1hdGhiYntOfSIpOwpkZWZpbmVNYWNybygiXFxOdSIsICJcXG1hdGhybXtOfSIpOwpkZWZpbmVNYWNybygiXFxPbWljcm9uIiwgIlxcbWF0aHJte099Iik7CmRlZmluZU1hY3JvKCJcXHBsdXNtbiIsICJcXHBtIik7CmRlZmluZU1hY3JvKCJcXHJhcnIiLCAiXFxyaWdodGFycm93Iik7CmRlZmluZU1hY3JvKCJcXHJBcnIiLCAiXFxSaWdodGFycm93Iik7CmRlZmluZU1hY3JvKCJcXFJhcnIiLCAiXFxSaWdodGFycm93Iik7CmRlZmluZU1hY3JvKCJcXHJlYWwiLCAiXFxSZSIpOwpkZWZpbmVNYWNybygiXFxyZWFscyIsICJcXG1hdGhiYntSfSIpOwpkZWZpbmVNYWNybygiXFxSZWFscyIsICJcXG1hdGhiYntSfSIpOwpkZWZpbmVNYWNybygiXFxSaG8iLCAiXFxtYXRocm17UH0iKTsKZGVmaW5lTWFjcm8oIlxcc2RvdCIsICJcXGNkb3QiKTsKZGVmaW5lTWFjcm8oIlxcc2VjdCIsICJcXFMiKTsKZGVmaW5lTWFjcm8oIlxcc3BhZGVzIiwgIlxcc3BhZGVzdWl0Iik7CmRlZmluZU1hY3JvKCJcXHN1YiIsICJcXHN1YnNldCIpOwpkZWZpbmVNYWNybygiXFxzdWJlIiwgIlxcc3Vic2V0ZXEiKTsKZGVmaW5lTWFjcm8oIlxcc3VwZSIsICJcXHN1cHNldGVxIik7CmRlZmluZU1hY3JvKCJcXFRhdSIsICJcXG1hdGhybXtUfSIpOwpkZWZpbmVNYWNybygiXFx0aGV0YXN5bSIsICJcXHZhcnRoZXRhIik7CmRlZmluZU1hY3JvKCJcXHdlaWVycCIsICJcXHdwIik7CmRlZmluZU1hY3JvKCJcXFpldGEiLCAiXFxtYXRocm17Wn0iKTsKZGVmaW5lTWFjcm8oIlxcYXJnbWluIiwgIlxcRE9UU0JcXG9wZXJhdG9ybmFtZSp7YXJnXFwsbWlufSIpOwpkZWZpbmVNYWNybygiXFxhcmdtYXgiLCAiXFxET1RTQlxcb3BlcmF0b3JuYW1lKnthcmdcXCxtYXh9Iik7CmRlZmluZU1hY3JvKCJcXHBsaW0iLCAiXFxET1RTQlxcbWF0aG9we1xcb3BlcmF0b3JuYW1le3BsaW19fVxcbGltaXRzIik7CmRlZmluZU1hY3JvKCJcXGJyYSIsICJcXG1hdGhpbm5lcntcXGxhbmdsZXsjMX18fSIpOwpkZWZpbmVNYWNybygiXFxrZXQiLCAiXFxtYXRoaW5uZXJ7fHsjMX1cXHJhbmdsZX0iKTsKZGVmaW5lTWFjcm8oIlxcYnJha2V0IiwgIlxcbWF0aGlubmVye1xcbGFuZ2xleyMxfVxccmFuZ2xlfSIpOwpkZWZpbmVNYWNybygiXFxCcmEiLCAiXFxsZWZ0XFxsYW5nbGUjMVxccmlnaHR8Iik7CmRlZmluZU1hY3JvKCJcXEtldCIsICJcXGxlZnR8IzFcXHJpZ2h0XFxyYW5nbGUiKTsKdmFyIGJyYWtldEhlbHBlciA9IChvbmUpID0+IChjb250ZXh0KSA9PiB7CiAgdmFyIGxlZnQgPSBjb250ZXh0LmNvbnN1bWVBcmcoKS50b2tlbnM7CiAgdmFyIG1pZGRsZSA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VuczsKICB2YXIgbWlkZGxlRG91YmxlID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zOwogIHZhciByaWdodCA9IGNvbnRleHQuY29uc3VtZUFyZygpLnRva2VuczsKICB2YXIgb2xkTWlkZGxlID0gY29udGV4dC5tYWNyb3MuZ2V0KCJ8Iik7CiAgdmFyIG9sZE1pZGRsZURvdWJsZSA9IGNvbnRleHQubWFjcm9zLmdldCgiXFx8Iik7CiAgY29udGV4dC5tYWNyb3MuYmVnaW5Hcm91cCgpOwogIHZhciBtaWRNYWNybyA9IChkb3VibGUpID0+IChjb250ZXh0MikgPT4gewogICAgaWYgKG9uZSkgewogICAgICBjb250ZXh0Mi5tYWNyb3Muc2V0KCJ8Iiwgb2xkTWlkZGxlKTsKICAgICAgaWYgKG1pZGRsZURvdWJsZS5sZW5ndGgpIHsKICAgICAgICBjb250ZXh0Mi5tYWNyb3Muc2V0KCJcXHwiLCBvbGRNaWRkbGVEb3VibGUpOwogICAgICB9CiAgICB9CiAgICB2YXIgZG91YmxlZCA9IGRvdWJsZTsKICAgIGlmICghZG91YmxlICYmIG1pZGRsZURvdWJsZS5sZW5ndGgpIHsKICAgICAgdmFyIG5leHRUb2tlbiA9IGNvbnRleHQyLmZ1dHVyZSgpOwogICAgICBpZiAobmV4dFRva2VuLnRleHQgPT09ICJ8IikgewogICAgICAgIGNvbnRleHQyLnBvcFRva2VuKCk7CiAgICAgICAgZG91YmxlZCA9IHRydWU7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiB7CiAgICAgIHRva2VuczogZG91YmxlZCA/IG1pZGRsZURvdWJsZSA6IG1pZGRsZSwKICAgICAgbnVtQXJnczogMAogICAgfTsKICB9OwogIGNvbnRleHQubWFjcm9zLnNldCgifCIsIG1pZE1hY3JvKGZhbHNlKSk7CiAgaWYgKG1pZGRsZURvdWJsZS5sZW5ndGgpIHsKICAgIGNvbnRleHQubWFjcm9zLnNldCgiXFx8IiwgbWlkTWFjcm8odHJ1ZSkpOwogIH0KICB2YXIgYXJnID0gY29udGV4dC5jb25zdW1lQXJnKCkudG9rZW5zOwogIHZhciBleHBhbmRlZCA9IGNvbnRleHQuZXhwYW5kVG9rZW5zKFsKICAgIC4uLnJpZ2h0LAogICAgLi4uYXJnLAogICAgLi4ubGVmdAogICAgLy8gcmV2ZXJzZWQKICBdKTsKICBjb250ZXh0Lm1hY3Jvcy5lbmRHcm91cCgpOwogIHJldHVybiB7CiAgICB0b2tlbnM6IGV4cGFuZGVkLnJldmVyc2UoKSwKICAgIG51bUFyZ3M6IDAKICB9Owp9OwpkZWZpbmVNYWNybygiXFxicmFAa2V0IiwgYnJha2V0SGVscGVyKGZhbHNlKSk7CmRlZmluZU1hY3JvKCJcXGJyYUBzZXQiLCBicmFrZXRIZWxwZXIodHJ1ZSkpOwpkZWZpbmVNYWNybygiXFxCcmFrZXQiLCAiXFxicmFAa2V0e1xcbGVmdFxcbGFuZ2xlfXtcXCxcXG1pZGRsZVxcdmVydFxcLH17XFwsXFxtaWRkbGVcXHZlcnRcXCx9e1xccmlnaHRcXHJhbmdsZX0iKTsKZGVmaW5lTWFjcm8oIlxcU2V0IiwgIlxcYnJhQHNldHtcXGxlZnRcXHtcXDp9e1xcO1xcbWlkZGxlXFx2ZXJ0XFw7fXtcXDtcXG1pZGRsZVxcVmVydFxcO317XFw6XFxyaWdodFxcfX0iKTsKZGVmaW5lTWFjcm8oIlxcc2V0IiwgIlxcYnJhQHNldHtcXHtcXCx9e1xcbWlkfXt9e1xcLFxcfX0iKTsKZGVmaW5lTWFjcm8oIlxcYW5nbG4iLCAie1xcYW5nbCBufSIpOwpkZWZpbmVNYWNybygiXFxibHVlIiwgIlxcdGV4dGNvbG9yeyMjNjQ5NWVkfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcb3JhbmdlIiwgIlxcdGV4dGNvbG9yeyMjZmZhNTAwfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxccGluayIsICJcXHRleHRjb2xvcnsjI2ZmMDBhZn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHJlZCIsICJcXHRleHRjb2xvcnsjI2RmMDAzMH17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGdyZWVuIiwgIlxcdGV4dGNvbG9yeyMjMjhhZTdifXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcZ3JheSIsICJcXHRleHRjb2xvcntncmF5fXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxccHVycGxlIiwgIlxcdGV4dGNvbG9yeyMjOWQzOGJkfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcYmx1ZUEiLCAiXFx0ZXh0Y29sb3J7IyNjY2ZhZmZ9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxibHVlQiIsICJcXHRleHRjb2xvcnsjIzgwZjZmZn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGJsdWVDIiwgIlxcdGV4dGNvbG9yeyMjNjNkOWVhfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcYmx1ZUQiLCAiXFx0ZXh0Y29sb3J7IyMxMWFjY2R9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxibHVlRSIsICJcXHRleHRjb2xvcnsjIzBjN2Y5OX17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHRlYWxBIiwgIlxcdGV4dGNvbG9yeyMjOTRmZmY1fXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcdGVhbEIiLCAiXFx0ZXh0Y29sb3J7IyMyNmVkZDV9eyMxfSIpOwpkZWZpbmVNYWNybygiXFx0ZWFsQyIsICJcXHRleHRjb2xvcnsjIzAxZDFjMX17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHRlYWxEIiwgIlxcdGV4dGNvbG9yeyMjMDFhOTk1fXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcdGVhbEUiLCAiXFx0ZXh0Y29sb3J7IyMyMDgxNzB9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmVlbkEiLCAiXFx0ZXh0Y29sb3J7IyNiNmZmYjB9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmVlbkIiLCAiXFx0ZXh0Y29sb3J7IyM4YWYyODF9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmVlbkMiLCAiXFx0ZXh0Y29sb3J7IyM3NGNmNzB9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmVlbkQiLCAiXFx0ZXh0Y29sb3J7IyMxZmFiNTR9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmVlbkUiLCAiXFx0ZXh0Y29sb3J7IyMwZDkyM2Z9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxnb2xkQSIsICJcXHRleHRjb2xvcnsjI2ZmZDBhOX17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGdvbGRCIiwgIlxcdGV4dGNvbG9yeyMjZmZiYjcxfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcZ29sZEMiLCAiXFx0ZXh0Y29sb3J7IyNmZjljMzl9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxnb2xkRCIsICJcXHRleHRjb2xvcnsjI2UwN2QxMH17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGdvbGRFIiwgIlxcdGV4dGNvbG9yeyMjYTc1YTA1fXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxccmVkQSIsICJcXHRleHRjb2xvcnsjI2ZjYTlhOX17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHJlZEIiLCAiXFx0ZXh0Y29sb3J7IyNmZjg0ODJ9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxyZWRDIiwgIlxcdGV4dGNvbG9yeyMjZjk2ODVkfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxccmVkRCIsICJcXHRleHRjb2xvcnsjI2U4NGQzOX17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHJlZEUiLCAiXFx0ZXh0Y29sb3J7IyNiYzI2MTJ9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxtYXJvb25BIiwgIlxcdGV4dGNvbG9yeyMjZmZiZGUwfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcbWFyb29uQiIsICJcXHRleHRjb2xvcnsjI2ZmOTJjNn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXG1hcm9vbkMiLCAiXFx0ZXh0Y29sb3J7IyNlZDVmYTZ9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxtYXJvb25EIiwgIlxcdGV4dGNvbG9yeyMjY2EzMzdjfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcbWFyb29uRSIsICJcXHRleHRjb2xvcnsjIzllMDM0ZX17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHB1cnBsZUEiLCAiXFx0ZXh0Y29sb3J7IyNkZGQ3ZmZ9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxwdXJwbGVCIiwgIlxcdGV4dGNvbG9yeyMjYzZiOWZjfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxccHVycGxlQyIsICJcXHRleHRjb2xvcnsjI2FhODdmZn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXHB1cnBsZUQiLCAiXFx0ZXh0Y29sb3J7IyM3ODU0YWJ9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxwdXJwbGVFIiwgIlxcdGV4dGNvbG9yeyMjNTQzYjc4fXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcbWludEEiLCAiXFx0ZXh0Y29sb3J7IyNmNWY5ZTh9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxtaW50QiIsICJcXHRleHRjb2xvcnsjI2VkZjJkZn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXG1pbnRDIiwgIlxcdGV4dGNvbG9yeyMjZTBlNWNjfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcZ3JheUEiLCAiXFx0ZXh0Y29sb3J7IyNmNmY3Zjd9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmF5QiIsICJcXHRleHRjb2xvcnsjI2YwZjFmMn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGdyYXlDIiwgIlxcdGV4dGNvbG9yeyMjZTNlNWU2fXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcZ3JheUQiLCAiXFx0ZXh0Y29sb3J7IyNkNmQ4ZGF9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmF5RSIsICJcXHRleHRjb2xvcnsjI2JhYmVjMn17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGdyYXlGIiwgIlxcdGV4dGNvbG9yeyMjODg4ZDkzfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxcZ3JheUciLCAiXFx0ZXh0Y29sb3J7IyM2MjY1Njl9eyMxfSIpOwpkZWZpbmVNYWNybygiXFxncmF5SCIsICJcXHRleHRjb2xvcnsjIzNiM2U0MH17IzF9Iik7CmRlZmluZU1hY3JvKCJcXGdyYXlJIiwgIlxcdGV4dGNvbG9yeyMjMjEyNDJjfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxca2FCbHVlIiwgIlxcdGV4dGNvbG9yeyMjMzE0NDUzfXsjMX0iKTsKZGVmaW5lTWFjcm8oIlxca2FHcmVlbiIsICJcXHRleHRjb2xvcnsjIzcxQjMwN317IzF9Iik7CnZhciBpbXBsaWNpdENvbW1hbmRzID0gewogICJeIjogdHJ1ZSwKICAvLyBQYXJzZXIuanMKICAiXyI6IHRydWUsCiAgLy8gUGFyc2VyLmpzCiAgIlxcbGltaXRzIjogdHJ1ZSwKICAvLyBQYXJzZXIuanMKICAiXFxub2xpbWl0cyI6IHRydWUKICAvLyBQYXJzZXIuanMKfTsKdmFyIE1hY3JvRXhwYW5kZXIgPSBjbGFzcyB7CiAgY29uc3RydWN0b3IoaW5wdXQsIHNldHRpbmdzLCBtb2RlKSB7CiAgICB0aGlzLnNldHRpbmdzID0gdm9pZCAwOwogICAgdGhpcy5leHBhbnNpb25Db3VudCA9IHZvaWQgMDsKICAgIHRoaXMubGV4ZXIgPSB2b2lkIDA7CiAgICB0aGlzLm1hY3JvcyA9IHZvaWQgMDsKICAgIHRoaXMuc3RhY2sgPSB2b2lkIDA7CiAgICB0aGlzLm1vZGUgPSB2b2lkIDA7CiAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7CiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ID0gMDsKICAgIHRoaXMuZmVlZChpbnB1dCk7CiAgICB0aGlzLm1hY3JvcyA9IG5ldyBOYW1lc3BhY2UobWFjcm9zLCBzZXR0aW5ncy5tYWNyb3MpOwogICAgdGhpcy5tb2RlID0gbW9kZTsKICAgIHRoaXMuc3RhY2sgPSBbXTsKICB9CiAgLyoqCiAgICogRmVlZCBhIG5ldyBpbnB1dCBzdHJpbmcgdG8gdGhlIHNhbWUgTWFjcm9FeHBhbmRlcgogICAqICh3aXRoIGV4aXN0aW5nIG1hY3JvcyBldGMuKS4KICAgKi8KICBmZWVkKGlucHV0KSB7CiAgICB0aGlzLmxleGVyID0gbmV3IExleGVyKGlucHV0LCB0aGlzLnNldHRpbmdzKTsKICB9CiAgLyoqCiAgICogU3dpdGNoZXMgYmV0d2VlbiAidGV4dCIgYW5kICJtYXRoIiBtb2Rlcy4KICAgKi8KICBzd2l0Y2hNb2RlKG5ld01vZGUpIHsKICAgIHRoaXMubW9kZSA9IG5ld01vZGU7CiAgfQogIC8qKgogICAqIFN0YXJ0IGEgbmV3IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLgogICAqLwogIGJlZ2luR3JvdXAoKSB7CiAgICB0aGlzLm1hY3Jvcy5iZWdpbkdyb3VwKCk7CiAgfQogIC8qKgogICAqIEVuZCBjdXJyZW50IGdyb3VwIG5lc3Rpbmcgd2l0aGluIGFsbCBuYW1lc3BhY2VzLgogICAqLwogIGVuZEdyb3VwKCkgewogICAgdGhpcy5tYWNyb3MuZW5kR3JvdXAoKTsKICB9CiAgLyoqCiAgICogRW5kcyBhbGwgY3VycmVudGx5IG5lc3RlZCBncm91cHMgKGlmIGFueSksIHJlc3RvcmluZyB2YWx1ZXMgYmVmb3JlIHRoZQogICAqIGdyb3VwcyBiZWdhbi4gIFVzZWZ1bCBpbiBjYXNlIG9mIGFuIGVycm9yIGluIHRoZSBtaWRkbGUgb2YgcGFyc2luZy4KICAgKi8KICBlbmRHcm91cHMoKSB7CiAgICB0aGlzLm1hY3Jvcy5lbmRHcm91cHMoKTsKICB9CiAgLyoqCiAgICogUmV0dXJucyB0aGUgdG9wbW9zdCB0b2tlbiBvbiB0aGUgc3RhY2ssIHdpdGhvdXQgZXhwYW5kaW5nIGl0LgogICAqIFNpbWlsYXIgaW4gYmVoYXZpb3IgdG8gVGVYJ3MgYFxmdXR1cmVsZXRgLgogICAqLwogIGZ1dHVyZSgpIHsKICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkgewogICAgICB0aGlzLnB1c2hUb2tlbih0aGlzLmxleGVyLmxleCgpKTsKICAgIH0KICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07CiAgfQogIC8qKgogICAqIFJlbW92ZSBhbmQgcmV0dXJuIHRoZSBuZXh0IHVuZXhwYW5kZWQgdG9rZW4uCiAgICovCiAgcG9wVG9rZW4oKSB7CiAgICB0aGlzLmZ1dHVyZSgpOwogICAgcmV0dXJuIHRoaXMuc3RhY2sucG9wKCk7CiAgfQogIC8qKgogICAqIEFkZCBhIGdpdmVuIHRva2VuIHRvIHRoZSB0b2tlbiBzdGFjay4gIEluIHBhcnRpY3VsYXIsIHRoaXMgZ2V0IGJlIHVzZWQKICAgKiB0byBwdXQgYmFjayBhIHRva2VuIHJldHVybmVkIGZyb20gb25lIG9mIHRoZSBvdGhlciBtZXRob2RzLgogICAqLwogIHB1c2hUb2tlbih0b2tlbikgewogICAgdGhpcy5zdGFjay5wdXNoKHRva2VuKTsKICB9CiAgLyoqCiAgICogQXBwZW5kIGFuIGFycmF5IG9mIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suCiAgICovCiAgcHVzaFRva2Vucyh0b2tlbnMpIHsKICAgIHRoaXMuc3RhY2sucHVzaCguLi50b2tlbnMpOwogIH0KICAvKioKICAgKiBGaW5kIGFuIG1hY3JvIGFyZ3VtZW50IHdpdGhvdXQgZXhwYW5kaW5nIHRva2VucyBhbmQgYXBwZW5kIHRoZSBhcnJheSBvZgogICAqIHRva2VucyB0byB0aGUgdG9rZW4gc3RhY2suIFVzZXMgVG9rZW4gYXMgYSBjb250YWluZXIgZm9yIHRoZSByZXN1bHQuCiAgICovCiAgc2NhbkFyZ3VtZW50KGlzT3B0aW9uYWwpIHsKICAgIHZhciBzdGFydDsKICAgIHZhciBlbmQ7CiAgICB2YXIgdG9rZW5zOwogICAgaWYgKGlzT3B0aW9uYWwpIHsKICAgICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7CiAgICAgIGlmICh0aGlzLmZ1dHVyZSgpLnRleHQgIT09ICJbIikgewogICAgICAgIHJldHVybiBudWxsOwogICAgICB9CiAgICAgIHN0YXJ0ID0gdGhpcy5wb3BUb2tlbigpOwogICAgICAoewogICAgICAgIHRva2VucywKICAgICAgICBlbmQKICAgICAgfSA9IHRoaXMuY29uc3VtZUFyZyhbIl0iXSkpOwogICAgfSBlbHNlIHsKICAgICAgKHsKICAgICAgICB0b2tlbnMsCiAgICAgICAgc3RhcnQsCiAgICAgICAgZW5kCiAgICAgIH0gPSB0aGlzLmNvbnN1bWVBcmcoKSk7CiAgICB9CiAgICB0aGlzLnB1c2hUb2tlbihuZXcgVG9rZW4oIkVPRiIsIGVuZC5sb2MpKTsKICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpOwogICAgcmV0dXJuIHN0YXJ0LnJhbmdlKGVuZCwgIiIpOwogIH0KICAvKioKICAgKiBDb25zdW1lIGFsbCBmb2xsb3dpbmcgc3BhY2UgdG9rZW5zLCB3aXRob3V0IGV4cGFuc2lvbi4KICAgKi8KICBjb25zdW1lU3BhY2VzKCkgewogICAgZm9yICg7IDsgKSB7CiAgICAgIHZhciB0b2tlbiA9IHRoaXMuZnV0dXJlKCk7CiAgICAgIGlmICh0b2tlbi50ZXh0ID09PSAiICIpIHsKICAgICAgICB0aGlzLnN0YWNrLnBvcCgpOwogICAgICB9IGVsc2UgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9CiAgfQogIC8qKgogICAqIENvbnN1bWUgYW4gYXJndW1lbnQgZnJvbSB0aGUgdG9rZW4gc3RyZWFtLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgYXJyYXkKICAgKiBvZiB0b2tlbnMgYW5kIHN0YXJ0L2VuZCB0b2tlbi4KICAgKi8KICBjb25zdW1lQXJnKGRlbGltcykgewogICAgdmFyIHRva2VucyA9IFtdOwogICAgdmFyIGlzRGVsaW1pdGVkID0gZGVsaW1zICYmIGRlbGltcy5sZW5ndGggPiAwOwogICAgaWYgKCFpc0RlbGltaXRlZCkgewogICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsKICAgIH0KICAgIHZhciBzdGFydCA9IHRoaXMuZnV0dXJlKCk7CiAgICB2YXIgdG9rOwogICAgdmFyIGRlcHRoID0gMDsKICAgIHZhciBtYXRjaCA9IDA7CiAgICBkbyB7CiAgICAgIHRvayA9IHRoaXMucG9wVG9rZW4oKTsKICAgICAgdG9rZW5zLnB1c2godG9rKTsKICAgICAgaWYgKHRvay50ZXh0ID09PSAieyIpIHsKICAgICAgICArK2RlcHRoOwogICAgICB9IGVsc2UgaWYgKHRvay50ZXh0ID09PSAifSIpIHsKICAgICAgICAtLWRlcHRoOwogICAgICAgIGlmIChkZXB0aCA9PT0gLTEpIHsKICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJFeHRyYSB9IiwgdG9rKTsKICAgICAgICB9CiAgICAgIH0gZWxzZSBpZiAodG9rLnRleHQgPT09ICJFT0YiKSB7CiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0IGluIGEgbWFjcm8gYXJndW1lbnQsIGV4cGVjdGVkICciICsgKGRlbGltcyAmJiBpc0RlbGltaXRlZCA/IGRlbGltc1ttYXRjaF0gOiAifSIpICsgIiciLCB0b2spOwogICAgICB9CiAgICAgIGlmIChkZWxpbXMgJiYgaXNEZWxpbWl0ZWQpIHsKICAgICAgICBpZiAoKGRlcHRoID09PSAwIHx8IGRlcHRoID09PSAxICYmIGRlbGltc1ttYXRjaF0gPT09ICJ7IikgJiYgdG9rLnRleHQgPT09IGRlbGltc1ttYXRjaF0pIHsKICAgICAgICAgICsrbWF0Y2g7CiAgICAgICAgICBpZiAobWF0Y2ggPT09IGRlbGltcy5sZW5ndGgpIHsKICAgICAgICAgICAgdG9rZW5zLnNwbGljZSgtbWF0Y2gsIG1hdGNoKTsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG1hdGNoID0gMDsKICAgICAgICB9CiAgICAgIH0KICAgIH0gd2hpbGUgKGRlcHRoICE9PSAwIHx8IGlzRGVsaW1pdGVkKTsKICAgIGlmIChzdGFydC50ZXh0ID09PSAieyIgJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50ZXh0ID09PSAifSIpIHsKICAgICAgdG9rZW5zLnBvcCgpOwogICAgICB0b2tlbnMuc2hpZnQoKTsKICAgIH0KICAgIHRva2Vucy5yZXZlcnNlKCk7CiAgICByZXR1cm4gewogICAgICB0b2tlbnMsCiAgICAgIHN0YXJ0LAogICAgICBlbmQ6IHRvawogICAgfTsKICB9CiAgLyoqCiAgICogQ29uc3VtZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiAoZGVsaW1pdGVkKSBhcmd1bWVudHMgZnJvbSB0aGUgdG9rZW4KICAgKiBzdHJlYW0gYW5kIHJldHVybiB0aGUgcmVzdWx0aW5nIGFycmF5IG9mIGFyZ3VtZW50cy4KICAgKi8KICBjb25zdW1lQXJncyhudW1BcmdzLCBkZWxpbWl0ZXJzMikgewogICAgaWYgKGRlbGltaXRlcnMyKSB7CiAgICAgIGlmIChkZWxpbWl0ZXJzMi5sZW5ndGggIT09IG51bUFyZ3MgKyAxKSB7CiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlRoZSBsZW5ndGggb2YgZGVsaW1pdGVycyBkb2Vzbid0IG1hdGNoIHRoZSBudW1iZXIgb2YgYXJncyEiKTsKICAgICAgfQogICAgICB2YXIgZGVsaW1zID0gZGVsaW1pdGVyczJbMF07CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsaW1zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgdmFyIHRvayA9IHRoaXMucG9wVG9rZW4oKTsKICAgICAgICBpZiAoZGVsaW1zW2ldICE9PSB0b2sudGV4dCkgewogICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVzZSBvZiB0aGUgbWFjcm8gZG9lc24ndCBtYXRjaCBpdHMgZGVmaW5pdGlvbiIsIHRvayk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICB2YXIgYXJncyA9IFtdOwogICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bUFyZ3M7IF9pKyspIHsKICAgICAgYXJncy5wdXNoKHRoaXMuY29uc3VtZUFyZyhkZWxpbWl0ZXJzMiAmJiBkZWxpbWl0ZXJzMltfaSArIDFdKS50b2tlbnMpOwogICAgfQogICAgcmV0dXJuIGFyZ3M7CiAgfQogIC8qKgogICAqIEluY3JlbWVudCBgZXhwYW5zaW9uQ291bnRgIGJ5IHRoZSBzcGVjaWZpZWQgYW1vdW50LgogICAqIFRocm93IGFuIGVycm9yIGlmIGl0IGV4Y2VlZHMgYG1heEV4cGFuZGAuCiAgICovCiAgY291bnRFeHBhbnNpb24oYW1vdW50KSB7CiAgICB0aGlzLmV4cGFuc2lvbkNvdW50ICs9IGFtb3VudDsKICAgIGlmICh0aGlzLmV4cGFuc2lvbkNvdW50ID4gdGhpcy5zZXR0aW5ncy5tYXhFeHBhbmQpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlRvbyBtYW55IGV4cGFuc2lvbnM6IGluZmluaXRlIGxvb3Agb3IgbmVlZCB0byBpbmNyZWFzZSBtYXhFeHBhbmQgc2V0dGluZyIpOwogICAgfQogIH0KICAvKioKICAgKiBFeHBhbmQgdGhlIG5leHQgdG9rZW4gb25seSBvbmNlIGlmIHBvc3NpYmxlLgogICAqCiAgICogSWYgdGhlIHRva2VuIGlzIGV4cGFuZGVkLCB0aGUgcmVzdWx0aW5nIHRva2VucyB3aWxsIGJlIHB1c2hlZCBvbnRvCiAgICogdGhlIHN0YWNrIGluIHJldmVyc2Ugb3JkZXIsIGFuZCB0aGUgbnVtYmVyIG9mIHN1Y2ggdG9rZW5zIHdpbGwgYmUKICAgKiByZXR1cm5lZC4gIFRoaXMgbnVtYmVyIG1pZ2h0IGJlIHplcm8gb3IgcG9zaXRpdmUuCiAgICoKICAgKiBJZiBub3QsIHRoZSByZXR1cm4gdmFsdWUgaXMgYGZhbHNlYCwgYW5kIHRoZSBuZXh0IHRva2VuIHJlbWFpbnMgYXQgdGhlCiAgICogdG9wIG9mIHRoZSBzdGFjay4KICAgKgogICAqIEluIGVpdGhlciBjYXNlLCB0aGUgbmV4dCB0b2tlbiB3aWxsIGJlIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLAogICAqIG9yIHRoZSBzdGFjayB3aWxsIGJlIGVtcHR5IChpbiBjYXNlIG9mIGVtcHR5IGV4cGFuc2lvbgogICAqIGFuZCBubyBvdGhlciB0b2tlbnMpLgogICAqCiAgICogVXNlZCB0byBpbXBsZW1lbnQgYGV4cGFuZEFmdGVyRnV0dXJlYCBhbmQgYGV4cGFuZE5leHRUb2tlbmAuCiAgICoKICAgKiBJZiBleHBhbmRhYmxlT25seSwgb25seSBleHBhbmRhYmxlIHRva2VucyBhcmUgZXhwYW5kZWQgYW5kCiAgICogYW4gdW5kZWZpbmVkIGNvbnRyb2wgc2VxdWVuY2UgcmVzdWx0cyBpbiBhbiBlcnJvci4KICAgKi8KICBleHBhbmRPbmNlKGV4cGFuZGFibGVPbmx5KSB7CiAgICB2YXIgdG9wVG9rZW4gPSB0aGlzLnBvcFRva2VuKCk7CiAgICB2YXIgbmFtZSA9IHRvcFRva2VuLnRleHQ7CiAgICB2YXIgZXhwYW5zaW9uID0gIXRvcFRva2VuLm5vZXhwYW5kID8gdGhpcy5fZ2V0RXhwYW5zaW9uKG5hbWUpIDogbnVsbDsKICAgIGlmIChleHBhbnNpb24gPT0gbnVsbCB8fCBleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24udW5leHBhbmRhYmxlKSB7CiAgICAgIGlmIChleHBhbmRhYmxlT25seSAmJiBleHBhbnNpb24gPT0gbnVsbCAmJiBuYW1lWzBdID09PSAiXFwiICYmICF0aGlzLmlzRGVmaW5lZChuYW1lKSkgewogICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogIiArIG5hbWUpOwogICAgICB9CiAgICAgIHRoaXMucHVzaFRva2VuKHRvcFRva2VuKTsKICAgICAgcmV0dXJuIGZhbHNlOwogICAgfQogICAgdGhpcy5jb3VudEV4cGFuc2lvbigxKTsKICAgIHZhciB0b2tlbnMgPSBleHBhbnNpb24udG9rZW5zOwogICAgdmFyIGFyZ3MgPSB0aGlzLmNvbnN1bWVBcmdzKGV4cGFuc2lvbi5udW1BcmdzLCBleHBhbnNpb24uZGVsaW1pdGVycyk7CiAgICBpZiAoZXhwYW5zaW9uLm51bUFyZ3MpIHsKICAgICAgdG9rZW5zID0gdG9rZW5zLnNsaWNlKCk7CiAgICAgIGZvciAodmFyIGkgPSB0b2tlbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsKICAgICAgICB2YXIgdG9rID0gdG9rZW5zW2ldOwogICAgICAgIGlmICh0b2sudGV4dCA9PT0gIiMiKSB7CiAgICAgICAgICBpZiAoaSA9PT0gMCkgewogICAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiSW5jb21wbGV0ZSBwbGFjZWhvbGRlciBhdCBlbmQgb2YgbWFjcm8gYm9keSIsIHRvayk7CiAgICAgICAgICB9CiAgICAgICAgICB0b2sgPSB0b2tlbnNbLS1pXTsKICAgICAgICAgIGlmICh0b2sudGV4dCA9PT0gIiMiKSB7CiAgICAgICAgICAgIHRva2Vucy5zcGxpY2UoaSArIDEsIDEpOwogICAgICAgICAgfSBlbHNlIGlmICgvXlsxLTldJC8udGVzdCh0b2sudGV4dCkpIHsKICAgICAgICAgICAgdG9rZW5zLnNwbGljZShpLCAyLCAuLi5hcmdzWyt0b2sudGV4dCAtIDFdKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJOb3QgYSB2YWxpZCBhcmd1bWVudCBudW1iZXIiLCB0b2spOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgdGhpcy5wdXNoVG9rZW5zKHRva2Vucyk7CiAgICByZXR1cm4gdG9rZW5zLmxlbmd0aDsKICB9CiAgLyoqCiAgICogRXhwYW5kIHRoZSBuZXh0IHRva2VuIG9ubHkgb25jZSAoaWYgcG9zc2libGUpLCBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcKICAgKiB0b3AgdG9rZW4gb24gdGhlIHN0YWNrICh3aXRob3V0IHJlbW92aW5nIGFueXRoaW5nIGZyb20gdGhlIHN0YWNrKS4KICAgKiBTaW1pbGFyIGluIGJlaGF2aW9yIHRvIFRlWCdzIGBcZXhwYW5kYWZ0ZXJcZnV0dXJlbGV0YC4KICAgKiBFcXVpdmFsZW50IHRvIGV4cGFuZE9uY2UoKSBmb2xsb3dlZCBieSBmdXR1cmUoKS4KICAgKi8KICBleHBhbmRBZnRlckZ1dHVyZSgpIHsKICAgIHRoaXMuZXhwYW5kT25jZSgpOwogICAgcmV0dXJuIHRoaXMuZnV0dXJlKCk7CiAgfQogIC8qKgogICAqIFJlY3Vyc2l2ZWx5IGV4cGFuZCBmaXJzdCB0b2tlbiwgdGhlbiByZXR1cm4gZmlyc3Qgbm9uLWV4cGFuZGFibGUgdG9rZW4uCiAgICovCiAgZXhwYW5kTmV4dFRva2VuKCkgewogICAgZm9yICg7IDsgKSB7CiAgICAgIGlmICh0aGlzLmV4cGFuZE9uY2UoKSA9PT0gZmFsc2UpIHsKICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpOwogICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHsKICAgICAgICAgIHRva2VuLnRleHQgPSAiXFxyZWxheCI7CiAgICAgICAgfQogICAgICAgIHJldHVybiB0b2tlbjsKICAgICAgfQogICAgfQogICAgdGhyb3cgbmV3IEVycm9yKCk7CiAgfQogIC8qKgogICAqIEZ1bGx5IGV4cGFuZCB0aGUgZ2l2ZW4gbWFjcm8gbmFtZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZgogICAqIHRva2Vucywgb3IgcmV0dXJuIGB1bmRlZmluZWRgIGlmIG5vIHN1Y2ggbWFjcm8gaXMgZGVmaW5lZC4KICAgKi8KICBleHBhbmRNYWNybyhuYW1lKSB7CiAgICByZXR1cm4gdGhpcy5tYWNyb3MuaGFzKG5hbWUpID8gdGhpcy5leHBhbmRUb2tlbnMoW25ldyBUb2tlbihuYW1lKV0pIDogdm9pZCAwOwogIH0KICAvKioKICAgKiBGdWxseSBleHBhbmQgdGhlIGdpdmVuIHRva2VuIHN0cmVhbSBhbmQgcmV0dXJuIHRoZSByZXN1bHRpbmcgbGlzdCBvZgogICAqIHRva2Vucy4gIE5vdGUgdGhhdCB0aGUgaW5wdXQgdG9rZW5zIGFyZSBpbiByZXZlcnNlIG9yZGVyLCBidXQgdGhlCiAgICogb3V0cHV0IHRva2VucyBhcmUgaW4gZm9yd2FyZCBvcmRlci4KICAgKi8KICBleHBhbmRUb2tlbnModG9rZW5zKSB7CiAgICB2YXIgb3V0cHV0ID0gW107CiAgICB2YXIgb2xkU3RhY2tMZW5ndGggPSB0aGlzLnN0YWNrLmxlbmd0aDsKICAgIHRoaXMucHVzaFRva2Vucyh0b2tlbnMpOwogICAgd2hpbGUgKHRoaXMuc3RhY2subGVuZ3RoID4gb2xkU3RhY2tMZW5ndGgpIHsKICAgICAgaWYgKHRoaXMuZXhwYW5kT25jZSh0cnVlKSA9PT0gZmFsc2UpIHsKICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnN0YWNrLnBvcCgpOwogICAgICAgIGlmICh0b2tlbi50cmVhdEFzUmVsYXgpIHsKICAgICAgICAgIHRva2VuLm5vZXhwYW5kID0gZmFsc2U7CiAgICAgICAgICB0b2tlbi50cmVhdEFzUmVsYXggPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgb3V0cHV0LnB1c2godG9rZW4pOwogICAgICB9CiAgICB9CiAgICB0aGlzLmNvdW50RXhwYW5zaW9uKG91dHB1dC5sZW5ndGgpOwogICAgcmV0dXJuIG91dHB1dDsKICB9CiAgLyoqCiAgICogRnVsbHkgZXhwYW5kIHRoZSBnaXZlbiBtYWNybyBuYW1lIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIHN0cmluZywKICAgKiBvciByZXR1cm4gYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBtYWNybyBpcyBkZWZpbmVkLgogICAqLwogIGV4cGFuZE1hY3JvQXNUZXh0KG5hbWUpIHsKICAgIHZhciB0b2tlbnMgPSB0aGlzLmV4cGFuZE1hY3JvKG5hbWUpOwogICAgaWYgKHRva2VucykgewogICAgICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IHRva2VuLnRleHQpLmpvaW4oIiIpOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIHRva2VuczsKICAgIH0KICB9CiAgLyoqCiAgICogUmV0dXJucyB0aGUgZXhwYW5kZWQgbWFjcm8gYXMgYSByZXZlcnNlZCBhcnJheSBvZiB0b2tlbnMgYW5kIGEgbWFjcm8KICAgKiBhcmd1bWVudCBjb3VudC4gIE9yIHJldHVybnMgYG51bGxgIGlmIG5vIHN1Y2ggbWFjcm8uCiAgICovCiAgX2dldEV4cGFuc2lvbihuYW1lKSB7CiAgICB2YXIgZGVmaW5pdGlvbiA9IHRoaXMubWFjcm9zLmdldChuYW1lKTsKICAgIGlmIChkZWZpbml0aW9uID09IG51bGwpIHsKICAgICAgcmV0dXJuIGRlZmluaXRpb247CiAgICB9CiAgICBpZiAobmFtZS5sZW5ndGggPT09IDEpIHsKICAgICAgdmFyIGNhdGNvZGUgPSB0aGlzLmxleGVyLmNhdGNvZGVzW25hbWVdOwogICAgICBpZiAoY2F0Y29kZSAhPSBudWxsICYmIGNhdGNvZGUgIT09IDEzKSB7CiAgICAgICAgcmV0dXJuOwogICAgICB9CiAgICB9CiAgICB2YXIgZXhwYW5zaW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09ICJmdW5jdGlvbiIgPyBkZWZpbml0aW9uKHRoaXMpIDogZGVmaW5pdGlvbjsKICAgIGlmICh0eXBlb2YgZXhwYW5zaW9uID09PSAic3RyaW5nIikgewogICAgICB2YXIgbnVtQXJncyA9IDA7CiAgICAgIGlmIChleHBhbnNpb24uaW5kZXhPZigiIyIpICE9PSAtMSkgewogICAgICAgIHZhciBzdHJpcHBlZCA9IGV4cGFuc2lvbi5yZXBsYWNlKC8jIy9nLCAiIik7CiAgICAgICAgd2hpbGUgKHN0cmlwcGVkLmluZGV4T2YoIiMiICsgKG51bUFyZ3MgKyAxKSkgIT09IC0xKSB7CiAgICAgICAgICArK251bUFyZ3M7CiAgICAgICAgfQogICAgICB9CiAgICAgIHZhciBib2R5TGV4ZXIgPSBuZXcgTGV4ZXIoZXhwYW5zaW9uLCB0aGlzLnNldHRpbmdzKTsKICAgICAgdmFyIHRva2VucyA9IFtdOwogICAgICB2YXIgdG9rID0gYm9keUxleGVyLmxleCgpOwogICAgICB3aGlsZSAodG9rLnRleHQgIT09ICJFT0YiKSB7CiAgICAgICAgdG9rZW5zLnB1c2godG9rKTsKICAgICAgICB0b2sgPSBib2R5TGV4ZXIubGV4KCk7CiAgICAgIH0KICAgICAgdG9rZW5zLnJldmVyc2UoKTsKICAgICAgdmFyIGV4cGFuZGVkID0gewogICAgICAgIHRva2VucywKICAgICAgICBudW1BcmdzCiAgICAgIH07CiAgICAgIHJldHVybiBleHBhbmRlZDsKICAgIH0KICAgIHJldHVybiBleHBhbnNpb247CiAgfQogIC8qKgogICAqIERldGVybWluZSB3aGV0aGVyIGEgY29tbWFuZCBpcyBjdXJyZW50bHkgImRlZmluZWQiIChoYXMgc29tZQogICAqIGZ1bmN0aW9uYWxpdHkpLCBtZWFuaW5nIHRoYXQgaXQncyBhIG1hY3JvIChpbiB0aGUgY3VycmVudCBncm91cCksCiAgICogYSBmdW5jdGlvbiwgYSBzeW1ib2wsIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBjb21tYW5kcyBsaXN0ZWQgaW4KICAgKiBgaW1wbGljaXRDb21tYW5kc2AuCiAgICovCiAgaXNEZWZpbmVkKG5hbWUpIHsKICAgIHJldHVybiB0aGlzLm1hY3Jvcy5oYXMobmFtZSkgfHwgZnVuY3Rpb25zLmhhc093blByb3BlcnR5KG5hbWUpIHx8IHN5bWJvbHMubWF0aC5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBzeW1ib2xzLnRleHQuaGFzT3duUHJvcGVydHkobmFtZSkgfHwgaW1wbGljaXRDb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShuYW1lKTsKICB9CiAgLyoqCiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBjb21tYW5kIGlzIGV4cGFuZGFibGUuCiAgICovCiAgaXNFeHBhbmRhYmxlKG5hbWUpIHsKICAgIHZhciBtYWNybyA9IHRoaXMubWFjcm9zLmdldChuYW1lKTsKICAgIHJldHVybiBtYWNybyAhPSBudWxsID8gdHlwZW9mIG1hY3JvID09PSAic3RyaW5nIiB8fCB0eXBlb2YgbWFjcm8gPT09ICJmdW5jdGlvbiIgfHwgIW1hY3JvLnVuZXhwYW5kYWJsZSA6IGZ1bmN0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhZnVuY3Rpb25zW25hbWVdLnByaW1pdGl2ZTsKICB9Cn07CnZhciB1bmljb2RlU3ViUmVnRXggPSAvXlvigorigovigozigo3igo7igoDigoHigoLigoPigoTigoXigobigofigojigonigpDigpHigpXhtaLisbzigpbigpfigpjigpnigpLigprhtaPigpvigpzhtaThtaXigpPhtabhtafhtajhtanhtapdLzsKdmFyIHVTdWJzQW5kU3VwcyA9IE9iamVjdC5mcmVlemUoewogICLigooiOiAiKyIsCiAgIuKCiyI6ICItIiwKICAi4oKMIjogIj0iLAogICLigo0iOiAiKCIsCiAgIuKCjiI6ICIpIiwKICAi4oKAIjogIjAiLAogICLigoEiOiAiMSIsCiAgIuKCgiI6ICIyIiwKICAi4oKDIjogIjMiLAogICLigoQiOiAiNCIsCiAgIuKChSI6ICI1IiwKICAi4oKGIjogIjYiLAogICLigociOiAiNyIsCiAgIuKCiCI6ICI4IiwKICAi4oKJIjogIjkiLAogICLigpAiOiAiYSIsCiAgIuKCkSI6ICJlIiwKICAi4oKVIjogImgiLAogICLhtaIiOiAiaSIsCiAgIuKxvCI6ICJqIiwKICAi4oKWIjogImsiLAogICLigpciOiAibCIsCiAgIuKCmCI6ICJtIiwKICAi4oKZIjogIm4iLAogICLigpIiOiAibyIsCiAgIuKCmiI6ICJwIiwKICAi4bWjIjogInIiLAogICLigpsiOiAicyIsCiAgIuKCnCI6ICJ0IiwKICAi4bWkIjogInUiLAogICLhtaUiOiAidiIsCiAgIuKCkyI6ICJ4IiwKICAi4bWmIjogIs6yIiwKICAi4bWnIjogIs6zIiwKICAi4bWoIjogIs+BIiwKICAi4bWpIjogIs+VIiwKICAi4bWqIjogIs+HIiwKICAi4oG6IjogIisiLAogICLigbsiOiAiLSIsCiAgIuKBvCI6ICI9IiwKICAi4oG9IjogIigiLAogICLigb4iOiAiKSIsCiAgIuKBsCI6ICIwIiwKICAiwrkiOiAiMSIsCiAgIsKyIjogIjIiLAogICLCsyI6ICIzIiwKICAi4oG0IjogIjQiLAogICLigbUiOiAiNSIsCiAgIuKBtiI6ICI2IiwKICAi4oG3IjogIjciLAogICLigbgiOiAiOCIsCiAgIuKBuSI6ICI5IiwKICAi4bSsIjogIkEiLAogICLhtK4iOiAiQiIsCiAgIuG0sCI6ICJEIiwKICAi4bSxIjogIkUiLAogICLhtLMiOiAiRyIsCiAgIuG0tCI6ICJIIiwKICAi4bS1IjogIkkiLAogICLhtLYiOiAiSiIsCiAgIuG0tyI6ICJLIiwKICAi4bS4IjogIkwiLAogICLhtLkiOiAiTSIsCiAgIuG0uiI6ICJOIiwKICAi4bS8IjogIk8iLAogICLhtL4iOiAiUCIsCiAgIuG0vyI6ICJSIiwKICAi4bWAIjogIlQiLAogICLhtYEiOiAiVSIsCiAgIuKxvSI6ICJWIiwKICAi4bWCIjogIlciLAogICLhtYMiOiAiYSIsCiAgIuG1hyI6ICJiIiwKICAi4bacIjogImMiLAogICLhtYgiOiAiZCIsCiAgIuG1iSI6ICJlIiwKICAi4bagIjogImYiLAogICLhtY0iOiAiZyIsCiAgIsqwIjogImgiLAogICLigbEiOiAiaSIsCiAgIsqyIjogImoiLAogICLhtY8iOiAiayIsCiAgIsuhIjogImwiLAogICLhtZAiOiAibSIsCiAgIuKBvyI6ICJuIiwKICAi4bWSIjogIm8iLAogICLhtZYiOiAicCIsCiAgIsqzIjogInIiLAogICLLoiI6ICJzIiwKICAi4bWXIjogInQiLAogICLhtZgiOiAidSIsCiAgIuG1myI6ICJ2IiwKICAiyrciOiAidyIsCiAgIsujIjogIngiLAogICLKuCI6ICJ5IiwKICAi4ba7IjogInoiLAogICLhtZ0iOiAizrIiLAogICLhtZ4iOiAizrMiLAogICLhtZ8iOiAizrQiLAogICLhtaAiOiAiz5UiLAogICLhtaEiOiAiz4ciLAogICLhtr8iOiAizrgiCn0pOwp2YXIgdW5pY29kZUFjY2VudHMgPSB7CiAgIsyBIjogewogICAgInRleHQiOiAiXFwnIiwKICAgICJtYXRoIjogIlxcYWN1dGUiCiAgfSwKICAizIAiOiB7CiAgICAidGV4dCI6ICJcXGAiLAogICAgIm1hdGgiOiAiXFxncmF2ZSIKICB9LAogICLMiCI6IHsKICAgICJ0ZXh0IjogJ1xcIicsCiAgICAibWF0aCI6ICJcXGRkb3QiCiAgfSwKICAizIMiOiB7CiAgICAidGV4dCI6ICJcXH4iLAogICAgIm1hdGgiOiAiXFx0aWxkZSIKICB9LAogICLMhCI6IHsKICAgICJ0ZXh0IjogIlxcPSIsCiAgICAibWF0aCI6ICJcXGJhciIKICB9LAogICLMhiI6IHsKICAgICJ0ZXh0IjogIlxcdSIsCiAgICAibWF0aCI6ICJcXGJyZXZlIgogIH0sCiAgIsyMIjogewogICAgInRleHQiOiAiXFx2IiwKICAgICJtYXRoIjogIlxcY2hlY2siCiAgfSwKICAizIIiOiB7CiAgICAidGV4dCI6ICJcXF4iLAogICAgIm1hdGgiOiAiXFxoYXQiCiAgfSwKICAizIciOiB7CiAgICAidGV4dCI6ICJcXC4iLAogICAgIm1hdGgiOiAiXFxkb3QiCiAgfSwKICAizIoiOiB7CiAgICAidGV4dCI6ICJcXHIiLAogICAgIm1hdGgiOiAiXFxtYXRocmluZyIKICB9LAogICLMiyI6IHsKICAgICJ0ZXh0IjogIlxcSCIKICB9LAogICLMpyI6IHsKICAgICJ0ZXh0IjogIlxcYyIKICB9Cn07CnZhciB1bmljb2RlU3ltYm9scyA9IHsKICAiw6EiOiAiYcyBIiwKICAiw6AiOiAiYcyAIiwKICAiw6QiOiAiYcyIIiwKICAix58iOiAiYcyIzIQiLAogICLDoyI6ICJhzIMiLAogICLEgSI6ICJhzIQiLAogICLEgyI6ICJhzIYiLAogICLhuq8iOiAiYcyGzIEiLAogICLhurEiOiAiYcyGzIAiLAogICLhurUiOiAiYcyGzIMiLAogICLHjiI6ICJhzIwiLAogICLDoiI6ICJhzIIiLAogICLhuqUiOiAiYcyCzIEiLAogICLhuqciOiAiYcyCzIAiLAogICLhuqsiOiAiYcyCzIMiLAogICLIpyI6ICJhzIciLAogICLHoSI6ICJhzIfMhCIsCiAgIsOlIjogImHMiiIsCiAgIse7IjogImHMisyBIiwKICAi4biDIjogImLMhyIsCiAgIsSHIjogImPMgSIsCiAgIuG4iSI6ICJjzKfMgSIsCiAgIsSNIjogImPMjCIsCiAgIsSJIjogImPMgiIsCiAgIsSLIjogImPMhyIsCiAgIsOnIjogImPMpyIsCiAgIsSPIjogImTMjCIsCiAgIuG4iyI6ICJkzIciLAogICLhuJEiOiAiZMynIiwKICAiw6kiOiAiZcyBIiwKICAiw6giOiAiZcyAIiwKICAiw6siOiAiZcyIIiwKICAi4bq9IjogImXMgyIsCiAgIsSTIjogImXMhCIsCiAgIuG4lyI6ICJlzITMgSIsCiAgIuG4lSI6ICJlzITMgCIsCiAgIsSVIjogImXMhiIsCiAgIuG4nSI6ICJlzKfMhiIsCiAgIsSbIjogImXMjCIsCiAgIsOqIjogImXMgiIsCiAgIuG6vyI6ICJlzILMgSIsCiAgIuG7gSI6ICJlzILMgCIsCiAgIuG7hSI6ICJlzILMgyIsCiAgIsSXIjogImXMhyIsCiAgIsipIjogImXMpyIsCiAgIuG4nyI6ICJmzIciLAogICLHtSI6ICJnzIEiLAogICLhuKEiOiAiZ8yEIiwKICAixJ8iOiAiZ8yGIiwKICAix6ciOiAiZ8yMIiwKICAixJ0iOiAiZ8yCIiwKICAixKEiOiAiZ8yHIiwKICAixKMiOiAiZ8ynIiwKICAi4binIjogImjMiCIsCiAgIsifIjogImjMjCIsCiAgIsSlIjogImjMgiIsCiAgIuG4oyI6ICJozIciLAogICLhuKkiOiAiaMynIiwKICAiw60iOiAiacyBIiwKICAiw6wiOiAiacyAIiwKICAiw68iOiAiacyIIiwKICAi4bivIjogImnMiMyBIiwKICAixKkiOiAiacyDIiwKICAixKsiOiAiacyEIiwKICAixK0iOiAiacyGIiwKICAix5AiOiAiacyMIiwKICAiw64iOiAiacyCIiwKICAix7AiOiAiasyMIiwKICAixLUiOiAiasyCIiwKICAi4bixIjogImvMgSIsCiAgIsepIjogImvMjCIsCiAgIsS3IjogImvMpyIsCiAgIsS6IjogImzMgSIsCiAgIsS+IjogImzMjCIsCiAgIsS8IjogImzMpyIsCiAgIuG4vyI6ICJtzIEiLAogICLhuYEiOiAibcyHIiwKICAixYQiOiAibsyBIiwKICAix7kiOiAibsyAIiwKICAiw7EiOiAibsyDIiwKICAixYgiOiAibsyMIiwKICAi4bmFIjogIm7MhyIsCiAgIsWGIjogIm7MpyIsCiAgIsOzIjogIm/MgSIsCiAgIsOyIjogIm/MgCIsCiAgIsO2IjogIm/MiCIsCiAgIsirIjogIm/MiMyEIiwKICAiw7UiOiAib8yDIiwKICAi4bmNIjogIm/Mg8yBIiwKICAi4bmPIjogIm/Mg8yIIiwKICAiyK0iOiAib8yDzIQiLAogICLFjSI6ICJvzIQiLAogICLhuZMiOiAib8yEzIEiLAogICLhuZEiOiAib8yEzIAiLAogICLFjyI6ICJvzIYiLAogICLHkiI6ICJvzIwiLAogICLDtCI6ICJvzIIiLAogICLhu5EiOiAib8yCzIEiLAogICLhu5MiOiAib8yCzIAiLAogICLhu5ciOiAib8yCzIMiLAogICLIryI6ICJvzIciLAogICLIsSI6ICJvzIfMhCIsCiAgIsWRIjogIm/MiyIsCiAgIuG5lSI6ICJwzIEiLAogICLhuZciOiAicMyHIiwKICAixZUiOiAicsyBIiwKICAixZkiOiAicsyMIiwKICAi4bmZIjogInLMhyIsCiAgIsWXIjogInLMpyIsCiAgIsWbIjogInPMgSIsCiAgIuG5pSI6ICJzzIHMhyIsCiAgIsWhIjogInPMjCIsCiAgIuG5pyI6ICJzzIzMhyIsCiAgIsWdIjogInPMgiIsCiAgIuG5oSI6ICJzzIciLAogICLFnyI6ICJzzKciLAogICLhupciOiAidMyIIiwKICAixaUiOiAidMyMIiwKICAi4bmrIjogInTMhyIsCiAgIsWjIjogInTMpyIsCiAgIsO6IjogInXMgSIsCiAgIsO5IjogInXMgCIsCiAgIsO8IjogInXMiCIsCiAgIseYIjogInXMiMyBIiwKICAix5wiOiAidcyIzIAiLAogICLHliI6ICJ1zIjMhCIsCiAgIseaIjogInXMiMyMIiwKICAixakiOiAidcyDIiwKICAi4bm5IjogInXMg8yBIiwKICAixasiOiAidcyEIiwKICAi4bm7IjogInXMhMyIIiwKICAixa0iOiAidcyGIiwKICAix5QiOiAidcyMIiwKICAiw7siOiAidcyCIiwKICAixa8iOiAidcyKIiwKICAixbEiOiAidcyLIiwKICAi4bm9IjogInbMgyIsCiAgIuG6gyI6ICJ3zIEiLAogICLhuoEiOiAid8yAIiwKICAi4bqFIjogInfMiCIsCiAgIsW1IjogInfMgiIsCiAgIuG6hyI6ICJ3zIciLAogICLhupgiOiAid8yKIiwKICAi4bqNIjogInjMiCIsCiAgIuG6iyI6ICJ4zIciLAogICLDvSI6ICJ5zIEiLAogICLhu7MiOiAiecyAIiwKICAiw78iOiAiecyIIiwKICAi4bu5IjogInnMgyIsCiAgIsizIjogInnMhCIsCiAgIsW3IjogInnMgiIsCiAgIuG6jyI6ICJ5zIciLAogICLhupkiOiAiecyKIiwKICAixboiOiAiesyBIiwKICAixb4iOiAiesyMIiwKICAi4bqRIjogInrMgiIsCiAgIsW8IjogInrMhyIsCiAgIsOBIjogIkHMgSIsCiAgIsOAIjogIkHMgCIsCiAgIsOEIjogIkHMiCIsCiAgIseeIjogIkHMiMyEIiwKICAiw4MiOiAiQcyDIiwKICAixIAiOiAiQcyEIiwKICAixIIiOiAiQcyGIiwKICAi4bquIjogIkHMhsyBIiwKICAi4bqwIjogIkHMhsyAIiwKICAi4bq0IjogIkHMhsyDIiwKICAix40iOiAiQcyMIiwKICAiw4IiOiAiQcyCIiwKICAi4bqkIjogIkHMgsyBIiwKICAi4bqmIjogIkHMgsyAIiwKICAi4bqqIjogIkHMgsyDIiwKICAiyKYiOiAiQcyHIiwKICAix6AiOiAiQcyHzIQiLAogICLDhSI6ICJBzIoiLAogICLHuiI6ICJBzIrMgSIsCiAgIuG4giI6ICJCzIciLAogICLEhiI6ICJDzIEiLAogICLhuIgiOiAiQ8ynzIEiLAogICLEjCI6ICJDzIwiLAogICLEiCI6ICJDzIIiLAogICLEiiI6ICJDzIciLAogICLDhyI6ICJDzKciLAogICLEjiI6ICJEzIwiLAogICLhuIoiOiAiRMyHIiwKICAi4biQIjogIkTMpyIsCiAgIsOJIjogIkXMgSIsCiAgIsOIIjogIkXMgCIsCiAgIsOLIjogIkXMiCIsCiAgIuG6vCI6ICJFzIMiLAogICLEkiI6ICJFzIQiLAogICLhuJYiOiAiRcyEzIEiLAogICLhuJQiOiAiRcyEzIAiLAogICLElCI6ICJFzIYiLAogICLhuJwiOiAiRcynzIYiLAogICLEmiI6ICJFzIwiLAogICLDiiI6ICJFzIIiLAogICLhur4iOiAiRcyCzIEiLAogICLhu4AiOiAiRcyCzIAiLAogICLhu4QiOiAiRcyCzIMiLAogICLEliI6ICJFzIciLAogICLIqCI6ICJFzKciLAogICLhuJ4iOiAiRsyHIiwKICAix7QiOiAiR8yBIiwKICAi4bigIjogIkfMhCIsCiAgIsSeIjogIkfMhiIsCiAgIsemIjogIkfMjCIsCiAgIsScIjogIkfMgiIsCiAgIsSgIjogIkfMhyIsCiAgIsSiIjogIkfMpyIsCiAgIuG4piI6ICJIzIgiLAogICLIniI6ICJIzIwiLAogICLEpCI6ICJIzIIiLAogICLhuKIiOiAiSMyHIiwKICAi4bioIjogIkjMpyIsCiAgIsONIjogIknMgSIsCiAgIsOMIjogIknMgCIsCiAgIsOPIjogIknMiCIsCiAgIuG4riI6ICJJzIjMgSIsCiAgIsSoIjogIknMgyIsCiAgIsSqIjogIknMhCIsCiAgIsSsIjogIknMhiIsCiAgIsePIjogIknMjCIsCiAgIsOOIjogIknMgiIsCiAgIsSwIjogIknMhyIsCiAgIsS0IjogIkrMgiIsCiAgIuG4sCI6ICJLzIEiLAogICLHqCI6ICJLzIwiLAogICLEtiI6ICJLzKciLAogICLEuSI6ICJMzIEiLAogICLEvSI6ICJMzIwiLAogICLEuyI6ICJMzKciLAogICLhuL4iOiAiTcyBIiwKICAi4bmAIjogIk3MhyIsCiAgIsWDIjogIk7MgSIsCiAgIse4IjogIk7MgCIsCiAgIsORIjogIk7MgyIsCiAgIsWHIjogIk7MjCIsCiAgIuG5hCI6ICJOzIciLAogICLFhSI6ICJOzKciLAogICLDkyI6ICJPzIEiLAogICLDkiI6ICJPzIAiLAogICLDliI6ICJPzIgiLAogICLIqiI6ICJPzIjMhCIsCiAgIsOVIjogIk/MgyIsCiAgIuG5jCI6ICJPzIPMgSIsCiAgIuG5jiI6ICJPzIPMiCIsCiAgIsisIjogIk/Mg8yEIiwKICAixYwiOiAiT8yEIiwKICAi4bmSIjogIk/MhMyBIiwKICAi4bmQIjogIk/MhMyAIiwKICAixY4iOiAiT8yGIiwKICAix5EiOiAiT8yMIiwKICAiw5QiOiAiT8yCIiwKICAi4buQIjogIk/MgsyBIiwKICAi4buSIjogIk/MgsyAIiwKICAi4buWIjogIk/MgsyDIiwKICAiyK4iOiAiT8yHIiwKICAiyLAiOiAiT8yHzIQiLAogICLFkCI6ICJPzIsiLAogICLhuZQiOiAiUMyBIiwKICAi4bmWIjogIlDMhyIsCiAgIsWUIjogIlLMgSIsCiAgIsWYIjogIlLMjCIsCiAgIuG5mCI6ICJSzIciLAogICLFliI6ICJSzKciLAogICLFmiI6ICJTzIEiLAogICLhuaQiOiAiU8yBzIciLAogICLFoCI6ICJTzIwiLAogICLhuaYiOiAiU8yMzIciLAogICLFnCI6ICJTzIIiLAogICLhuaAiOiAiU8yHIiwKICAixZ4iOiAiU8ynIiwKICAixaQiOiAiVMyMIiwKICAi4bmqIjogIlTMhyIsCiAgIsWiIjogIlTMpyIsCiAgIsOaIjogIlXMgSIsCiAgIsOZIjogIlXMgCIsCiAgIsOcIjogIlXMiCIsCiAgIseXIjogIlXMiMyBIiwKICAix5siOiAiVcyIzIAiLAogICLHlSI6ICJVzIjMhCIsCiAgIseZIjogIlXMiMyMIiwKICAixagiOiAiVcyDIiwKICAi4bm4IjogIlXMg8yBIiwKICAixaoiOiAiVcyEIiwKICAi4bm6IjogIlXMhMyIIiwKICAixawiOiAiVcyGIiwKICAix5MiOiAiVcyMIiwKICAiw5siOiAiVcyCIiwKICAixa4iOiAiVcyKIiwKICAixbAiOiAiVcyLIiwKICAi4bm8IjogIlbMgyIsCiAgIuG6giI6ICJXzIEiLAogICLhuoAiOiAiV8yAIiwKICAi4bqEIjogIlfMiCIsCiAgIsW0IjogIlfMgiIsCiAgIuG6hiI6ICJXzIciLAogICLhuowiOiAiWMyIIiwKICAi4bqKIjogIljMhyIsCiAgIsOdIjogIlnMgSIsCiAgIuG7siI6ICJZzIAiLAogICLFuCI6ICJZzIgiLAogICLhu7giOiAiWcyDIiwKICAiyLIiOiAiWcyEIiwKICAixbYiOiAiWcyCIiwKICAi4bqOIjogIlnMhyIsCiAgIsW5IjogIlrMgSIsCiAgIsW9IjogIlrMjCIsCiAgIuG6kCI6ICJazIIiLAogICLFuyI6ICJazIciLAogICLOrCI6ICLOscyBIiwKICAi4b2wIjogIs6xzIAiLAogICLhvrEiOiAizrHMhCIsCiAgIuG+sCI6ICLOscyGIiwKICAizq0iOiAizrXMgSIsCiAgIuG9siI6ICLOtcyAIiwKICAizq4iOiAizrfMgSIsCiAgIuG9tCI6ICLOt8yAIiwKICAizq8iOiAizrnMgSIsCiAgIuG9tiI6ICLOucyAIiwKICAiz4oiOiAizrnMiCIsCiAgIs6QIjogIs65zIjMgSIsCiAgIuG/kiI6ICLOucyIzIAiLAogICLhv5EiOiAizrnMhCIsCiAgIuG/kCI6ICLOucyGIiwKICAiz4wiOiAizr/MgSIsCiAgIuG9uCI6ICLOv8yAIiwKICAiz40iOiAiz4XMgSIsCiAgIuG9uiI6ICLPhcyAIiwKICAiz4siOiAiz4XMiCIsCiAgIs6wIjogIs+FzIjMgSIsCiAgIuG/oiI6ICLPhcyIzIAiLAogICLhv6EiOiAiz4XMhCIsCiAgIuG/oCI6ICLPhcyGIiwKICAiz44iOiAiz4nMgSIsCiAgIuG9vCI6ICLPicyAIiwKICAizo4iOiAizqXMgSIsCiAgIuG/qiI6ICLOpcyAIiwKICAizqsiOiAizqXMiCIsCiAgIuG/qSI6ICLOpcyEIiwKICAi4b+oIjogIs6lzIYiLAogICLOjyI6ICLOqcyBIiwKICAi4b+6IjogIs6pzIAiCn07CnZhciBQYXJzZXIgPSBjbGFzcyBfUGFyc2VyIHsKICBjb25zdHJ1Y3RvcihpbnB1dCwgc2V0dGluZ3MpIHsKICAgIHRoaXMubW9kZSA9IHZvaWQgMDsKICAgIHRoaXMuZ3VsbGV0ID0gdm9pZCAwOwogICAgdGhpcy5zZXR0aW5ncyA9IHZvaWQgMDsKICAgIHRoaXMubGVmdHJpZ2h0RGVwdGggPSB2b2lkIDA7CiAgICB0aGlzLm5leHRUb2tlbiA9IHZvaWQgMDsKICAgIHRoaXMubW9kZSA9ICJtYXRoIjsKICAgIHRoaXMuZ3VsbGV0ID0gbmV3IE1hY3JvRXhwYW5kZXIoaW5wdXQsIHNldHRpbmdzLCB0aGlzLm1vZGUpOwogICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzOwogICAgdGhpcy5sZWZ0cmlnaHREZXB0aCA9IDA7CiAgfQogIC8qKgogICAqIENoZWNrcyBhIHJlc3VsdCB0byBtYWtlIHN1cmUgaXQgaGFzIHRoZSByaWdodCB0eXBlLCBhbmQgdGhyb3dzIGFuCiAgICogYXBwcm9wcmlhdGUgZXJyb3Igb3RoZXJ3aXNlLgogICAqLwogIGV4cGVjdCh0ZXh0MiwgY29uc3VtZSkgewogICAgaWYgKGNvbnN1bWUgPT09IHZvaWQgMCkgewogICAgICBjb25zdW1lID0gdHJ1ZTsKICAgIH0KICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCAhPT0gdGV4dDIpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkV4cGVjdGVkICciICsgdGV4dDIgKyAiJywgZ290ICciICsgdGhpcy5mZXRjaCgpLnRleHQgKyAiJyIsIHRoaXMuZmV0Y2goKSk7CiAgICB9CiAgICBpZiAoY29uc3VtZSkgewogICAgICB0aGlzLmNvbnN1bWUoKTsKICAgIH0KICB9CiAgLyoqCiAgICogRGlzY2FyZHMgdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBjb25zaWRlcmluZyBpdCBjb25zdW1lZC4KICAgKi8KICBjb25zdW1lKCkgewogICAgdGhpcy5uZXh0VG9rZW4gPSBudWxsOwogIH0KICAvKioKICAgKiBSZXR1cm4gdGhlIGN1cnJlbnQgbG9va2FoZWFkIHRva2VuLCBvciBpZiB0aGVyZSBpc24ndCBvbmUgKGF0IHRoZQogICAqIGJlZ2lubmluZywgb3IgaWYgdGhlIHByZXZpb3VzIGxvb2thaGVhZCB0b2tlbiB3YXMgY29uc3VtZSgpZCksCiAgICogZmV0Y2ggdGhlIG5leHQgdG9rZW4gYXMgdGhlIG5ldyBsb29rYWhlYWQgdG9rZW4gYW5kIHJldHVybiBpdC4KICAgKi8KICBmZXRjaCgpIHsKICAgIGlmICh0aGlzLm5leHRUb2tlbiA9PSBudWxsKSB7CiAgICAgIHRoaXMubmV4dFRva2VuID0gdGhpcy5ndWxsZXQuZXhwYW5kTmV4dFRva2VuKCk7CiAgICB9CiAgICByZXR1cm4gdGhpcy5uZXh0VG9rZW47CiAgfQogIC8qKgogICAqIFN3aXRjaGVzIGJldHdlZW4gInRleHQiIGFuZCAibWF0aCIgbW9kZXMuCiAgICovCiAgc3dpdGNoTW9kZShuZXdNb2RlKSB7CiAgICB0aGlzLm1vZGUgPSBuZXdNb2RlOwogICAgdGhpcy5ndWxsZXQuc3dpdGNoTW9kZShuZXdNb2RlKTsKICB9CiAgLyoqCiAgICogTWFpbiBwYXJzaW5nIGZ1bmN0aW9uLCB3aGljaCBwYXJzZXMgYW4gZW50aXJlIGlucHV0LgogICAqLwogIHBhcnNlKCkgewogICAgaWYgKCF0aGlzLnNldHRpbmdzLmdsb2JhbEdyb3VwKSB7CiAgICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTsKICAgIH0KICAgIGlmICh0aGlzLnNldHRpbmdzLmNvbG9ySXNUZXh0Q29sb3IpIHsKICAgICAgdGhpcy5ndWxsZXQubWFjcm9zLnNldCgiXFxjb2xvciIsICJcXHRleHRjb2xvciIpOwogICAgfQogICAgdHJ5IHsKICAgICAgdmFyIHBhcnNlID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UpOwogICAgICB0aGlzLmV4cGVjdCgiRU9GIik7CiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5nbG9iYWxHcm91cCkgewogICAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7CiAgICAgIH0KICAgICAgcmV0dXJuIHBhcnNlOwogICAgfSBmaW5hbGx5IHsKICAgICAgdGhpcy5ndWxsZXQuZW5kR3JvdXBzKCk7CiAgICB9CiAgfQogIC8qKgogICAqIEZ1bGx5IHBhcnNlIGEgc2VwYXJhdGUgc2VxdWVuY2Ugb2YgdG9rZW5zIGFzIGEgc2VwYXJhdGUgam9iLgogICAqIFRva2VucyBzaG91bGQgYmUgc3BlY2lmaWVkIGluIHJldmVyc2Ugb3JkZXIsIGFzIGluIGEgTWFjcm9EZWZpbml0aW9uLgogICAqLwogIHN1YnBhcnNlKHRva2VucykgewogICAgdmFyIG9sZFRva2VuID0gdGhpcy5uZXh0VG9rZW47CiAgICB0aGlzLmNvbnN1bWUoKTsKICAgIHRoaXMuZ3VsbGV0LnB1c2hUb2tlbihuZXcgVG9rZW4oIn0iKSk7CiAgICB0aGlzLmd1bGxldC5wdXNoVG9rZW5zKHRva2Vucyk7CiAgICB2YXIgcGFyc2UgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSk7CiAgICB0aGlzLmV4cGVjdCgifSIpOwogICAgdGhpcy5uZXh0VG9rZW4gPSBvbGRUb2tlbjsKICAgIHJldHVybiBwYXJzZTsKICB9CiAgLyoqCiAgICogUGFyc2VzIGFuICJleHByZXNzaW9uIiwgd2hpY2ggaXMgYSBsaXN0IG9mIGF0b21zLgogICAqCiAgICogYGJyZWFrT25JbmZpeGA6IFNob3VsZCB0aGUgcGFyc2luZyBzdG9wIHdoZW4gd2UgaGl0IGluZml4IG5vZGVzPyBUaGlzCiAgICogICAgICAgICAgICAgICAgIGhhcHBlbnMgd2hlbiBmdW5jdGlvbnMgaGF2ZSBoaWdoZXIgcHJlY2VkZW5jZSBoYW4gaW5maXgKICAgKiAgICAgICAgICAgICAgICAgbm9kZXMgaW4gaW1wbGljaXQgcGFyc2VzLgogICAqCiAgICogYGJyZWFrT25Ub2tlblRleHRgOiBUaGUgdGV4dCBvZiB0aGUgdG9rZW4gdGhhdCB0aGUgZXhwcmVzc2lvbiBzaG91bGQgZW5kCiAgICogICAgICAgICAgICAgICAgICAgICB3aXRoLCBvciBgbnVsbGAgaWYgc29tZXRoaW5nIGVsc2Ugc2hvdWxkIGVuZCB0aGUKICAgKiAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb24uCiAgICovCiAgcGFyc2VFeHByZXNzaW9uKGJyZWFrT25JbmZpeCwgYnJlYWtPblRva2VuVGV4dCkgewogICAgdmFyIGJvZHkgPSBbXTsKICAgIHdoaWxlICh0cnVlKSB7CiAgICAgIGlmICh0aGlzLm1vZGUgPT09ICJtYXRoIikgewogICAgICAgIHRoaXMuY29uc3VtZVNwYWNlcygpOwogICAgICB9CiAgICAgIHZhciBsZXggPSB0aGlzLmZldGNoKCk7CiAgICAgIGlmIChfUGFyc2VyLmVuZE9mRXhwcmVzc2lvbi5pbmRleE9mKGxleC50ZXh0KSAhPT0gLTEpIHsKICAgICAgICBicmVhazsKICAgICAgfQogICAgICBpZiAoYnJlYWtPblRva2VuVGV4dCAmJiBsZXgudGV4dCA9PT0gYnJlYWtPblRva2VuVGV4dCkgewogICAgICAgIGJyZWFrOwogICAgICB9CiAgICAgIGlmIChicmVha09uSW5maXggJiYgZnVuY3Rpb25zW2xleC50ZXh0XSAmJiBmdW5jdGlvbnNbbGV4LnRleHRdLmluZml4KSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgICAgdmFyIGF0b20gPSB0aGlzLnBhcnNlQXRvbShicmVha09uVG9rZW5UZXh0KTsKICAgICAgaWYgKCFhdG9tKSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0gZWxzZSBpZiAoYXRvbS50eXBlID09PSAiaW50ZXJuYWwiKSB7CiAgICAgICAgY29udGludWU7CiAgICAgIH0KICAgICAgYm9keS5wdXNoKGF0b20pOwogICAgfQogICAgaWYgKHRoaXMubW9kZSA9PT0gInRleHQiKSB7CiAgICAgIHRoaXMuZm9ybUxpZ2F0dXJlcyhib2R5KTsKICAgIH0KICAgIHJldHVybiB0aGlzLmhhbmRsZUluZml4Tm9kZXMoYm9keSk7CiAgfQogIC8qKgogICAqIFJld3JpdGVzIGluZml4IG9wZXJhdG9ycyBzdWNoIGFzIFxvdmVyIHdpdGggY29ycmVzcG9uZGluZyBjb21tYW5kcyBzdWNoCiAgICogYXMgXGZyYWMuCiAgICoKICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwLiAgSWYgdGhlcmUncyBtb3JlIHRoYW4gb25lCiAgICogdGhlbiB0aGUgZXhwcmVzc2lvbiBpcyBhbWJpZ3VvdXMuICBUaGlzIGNhbiBiZSByZXNvbHZlZCBieSBhZGRpbmcge30uCiAgICovCiAgaGFuZGxlSW5maXhOb2Rlcyhib2R5KSB7CiAgICB2YXIgb3ZlckluZGV4ID0gLTE7CiAgICB2YXIgZnVuY05hbWU7CiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHsKICAgICAgaWYgKGJvZHlbaV0udHlwZSA9PT0gImluZml4IikgewogICAgICAgIGlmIChvdmVySW5kZXggIT09IC0xKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigib25seSBvbmUgaW5maXggb3BlcmF0b3IgcGVyIGdyb3VwIiwgYm9keVtpXS50b2tlbik7CiAgICAgICAgfQogICAgICAgIG92ZXJJbmRleCA9IGk7CiAgICAgICAgZnVuY05hbWUgPSBib2R5W2ldLnJlcGxhY2VXaXRoOwogICAgICB9CiAgICB9CiAgICBpZiAob3ZlckluZGV4ICE9PSAtMSAmJiBmdW5jTmFtZSkgewogICAgICB2YXIgbnVtZXJOb2RlOwogICAgICB2YXIgZGVub21Ob2RlOwogICAgICB2YXIgbnVtZXJCb2R5ID0gYm9keS5zbGljZSgwLCBvdmVySW5kZXgpOwogICAgICB2YXIgZGVub21Cb2R5ID0gYm9keS5zbGljZShvdmVySW5kZXggKyAxKTsKICAgICAgaWYgKG51bWVyQm9keS5sZW5ndGggPT09IDEgJiYgbnVtZXJCb2R5WzBdLnR5cGUgPT09ICJvcmRncm91cCIpIHsKICAgICAgICBudW1lck5vZGUgPSBudW1lckJvZHlbMF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgbnVtZXJOb2RlID0gewogICAgICAgICAgdHlwZTogIm9yZGdyb3VwIiwKICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSwKICAgICAgICAgIGJvZHk6IG51bWVyQm9keQogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKGRlbm9tQm9keS5sZW5ndGggPT09IDEgJiYgZGVub21Cb2R5WzBdLnR5cGUgPT09ICJvcmRncm91cCIpIHsKICAgICAgICBkZW5vbU5vZGUgPSBkZW5vbUJvZHlbMF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZGVub21Ob2RlID0gewogICAgICAgICAgdHlwZTogIm9yZGdyb3VwIiwKICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSwKICAgICAgICAgIGJvZHk6IGRlbm9tQm9keQogICAgICAgIH07CiAgICAgIH0KICAgICAgdmFyIG5vZGU7CiAgICAgIGlmIChmdW5jTmFtZSA9PT0gIlxcXFxhYm92ZWZyYWMiKSB7CiAgICAgICAgbm9kZSA9IHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmNOYW1lLCBbbnVtZXJOb2RlLCBib2R5W292ZXJJbmRleF0sIGRlbm9tTm9kZV0sIFtdKTsKICAgICAgfSBlbHNlIHsKICAgICAgICBub2RlID0gdGhpcy5jYWxsRnVuY3Rpb24oZnVuY05hbWUsIFtudW1lck5vZGUsIGRlbm9tTm9kZV0sIFtdKTsKICAgICAgfQogICAgICByZXR1cm4gW25vZGVdOwogICAgfSBlbHNlIHsKICAgICAgcmV0dXJuIGJvZHk7CiAgICB9CiAgfQogIC8qKgogICAqIEhhbmRsZSBhIHN1YnNjcmlwdCBvciBzdXBlcnNjcmlwdCB3aXRoIG5pY2UgZXJyb3JzLgogICAqLwogIGhhbmRsZVN1cFN1YnNjcmlwdChuYW1lKSB7CiAgICB2YXIgc3ltYm9sVG9rZW4gPSB0aGlzLmZldGNoKCk7CiAgICB2YXIgc3ltYm9sID0gc3ltYm9sVG9rZW4udGV4dDsKICAgIHRoaXMuY29uc3VtZSgpOwogICAgdGhpcy5jb25zdW1lU3BhY2VzKCk7CiAgICB2YXIgZ3JvdXA7CiAgICBkbyB7CiAgICAgIHZhciBfZ3JvdXA7CiAgICAgIGdyb3VwID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpOwogICAgfSB3aGlsZSAoKChfZ3JvdXAgPSBncm91cCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9ncm91cC50eXBlKSA9PT0gImludGVybmFsIik7CiAgICBpZiAoIWdyb3VwKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJFeHBlY3RlZCBncm91cCBhZnRlciAnIiArIHN5bWJvbCArICInIiwgc3ltYm9sVG9rZW4pOwogICAgfQogICAgcmV0dXJuIGdyb3VwOwogIH0KICAvKioKICAgKiBDb252ZXJ0cyB0aGUgdGV4dHVhbCBpbnB1dCBvZiBhbiB1bnN1cHBvcnRlZCBjb21tYW5kIGludG8gYSB0ZXh0IG5vZGUKICAgKiBjb250YWluZWQgd2l0aGluIGEgY29sb3Igbm9kZSB3aG9zZSBjb2xvciBpcyBkZXRlcm1pbmVkIGJ5IGVycm9yQ29sb3IKICAgKi8KICBmb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0MikgewogICAgdmFyIHRleHRvcmRBcnJheSA9IFtdOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0Mi5sZW5ndGg7IGkrKykgewogICAgICB0ZXh0b3JkQXJyYXkucHVzaCh7CiAgICAgICAgdHlwZTogInRleHRvcmQiLAogICAgICAgIG1vZGU6ICJ0ZXh0IiwKICAgICAgICB0ZXh0OiB0ZXh0MltpXQogICAgICB9KTsKICAgIH0KICAgIHZhciB0ZXh0Tm9kZSA9IHsKICAgICAgdHlwZTogInRleHQiLAogICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgIGJvZHk6IHRleHRvcmRBcnJheQogICAgfTsKICAgIHZhciBjb2xvck5vZGUgPSB7CiAgICAgIHR5cGU6ICJjb2xvciIsCiAgICAgIG1vZGU6IHRoaXMubW9kZSwKICAgICAgY29sb3I6IHRoaXMuc2V0dGluZ3MuZXJyb3JDb2xvciwKICAgICAgYm9keTogW3RleHROb2RlXQogICAgfTsKICAgIHJldHVybiBjb2xvck5vZGU7CiAgfQogIC8qKgogICAqIFBhcnNlcyBhIGdyb3VwIHdpdGggb3B0aW9uYWwgc3VwZXIvc3Vic2NyaXB0cy4KICAgKi8KICBwYXJzZUF0b20oYnJlYWtPblRva2VuVGV4dCkgewogICAgdmFyIGJhc2UgPSB0aGlzLnBhcnNlR3JvdXAoImF0b20iLCBicmVha09uVG9rZW5UZXh0KTsKICAgIGlmICgoYmFzZSA9PSBudWxsID8gdm9pZCAwIDogYmFzZS50eXBlKSA9PT0gImludGVybmFsIikgewogICAgICByZXR1cm4gYmFzZTsKICAgIH0KICAgIGlmICh0aGlzLm1vZGUgPT09ICJ0ZXh0IikgewogICAgICByZXR1cm4gYmFzZTsKICAgIH0KICAgIHZhciBzdXBlcnNjcmlwdDsKICAgIHZhciBzdWJzY3JpcHQ7CiAgICB3aGlsZSAodHJ1ZSkgewogICAgICB0aGlzLmNvbnN1bWVTcGFjZXMoKTsKICAgICAgdmFyIGxleCA9IHRoaXMuZmV0Y2goKTsKICAgICAgaWYgKGxleC50ZXh0ID09PSAiXFxsaW1pdHMiIHx8IGxleC50ZXh0ID09PSAiXFxub2xpbWl0cyIpIHsKICAgICAgICBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09ICJvcCIpIHsKICAgICAgICAgIHZhciBsaW1pdHMgPSBsZXgudGV4dCA9PT0gIlxcbGltaXRzIjsKICAgICAgICAgIGJhc2UubGltaXRzID0gbGltaXRzOwogICAgICAgICAgYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIgPSB0cnVlOwogICAgICAgIH0gZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnR5cGUgPT09ICJvcGVyYXRvcm5hbWUiKSB7CiAgICAgICAgICBpZiAoYmFzZS5hbHdheXNIYW5kbGVTdXBTdWIpIHsKICAgICAgICAgICAgYmFzZS5saW1pdHMgPSBsZXgudGV4dCA9PT0gIlxcbGltaXRzIjsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkxpbWl0IGNvbnRyb2xzIG11c3QgZm9sbG93IGEgbWF0aCBvcGVyYXRvciIsIGxleCk7CiAgICAgICAgfQogICAgICAgIHRoaXMuY29uc3VtZSgpOwogICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSAiXiIpIHsKICAgICAgICBpZiAoc3VwZXJzY3JpcHQpIHsKICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJEb3VibGUgc3VwZXJzY3JpcHQiLCBsZXgpOwogICAgICAgIH0KICAgICAgICBzdXBlcnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KCJzdXBlcnNjcmlwdCIpOwogICAgICB9IGVsc2UgaWYgKGxleC50ZXh0ID09PSAiXyIpIHsKICAgICAgICBpZiAoc3Vic2NyaXB0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiRG91YmxlIHN1YnNjcmlwdCIsIGxleCk7CiAgICAgICAgfQogICAgICAgIHN1YnNjcmlwdCA9IHRoaXMuaGFuZGxlU3VwU3Vic2NyaXB0KCJzdWJzY3JpcHQiKTsKICAgICAgfSBlbHNlIGlmIChsZXgudGV4dCA9PT0gIiciKSB7CiAgICAgICAgaWYgKHN1cGVyc2NyaXB0KSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiRG91YmxlIHN1cGVyc2NyaXB0IiwgbGV4KTsKICAgICAgICB9CiAgICAgICAgdmFyIHByaW1lID0gewogICAgICAgICAgdHlwZTogInRleHRvcmQiLAogICAgICAgICAgbW9kZTogdGhpcy5tb2RlLAogICAgICAgICAgdGV4dDogIlxccHJpbWUiCiAgICAgICAgfTsKICAgICAgICB2YXIgcHJpbWVzID0gW3ByaW1lXTsKICAgICAgICB0aGlzLmNvbnN1bWUoKTsKICAgICAgICB3aGlsZSAodGhpcy5mZXRjaCgpLnRleHQgPT09ICInIikgewogICAgICAgICAgcHJpbWVzLnB1c2gocHJpbWUpOwogICAgICAgICAgdGhpcy5jb25zdW1lKCk7CiAgICAgICAgfQogICAgICAgIGlmICh0aGlzLmZldGNoKCkudGV4dCA9PT0gIl4iKSB7CiAgICAgICAgICBwcmltZXMucHVzaCh0aGlzLmhhbmRsZVN1cFN1YnNjcmlwdCgic3VwZXJzY3JpcHQiKSk7CiAgICAgICAgfQogICAgICAgIHN1cGVyc2NyaXB0ID0gewogICAgICAgICAgdHlwZTogIm9yZGdyb3VwIiwKICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSwKICAgICAgICAgIGJvZHk6IHByaW1lcwogICAgICAgIH07CiAgICAgIH0gZWxzZSBpZiAodVN1YnNBbmRTdXBzW2xleC50ZXh0XSkgewogICAgICAgIHZhciBpc1N1YiA9IHVuaWNvZGVTdWJSZWdFeC50ZXN0KGxleC50ZXh0KTsKICAgICAgICB2YXIgc3Vic3VwVG9rZW5zID0gW107CiAgICAgICAgc3Vic3VwVG9rZW5zLnB1c2gobmV3IFRva2VuKHVTdWJzQW5kU3Vwc1tsZXgudGV4dF0pKTsKICAgICAgICB0aGlzLmNvbnN1bWUoKTsKICAgICAgICB3aGlsZSAodHJ1ZSkgewogICAgICAgICAgdmFyIHRva2VuID0gdGhpcy5mZXRjaCgpLnRleHQ7CiAgICAgICAgICBpZiAoIXVTdWJzQW5kU3Vwc1t0b2tlbl0pIHsKICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAodW5pY29kZVN1YlJlZ0V4LnRlc3QodG9rZW4pICE9PSBpc1N1YikgewogICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICAgIHN1YnN1cFRva2Vucy51bnNoaWZ0KG5ldyBUb2tlbih1U3Vic0FuZFN1cHNbdG9rZW5dKSk7CiAgICAgICAgICB0aGlzLmNvbnN1bWUoKTsKICAgICAgICB9CiAgICAgICAgdmFyIGJvZHkgPSB0aGlzLnN1YnBhcnNlKHN1YnN1cFRva2Vucyk7CiAgICAgICAgaWYgKGlzU3ViKSB7CiAgICAgICAgICBzdWJzY3JpcHQgPSB7CiAgICAgICAgICAgIHR5cGU6ICJvcmRncm91cCIsCiAgICAgICAgICAgIG1vZGU6ICJtYXRoIiwKICAgICAgICAgICAgYm9keQogICAgICAgICAgfTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgc3VwZXJzY3JpcHQgPSB7CiAgICAgICAgICAgIHR5cGU6ICJvcmRncm91cCIsCiAgICAgICAgICAgIG1vZGU6ICJtYXRoIiwKICAgICAgICAgICAgYm9keQogICAgICAgICAgfTsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnJlYWs7CiAgICAgIH0KICAgIH0KICAgIGlmIChzdXBlcnNjcmlwdCB8fCBzdWJzY3JpcHQpIHsKICAgICAgcmV0dXJuIHsKICAgICAgICB0eXBlOiAic3Vwc3ViIiwKICAgICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgICAgYmFzZSwKICAgICAgICBzdXA6IHN1cGVyc2NyaXB0LAogICAgICAgIHN1Yjogc3Vic2NyaXB0CiAgICAgIH07CiAgICB9IGVsc2UgewogICAgICByZXR1cm4gYmFzZTsKICAgIH0KICB9CiAgLyoqCiAgICogUGFyc2VzIGFuIGVudGlyZSBmdW5jdGlvbiwgaW5jbHVkaW5nIGl0cyBiYXNlIGFuZCBhbGwgb2YgaXRzIGFyZ3VtZW50cy4KICAgKi8KICBwYXJzZUZ1bmN0aW9uKGJyZWFrT25Ub2tlblRleHQsIG5hbWUpIHsKICAgIHZhciB0b2tlbiA9IHRoaXMuZmV0Y2goKTsKICAgIHZhciBmdW5jID0gdG9rZW4udGV4dDsKICAgIHZhciBmdW5jRGF0YSA9IGZ1bmN0aW9uc1tmdW5jXTsKICAgIGlmICghZnVuY0RhdGEpIHsKICAgICAgcmV0dXJuIG51bGw7CiAgICB9CiAgICB0aGlzLmNvbnN1bWUoKTsKICAgIGlmIChuYW1lICYmIG5hbWUgIT09ICJhdG9tIiAmJiAhZnVuY0RhdGEuYWxsb3dlZEluQXJndW1lbnQpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkdvdCBmdW5jdGlvbiAnIiArIGZ1bmMgKyAiJyB3aXRoIG5vIGFyZ3VtZW50cyIgKyAobmFtZSA/ICIgYXMgIiArIG5hbWUgOiAiIiksIHRva2VuKTsKICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAidGV4dCIgJiYgIWZ1bmNEYXRhLmFsbG93ZWRJblRleHQpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkNhbid0IHVzZSBmdW5jdGlvbiAnIiArIGZ1bmMgKyAiJyBpbiB0ZXh0IG1vZGUiLCB0b2tlbik7CiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gIm1hdGgiICYmIGZ1bmNEYXRhLmFsbG93ZWRJbk1hdGggPT09IGZhbHNlKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJDYW4ndCB1c2UgZnVuY3Rpb24gJyIgKyBmdW5jICsgIicgaW4gbWF0aCBtb2RlIiwgdG9rZW4pOwogICAgfQogICAgdmFyIHsKICAgICAgYXJncywKICAgICAgb3B0QXJncwogICAgfSA9IHRoaXMucGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpOwogICAgcmV0dXJuIHRoaXMuY2FsbEZ1bmN0aW9uKGZ1bmMsIGFyZ3MsIG9wdEFyZ3MsIHRva2VuLCBicmVha09uVG9rZW5UZXh0KTsKICB9CiAgLyoqCiAgICogQ2FsbCBhIGZ1bmN0aW9uIGhhbmRsZXIgd2l0aCBhIHN1aXRhYmxlIGNvbnRleHQgYW5kIGFyZ3VtZW50cy4KICAgKi8KICBjYWxsRnVuY3Rpb24obmFtZSwgYXJncywgb3B0QXJncywgdG9rZW4sIGJyZWFrT25Ub2tlblRleHQpIHsKICAgIHZhciBjb250ZXh0ID0gewogICAgICBmdW5jTmFtZTogbmFtZSwKICAgICAgcGFyc2VyOiB0aGlzLAogICAgICB0b2tlbiwKICAgICAgYnJlYWtPblRva2VuVGV4dAogICAgfTsKICAgIHZhciBmdW5jID0gZnVuY3Rpb25zW25hbWVdOwogICAgaWYgKGZ1bmMgJiYgZnVuYy5oYW5kbGVyKSB7CiAgICAgIHJldHVybiBmdW5jLmhhbmRsZXIoY29udGV4dCwgYXJncywgb3B0QXJncyk7CiAgICB9IGVsc2UgewogICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiTm8gZnVuY3Rpb24gaGFuZGxlciBmb3IgIiArIG5hbWUpOwogICAgfQogIH0KICAvKioKICAgKiBQYXJzZXMgdGhlIGFyZ3VtZW50cyBvZiBhIGZ1bmN0aW9uIG9yIGVudmlyb25tZW50CiAgICovCiAgcGFyc2VBcmd1bWVudHMoZnVuYywgZnVuY0RhdGEpIHsKICAgIHZhciB0b3RhbEFyZ3MgPSBmdW5jRGF0YS5udW1BcmdzICsgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzOwogICAgaWYgKHRvdGFsQXJncyA9PT0gMCkgewogICAgICByZXR1cm4gewogICAgICAgIGFyZ3M6IFtdLAogICAgICAgIG9wdEFyZ3M6IFtdCiAgICAgIH07CiAgICB9CiAgICB2YXIgYXJncyA9IFtdOwogICAgdmFyIG9wdEFyZ3MgPSBbXTsKICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG90YWxBcmdzOyBpKyspIHsKICAgICAgdmFyIGFyZ1R5cGUgPSBmdW5jRGF0YS5hcmdUeXBlcyAmJiBmdW5jRGF0YS5hcmdUeXBlc1tpXTsKICAgICAgdmFyIGlzT3B0aW9uYWwgPSBpIDwgZnVuY0RhdGEubnVtT3B0aW9uYWxBcmdzOwogICAgICBpZiAoZnVuY0RhdGEucHJpbWl0aXZlICYmIGFyZ1R5cGUgPT0gbnVsbCB8fCAvLyBcc3FydCBleHBhbmRzIGludG8gcHJpbWl0aXZlIGlmIG9wdGlvbmFsIGFyZ3VtZW50IGRvZXNuJ3QgZXhpc3QKICAgICAgZnVuY0RhdGEudHlwZSA9PT0gInNxcnQiICYmIGkgPT09IDEgJiYgb3B0QXJnc1swXSA9PSBudWxsKSB7CiAgICAgICAgYXJnVHlwZSA9ICJwcmltaXRpdmUiOwogICAgICB9CiAgICAgIHZhciBhcmcgPSB0aGlzLnBhcnNlR3JvdXBPZlR5cGUoImFyZ3VtZW50IHRvICciICsgZnVuYyArICInIiwgYXJnVHlwZSwgaXNPcHRpb25hbCk7CiAgICAgIGlmIChpc09wdGlvbmFsKSB7CiAgICAgICAgb3B0QXJncy5wdXNoKGFyZyk7CiAgICAgIH0gZWxzZSBpZiAoYXJnICE9IG51bGwpIHsKICAgICAgICBhcmdzLnB1c2goYXJnKTsKICAgICAgfSBlbHNlIHsKICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiTnVsbCBhcmd1bWVudCwgcGxlYXNlIHJlcG9ydCB0aGlzIGFzIGEgYnVnIik7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiB7CiAgICAgIGFyZ3MsCiAgICAgIG9wdEFyZ3MKICAgIH07CiAgfQogIC8qKgogICAqIFBhcnNlcyBhIGdyb3VwIHdoZW4gdGhlIG1vZGUgaXMgY2hhbmdpbmcuCiAgICovCiAgcGFyc2VHcm91cE9mVHlwZShuYW1lLCB0eXBlLCBvcHRpb25hbCkgewogICAgc3dpdGNoICh0eXBlKSB7CiAgICAgIGNhc2UgImNvbG9yIjoKICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbG9yR3JvdXAob3B0aW9uYWwpOwogICAgICBjYXNlICJzaXplIjoKICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNpemVHcm91cChvcHRpb25hbCk7CiAgICAgIGNhc2UgInVybCI6CiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VVcmxHcm91cChvcHRpb25hbCk7CiAgICAgIGNhc2UgIm1hdGgiOgogICAgICBjYXNlICJ0ZXh0IjoKICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUFyZ3VtZW50R3JvdXAob3B0aW9uYWwsIHR5cGUpOwogICAgICBjYXNlICJoYm94IjogewogICAgICAgIHZhciBncm91cCA9IHRoaXMucGFyc2VBcmd1bWVudEdyb3VwKG9wdGlvbmFsLCAidGV4dCIpOwogICAgICAgIHJldHVybiBncm91cCAhPSBudWxsID8gewogICAgICAgICAgdHlwZTogInN0eWxpbmciLAogICAgICAgICAgbW9kZTogZ3JvdXAubW9kZSwKICAgICAgICAgIGJvZHk6IFtncm91cF0sCiAgICAgICAgICBzdHlsZTogInRleHQiCiAgICAgICAgICAvLyBzaW11bGF0ZSBcdGV4dHN0eWxlCiAgICAgICAgfSA6IG51bGw7CiAgICAgIH0KICAgICAgY2FzZSAicmF3IjogewogICAgICAgIHZhciB0b2tlbiA9IHRoaXMucGFyc2VTdHJpbmdHcm91cCgicmF3Iiwgb3B0aW9uYWwpOwogICAgICAgIHJldHVybiB0b2tlbiAhPSBudWxsID8gewogICAgICAgICAgdHlwZTogInJhdyIsCiAgICAgICAgICBtb2RlOiAidGV4dCIsCiAgICAgICAgICBzdHJpbmc6IHRva2VuLnRleHQKICAgICAgICB9IDogbnVsbDsKICAgICAgfQogICAgICBjYXNlICJwcmltaXRpdmUiOiB7CiAgICAgICAgaWYgKG9wdGlvbmFsKSB7CiAgICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiQSBwcmltaXRpdmUgYXJndW1lbnQgY2Fubm90IGJlIG9wdGlvbmFsIik7CiAgICAgICAgfQogICAgICAgIHZhciBfZ3JvdXAyID0gdGhpcy5wYXJzZUdyb3VwKG5hbWUpOwogICAgICAgIGlmIChfZ3JvdXAyID09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJFeHBlY3RlZCBncm91cCBhcyAiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIF9ncm91cDI7CiAgICAgIH0KICAgICAgY2FzZSAib3JpZ2luYWwiOgogICAgICBjYXNlIG51bGw6CiAgICAgIGNhc2Ugdm9pZCAwOgogICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCk7CiAgICAgIGRlZmF1bHQ6CiAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVua25vd24gZ3JvdXAgdHlwZSBhcyAiICsgbmFtZSwgdGhpcy5mZXRjaCgpKTsKICAgIH0KICB9CiAgLyoqCiAgICogRGlzY2FyZCBhbnkgc3BhY2UgdG9rZW5zLCBmZXRjaGluZyB0aGUgbmV4dCBub24tc3BhY2UgdG9rZW4uCiAgICovCiAgY29uc3VtZVNwYWNlcygpIHsKICAgIHdoaWxlICh0aGlzLmZldGNoKCkudGV4dCA9PT0gIiAiKSB7CiAgICAgIHRoaXMuY29uc3VtZSgpOwogICAgfQogIH0KICAvKioKICAgKiBQYXJzZXMgYSBncm91cCwgZXNzZW50aWFsbHkgcmV0dXJuaW5nIHRoZSBzdHJpbmcgZm9ybWVkIGJ5IHRoZQogICAqIGJyYWNlLWVuY2xvc2VkIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uCiAgICovCiAgcGFyc2VTdHJpbmdHcm91cChtb2RlTmFtZSwgb3B0aW9uYWwpIHsKICAgIHZhciBhcmdUb2tlbiA9IHRoaXMuZ3VsbGV0LnNjYW5Bcmd1bWVudChvcHRpb25hbCk7CiAgICBpZiAoYXJnVG9rZW4gPT0gbnVsbCkgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIHZhciBzdHIgPSAiIjsKICAgIHZhciBuZXh0VG9rZW47CiAgICB3aGlsZSAoKG5leHRUb2tlbiA9IHRoaXMuZmV0Y2goKSkudGV4dCAhPT0gIkVPRiIpIHsKICAgICAgc3RyICs9IG5leHRUb2tlbi50ZXh0OwogICAgICB0aGlzLmNvbnN1bWUoKTsKICAgIH0KICAgIHRoaXMuY29uc3VtZSgpOwogICAgYXJnVG9rZW4udGV4dCA9IHN0cjsKICAgIHJldHVybiBhcmdUb2tlbjsKICB9CiAgLyoqCiAgICogUGFyc2VzIGEgcmVnZXgtZGVsaW1pdGVkIGdyb3VwOiB0aGUgbGFyZ2VzdCBzZXF1ZW5jZSBvZiB0b2tlbnMKICAgKiB3aG9zZSBjb25jYXRlbmF0ZWQgc3RyaW5ncyBtYXRjaCBgcmVnZXhgLiBSZXR1cm5zIHRoZSBzdHJpbmcKICAgKiBmb3JtZWQgYnkgdGhlIHRva2VucyBwbHVzIHNvbWUgcG9zaXRpb24gaW5mb3JtYXRpb24uCiAgICovCiAgcGFyc2VSZWdleEdyb3VwKHJlZ2V4LCBtb2RlTmFtZSkgewogICAgdmFyIGZpcnN0VG9rZW4gPSB0aGlzLmZldGNoKCk7CiAgICB2YXIgbGFzdFRva2VuID0gZmlyc3RUb2tlbjsKICAgIHZhciBzdHIgPSAiIjsKICAgIHZhciBuZXh0VG9rZW47CiAgICB3aGlsZSAoKG5leHRUb2tlbiA9IHRoaXMuZmV0Y2goKSkudGV4dCAhPT0gIkVPRiIgJiYgcmVnZXgudGVzdChzdHIgKyBuZXh0VG9rZW4udGV4dCkpIHsKICAgICAgbGFzdFRva2VuID0gbmV4dFRva2VuOwogICAgICBzdHIgKz0gbGFzdFRva2VuLnRleHQ7CiAgICAgIHRoaXMuY29uc3VtZSgpOwogICAgfQogICAgaWYgKHN0ciA9PT0gIiIpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkludmFsaWQgIiArIG1vZGVOYW1lICsgIjogJyIgKyBmaXJzdFRva2VuLnRleHQgKyAiJyIsIGZpcnN0VG9rZW4pOwogICAgfQogICAgcmV0dXJuIGZpcnN0VG9rZW4ucmFuZ2UobGFzdFRva2VuLCBzdHIpOwogIH0KICAvKioKICAgKiBQYXJzZXMgYSBjb2xvciBkZXNjcmlwdGlvbi4KICAgKi8KICBwYXJzZUNvbG9yR3JvdXAob3B0aW9uYWwpIHsKICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoImNvbG9yIiwgb3B0aW9uYWwpOwogICAgaWYgKHJlcyA9PSBudWxsKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgdmFyIG1hdGNoID0gL14oI1thLWYwLTldezN9fCM/W2EtZjAtOV17Nn18W2Etel0rKSQvaS5leGVjKHJlcy50ZXh0KTsKICAgIGlmICghbWF0Y2gpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkludmFsaWQgY29sb3I6ICciICsgcmVzLnRleHQgKyAiJyIsIHJlcyk7CiAgICB9CiAgICB2YXIgY29sb3IgPSBtYXRjaFswXTsKICAgIGlmICgvXlswLTlhLWZdezZ9JC9pLnRlc3QoY29sb3IpKSB7CiAgICAgIGNvbG9yID0gIiMiICsgY29sb3I7CiAgICB9CiAgICByZXR1cm4gewogICAgICB0eXBlOiAiY29sb3ItdG9rZW4iLAogICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgIGNvbG9yCiAgICB9OwogIH0KICAvKioKICAgKiBQYXJzZXMgYSBzaXplIHNwZWNpZmljYXRpb24sIGNvbnNpc3Rpbmcgb2YgbWFnbml0dWRlIGFuZCB1bml0LgogICAqLwogIHBhcnNlU2l6ZUdyb3VwKG9wdGlvbmFsKSB7CiAgICB2YXIgcmVzOwogICAgdmFyIGlzQmxhbmsgPSBmYWxzZTsKICAgIHRoaXMuZ3VsbGV0LmNvbnN1bWVTcGFjZXMoKTsKICAgIGlmICghb3B0aW9uYWwgJiYgdGhpcy5ndWxsZXQuZnV0dXJlKCkudGV4dCAhPT0gInsiKSB7CiAgICAgIHJlcyA9IHRoaXMucGFyc2VSZWdleEdyb3VwKC9eWy0rXT8gKig/OiR8XGQrfFxkK1wuXGQqfFwuXGQqKSAqW2Etel17MCwyfSAqJC8sICJzaXplIik7CiAgICB9IGVsc2UgewogICAgICByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoInNpemUiLCBvcHRpb25hbCk7CiAgICB9CiAgICBpZiAoIXJlcykgewogICAgICByZXR1cm4gbnVsbDsKICAgIH0KICAgIGlmICghb3B0aW9uYWwgJiYgcmVzLnRleHQubGVuZ3RoID09PSAwKSB7CiAgICAgIHJlcy50ZXh0ID0gIjBwdCI7CiAgICAgIGlzQmxhbmsgPSB0cnVlOwogICAgfQogICAgdmFyIG1hdGNoID0gLyhbLStdPykgKihcZCsoPzpcLlxkKik/fFwuXGQrKSAqKFthLXpdezJ9KS8uZXhlYyhyZXMudGV4dCk7CiAgICBpZiAoIW1hdGNoKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIHNpemU6ICciICsgcmVzLnRleHQgKyAiJyIsIHJlcyk7CiAgICB9CiAgICB2YXIgZGF0YSA9IHsKICAgICAgbnVtYmVyOiArKG1hdGNoWzFdICsgbWF0Y2hbMl0pLAogICAgICAvLyBzaWduICsgbWFnbml0dWRlLCBjYXN0IHRvIG51bWJlcgogICAgICB1bml0OiBtYXRjaFszXQogICAgfTsKICAgIGlmICghdmFsaWRVbml0KGRhdGEpKSB7CiAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJJbnZhbGlkIHVuaXQ6ICciICsgZGF0YS51bml0ICsgIiciLCByZXMpOwogICAgfQogICAgcmV0dXJuIHsKICAgICAgdHlwZTogInNpemUiLAogICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgIHZhbHVlOiBkYXRhLAogICAgICBpc0JsYW5rCiAgICB9OwogIH0KICAvKioKICAgKiBQYXJzZXMgYW4gVVJMLCBjaGVja2luZyBlc2NhcGVkIGxldHRlcnMgYW5kIGFsbG93ZWQgcHJvdG9jb2xzLAogICAqIGFuZCBzZXR0aW5nIHRoZSBjYXRjb2RlIG9mICUgYXMgYW4gYWN0aXZlIGNoYXJhY3RlciAoYXMgaW4gXGh5cGVycmVmKS4KICAgKi8KICBwYXJzZVVybEdyb3VwKG9wdGlvbmFsKSB7CiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKCIlIiwgMTMpOwogICAgdGhpcy5ndWxsZXQubGV4ZXIuc2V0Q2F0Y29kZSgifiIsIDEyKTsKICAgIHZhciByZXMgPSB0aGlzLnBhcnNlU3RyaW5nR3JvdXAoInVybCIsIG9wdGlvbmFsKTsKICAgIHRoaXMuZ3VsbGV0LmxleGVyLnNldENhdGNvZGUoIiUiLCAxNCk7CiAgICB0aGlzLmd1bGxldC5sZXhlci5zZXRDYXRjb2RlKCJ+IiwgMTMpOwogICAgaWYgKHJlcyA9PSBudWxsKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgdmFyIHVybCA9IHJlcy50ZXh0LnJlcGxhY2UoL1xcKFsjJCUmfl9ee31dKS9nLCAiJDEiKTsKICAgIHJldHVybiB7CiAgICAgIHR5cGU6ICJ1cmwiLAogICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgIHVybAogICAgfTsKICB9CiAgLyoqCiAgICogUGFyc2VzIGFuIGFyZ3VtZW50IHdpdGggdGhlIG1vZGUgc3BlY2lmaWVkLgogICAqLwogIHBhcnNlQXJndW1lbnRHcm91cChvcHRpb25hbCwgbW9kZSkgewogICAgdmFyIGFyZ1Rva2VuID0gdGhpcy5ndWxsZXQuc2NhbkFyZ3VtZW50KG9wdGlvbmFsKTsKICAgIGlmIChhcmdUb2tlbiA9PSBudWxsKSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgdmFyIG91dGVyTW9kZSA9IHRoaXMubW9kZTsKICAgIGlmIChtb2RlKSB7CiAgICAgIHRoaXMuc3dpdGNoTW9kZShtb2RlKTsKICAgIH0KICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTsKICAgIHZhciBleHByZXNzaW9uID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oZmFsc2UsICJFT0YiKTsKICAgIHRoaXMuZXhwZWN0KCJFT0YiKTsKICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7CiAgICB2YXIgcmVzdWx0ID0gewogICAgICB0eXBlOiAib3JkZ3JvdXAiLAogICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgIGxvYzogYXJnVG9rZW4ubG9jLAogICAgICBib2R5OiBleHByZXNzaW9uCiAgICB9OwogICAgaWYgKG1vZGUpIHsKICAgICAgdGhpcy5zd2l0Y2hNb2RlKG91dGVyTW9kZSk7CiAgICB9CiAgICByZXR1cm4gcmVzdWx0OwogIH0KICAvKioKICAgKiBQYXJzZXMgYW4gb3JkaW5hcnkgZ3JvdXAsIHdoaWNoIGlzIGVpdGhlciBhIHNpbmdsZSBudWNsZXVzIChsaWtlICJ4IikKICAgKiBvciBhbiBleHByZXNzaW9uIGluIGJyYWNlcyAobGlrZSAie3greX0iKSBvciBhbiBpbXBsaWNpdCBncm91cCwgYSBncm91cAogICAqIHRoYXQgc3RhcnRzIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLCBhbmQgZW5kcyByaWdodCBiZWZvcmUgYSBoaWdoZXIgZXhwbGljaXQKICAgKiBncm91cCBlbmRzLCBvciBhdCBFT0YuCiAgICovCiAgcGFyc2VHcm91cChuYW1lLCBicmVha09uVG9rZW5UZXh0KSB7CiAgICB2YXIgZmlyc3RUb2tlbiA9IHRoaXMuZmV0Y2goKTsKICAgIHZhciB0ZXh0MiA9IGZpcnN0VG9rZW4udGV4dDsKICAgIHZhciByZXN1bHQ7CiAgICBpZiAodGV4dDIgPT09ICJ7IiB8fCB0ZXh0MiA9PT0gIlxcYmVnaW5ncm91cCIpIHsKICAgICAgdGhpcy5jb25zdW1lKCk7CiAgICAgIHZhciBncm91cEVuZCA9IHRleHQyID09PSAieyIgPyAifSIgOiAiXFxlbmRncm91cCI7CiAgICAgIHRoaXMuZ3VsbGV0LmJlZ2luR3JvdXAoKTsKICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnBhcnNlRXhwcmVzc2lvbihmYWxzZSwgZ3JvdXBFbmQpOwogICAgICB2YXIgbGFzdFRva2VuID0gdGhpcy5mZXRjaCgpOwogICAgICB0aGlzLmV4cGVjdChncm91cEVuZCk7CiAgICAgIHRoaXMuZ3VsbGV0LmVuZEdyb3VwKCk7CiAgICAgIHJlc3VsdCA9IHsKICAgICAgICB0eXBlOiAib3JkZ3JvdXAiLAogICAgICAgIG1vZGU6IHRoaXMubW9kZSwKICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGZpcnN0VG9rZW4sIGxhc3RUb2tlbiksCiAgICAgICAgYm9keTogZXhwcmVzc2lvbiwKICAgICAgICAvLyBBIGdyb3VwIGZvcm1lZCBieSBcYmVnaW5ncm91cC4uLlxlbmRncm91cCBpcyBhIHNlbWktc2ltcGxlIGdyb3VwCiAgICAgICAgLy8gd2hpY2ggZG9lc24ndCBhZmZlY3Qgc3BhY2luZyBpbiBtYXRoIG1vZGUsIGkuZS4sIGlzIHRyYW5zcGFyZW50LgogICAgICAgIC8vIGh0dHBzOi8vdGV4LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xOTMwL3doZW4tc2hvdWxkLW9uZS0KICAgICAgICAvLyB1c2UtYmVnaW5ncm91cC1pbnN0ZWFkLW9mLWJncm91cAogICAgICAgIHNlbWlzaW1wbGU6IHRleHQyID09PSAiXFxiZWdpbmdyb3VwIiB8fCB2b2lkIDAKICAgICAgfTsKICAgIH0gZWxzZSB7CiAgICAgIHJlc3VsdCA9IHRoaXMucGFyc2VGdW5jdGlvbihicmVha09uVG9rZW5UZXh0LCBuYW1lKSB8fCB0aGlzLnBhcnNlU3ltYm9sKCk7CiAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCAmJiB0ZXh0MlswXSA9PT0gIlxcIiAmJiAhaW1wbGljaXRDb21tYW5kcy5oYXNPd25Qcm9wZXJ0eSh0ZXh0MikpIHsKICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy50aHJvd09uRXJyb3IpIHsKICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJVbmRlZmluZWQgY29udHJvbCBzZXF1ZW5jZTogIiArIHRleHQyLCBmaXJzdFRva2VuKTsKICAgICAgICB9CiAgICAgICAgcmVzdWx0ID0gdGhpcy5mb3JtYXRVbnN1cHBvcnRlZENtZCh0ZXh0Mik7CiAgICAgICAgdGhpcy5jb25zdW1lKCk7CiAgICAgIH0KICAgIH0KICAgIHJldHVybiByZXN1bHQ7CiAgfQogIC8qKgogICAqIEZvcm0gbGlnYXR1cmUtbGlrZSBjb21iaW5hdGlvbnMgb2YgY2hhcmFjdGVycyBmb3IgdGV4dCBtb2RlLgogICAqIFRoaXMgaW5jbHVkZXMgaW5wdXRzIGxpa2UgIi0tIiwgIi0tLSIsICJgYCIgYW5kICInJyIuCiAgICogVGhlIHJlc3VsdCB3aWxsIHNpbXBseSByZXBsYWNlIG11bHRpcGxlIHRleHRvcmQgbm9kZXMgd2l0aCBhIHNpbmdsZQogICAqIGNoYXJhY3RlciBpbiBlYWNoIHZhbHVlIGJ5IGEgc2luZ2xlIHRleHRvcmQgbm9kZSBoYXZpbmcgbXVsdGlwbGUKICAgKiBjaGFyYWN0ZXJzIGluIGl0cyB2YWx1ZS4gIFRoZSByZXByZXNlbnRhdGlvbiBpcyBzdGlsbCBBU0NJSSBzb3VyY2UuCiAgICogVGhlIGdyb3VwIHdpbGwgYmUgbW9kaWZpZWQgaW4gcGxhY2UuCiAgICovCiAgZm9ybUxpZ2F0dXJlcyhncm91cCkgewogICAgdmFyIG4gPSBncm91cC5sZW5ndGggLSAxOwogICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpIHsKICAgICAgdmFyIGEgPSBncm91cFtpXTsKICAgICAgdmFyIHYgPSBhLnRleHQ7CiAgICAgIGlmICh2ID09PSAiLSIgJiYgZ3JvdXBbaSArIDFdLnRleHQgPT09ICItIikgewogICAgICAgIGlmIChpICsgMSA8IG4gJiYgZ3JvdXBbaSArIDJdLnRleHQgPT09ICItIikgewogICAgICAgICAgZ3JvdXAuc3BsaWNlKGksIDMsIHsKICAgICAgICAgICAgdHlwZTogInRleHRvcmQiLAogICAgICAgICAgICBtb2RlOiAidGV4dCIsCiAgICAgICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UoYSwgZ3JvdXBbaSArIDJdKSwKICAgICAgICAgICAgdGV4dDogIi0tLSIKICAgICAgICAgIH0pOwogICAgICAgICAgbiAtPSAyOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBncm91cC5zcGxpY2UoaSwgMiwgewogICAgICAgICAgICB0eXBlOiAidGV4dG9yZCIsCiAgICAgICAgICAgIG1vZGU6ICJ0ZXh0IiwKICAgICAgICAgICAgbG9jOiBTb3VyY2VMb2NhdGlvbi5yYW5nZShhLCBncm91cFtpICsgMV0pLAogICAgICAgICAgICB0ZXh0OiAiLS0iCiAgICAgICAgICB9KTsKICAgICAgICAgIG4gLT0gMTsKICAgICAgICB9CiAgICAgIH0KICAgICAgaWYgKCh2ID09PSAiJyIgfHwgdiA9PT0gImAiKSAmJiBncm91cFtpICsgMV0udGV4dCA9PT0gdikgewogICAgICAgIGdyb3VwLnNwbGljZShpLCAyLCB7CiAgICAgICAgICB0eXBlOiAidGV4dG9yZCIsCiAgICAgICAgICBtb2RlOiAidGV4dCIsCiAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKGEsIGdyb3VwW2kgKyAxXSksCiAgICAgICAgICB0ZXh0OiB2ICsgdgogICAgICAgIH0pOwogICAgICAgIG4gLT0gMTsKICAgICAgfQogICAgfQogIH0KICAvKioKICAgKiBQYXJzZSBhIHNpbmdsZSBzeW1ib2wgb3V0IG9mIHRoZSBzdHJpbmcuIEhlcmUsIHdlIGhhbmRsZSBzaW5nbGUgY2hhcmFjdGVyCiAgICogc3ltYm9scyBhbmQgc3BlY2lhbCBmdW5jdGlvbnMgbGlrZSBcdmVyYi4KICAgKi8KICBwYXJzZVN5bWJvbCgpIHsKICAgIHZhciBudWNsZXVzID0gdGhpcy5mZXRjaCgpOwogICAgdmFyIHRleHQyID0gbnVjbGV1cy50ZXh0OwogICAgaWYgKC9eXFx2ZXJiW15hLXpBLVpdLy50ZXN0KHRleHQyKSkgewogICAgICB0aGlzLmNvbnN1bWUoKTsKICAgICAgdmFyIGFyZyA9IHRleHQyLnNsaWNlKDUpOwogICAgICB2YXIgc3RhciA9IGFyZy5jaGFyQXQoMCkgPT09ICIqIjsKICAgICAgaWYgKHN0YXIpIHsKICAgICAgICBhcmcgPSBhcmcuc2xpY2UoMSk7CiAgICAgIH0KICAgICAgaWYgKGFyZy5sZW5ndGggPCAyIHx8IGFyZy5jaGFyQXQoMCkgIT09IGFyZy5zbGljZSgtMSkpIHsKICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcigiXFx2ZXJiIGFzc2VydGlvbiBmYWlsZWQgLS1cbiAgICAgICAgICAgICAgICAgICAgcGxlYXNlIHJlcG9ydCB3aGF0IGlucHV0IGNhdXNlZCB0aGlzIGJ1ZyIpOwogICAgICB9CiAgICAgIGFyZyA9IGFyZy5zbGljZSgxLCAtMSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgdHlwZTogInZlcmIiLAogICAgICAgIG1vZGU6ICJ0ZXh0IiwKICAgICAgICBib2R5OiBhcmcsCiAgICAgICAgc3RhcgogICAgICB9OwogICAgfQogICAgaWYgKHVuaWNvZGVTeW1ib2xzLmhhc093blByb3BlcnR5KHRleHQyWzBdKSAmJiAhc3ltYm9sc1t0aGlzLm1vZGVdW3RleHQyWzBdXSkgewogICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSAibWF0aCIpIHsKICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdCgidW5pY29kZVRleHRJbk1hdGhNb2RlIiwgJ0FjY2VudGVkIFVuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgIicgKyB0ZXh0MlswXSArICciIHVzZWQgaW4gbWF0aCBtb2RlJywgbnVjbGV1cyk7CiAgICAgIH0KICAgICAgdGV4dDIgPSB1bmljb2RlU3ltYm9sc1t0ZXh0MlswXV0gKyB0ZXh0Mi5zbGljZSgxKTsKICAgIH0KICAgIHZhciBtYXRjaCA9IGNvbWJpbmluZ0RpYWNyaXRpY2FsTWFya3NFbmRSZWdleC5leGVjKHRleHQyKTsKICAgIGlmIChtYXRjaCkgewogICAgICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7CiAgICAgIGlmICh0ZXh0MiA9PT0gImkiKSB7CiAgICAgICAgdGV4dDIgPSAixLEiOwogICAgICB9IGVsc2UgaWYgKHRleHQyID09PSAiaiIpIHsKICAgICAgICB0ZXh0MiA9ICLItyI7CiAgICAgIH0KICAgIH0KICAgIHZhciBzeW1ib2w7CiAgICBpZiAoc3ltYm9sc1t0aGlzLm1vZGVdW3RleHQyXSkgewogICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QgJiYgdGhpcy5tb2RlID09PSAibWF0aCIgJiYgZXh0cmFMYXRpbi5pbmRleE9mKHRleHQyKSA+PSAwKSB7CiAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoInVuaWNvZGVUZXh0SW5NYXRoTW9kZSIsICdMYXRpbi0xL1VuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgIicgKyB0ZXh0MlswXSArICciIHVzZWQgaW4gbWF0aCBtb2RlJywgbnVjbGV1cyk7CiAgICAgIH0KICAgICAgdmFyIGdyb3VwID0gc3ltYm9sc1t0aGlzLm1vZGVdW3RleHQyXS5ncm91cDsKICAgICAgdmFyIGxvYyA9IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpOwogICAgICB2YXIgczsKICAgICAgaWYgKEFUT01TLmhhc093blByb3BlcnR5KGdyb3VwKSkgewogICAgICAgIHZhciBmYW1pbHkgPSBncm91cDsKICAgICAgICBzID0gewogICAgICAgICAgdHlwZTogImF0b20iLAogICAgICAgICAgbW9kZTogdGhpcy5tb2RlLAogICAgICAgICAgZmFtaWx5LAogICAgICAgICAgbG9jLAogICAgICAgICAgdGV4dDogdGV4dDIKICAgICAgICB9OwogICAgICB9IGVsc2UgewogICAgICAgIHMgPSB7CiAgICAgICAgICB0eXBlOiBncm91cCwKICAgICAgICAgIG1vZGU6IHRoaXMubW9kZSwKICAgICAgICAgIGxvYywKICAgICAgICAgIHRleHQ6IHRleHQyCiAgICAgICAgfTsKICAgICAgfQogICAgICBzeW1ib2wgPSBzOwogICAgfSBlbHNlIGlmICh0ZXh0Mi5jaGFyQ29kZUF0KDApID49IDEyOCkgewogICAgICBpZiAodGhpcy5zZXR0aW5ncy5zdHJpY3QpIHsKICAgICAgICBpZiAoIXN1cHBvcnRlZENvZGVwb2ludCh0ZXh0Mi5jaGFyQ29kZUF0KDApKSkgewogICAgICAgICAgdGhpcy5zZXR0aW5ncy5yZXBvcnROb25zdHJpY3QoInVua25vd25TeW1ib2wiLCAnVW5yZWNvZ25pemVkIFVuaWNvZGUgY2hhcmFjdGVyICInICsgdGV4dDJbMF0gKyAnIicgKyAoIiAoIiArIHRleHQyLmNoYXJDb2RlQXQoMCkgKyAiKSIpLCBudWNsZXVzKTsKICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gIm1hdGgiKSB7CiAgICAgICAgICB0aGlzLnNldHRpbmdzLnJlcG9ydE5vbnN0cmljdCgidW5pY29kZVRleHRJbk1hdGhNb2RlIiwgJ1VuaWNvZGUgdGV4dCBjaGFyYWN0ZXIgIicgKyB0ZXh0MlswXSArICciIHVzZWQgaW4gbWF0aCBtb2RlJywgbnVjbGV1cyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHN5bWJvbCA9IHsKICAgICAgICB0eXBlOiAidGV4dG9yZCIsCiAgICAgICAgbW9kZTogInRleHQiLAogICAgICAgIGxvYzogU291cmNlTG9jYXRpb24ucmFuZ2UobnVjbGV1cyksCiAgICAgICAgdGV4dDogdGV4dDIKICAgICAgfTsKICAgIH0gZWxzZSB7CiAgICAgIHJldHVybiBudWxsOwogICAgfQogICAgdGhpcy5jb25zdW1lKCk7CiAgICBpZiAobWF0Y2gpIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXRjaFswXS5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBhY2NlbnQyID0gbWF0Y2hbMF1baV07CiAgICAgICAgaWYgKCF1bmljb2RlQWNjZW50c1thY2NlbnQyXSkgewogICAgICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlVua25vd24gYWNjZW50ICcgIiArIGFjY2VudDIgKyAiJyIsIG51Y2xldXMpOwogICAgICAgIH0KICAgICAgICB2YXIgY29tbWFuZCA9IHVuaWNvZGVBY2NlbnRzW2FjY2VudDJdW3RoaXMubW9kZV0gfHwgdW5pY29kZUFjY2VudHNbYWNjZW50Ml0udGV4dDsKICAgICAgICBpZiAoIWNvbW1hbmQpIHsKICAgICAgICAgIHRocm93IG5ldyBQYXJzZUVycm9yKCJBY2NlbnQgIiArIGFjY2VudDIgKyAiIHVuc3VwcG9ydGVkIGluICIgKyB0aGlzLm1vZGUgKyAiIG1vZGUiLCBudWNsZXVzKTsKICAgICAgICB9CiAgICAgICAgc3ltYm9sID0gewogICAgICAgICAgdHlwZTogImFjY2VudCIsCiAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsCiAgICAgICAgICBsb2M6IFNvdXJjZUxvY2F0aW9uLnJhbmdlKG51Y2xldXMpLAogICAgICAgICAgbGFiZWw6IGNvbW1hbmQsCiAgICAgICAgICBpc1N0cmV0Y2h5OiBmYWxzZSwKICAgICAgICAgIGlzU2hpZnR5OiB0cnVlLAogICAgICAgICAgLy8gJEZsb3dGaXhNZQogICAgICAgICAgYmFzZTogc3ltYm9sCiAgICAgICAgfTsKICAgICAgfQogICAgfQogICAgcmV0dXJuIHN5bWJvbDsKICB9Cn07ClBhcnNlci5lbmRPZkV4cHJlc3Npb24gPSBbIn0iLCAiXFxlbmRncm91cCIsICJcXGVuZCIsICJcXHJpZ2h0IiwgIiYiXTsKdmFyIHBhcnNlVHJlZSA9IGZ1bmN0aW9uIHBhcnNlVHJlZTIodG9QYXJzZSwgc2V0dGluZ3MpIHsKICBpZiAoISh0eXBlb2YgdG9QYXJzZSA9PT0gInN0cmluZyIgfHwgdG9QYXJzZSBpbnN0YW5jZW9mIFN0cmluZykpIHsKICAgIHRocm93IG5ldyBUeXBlRXJyb3IoIkthVGVYIGNhbiBvbmx5IHBhcnNlIHN0cmluZyB0eXBlZCBleHByZXNzaW9uIik7CiAgfQogIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKHRvUGFyc2UsIHNldHRpbmdzKTsKICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFsiXFxkZkB0YWciXTsKICB2YXIgdHJlZSA9IHBhcnNlci5wYXJzZSgpOwogIGRlbGV0ZSBwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5jdXJyZW50WyJcXGN1cnJlbnRAY29sb3IiXTsKICBkZWxldGUgcGFyc2VyLmd1bGxldC5tYWNyb3MuY3VycmVudFsiXFxjb2xvciJdOwogIGlmIChwYXJzZXIuZ3VsbGV0Lm1hY3Jvcy5nZXQoIlxcZGZAdGFnIikpIHsKICAgIGlmICghc2V0dGluZ3MuZGlzcGxheU1vZGUpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIlxcdGFnIHdvcmtzIG9ubHkgaW4gZGlzcGxheSBlcXVhdGlvbnMiKTsKICAgIH0KICAgIHRyZWUgPSBbewogICAgICB0eXBlOiAidGFnIiwKICAgICAgbW9kZTogInRleHQiLAogICAgICBib2R5OiB0cmVlLAogICAgICB0YWc6IHBhcnNlci5zdWJwYXJzZShbbmV3IFRva2VuKCJcXGRmQHRhZyIpXSkKICAgIH1dOwogIH0KICByZXR1cm4gdHJlZTsKfTsKdmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcjIoZXhwcmVzc2lvbiwgYmFzZU5vZGUsIG9wdGlvbnMpIHsKICBiYXNlTm9kZS50ZXh0Q29udGVudCA9ICIiOwogIHZhciBub2RlID0gcmVuZGVyVG9Eb21UcmVlKGV4cHJlc3Npb24sIG9wdGlvbnMpLnRvTm9kZSgpOwogIGJhc2VOb2RlLmFwcGVuZENoaWxkKG5vZGUpOwp9OwppZiAodHlwZW9mIGRvY3VtZW50ICE9PSAidW5kZWZpbmVkIikgewogIGlmIChkb2N1bWVudC5jb21wYXRNb2RlICE9PSAiQ1NTMUNvbXBhdCIpIHsKICAgIHR5cGVvZiBjb25zb2xlICE9PSAidW5kZWZpbmVkIiAmJiBjb25zb2xlLndhcm4oIldhcm5pbmc6IEthVGVYIGRvZXNuJ3Qgd29yayBpbiBxdWlya3MgbW9kZS4gTWFrZSBzdXJlIHlvdXIgd2Vic2l0ZSBoYXMgYSBzdWl0YWJsZSBkb2N0eXBlLiIpOwogICAgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyMygpIHsKICAgICAgdGhyb3cgbmV3IFBhcnNlRXJyb3IoIkthVGVYIGRvZXNuJ3Qgd29yayBpbiBxdWlya3MgbW9kZS4iKTsKICAgIH07CiAgfQp9CnZhciByZW5kZXJUb1N0cmluZyA9IGZ1bmN0aW9uIHJlbmRlclRvU3RyaW5nMihleHByZXNzaW9uLCBvcHRpb25zKSB7CiAgdmFyIG1hcmt1cCA9IHJlbmRlclRvRG9tVHJlZShleHByZXNzaW9uLCBvcHRpb25zKS50b01hcmt1cCgpOwogIHJldHVybiBtYXJrdXA7Cn07CnZhciBnZW5lcmF0ZVBhcnNlVHJlZSA9IGZ1bmN0aW9uIGdlbmVyYXRlUGFyc2VUcmVlMihleHByZXNzaW9uLCBvcHRpb25zKSB7CiAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpOwogIHJldHVybiBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpOwp9Owp2YXIgcmVuZGVyRXJyb3IgPSBmdW5jdGlvbiByZW5kZXJFcnJvcjIoZXJyb3IsIGV4cHJlc3Npb24sIG9wdGlvbnMpIHsKICBpZiAob3B0aW9ucy50aHJvd09uRXJyb3IgfHwgIShlcnJvciBpbnN0YW5jZW9mIFBhcnNlRXJyb3IpKSB7CiAgICB0aHJvdyBlcnJvcjsKICB9CiAgdmFyIG5vZGUgPSBidWlsZENvbW1vbi5tYWtlU3BhbihbImthdGV4LWVycm9yIl0sIFtuZXcgU3ltYm9sTm9kZShleHByZXNzaW9uKV0pOwogIG5vZGUuc2V0QXR0cmlidXRlKCJ0aXRsZSIsIGVycm9yLnRvU3RyaW5nKCkpOwogIG5vZGUuc2V0QXR0cmlidXRlKCJzdHlsZSIsICJjb2xvcjoiICsgb3B0aW9ucy5lcnJvckNvbG9yKTsKICByZXR1cm4gbm9kZTsKfTsKdmFyIHJlbmRlclRvRG9tVHJlZSA9IGZ1bmN0aW9uIHJlbmRlclRvRG9tVHJlZTIoZXhwcmVzc2lvbiwgb3B0aW9ucykgewogIHZhciBzZXR0aW5ncyA9IG5ldyBTZXR0aW5ncyhvcHRpb25zKTsKICB0cnkgewogICAgdmFyIHRyZWUgPSBwYXJzZVRyZWUoZXhwcmVzc2lvbiwgc2V0dGluZ3MpOwogICAgcmV0dXJuIGJ1aWxkVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7CiAgfSBjYXRjaCAoZXJyb3IpIHsKICAgIHJldHVybiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpOwogIH0KfTsKdmFyIHJlbmRlclRvSFRNTFRyZWUgPSBmdW5jdGlvbiByZW5kZXJUb0hUTUxUcmVlMihleHByZXNzaW9uLCBvcHRpb25zKSB7CiAgdmFyIHNldHRpbmdzID0gbmV3IFNldHRpbmdzKG9wdGlvbnMpOwogIHRyeSB7CiAgICB2YXIgdHJlZSA9IHBhcnNlVHJlZShleHByZXNzaW9uLCBzZXR0aW5ncyk7CiAgICByZXR1cm4gYnVpbGRIVE1MVHJlZSh0cmVlLCBleHByZXNzaW9uLCBzZXR0aW5ncyk7CiAgfSBjYXRjaCAoZXJyb3IpIHsKICAgIHJldHVybiByZW5kZXJFcnJvcihlcnJvciwgZXhwcmVzc2lvbiwgc2V0dGluZ3MpOwogIH0KfTsKdmFyIHZlcnNpb24gPSAiMC4xNi4yMiI7CnZhciBfX2RvbVRyZWUgPSB7CiAgU3BhbiwKICBBbmNob3IsCiAgU3ltYm9sTm9kZSwKICBTdmdOb2RlLAogIFBhdGhOb2RlLAogIExpbmVOb2RlCn07CnZhciBrYXRleCA9IHsKICAvKioKICAgKiBDdXJyZW50IEthVGVYIHZlcnNpb24KICAgKi8KICB2ZXJzaW9uLAogIC8qKgogICAqIFJlbmRlcnMgdGhlIGdpdmVuIExhVGVYIGludG8gYW4gSFRNTCtNYXRoTUwgY29tYmluYXRpb24sIGFuZCBhZGRzCiAgICogaXQgYXMgYSBjaGlsZCB0byB0aGUgc3BlY2lmaWVkIERPTSBub2RlLgogICAqLwogIHJlbmRlciwKICAvKioKICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGNvbWJpbmF0aW9uIHN0cmluZywKICAgKiBmb3Igc2VuZGluZyB0byB0aGUgY2xpZW50LgogICAqLwogIHJlbmRlclRvU3RyaW5nLAogIC8qKgogICAqIEthVGVYIGVycm9yLCB1c3VhbGx5IGR1cmluZyBwYXJzaW5nLgogICAqLwogIFBhcnNlRXJyb3IsCiAgLyoqCiAgICogVGhlIHNjaGVtYSBvZiBTZXR0aW5ncwogICAqLwogIFNFVFRJTkdTX1NDSEVNQSwKICAvKioKICAgKiBQYXJzZXMgdGhlIGdpdmVuIExhVGVYIGludG8gS2FUZVgncyBpbnRlcm5hbCBwYXJzZSB0cmVlIHN0cnVjdHVyZSwKICAgKiB3aXRob3V0IHJlbmRlcmluZyB0byBIVE1MIG9yIE1hdGhNTC4KICAgKgogICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuCiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5CiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay4KICAgKi8KICBfX3BhcnNlOiBnZW5lcmF0ZVBhcnNlVHJlZSwKICAvKioKICAgKiBSZW5kZXJzIHRoZSBnaXZlbiBMYVRlWCBpbnRvIGFuIEhUTUwrTWF0aE1MIGludGVybmFsIERPTSB0cmVlCiAgICogcmVwcmVzZW50YXRpb24sIHdpdGhvdXQgZmxhdHRlbmluZyB0aGF0IHJlcHJlc2VudGF0aW9uIHRvIGEgc3RyaW5nLgogICAqCiAgICogTk9URTogVGhpcyBtZXRob2QgaXMgbm90IGN1cnJlbnRseSByZWNvbW1lbmRlZCBmb3IgcHVibGljIHVzZS4KICAgKiBUaGUgaW50ZXJuYWwgdHJlZSByZXByZXNlbnRhdGlvbiBpcyB1bnN0YWJsZSBhbmQgaXMgdmVyeSBsaWtlbHkKICAgKiB0byBjaGFuZ2UuIFVzZSBhdCB5b3VyIG93biByaXNrLgogICAqLwogIF9fcmVuZGVyVG9Eb21UcmVlOiByZW5kZXJUb0RvbVRyZWUsCiAgLyoqCiAgICogUmVuZGVycyB0aGUgZ2l2ZW4gTGFUZVggaW50byBhbiBIVE1MIGludGVybmFsIERPTSB0cmVlIHJlcHJlc2VudGF0aW9uLAogICAqIHdpdGhvdXQgTWF0aE1MIGFuZCB3aXRob3V0IGZsYXR0ZW5pbmcgdGhhdCByZXByZXNlbnRhdGlvbiB0byBhIHN0cmluZy4KICAgKgogICAqIE5PVEU6IFRoaXMgbWV0aG9kIGlzIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuCiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5CiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay4KICAgKi8KICBfX3JlbmRlclRvSFRNTFRyZWU6IHJlbmRlclRvSFRNTFRyZWUsCiAgLyoqCiAgICogZXh0ZW5kcyBpbnRlcm5hbCBmb250IG1ldHJpY3Mgb2JqZWN0IHdpdGggYSBuZXcgb2JqZWN0CiAgICogZWFjaCBrZXkgaW4gdGhlIG5ldyBvYmplY3QgcmVwcmVzZW50cyBhIGZvbnQgbmFtZQogICovCiAgX19zZXRGb250TWV0cmljczogc2V0Rm9udE1ldHJpY3MsCiAgLyoqCiAgICogYWRkcyBhIG5ldyBzeW1ib2wgdG8gYnVpbHRpbiBzeW1ib2xzIHRhYmxlCiAgICovCiAgX19kZWZpbmVTeW1ib2w6IGRlZmluZVN5bWJvbCwKICAvKioKICAgKiBhZGRzIGEgbmV3IGZ1bmN0aW9uIHRvIGJ1aWx0aW4gZnVuY3Rpb24gbGlzdCwKICAgKiB3aGljaCBkaXJlY3RseSBwcm9kdWNlIHBhcnNlIHRyZWUgZWxlbWVudHMKICAgKiBhbmQgaGF2ZSB0aGVpciBvd24gaHRtbC9tYXRobWwgYnVpbGRlcnMKICAgKi8KICBfX2RlZmluZUZ1bmN0aW9uOiBkZWZpbmVGdW5jdGlvbiwKICAvKioKICAgKiBhZGRzIGEgbmV3IG1hY3JvIHRvIGJ1aWx0aW4gbWFjcm8gbGlzdAogICAqLwogIF9fZGVmaW5lTWFjcm86IGRlZmluZU1hY3JvLAogIC8qKgogICAqIEV4cG9zZSB0aGUgZG9tIHRyZWUgbm9kZSB0eXBlcywgd2hpY2ggY2FuIGJlIHVzZWZ1bCBmb3IgdHlwZSBjaGVja2luZyBub2Rlcy4KICAgKgogICAqIE5PVEU6IFRoZXNlIG1ldGhvZHMgYXJlIG5vdCBjdXJyZW50bHkgcmVjb21tZW5kZWQgZm9yIHB1YmxpYyB1c2UuCiAgICogVGhlIGludGVybmFsIHRyZWUgcmVwcmVzZW50YXRpb24gaXMgdW5zdGFibGUgYW5kIGlzIHZlcnkgbGlrZWx5CiAgICogdG8gY2hhbmdlLiBVc2UgYXQgeW91ciBvd24gcmlzay4KICAgKi8KICBfX2RvbVRyZWUKfTsKCmV4cG9ydCB7CiAga2F0ZXgKfTsKLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2h1bmstRlYySjRISU4uanMubWFwCg==",
            "encoding": "base64"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.746Z",
        "time": 2.370000001974404,
        "timings": {
          "blocked": 0.6790000015117694,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.34299999886378646,
          "receive": 1.348000001598848,
          "_blocked_queueing": 0.6170000015117694,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed",
          "lineNumber": 5
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-Y7LV7UOF.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "631"
            },
            {
              "name": "Etag",
              "value": "W/\"277-Z8rO7OFoY2uDsPT3/d0j/0UCPwU\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 631,
            "mimeType": "text/javascript",
            "text": "// node_modules/longest-streak/index.js\nfunction longestStreak(value, substring) {\n  const source = String(value);\n  let index = source.indexOf(substring);\n  let expected = index;\n  let count = 0;\n  let max = 0;\n  if (typeof substring !== \"string\") {\n    throw new TypeError(\"Expected substring\");\n  }\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count;\n      }\n    } else {\n      count = 1;\n    }\n    expected = index + substring.length;\n    index = source.indexOf(substring, expected);\n  }\n  return max;\n}\n\nexport {\n  longestStreak\n};\n//# sourceMappingURL=chunk-Y7LV7UOF.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.746Z",
        "time": 1.2700000006589107,
        "timings": {
          "blocked": 0.6600000012591482,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.33400000055134293,
          "receive": 0.27599999884841964,
          "_blocked_queueing": 0.6270000012591481,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed",
          "lineNumber": 13
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-EIBGEDEJ.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-math.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "25371"
            },
            {
              "name": "Etag",
              "value": "W/\"631b-L7uLFLb6BvJBBq8MSEUkWoS0Dww\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 25371,
            "mimeType": "text/javascript",
            "text": "import {\n  __publicField\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/devlop/lib/development.js\nvar AssertionError = class extends Error {\n  /**\n   * Create an assertion error.\n   *\n   * @param {string} message\n   *   Message explaining error.\n   * @param {unknown} actual\n   *   Value.\n   * @param {unknown} expected\n   *   Baseline.\n   * @param {string} operator\n   *   Name of equality operation.\n   * @param {boolean} generated\n   *   Whether `message` is a custom message or not\n   * @returns\n   *   Instance.\n   */\n  // eslint-disable-next-line max-params\n  constructor(message, actual, expected, operator, generated) {\n    super(message);\n    __publicField(\n      this,\n      \"name\",\n      /** @type {const} */\n      \"Assertion\"\n    );\n    __publicField(\n      this,\n      \"code\",\n      /** @type {const} */\n      \"ERR_ASSERTION\"\n    );\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.actual = actual;\n    this.expected = expected;\n    this.generated = generated;\n    this.operator = operator;\n  }\n};\nfunction ok(value, message) {\n  assert(\n    Boolean(value),\n    false,\n    true,\n    \"ok\",\n    \"Expected value to be truthy\",\n    message\n  );\n}\nfunction unreachable(message) {\n  assert(false, false, true, \"ok\", \"Unreachable\", message);\n}\nfunction assert(bool, actual, expected, operator, defaultMessage, userMessage) {\n  if (!bool) {\n    throw userMessage instanceof Error ? userMessage : new AssertionError(\n      userMessage || defaultMessage,\n      actual,\n      expected,\n      operator,\n      !userMessage\n    );\n  }\n}\n\n// node_modules/micromark-util-symbol/lib/codes.js\nvar codes = (\n  /** @type {const} */\n  {\n    carriageReturn: -5,\n    lineFeed: -4,\n    carriageReturnLineFeed: -3,\n    horizontalTab: -2,\n    virtualSpace: -1,\n    eof: null,\n    nul: 0,\n    soh: 1,\n    stx: 2,\n    etx: 3,\n    eot: 4,\n    enq: 5,\n    ack: 6,\n    bel: 7,\n    bs: 8,\n    ht: 9,\n    // `\\t`\n    lf: 10,\n    // `\\n`\n    vt: 11,\n    // `\\v`\n    ff: 12,\n    // `\\f`\n    cr: 13,\n    // `\\r`\n    so: 14,\n    si: 15,\n    dle: 16,\n    dc1: 17,\n    dc2: 18,\n    dc3: 19,\n    dc4: 20,\n    nak: 21,\n    syn: 22,\n    etb: 23,\n    can: 24,\n    em: 25,\n    sub: 26,\n    esc: 27,\n    fs: 28,\n    gs: 29,\n    rs: 30,\n    us: 31,\n    space: 32,\n    exclamationMark: 33,\n    // `!`\n    quotationMark: 34,\n    // `\"`\n    numberSign: 35,\n    // `#`\n    dollarSign: 36,\n    // `$`\n    percentSign: 37,\n    // `%`\n    ampersand: 38,\n    // `&`\n    apostrophe: 39,\n    // `'`\n    leftParenthesis: 40,\n    // `(`\n    rightParenthesis: 41,\n    // `)`\n    asterisk: 42,\n    // `*`\n    plusSign: 43,\n    // `+`\n    comma: 44,\n    // `,`\n    dash: 45,\n    // `-`\n    dot: 46,\n    // `.`\n    slash: 47,\n    // `/`\n    digit0: 48,\n    // `0`\n    digit1: 49,\n    // `1`\n    digit2: 50,\n    // `2`\n    digit3: 51,\n    // `3`\n    digit4: 52,\n    // `4`\n    digit5: 53,\n    // `5`\n    digit6: 54,\n    // `6`\n    digit7: 55,\n    // `7`\n    digit8: 56,\n    // `8`\n    digit9: 57,\n    // `9`\n    colon: 58,\n    // `:`\n    semicolon: 59,\n    // `;`\n    lessThan: 60,\n    // `<`\n    equalsTo: 61,\n    // `=`\n    greaterThan: 62,\n    // `>`\n    questionMark: 63,\n    // `?`\n    atSign: 64,\n    // `@`\n    uppercaseA: 65,\n    // `A`\n    uppercaseB: 66,\n    // `B`\n    uppercaseC: 67,\n    // `C`\n    uppercaseD: 68,\n    // `D`\n    uppercaseE: 69,\n    // `E`\n    uppercaseF: 70,\n    // `F`\n    uppercaseG: 71,\n    // `G`\n    uppercaseH: 72,\n    // `H`\n    uppercaseI: 73,\n    // `I`\n    uppercaseJ: 74,\n    // `J`\n    uppercaseK: 75,\n    // `K`\n    uppercaseL: 76,\n    // `L`\n    uppercaseM: 77,\n    // `M`\n    uppercaseN: 78,\n    // `N`\n    uppercaseO: 79,\n    // `O`\n    uppercaseP: 80,\n    // `P`\n    uppercaseQ: 81,\n    // `Q`\n    uppercaseR: 82,\n    // `R`\n    uppercaseS: 83,\n    // `S`\n    uppercaseT: 84,\n    // `T`\n    uppercaseU: 85,\n    // `U`\n    uppercaseV: 86,\n    // `V`\n    uppercaseW: 87,\n    // `W`\n    uppercaseX: 88,\n    // `X`\n    uppercaseY: 89,\n    // `Y`\n    uppercaseZ: 90,\n    // `Z`\n    leftSquareBracket: 91,\n    // `[`\n    backslash: 92,\n    // `\\`\n    rightSquareBracket: 93,\n    // `]`\n    caret: 94,\n    // `^`\n    underscore: 95,\n    // `_`\n    graveAccent: 96,\n    // `` ` ``\n    lowercaseA: 97,\n    // `a`\n    lowercaseB: 98,\n    // `b`\n    lowercaseC: 99,\n    // `c`\n    lowercaseD: 100,\n    // `d`\n    lowercaseE: 101,\n    // `e`\n    lowercaseF: 102,\n    // `f`\n    lowercaseG: 103,\n    // `g`\n    lowercaseH: 104,\n    // `h`\n    lowercaseI: 105,\n    // `i`\n    lowercaseJ: 106,\n    // `j`\n    lowercaseK: 107,\n    // `k`\n    lowercaseL: 108,\n    // `l`\n    lowercaseM: 109,\n    // `m`\n    lowercaseN: 110,\n    // `n`\n    lowercaseO: 111,\n    // `o`\n    lowercaseP: 112,\n    // `p`\n    lowercaseQ: 113,\n    // `q`\n    lowercaseR: 114,\n    // `r`\n    lowercaseS: 115,\n    // `s`\n    lowercaseT: 116,\n    // `t`\n    lowercaseU: 117,\n    // `u`\n    lowercaseV: 118,\n    // `v`\n    lowercaseW: 119,\n    // `w`\n    lowercaseX: 120,\n    // `x`\n    lowercaseY: 121,\n    // `y`\n    lowercaseZ: 122,\n    // `z`\n    leftCurlyBrace: 123,\n    // `{`\n    verticalBar: 124,\n    // `|`\n    rightCurlyBrace: 125,\n    // `}`\n    tilde: 126,\n    // `~`\n    del: 127,\n    // Unicode Specials block.\n    byteOrderMarker: 65279,\n    // Unicode Specials block.\n    replacementCharacter: 65533\n    // ``\n  }\n);\n\n// node_modules/micromark-util-symbol/lib/constants.js\nvar constants = (\n  /** @type {const} */\n  {\n    attentionSideAfter: 2,\n    // Symbol to mark an attention sequence as after content: `a*`\n    attentionSideBefore: 1,\n    // Symbol to mark an attention sequence as before content: `*a`\n    atxHeadingOpeningFenceSizeMax: 6,\n    // 6 number signs is fine, 7 isnt.\n    autolinkDomainSizeMax: 63,\n    // 63 characters is fine, 64 is too many.\n    autolinkSchemeSizeMax: 32,\n    // 32 characters is fine, 33 is too many.\n    cdataOpeningString: \"CDATA[\",\n    // And preceded by `<![`.\n    characterGroupPunctuation: 2,\n    // Symbol used to indicate a character is punctuation\n    characterGroupWhitespace: 1,\n    // Symbol used to indicate a character is whitespace\n    characterReferenceDecimalSizeMax: 7,\n    // `&#9999999;`.\n    characterReferenceHexadecimalSizeMax: 6,\n    // `&#xff9999;`.\n    characterReferenceNamedSizeMax: 31,\n    // `&CounterClockwiseContourIntegral;`.\n    codeFencedSequenceSizeMin: 3,\n    // At least 3 ticks or tildes are needed.\n    contentTypeContent: \"content\",\n    contentTypeDocument: \"document\",\n    contentTypeFlow: \"flow\",\n    contentTypeString: \"string\",\n    contentTypeText: \"text\",\n    hardBreakPrefixSizeMin: 2,\n    // At least 2 trailing spaces are needed.\n    htmlBasic: 6,\n    // Symbol for `<div`\n    htmlCdata: 5,\n    // Symbol for `<![CDATA[]]>`\n    htmlComment: 2,\n    // Symbol for `<!---->`\n    htmlComplete: 7,\n    // Symbol for `<x>`\n    htmlDeclaration: 4,\n    // Symbol for `<!doctype>`\n    htmlInstruction: 3,\n    // Symbol for `<?php?>`\n    htmlRawSizeMax: 8,\n    // Length of `textarea`.\n    htmlRaw: 1,\n    // Symbol for `<script>`\n    linkResourceDestinationBalanceMax: 32,\n    // See: <https://spec.commonmark.org/0.30/#link-destination>, <https://github.com/remarkjs/react-markdown/issues/658#issuecomment-984345577>\n    linkReferenceSizeMax: 999,\n    // See: <https://spec.commonmark.org/0.30/#link-label>\n    listItemValueSizeMax: 10,\n    // See: <https://spec.commonmark.org/0.30/#ordered-list-marker>\n    numericBaseDecimal: 10,\n    numericBaseHexadecimal: 16,\n    tabSize: 4,\n    // Tabs have a hard-coded size of 4, per CommonMark.\n    thematicBreakMarkerCountMin: 3,\n    // At least 3 asterisks, dashes, or underscores are needed.\n    v8MaxSafeChunkSize: 1e4\n    // V8 (and potentially others) have problems injecting giant arrays into other arrays, hence we operate in chunks.\n  }\n);\n\n// node_modules/micromark-util-symbol/lib/types.js\nvar types = (\n  /** @type {const} */\n  {\n    // Generic type for data, such as in a title, a destination, etc.\n    data: \"data\",\n    // Generic type for syntactic whitespace (tabs, virtual spaces, spaces).\n    // Such as, between a fenced code fence and an info string.\n    whitespace: \"whitespace\",\n    // Generic type for line endings (line feed, carriage return, carriage return +\n    // line feed).\n    lineEnding: \"lineEnding\",\n    // A line ending, but ending a blank line.\n    lineEndingBlank: \"lineEndingBlank\",\n    // Generic type for whitespace (tabs, virtual spaces, spaces) at the start of a\n    // line.\n    linePrefix: \"linePrefix\",\n    // Generic type for whitespace (tabs, virtual spaces, spaces) at the end of a\n    // line.\n    lineSuffix: \"lineSuffix\",\n    // Whole ATX heading:\n    //\n    // ```markdown\n    // #\n    // ## Alpha\n    // ### Bravo ###\n    // ```\n    //\n    // Includes `atxHeadingSequence`, `whitespace`, `atxHeadingText`.\n    atxHeading: \"atxHeading\",\n    // Sequence of number signs in an ATX heading (`###`).\n    atxHeadingSequence: \"atxHeadingSequence\",\n    // Content in an ATX heading (`alpha`).\n    // Includes text.\n    atxHeadingText: \"atxHeadingText\",\n    // Whole autolink (`<https://example.com>` or `<admin@example.com>`)\n    // Includes `autolinkMarker` and `autolinkProtocol` or `autolinkEmail`.\n    autolink: \"autolink\",\n    // Email autolink w/o markers (`admin@example.com`)\n    autolinkEmail: \"autolinkEmail\",\n    // Marker around an `autolinkProtocol` or `autolinkEmail` (`<` or `>`).\n    autolinkMarker: \"autolinkMarker\",\n    // Protocol autolink w/o markers (`https://example.com`)\n    autolinkProtocol: \"autolinkProtocol\",\n    // A whole character escape (`\\-`).\n    // Includes `escapeMarker` and `characterEscapeValue`.\n    characterEscape: \"characterEscape\",\n    // The escaped character (`-`).\n    characterEscapeValue: \"characterEscapeValue\",\n    // A whole character reference (`&amp;`, `&#8800;`, or `&#x1D306;`).\n    // Includes `characterReferenceMarker`, an optional\n    // `characterReferenceMarkerNumeric`, in which case an optional\n    // `characterReferenceMarkerHexadecimal`, and a `characterReferenceValue`.\n    characterReference: \"characterReference\",\n    // The start or end marker (`&` or `;`).\n    characterReferenceMarker: \"characterReferenceMarker\",\n    // Mark reference as numeric (`#`).\n    characterReferenceMarkerNumeric: \"characterReferenceMarkerNumeric\",\n    // Mark reference as numeric (`x` or `X`).\n    characterReferenceMarkerHexadecimal: \"characterReferenceMarkerHexadecimal\",\n    // Value of character reference w/o markers (`amp`, `8800`, or `1D306`).\n    characterReferenceValue: \"characterReferenceValue\",\n    // Whole fenced code:\n    //\n    // ````markdown\n    // ```js\n    // alert(1)\n    // ```\n    // ````\n    codeFenced: \"codeFenced\",\n    // A fenced code fence, including whitespace, sequence, info, and meta\n    // (` ```js `).\n    codeFencedFence: \"codeFencedFence\",\n    // Sequence of grave accent or tilde characters (` ``` `) in a fence.\n    codeFencedFenceSequence: \"codeFencedFenceSequence\",\n    // Info word (`js`) in a fence.\n    // Includes string.\n    codeFencedFenceInfo: \"codeFencedFenceInfo\",\n    // Meta words (`highlight=\"1\"`) in a fence.\n    // Includes string.\n    codeFencedFenceMeta: \"codeFencedFenceMeta\",\n    // A line of code.\n    codeFlowValue: \"codeFlowValue\",\n    // Whole indented code:\n    //\n    // ```markdown\n    //     alert(1)\n    // ```\n    //\n    // Includes `lineEnding`, `linePrefix`, and `codeFlowValue`.\n    codeIndented: \"codeIndented\",\n    // A text code (``` `alpha` ```).\n    // Includes `codeTextSequence`, `codeTextData`, `lineEnding`, and can include\n    // `codeTextPadding`.\n    codeText: \"codeText\",\n    codeTextData: \"codeTextData\",\n    // A space or line ending right after or before a tick.\n    codeTextPadding: \"codeTextPadding\",\n    // A text code fence (` `` `).\n    codeTextSequence: \"codeTextSequence\",\n    // Whole content:\n    //\n    // ```markdown\n    // [a]: b\n    // c\n    // =\n    // d\n    // ```\n    //\n    // Includes `paragraph` and `definition`.\n    content: \"content\",\n    // Whole definition:\n    //\n    // ```markdown\n    // [micromark]: https://github.com/micromark/micromark\n    // ```\n    //\n    // Includes `definitionLabel`, `definitionMarker`, `whitespace`,\n    // `definitionDestination`, and optionally `lineEnding` and `definitionTitle`.\n    definition: \"definition\",\n    // Destination of a definition (`https://github.com/micromark/micromark` or\n    // `<https://github.com/micromark/micromark>`).\n    // Includes `definitionDestinationLiteral` or `definitionDestinationRaw`.\n    definitionDestination: \"definitionDestination\",\n    // Enclosed destination of a definition\n    // (`<https://github.com/micromark/micromark>`).\n    // Includes `definitionDestinationLiteralMarker` and optionally\n    // `definitionDestinationString`.\n    definitionDestinationLiteral: \"definitionDestinationLiteral\",\n    // Markers of an enclosed definition destination (`<` or `>`).\n    definitionDestinationLiteralMarker: \"definitionDestinationLiteralMarker\",\n    // Unenclosed destination of a definition\n    // (`https://github.com/micromark/micromark`).\n    // Includes `definitionDestinationString`.\n    definitionDestinationRaw: \"definitionDestinationRaw\",\n    // Text in an destination (`https://github.com/micromark/micromark`).\n    // Includes string.\n    definitionDestinationString: \"definitionDestinationString\",\n    // Label of a definition (`[micromark]`).\n    // Includes `definitionLabelMarker` and `definitionLabelString`.\n    definitionLabel: \"definitionLabel\",\n    // Markers of a definition label (`[` or `]`).\n    definitionLabelMarker: \"definitionLabelMarker\",\n    // Value of a definition label (`micromark`).\n    // Includes string.\n    definitionLabelString: \"definitionLabelString\",\n    // Marker between a label and a destination (`:`).\n    definitionMarker: \"definitionMarker\",\n    // Title of a definition (`\"x\"`, `'y'`, or `(z)`).\n    // Includes `definitionTitleMarker` and optionally `definitionTitleString`.\n    definitionTitle: \"definitionTitle\",\n    // Marker around a title of a definition (`\"`, `'`, `(`, or `)`).\n    definitionTitleMarker: \"definitionTitleMarker\",\n    // Data without markers in a title (`z`).\n    // Includes string.\n    definitionTitleString: \"definitionTitleString\",\n    // Emphasis (`*alpha*`).\n    // Includes `emphasisSequence` and `emphasisText`.\n    emphasis: \"emphasis\",\n    // Sequence of emphasis markers (`*` or `_`).\n    emphasisSequence: \"emphasisSequence\",\n    // Emphasis text (`alpha`).\n    // Includes text.\n    emphasisText: \"emphasisText\",\n    // The character escape marker (`\\`).\n    escapeMarker: \"escapeMarker\",\n    // A hard break created with a backslash (`\\\\n`).\n    // Note: does not include the line ending.\n    hardBreakEscape: \"hardBreakEscape\",\n    // A hard break created with trailing spaces (`  \\n`).\n    // Does not include the line ending.\n    hardBreakTrailing: \"hardBreakTrailing\",\n    // Flow HTML:\n    //\n    // ```markdown\n    // <div\n    // ```\n    //\n    // Inlcudes `lineEnding`, `htmlFlowData`.\n    htmlFlow: \"htmlFlow\",\n    htmlFlowData: \"htmlFlowData\",\n    // HTML in text (the tag in `a <i> b`).\n    // Includes `lineEnding`, `htmlTextData`.\n    htmlText: \"htmlText\",\n    htmlTextData: \"htmlTextData\",\n    // Whole image (`![alpha](bravo)`, `![alpha][bravo]`, `![alpha][]`, or\n    // `![alpha]`).\n    // Includes `label` and an optional `resource` or `reference`.\n    image: \"image\",\n    // Whole link label (`[*alpha*]`).\n    // Includes `labelLink` or `labelImage`, `labelText`, and `labelEnd`.\n    label: \"label\",\n    // Text in an label (`*alpha*`).\n    // Includes text.\n    labelText: \"labelText\",\n    // Start a link label (`[`).\n    // Includes a `labelMarker`.\n    labelLink: \"labelLink\",\n    // Start an image label (`![`).\n    // Includes `labelImageMarker` and `labelMarker`.\n    labelImage: \"labelImage\",\n    // Marker of a label (`[` or `]`).\n    labelMarker: \"labelMarker\",\n    // Marker to start an image (`!`).\n    labelImageMarker: \"labelImageMarker\",\n    // End a label (`]`).\n    // Includes `labelMarker`.\n    labelEnd: \"labelEnd\",\n    // Whole link (`[alpha](bravo)`, `[alpha][bravo]`, `[alpha][]`, or `[alpha]`).\n    // Includes `label` and an optional `resource` or `reference`.\n    link: \"link\",\n    // Whole paragraph:\n    //\n    // ```markdown\n    // alpha\n    // bravo.\n    // ```\n    //\n    // Includes text.\n    paragraph: \"paragraph\",\n    // A reference (`[alpha]` or `[]`).\n    // Includes `referenceMarker` and an optional `referenceString`.\n    reference: \"reference\",\n    // A reference marker (`[` or `]`).\n    referenceMarker: \"referenceMarker\",\n    // Reference text (`alpha`).\n    // Includes string.\n    referenceString: \"referenceString\",\n    // A resource (`(https://example.com \"alpha\")`).\n    // Includes `resourceMarker`, an optional `resourceDestination` with an optional\n    // `whitespace` and `resourceTitle`.\n    resource: \"resource\",\n    // A resource destination (`https://example.com`).\n    // Includes `resourceDestinationLiteral` or `resourceDestinationRaw`.\n    resourceDestination: \"resourceDestination\",\n    // A literal resource destination (`<https://example.com>`).\n    // Includes `resourceDestinationLiteralMarker` and optionally\n    // `resourceDestinationString`.\n    resourceDestinationLiteral: \"resourceDestinationLiteral\",\n    // A resource destination marker (`<` or `>`).\n    resourceDestinationLiteralMarker: \"resourceDestinationLiteralMarker\",\n    // A raw resource destination (`https://example.com`).\n    // Includes `resourceDestinationString`.\n    resourceDestinationRaw: \"resourceDestinationRaw\",\n    // Resource destination text (`https://example.com`).\n    // Includes string.\n    resourceDestinationString: \"resourceDestinationString\",\n    // A resource marker (`(` or `)`).\n    resourceMarker: \"resourceMarker\",\n    // A resource title (`\"alpha\"`, `'alpha'`, or `(alpha)`).\n    // Includes `resourceTitleMarker` and optionally `resourceTitleString`.\n    resourceTitle: \"resourceTitle\",\n    // A resource title marker (`\"`, `'`, `(`, or `)`).\n    resourceTitleMarker: \"resourceTitleMarker\",\n    // Resource destination title (`alpha`).\n    // Includes string.\n    resourceTitleString: \"resourceTitleString\",\n    // Whole setext heading:\n    //\n    // ```markdown\n    // alpha\n    // bravo\n    // =====\n    // ```\n    //\n    // Includes `setextHeadingText`, `lineEnding`, `linePrefix`, and\n    // `setextHeadingLine`.\n    setextHeading: \"setextHeading\",\n    // Content in a setext heading (`alpha\\nbravo`).\n    // Includes text.\n    setextHeadingText: \"setextHeadingText\",\n    // Underline in a setext heading, including whitespace suffix (`==`).\n    // Includes `setextHeadingLineSequence`.\n    setextHeadingLine: \"setextHeadingLine\",\n    // Sequence of equals or dash characters in underline in a setext heading (`-`).\n    setextHeadingLineSequence: \"setextHeadingLineSequence\",\n    // Strong (`**alpha**`).\n    // Includes `strongSequence` and `strongText`.\n    strong: \"strong\",\n    // Sequence of strong markers (`**` or `__`).\n    strongSequence: \"strongSequence\",\n    // Strong text (`alpha`).\n    // Includes text.\n    strongText: \"strongText\",\n    // Whole thematic break:\n    //\n    // ```markdown\n    // * * *\n    // ```\n    //\n    // Includes `thematicBreakSequence` and `whitespace`.\n    thematicBreak: \"thematicBreak\",\n    // A sequence of one or more thematic break markers (`***`).\n    thematicBreakSequence: \"thematicBreakSequence\",\n    // Whole block quote:\n    //\n    // ```markdown\n    // > a\n    // >\n    // > b\n    // ```\n    //\n    // Includes `blockQuotePrefix` and flow.\n    blockQuote: \"blockQuote\",\n    // The `>` or `> ` of a block quote.\n    blockQuotePrefix: \"blockQuotePrefix\",\n    // The `>` of a block quote prefix.\n    blockQuoteMarker: \"blockQuoteMarker\",\n    // The optional ` ` of a block quote prefix.\n    blockQuotePrefixWhitespace: \"blockQuotePrefixWhitespace\",\n    // Whole ordered list:\n    //\n    // ```markdown\n    // 1. a\n    //    b\n    // ```\n    //\n    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\n    // lines.\n    listOrdered: \"listOrdered\",\n    // Whole unordered list:\n    //\n    // ```markdown\n    // - a\n    //   b\n    // ```\n    //\n    // Includes `listItemPrefix`, flow, and optionally  `listItemIndent` on further\n    // lines.\n    listUnordered: \"listUnordered\",\n    // The indent of further list item lines.\n    listItemIndent: \"listItemIndent\",\n    // A marker, as in, `*`, `+`, `-`, `.`, or `)`.\n    listItemMarker: \"listItemMarker\",\n    // The thing that starts a list item, such as `1. `.\n    // Includes `listItemValue` if ordered, `listItemMarker`, and\n    // `listItemPrefixWhitespace` (unless followed by a line ending).\n    listItemPrefix: \"listItemPrefix\",\n    // The whitespace after a marker.\n    listItemPrefixWhitespace: \"listItemPrefixWhitespace\",\n    // The numerical value of an ordered item.\n    listItemValue: \"listItemValue\",\n    // Internal types used for subtokenizers, compiled away\n    chunkDocument: \"chunkDocument\",\n    chunkContent: \"chunkContent\",\n    chunkFlow: \"chunkFlow\",\n    chunkText: \"chunkText\",\n    chunkString: \"chunkString\"\n  }\n);\n\n// node_modules/micromark-util-symbol/lib/values.js\nvar values = (\n  /** @type {const} */\n  {\n    ht: \"\t\",\n    lf: \"\\n\",\n    cr: \"\\r\",\n    space: \" \",\n    exclamationMark: \"!\",\n    quotationMark: '\"',\n    numberSign: \"#\",\n    dollarSign: \"$\",\n    percentSign: \"%\",\n    ampersand: \"&\",\n    apostrophe: \"'\",\n    leftParenthesis: \"(\",\n    rightParenthesis: \")\",\n    asterisk: \"*\",\n    plusSign: \"+\",\n    comma: \",\",\n    dash: \"-\",\n    dot: \".\",\n    slash: \"/\",\n    digit0: \"0\",\n    digit1: \"1\",\n    digit2: \"2\",\n    digit3: \"3\",\n    digit4: \"4\",\n    digit5: \"5\",\n    digit6: \"6\",\n    digit7: \"7\",\n    digit8: \"8\",\n    digit9: \"9\",\n    colon: \":\",\n    semicolon: \";\",\n    lessThan: \"<\",\n    equalsTo: \"=\",\n    greaterThan: \">\",\n    questionMark: \"?\",\n    atSign: \"@\",\n    uppercaseA: \"A\",\n    uppercaseB: \"B\",\n    uppercaseC: \"C\",\n    uppercaseD: \"D\",\n    uppercaseE: \"E\",\n    uppercaseF: \"F\",\n    uppercaseG: \"G\",\n    uppercaseH: \"H\",\n    uppercaseI: \"I\",\n    uppercaseJ: \"J\",\n    uppercaseK: \"K\",\n    uppercaseL: \"L\",\n    uppercaseM: \"M\",\n    uppercaseN: \"N\",\n    uppercaseO: \"O\",\n    uppercaseP: \"P\",\n    uppercaseQ: \"Q\",\n    uppercaseR: \"R\",\n    uppercaseS: \"S\",\n    uppercaseT: \"T\",\n    uppercaseU: \"U\",\n    uppercaseV: \"V\",\n    uppercaseW: \"W\",\n    uppercaseX: \"X\",\n    uppercaseY: \"Y\",\n    uppercaseZ: \"Z\",\n    leftSquareBracket: \"[\",\n    backslash: \"\\\\\",\n    rightSquareBracket: \"]\",\n    caret: \"^\",\n    underscore: \"_\",\n    graveAccent: \"`\",\n    lowercaseA: \"a\",\n    lowercaseB: \"b\",\n    lowercaseC: \"c\",\n    lowercaseD: \"d\",\n    lowercaseE: \"e\",\n    lowercaseF: \"f\",\n    lowercaseG: \"g\",\n    lowercaseH: \"h\",\n    lowercaseI: \"i\",\n    lowercaseJ: \"j\",\n    lowercaseK: \"k\",\n    lowercaseL: \"l\",\n    lowercaseM: \"m\",\n    lowercaseN: \"n\",\n    lowercaseO: \"o\",\n    lowercaseP: \"p\",\n    lowercaseQ: \"q\",\n    lowercaseR: \"r\",\n    lowercaseS: \"s\",\n    lowercaseT: \"t\",\n    lowercaseU: \"u\",\n    lowercaseV: \"v\",\n    lowercaseW: \"w\",\n    lowercaseX: \"x\",\n    lowercaseY: \"y\",\n    lowercaseZ: \"z\",\n    leftCurlyBrace: \"{\",\n    verticalBar: \"|\",\n    rightCurlyBrace: \"}\",\n    tilde: \"~\",\n    replacementCharacter: \"\"\n  }\n);\n\n// node_modules/micromark-util-character/dev/index.js\nvar asciiAlpha = regexCheck(/[A-Za-z]/);\nvar asciiAlphanumeric = regexCheck(/[\\dA-Za-z]/);\nvar asciiAtext = regexCheck(/[#-'*+\\--9=?A-Z^-~]/);\nfunction asciiControl(code) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    code !== null && (code < codes.space || code === codes.del)\n  );\n}\nvar asciiDigit = regexCheck(/\\d/);\nvar asciiHexDigit = regexCheck(/[\\dA-Fa-f]/);\nvar asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);\nfunction markdownLineEnding(code) {\n  return code !== null && code < codes.horizontalTab;\n}\nfunction markdownLineEndingOrSpace(code) {\n  return code !== null && (code < codes.nul || code === codes.space);\n}\nfunction markdownSpace(code) {\n  return code === codes.horizontalTab || code === codes.virtualSpace || code === codes.space;\n}\nvar unicodePunctuation = regexCheck(new RegExp(\"\\\\p{P}|\\\\p{S}\", \"u\"));\nvar unicodeWhitespace = regexCheck(/\\s/);\nfunction regexCheck(regex) {\n  return check;\n  function check(code) {\n    return code !== null && code > -1 && regex.test(String.fromCharCode(code));\n  }\n}\n\n// node_modules/micromark-factory-space/dev/index.js\nfunction factorySpace(effects, ok2, type, max) {\n  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;\n  let size = 0;\n  return start;\n  function start(code) {\n    if (markdownSpace(code)) {\n      effects.enter(type);\n      return prefix(code);\n    }\n    return ok2(code);\n  }\n  function prefix(code) {\n    if (markdownSpace(code) && size++ < limit) {\n      effects.consume(code);\n      return prefix;\n    }\n    effects.exit(type);\n    return ok2(code);\n  }\n}\n\nexport {\n  ok,\n  unreachable,\n  codes,\n  constants,\n  types,\n  values,\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl,\n  asciiDigit,\n  asciiHexDigit,\n  asciiPunctuation,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace,\n  unicodePunctuation,\n  unicodeWhitespace,\n  factorySpace\n};\n//# sourceMappingURL=chunk-EIBGEDEJ.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.746Z",
        "time": 1.313000000664033,
        "timings": {
          "blocked": 0.6710000000768341,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.3279999997883569,
          "receive": 0.31400000079884194,
          "_blocked_queueing": 0.6450000000768341,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-katex.js?v=2a7591ed",
          "lineNumber": 7
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-JJWVCDWF.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-katex.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "32676"
            },
            {
              "name": "Etag",
              "value": "W/\"7fa4-4y2jOtWkB3YOv5dNeesdISrPK1g\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 32676,
            "mimeType": "text/javascript",
            "text": "import {\n  __export\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/comma-separated-tokens/index.js\nfunction parse(value) {\n  const tokens = [];\n  const input = String(value || \"\");\n  let index = input.indexOf(\",\");\n  let start = 0;\n  let end = false;\n  while (!end) {\n    if (index === -1) {\n      index = input.length;\n      end = true;\n    }\n    const token = input.slice(start, index).trim();\n    if (token || !end) {\n      tokens.push(token);\n    }\n    start = index + 1;\n    index = input.indexOf(\",\", start);\n  }\n  return tokens;\n}\nfunction stringify(values, options) {\n  const settings = options || {};\n  const input = values[values.length - 1] === \"\" ? [...values, \"\"] : values;\n  return input.join(\n    (settings.padRight ? \" \" : \"\") + \",\" + (settings.padLeft === false ? \"\" : \" \")\n  ).trim();\n}\n\n// node_modules/property-information/lib/hast-to-react.js\nvar hastToReact = {\n  classId: \"classID\",\n  dataType: \"datatype\",\n  itemId: \"itemID\",\n  strokeDashArray: \"strokeDasharray\",\n  strokeDashOffset: \"strokeDashoffset\",\n  strokeLineCap: \"strokeLinecap\",\n  strokeLineJoin: \"strokeLinejoin\",\n  strokeMiterLimit: \"strokeMiterlimit\",\n  typeOf: \"typeof\",\n  xLinkActuate: \"xlinkActuate\",\n  xLinkArcRole: \"xlinkArcrole\",\n  xLinkHref: \"xlinkHref\",\n  xLinkRole: \"xlinkRole\",\n  xLinkShow: \"xlinkShow\",\n  xLinkTitle: \"xlinkTitle\",\n  xLinkType: \"xlinkType\",\n  xmlnsXLink: \"xmlnsXlink\"\n};\n\n// node_modules/property-information/lib/util/info.js\nvar Info = class {\n  /**\n   * @param {string} property\n   *   Property.\n   * @param {string} attribute\n   *   Attribute.\n   * @returns\n   *   Info.\n   */\n  constructor(property, attribute) {\n    this.attribute = attribute;\n    this.property = property;\n  }\n};\nInfo.prototype.attribute = \"\";\nInfo.prototype.booleanish = false;\nInfo.prototype.boolean = false;\nInfo.prototype.commaOrSpaceSeparated = false;\nInfo.prototype.commaSeparated = false;\nInfo.prototype.defined = false;\nInfo.prototype.mustUseProperty = false;\nInfo.prototype.number = false;\nInfo.prototype.overloadedBoolean = false;\nInfo.prototype.property = \"\";\nInfo.prototype.spaceSeparated = false;\nInfo.prototype.space = void 0;\n\n// node_modules/property-information/lib/util/types.js\nvar types_exports = {};\n__export(types_exports, {\n  boolean: () => boolean,\n  booleanish: () => booleanish,\n  commaOrSpaceSeparated: () => commaOrSpaceSeparated,\n  commaSeparated: () => commaSeparated,\n  number: () => number,\n  overloadedBoolean: () => overloadedBoolean,\n  spaceSeparated: () => spaceSeparated\n});\nvar powers = 0;\nvar boolean = increment();\nvar booleanish = increment();\nvar overloadedBoolean = increment();\nvar number = increment();\nvar spaceSeparated = increment();\nvar commaSeparated = increment();\nvar commaOrSpaceSeparated = increment();\nfunction increment() {\n  return 2 ** ++powers;\n}\n\n// node_modules/property-information/lib/util/defined-info.js\nvar checks = (\n  /** @type {ReadonlyArray<keyof typeof types>} */\n  Object.keys(types_exports)\n);\nvar DefinedInfo = class extends Info {\n  /**\n   * @constructor\n   * @param {string} property\n   *   Property.\n   * @param {string} attribute\n   *   Attribute.\n   * @param {number | null | undefined} [mask]\n   *   Mask.\n   * @param {Space | undefined} [space]\n   *   Space.\n   * @returns\n   *   Info.\n   */\n  constructor(property, attribute, mask, space) {\n    let index = -1;\n    super(property, attribute);\n    mark(this, \"space\", space);\n    if (typeof mask === \"number\") {\n      while (++index < checks.length) {\n        const check = checks[index];\n        mark(this, checks[index], (mask & types_exports[check]) === types_exports[check]);\n      }\n    }\n  }\n};\nDefinedInfo.prototype.defined = true;\nfunction mark(values, key, value) {\n  if (value) {\n    values[key] = value;\n  }\n}\n\n// node_modules/property-information/lib/normalize.js\nfunction normalize(value) {\n  return value.toLowerCase();\n}\n\n// node_modules/property-information/lib/find.js\nvar cap = /[A-Z]/g;\nvar dash = /-[a-z]/g;\nvar valid = /^data[-\\w.:]+$/i;\nfunction find(schema, value) {\n  const normal = normalize(value);\n  let property = value;\n  let Type = Info;\n  if (normal in schema.normal) {\n    return schema.property[schema.normal[normal]];\n  }\n  if (normal.length > 4 && normal.slice(0, 4) === \"data\" && valid.test(value)) {\n    if (value.charAt(4) === \"-\") {\n      const rest = value.slice(5).replace(dash, camelcase);\n      property = \"data\" + rest.charAt(0).toUpperCase() + rest.slice(1);\n    } else {\n      const rest = value.slice(4);\n      if (!dash.test(rest)) {\n        let dashes = rest.replace(cap, kebab);\n        if (dashes.charAt(0) !== \"-\") {\n          dashes = \"-\" + dashes;\n        }\n        value = \"data\" + dashes;\n      }\n    }\n    Type = DefinedInfo;\n  }\n  return new Type(property, value);\n}\nfunction kebab($0) {\n  return \"-\" + $0.toLowerCase();\n}\nfunction camelcase($0) {\n  return $0.charAt(1).toUpperCase();\n}\n\n// node_modules/property-information/lib/util/schema.js\nvar Schema = class {\n  /**\n   * @param {SchemaType['property']} property\n   *   Property.\n   * @param {SchemaType['normal']} normal\n   *   Normal.\n   * @param {Space | undefined} [space]\n   *   Space.\n   * @returns\n   *   Schema.\n   */\n  constructor(property, normal, space) {\n    this.normal = normal;\n    this.property = property;\n    if (space) {\n      this.space = space;\n    }\n  }\n};\nSchema.prototype.normal = {};\nSchema.prototype.property = {};\nSchema.prototype.space = void 0;\n\n// node_modules/property-information/lib/util/merge.js\nfunction merge(definitions, space) {\n  const property = {};\n  const normal = {};\n  for (const definition of definitions) {\n    Object.assign(property, definition.property);\n    Object.assign(normal, definition.normal);\n  }\n  return new Schema(property, normal, space);\n}\n\n// node_modules/property-information/lib/util/create.js\nfunction create(definition) {\n  const properties = {};\n  const normals = {};\n  for (const [property, value] of Object.entries(definition.properties)) {\n    const info = new DefinedInfo(\n      property,\n      definition.transform(definition.attributes || {}, property),\n      value,\n      definition.space\n    );\n    if (definition.mustUseProperty && definition.mustUseProperty.includes(property)) {\n      info.mustUseProperty = true;\n    }\n    properties[property] = info;\n    normals[normalize(property)] = property;\n    normals[normalize(info.attribute)] = property;\n  }\n  return new Schema(properties, normals, definition.space);\n}\n\n// node_modules/property-information/lib/aria.js\nvar aria = create({\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: booleanish,\n    ariaAutoComplete: null,\n    ariaBusy: booleanish,\n    ariaChecked: booleanish,\n    ariaColCount: number,\n    ariaColIndex: number,\n    ariaColSpan: number,\n    ariaControls: spaceSeparated,\n    ariaCurrent: null,\n    ariaDescribedBy: spaceSeparated,\n    ariaDetails: null,\n    ariaDisabled: booleanish,\n    ariaDropEffect: spaceSeparated,\n    ariaErrorMessage: null,\n    ariaExpanded: booleanish,\n    ariaFlowTo: spaceSeparated,\n    ariaGrabbed: booleanish,\n    ariaHasPopup: null,\n    ariaHidden: booleanish,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: spaceSeparated,\n    ariaLevel: number,\n    ariaLive: null,\n    ariaModal: booleanish,\n    ariaMultiLine: booleanish,\n    ariaMultiSelectable: booleanish,\n    ariaOrientation: null,\n    ariaOwns: spaceSeparated,\n    ariaPlaceholder: null,\n    ariaPosInSet: number,\n    ariaPressed: booleanish,\n    ariaReadOnly: booleanish,\n    ariaRelevant: null,\n    ariaRequired: booleanish,\n    ariaRoleDescription: spaceSeparated,\n    ariaRowCount: number,\n    ariaRowIndex: number,\n    ariaRowSpan: number,\n    ariaSelected: booleanish,\n    ariaSetSize: number,\n    ariaSort: null,\n    ariaValueMax: number,\n    ariaValueMin: number,\n    ariaValueNow: number,\n    ariaValueText: null,\n    role: null\n  },\n  transform(_, property) {\n    return property === \"role\" ? property : \"aria-\" + property.slice(4).toLowerCase();\n  }\n});\n\n// node_modules/property-information/lib/util/case-sensitive-transform.js\nfunction caseSensitiveTransform(attributes, attribute) {\n  return attribute in attributes ? attributes[attribute] : attribute;\n}\n\n// node_modules/property-information/lib/util/case-insensitive-transform.js\nfunction caseInsensitiveTransform(attributes, property) {\n  return caseSensitiveTransform(attributes, property.toLowerCase());\n}\n\n// node_modules/property-information/lib/html.js\nvar html = create({\n  attributes: {\n    acceptcharset: \"accept-charset\",\n    classname: \"class\",\n    htmlfor: \"for\",\n    httpequiv: \"http-equiv\"\n  },\n  mustUseProperty: [\"checked\", \"multiple\", \"muted\", \"selected\"],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: commaSeparated,\n    acceptCharset: spaceSeparated,\n    accessKey: spaceSeparated,\n    action: null,\n    allow: null,\n    allowFullScreen: boolean,\n    allowPaymentRequest: boolean,\n    allowUserMedia: boolean,\n    alt: null,\n    as: null,\n    async: boolean,\n    autoCapitalize: null,\n    autoComplete: spaceSeparated,\n    autoFocus: boolean,\n    autoPlay: boolean,\n    blocking: spaceSeparated,\n    capture: null,\n    charSet: null,\n    checked: boolean,\n    cite: null,\n    className: spaceSeparated,\n    cols: number,\n    colSpan: null,\n    content: null,\n    contentEditable: booleanish,\n    controls: boolean,\n    controlsList: spaceSeparated,\n    coords: number | commaSeparated,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: boolean,\n    defer: boolean,\n    dir: null,\n    dirName: null,\n    disabled: boolean,\n    download: overloadedBoolean,\n    draggable: booleanish,\n    encType: null,\n    enterKeyHint: null,\n    fetchPriority: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: boolean,\n    formTarget: null,\n    headers: spaceSeparated,\n    height: number,\n    hidden: overloadedBoolean,\n    high: number,\n    href: null,\n    hrefLang: null,\n    htmlFor: spaceSeparated,\n    httpEquiv: spaceSeparated,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inert: boolean,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: boolean,\n    itemId: null,\n    itemProp: spaceSeparated,\n    itemRef: spaceSeparated,\n    itemScope: boolean,\n    itemType: spaceSeparated,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: boolean,\n    low: number,\n    manifest: null,\n    max: null,\n    maxLength: number,\n    media: null,\n    method: null,\n    min: null,\n    minLength: number,\n    multiple: boolean,\n    muted: boolean,\n    name: null,\n    nonce: null,\n    noModule: boolean,\n    noValidate: boolean,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeToggle: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: boolean,\n    optimum: number,\n    pattern: null,\n    ping: spaceSeparated,\n    placeholder: null,\n    playsInline: boolean,\n    popover: null,\n    popoverTarget: null,\n    popoverTargetAction: null,\n    poster: null,\n    preload: null,\n    readOnly: boolean,\n    referrerPolicy: null,\n    rel: spaceSeparated,\n    required: boolean,\n    reversed: boolean,\n    rows: number,\n    rowSpan: number,\n    sandbox: spaceSeparated,\n    scope: null,\n    scoped: boolean,\n    seamless: boolean,\n    selected: boolean,\n    shadowRootClonable: boolean,\n    shadowRootDelegatesFocus: boolean,\n    shadowRootMode: null,\n    shape: null,\n    size: number,\n    sizes: null,\n    slot: null,\n    span: number,\n    spellCheck: booleanish,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: number,\n    step: null,\n    style: null,\n    tabIndex: number,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: boolean,\n    useMap: null,\n    value: booleanish,\n    width: number,\n    wrap: null,\n    writingSuggestions: null,\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null,\n    // Several. Use CSS `text-align` instead,\n    aLink: null,\n    // `<body>`. Use CSS `a:active {color}` instead\n    archive: spaceSeparated,\n    // `<object>`. List of URIs to archives\n    axis: null,\n    // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null,\n    // `<body>`. Use CSS `background-image` instead\n    bgColor: null,\n    // `<body>` and table elements. Use CSS `background-color` instead\n    border: number,\n    // `<table>`. Use CSS `border-width` instead,\n    borderColor: null,\n    // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: number,\n    // `<body>`\n    cellPadding: null,\n    // `<table>`\n    cellSpacing: null,\n    // `<table>`\n    char: null,\n    // Several table elements. When `align=char`, sets the character to align on\n    charOff: null,\n    // Several table elements. When `char`, offsets the alignment\n    classId: null,\n    // `<object>`\n    clear: null,\n    // `<br>`. Use CSS `clear` instead\n    code: null,\n    // `<object>`\n    codeBase: null,\n    // `<object>`\n    codeType: null,\n    // `<object>`\n    color: null,\n    // `<font>` and `<hr>`. Use CSS instead\n    compact: boolean,\n    // Lists. Use CSS to reduce space between items instead\n    declare: boolean,\n    // `<object>`\n    event: null,\n    // `<script>`\n    face: null,\n    // `<font>`. Use CSS instead\n    frame: null,\n    // `<table>`\n    frameBorder: null,\n    // `<iframe>`. Use CSS `border` instead\n    hSpace: number,\n    // `<img>` and `<object>`\n    leftMargin: number,\n    // `<body>`\n    link: null,\n    // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null,\n    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null,\n    // `<img>`. Use a `<picture>`\n    marginHeight: number,\n    // `<body>`\n    marginWidth: number,\n    // `<body>`\n    noResize: boolean,\n    // `<frame>`\n    noHref: boolean,\n    // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: boolean,\n    // `<hr>`. Use background-color and height instead of borders\n    noWrap: boolean,\n    // `<td>` and `<th>`\n    object: null,\n    // `<applet>`\n    profile: null,\n    // `<head>`\n    prompt: null,\n    // `<isindex>`\n    rev: null,\n    // `<link>`\n    rightMargin: number,\n    // `<body>`\n    rules: null,\n    // `<table>`\n    scheme: null,\n    // `<meta>`\n    scrolling: booleanish,\n    // `<frame>`. Use overflow in the child context\n    standby: null,\n    // `<object>`\n    summary: null,\n    // `<table>`\n    text: null,\n    // `<body>`. Use CSS `color` instead\n    topMargin: number,\n    // `<body>`\n    valueType: null,\n    // `<param>`\n    version: null,\n    // `<html>`. Use a doctype.\n    vAlign: null,\n    // Several. Use CSS `vertical-align` instead\n    vLink: null,\n    // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: number,\n    // `<img>` and `<object>`\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: boolean,\n    disableRemotePlayback: boolean,\n    prefix: null,\n    property: null,\n    results: number,\n    security: null,\n    unselectable: null\n  },\n  space: \"html\",\n  transform: caseInsensitiveTransform\n});\n\n// node_modules/property-information/lib/svg.js\nvar svg = create({\n  attributes: {\n    accentHeight: \"accent-height\",\n    alignmentBaseline: \"alignment-baseline\",\n    arabicForm: \"arabic-form\",\n    baselineShift: \"baseline-shift\",\n    capHeight: \"cap-height\",\n    className: \"class\",\n    clipPath: \"clip-path\",\n    clipRule: \"clip-rule\",\n    colorInterpolation: \"color-interpolation\",\n    colorInterpolationFilters: \"color-interpolation-filters\",\n    colorProfile: \"color-profile\",\n    colorRendering: \"color-rendering\",\n    crossOrigin: \"crossorigin\",\n    dataType: \"datatype\",\n    dominantBaseline: \"dominant-baseline\",\n    enableBackground: \"enable-background\",\n    fillOpacity: \"fill-opacity\",\n    fillRule: \"fill-rule\",\n    floodColor: \"flood-color\",\n    floodOpacity: \"flood-opacity\",\n    fontFamily: \"font-family\",\n    fontSize: \"font-size\",\n    fontSizeAdjust: \"font-size-adjust\",\n    fontStretch: \"font-stretch\",\n    fontStyle: \"font-style\",\n    fontVariant: \"font-variant\",\n    fontWeight: \"font-weight\",\n    glyphName: \"glyph-name\",\n    glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n    glyphOrientationVertical: \"glyph-orientation-vertical\",\n    hrefLang: \"hreflang\",\n    horizAdvX: \"horiz-adv-x\",\n    horizOriginX: \"horiz-origin-x\",\n    horizOriginY: \"horiz-origin-y\",\n    imageRendering: \"image-rendering\",\n    letterSpacing: \"letter-spacing\",\n    lightingColor: \"lighting-color\",\n    markerEnd: \"marker-end\",\n    markerMid: \"marker-mid\",\n    markerStart: \"marker-start\",\n    navDown: \"nav-down\",\n    navDownLeft: \"nav-down-left\",\n    navDownRight: \"nav-down-right\",\n    navLeft: \"nav-left\",\n    navNext: \"nav-next\",\n    navPrev: \"nav-prev\",\n    navRight: \"nav-right\",\n    navUp: \"nav-up\",\n    navUpLeft: \"nav-up-left\",\n    navUpRight: \"nav-up-right\",\n    onAbort: \"onabort\",\n    onActivate: \"onactivate\",\n    onAfterPrint: \"onafterprint\",\n    onBeforePrint: \"onbeforeprint\",\n    onBegin: \"onbegin\",\n    onCancel: \"oncancel\",\n    onCanPlay: \"oncanplay\",\n    onCanPlayThrough: \"oncanplaythrough\",\n    onChange: \"onchange\",\n    onClick: \"onclick\",\n    onClose: \"onclose\",\n    onCopy: \"oncopy\",\n    onCueChange: \"oncuechange\",\n    onCut: \"oncut\",\n    onDblClick: \"ondblclick\",\n    onDrag: \"ondrag\",\n    onDragEnd: \"ondragend\",\n    onDragEnter: \"ondragenter\",\n    onDragExit: \"ondragexit\",\n    onDragLeave: \"ondragleave\",\n    onDragOver: \"ondragover\",\n    onDragStart: \"ondragstart\",\n    onDrop: \"ondrop\",\n    onDurationChange: \"ondurationchange\",\n    onEmptied: \"onemptied\",\n    onEnd: \"onend\",\n    onEnded: \"onended\",\n    onError: \"onerror\",\n    onFocus: \"onfocus\",\n    onFocusIn: \"onfocusin\",\n    onFocusOut: \"onfocusout\",\n    onHashChange: \"onhashchange\",\n    onInput: \"oninput\",\n    onInvalid: \"oninvalid\",\n    onKeyDown: \"onkeydown\",\n    onKeyPress: \"onkeypress\",\n    onKeyUp: \"onkeyup\",\n    onLoad: \"onload\",\n    onLoadedData: \"onloadeddata\",\n    onLoadedMetadata: \"onloadedmetadata\",\n    onLoadStart: \"onloadstart\",\n    onMessage: \"onmessage\",\n    onMouseDown: \"onmousedown\",\n    onMouseEnter: \"onmouseenter\",\n    onMouseLeave: \"onmouseleave\",\n    onMouseMove: \"onmousemove\",\n    onMouseOut: \"onmouseout\",\n    onMouseOver: \"onmouseover\",\n    onMouseUp: \"onmouseup\",\n    onMouseWheel: \"onmousewheel\",\n    onOffline: \"onoffline\",\n    onOnline: \"ononline\",\n    onPageHide: \"onpagehide\",\n    onPageShow: \"onpageshow\",\n    onPaste: \"onpaste\",\n    onPause: \"onpause\",\n    onPlay: \"onplay\",\n    onPlaying: \"onplaying\",\n    onPopState: \"onpopstate\",\n    onProgress: \"onprogress\",\n    onRateChange: \"onratechange\",\n    onRepeat: \"onrepeat\",\n    onReset: \"onreset\",\n    onResize: \"onresize\",\n    onScroll: \"onscroll\",\n    onSeeked: \"onseeked\",\n    onSeeking: \"onseeking\",\n    onSelect: \"onselect\",\n    onShow: \"onshow\",\n    onStalled: \"onstalled\",\n    onStorage: \"onstorage\",\n    onSubmit: \"onsubmit\",\n    onSuspend: \"onsuspend\",\n    onTimeUpdate: \"ontimeupdate\",\n    onToggle: \"ontoggle\",\n    onUnload: \"onunload\",\n    onVolumeChange: \"onvolumechange\",\n    onWaiting: \"onwaiting\",\n    onZoom: \"onzoom\",\n    overlinePosition: \"overline-position\",\n    overlineThickness: \"overline-thickness\",\n    paintOrder: \"paint-order\",\n    panose1: \"panose-1\",\n    pointerEvents: \"pointer-events\",\n    referrerPolicy: \"referrerpolicy\",\n    renderingIntent: \"rendering-intent\",\n    shapeRendering: \"shape-rendering\",\n    stopColor: \"stop-color\",\n    stopOpacity: \"stop-opacity\",\n    strikethroughPosition: \"strikethrough-position\",\n    strikethroughThickness: \"strikethrough-thickness\",\n    strokeDashArray: \"stroke-dasharray\",\n    strokeDashOffset: \"stroke-dashoffset\",\n    strokeLineCap: \"stroke-linecap\",\n    strokeLineJoin: \"stroke-linejoin\",\n    strokeMiterLimit: \"stroke-miterlimit\",\n    strokeOpacity: \"stroke-opacity\",\n    strokeWidth: \"stroke-width\",\n    tabIndex: \"tabindex\",\n    textAnchor: \"text-anchor\",\n    textDecoration: \"text-decoration\",\n    textRendering: \"text-rendering\",\n    transformOrigin: \"transform-origin\",\n    typeOf: \"typeof\",\n    underlinePosition: \"underline-position\",\n    underlineThickness: \"underline-thickness\",\n    unicodeBidi: \"unicode-bidi\",\n    unicodeRange: \"unicode-range\",\n    unitsPerEm: \"units-per-em\",\n    vAlphabetic: \"v-alphabetic\",\n    vHanging: \"v-hanging\",\n    vIdeographic: \"v-ideographic\",\n    vMathematical: \"v-mathematical\",\n    vectorEffect: \"vector-effect\",\n    vertAdvY: \"vert-adv-y\",\n    vertOriginX: \"vert-origin-x\",\n    vertOriginY: \"vert-origin-y\",\n    wordSpacing: \"word-spacing\",\n    writingMode: \"writing-mode\",\n    xHeight: \"x-height\",\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: \"playbackorder\",\n    timelineBegin: \"timelinebegin\"\n  },\n  properties: {\n    about: commaOrSpaceSeparated,\n    accentHeight: number,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: number,\n    amplitude: number,\n    arabicForm: null,\n    ascent: number,\n    attributeName: null,\n    attributeType: null,\n    azimuth: number,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: number,\n    by: null,\n    calcMode: null,\n    capHeight: number,\n    className: spaceSeparated,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: number,\n    diffuseConstant: number,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: number,\n    dominantBaseline: null,\n    download: boolean,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: number,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: number,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: number,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: commaSeparated,\n    g2: commaSeparated,\n    glyphName: commaSeparated,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: number,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: number,\n    horizOriginX: number,\n    horizOriginY: number,\n    id: null,\n    ideographic: number,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: number,\n    k: number,\n    k1: number,\n    k2: number,\n    k3: number,\n    k4: number,\n    kernelMatrix: commaOrSpaceSeparated,\n    kernelUnitLength: null,\n    keyPoints: null,\n    // SEMI_COLON_SEPARATED\n    keySplines: null,\n    // SEMI_COLON_SEPARATED\n    keyTimes: null,\n    // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: number,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: number,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: number,\n    overlineThickness: number,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: number,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: spaceSeparated,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: number,\n    pointsAtY: number,\n    pointsAtZ: number,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: commaOrSpaceSeparated,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: commaOrSpaceSeparated,\n    rev: commaOrSpaceSeparated,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: commaOrSpaceSeparated,\n    requiredFeatures: commaOrSpaceSeparated,\n    requiredFonts: commaOrSpaceSeparated,\n    requiredFormats: commaOrSpaceSeparated,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: number,\n    specularExponent: number,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: number,\n    strikethroughThickness: number,\n    string: null,\n    stroke: null,\n    strokeDashArray: commaOrSpaceSeparated,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: number,\n    strokeOpacity: number,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: number,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: commaOrSpaceSeparated,\n    tabIndex: number,\n    tableValues: null,\n    target: null,\n    targetX: number,\n    targetY: number,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: commaOrSpaceSeparated,\n    to: null,\n    transform: null,\n    transformOrigin: null,\n    u1: null,\n    u2: null,\n    underlinePosition: number,\n    underlineThickness: number,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: number,\n    values: null,\n    vAlphabetic: number,\n    vMathematical: number,\n    vectorEffect: null,\n    vHanging: number,\n    vIdeographic: number,\n    version: null,\n    vertAdvY: number,\n    vertOriginX: number,\n    vertOriginY: number,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: number,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  },\n  space: \"svg\",\n  transform: caseSensitiveTransform\n});\n\n// node_modules/property-information/lib/xlink.js\nvar xlink = create({\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  },\n  space: \"xlink\",\n  transform(_, property) {\n    return \"xlink:\" + property.slice(5).toLowerCase();\n  }\n});\n\n// node_modules/property-information/lib/xmlns.js\nvar xmlns = create({\n  attributes: { xmlnsxlink: \"xmlns:xlink\" },\n  properties: { xmlnsXLink: null, xmlns: null },\n  space: \"xmlns\",\n  transform: caseInsensitiveTransform\n});\n\n// node_modules/property-information/lib/xml.js\nvar xml = create({\n  properties: { xmlBase: null, xmlLang: null, xmlSpace: null },\n  space: \"xml\",\n  transform(_, property) {\n    return \"xml:\" + property.slice(3).toLowerCase();\n  }\n});\n\n// node_modules/property-information/index.js\nvar html2 = merge([aria, html, xlink, xmlns, xml], \"html\");\nvar svg2 = merge([aria, svg, xlink, xmlns, xml], \"svg\");\n\n// node_modules/space-separated-tokens/index.js\nfunction parse2(value) {\n  const input = String(value || \"\").trim();\n  return input ? input.split(/[ \\t\\n\\r\\f]+/g) : [];\n}\nfunction stringify2(values) {\n  return values.join(\" \").trim();\n}\n\nexport {\n  parse,\n  stringify,\n  normalize,\n  hastToReact,\n  find,\n  html2 as html,\n  svg2 as svg,\n  parse2,\n  stringify2\n};\n//# sourceMappingURL=chunk-JJWVCDWF.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.751Z",
        "time": 2.1859999978914857,
        "timings": {
          "blocked": 1.1029999969042839,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.7009999989958015,
          "receive": 0.3820000019914005,
          "_blocked_queueing": 1.0009999969042838,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-katex.js?v=2a7591ed",
          "lineNumber": 12
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-XHSSKPCH.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-katex.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "5276"
            },
            {
              "name": "Etag",
              "value": "W/\"149c-xxmb4WK2kJI25ZCGIJOjJcDqB7s\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 5276,
            "mimeType": "text/javascript",
            "text": "// node_modules/unist-util-is/lib/index.js\nvar convert = (\n  // Note: overloads in JSDoc cant yet use different `@template`s.\n  /**\n   * @type {(\n   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &\n   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &\n   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &\n   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &\n   *   ((test?: Test) => Check)\n   * )}\n   */\n  /**\n   * @param {Test} [test]\n   * @returns {Check}\n   */\n  function(test) {\n    if (test === null || test === void 0) {\n      return ok;\n    }\n    if (typeof test === \"function\") {\n      return castFactory(test);\n    }\n    if (typeof test === \"object\") {\n      return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n    }\n    if (typeof test === \"string\") {\n      return typeFactory(test);\n    }\n    throw new Error(\"Expected function, string, or object as test\");\n  }\n);\nfunction anyFactory(tests) {\n  const checks = [];\n  let index = -1;\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n  return castFactory(any);\n  function any(...parameters) {\n    let index2 = -1;\n    while (++index2 < checks.length) {\n      if (checks[index2].apply(this, parameters)) return true;\n    }\n    return false;\n  }\n}\nfunction propsFactory(check) {\n  const checkAsRecord = (\n    /** @type {Record<string, unknown>} */\n    check\n  );\n  return castFactory(all);\n  function all(node) {\n    const nodeAsRecord = (\n      /** @type {Record<string, unknown>} */\n      /** @type {unknown} */\n      node\n    );\n    let key;\n    for (key in check) {\n      if (nodeAsRecord[key] !== checkAsRecord[key]) return false;\n    }\n    return true;\n  }\n}\nfunction typeFactory(check) {\n  return castFactory(type);\n  function type(node) {\n    return node && node.type === check;\n  }\n}\nfunction castFactory(testFunction) {\n  return check;\n  function check(value, index, parent) {\n    return Boolean(\n      looksLikeANode(value) && testFunction.call(\n        this,\n        value,\n        typeof index === \"number\" ? index : void 0,\n        parent || void 0\n      )\n    );\n  }\n}\nfunction ok() {\n  return true;\n}\nfunction looksLikeANode(value) {\n  return value !== null && typeof value === \"object\" && \"type\" in value;\n}\n\n// node_modules/unist-util-visit-parents/lib/color.js\nfunction color(d) {\n  return d;\n}\n\n// node_modules/unist-util-visit-parents/lib/index.js\nvar empty = [];\nvar CONTINUE = true;\nvar EXIT = false;\nvar SKIP = \"skip\";\nfunction visitParents(tree, test, visitor, reverse) {\n  let check;\n  if (typeof test === \"function\" && typeof visitor !== \"function\") {\n    reverse = visitor;\n    visitor = test;\n  } else {\n    check = test;\n  }\n  const is2 = convert(check);\n  const step = reverse ? -1 : 1;\n  factory(tree, void 0, [])();\n  function factory(node, index, parents) {\n    const value = (\n      /** @type {Record<string, unknown>} */\n      node && typeof node === \"object\" ? node : {}\n    );\n    if (typeof value.type === \"string\") {\n      const name = (\n        // `hast`\n        typeof value.tagName === \"string\" ? value.tagName : (\n          // `xast`\n          typeof value.name === \"string\" ? value.name : void 0\n        )\n      );\n      Object.defineProperty(visit, \"name\", {\n        value: \"node (\" + color(node.type + (name ? \"<\" + name + \">\" : \"\")) + \")\"\n      });\n    }\n    return visit;\n    function visit() {\n      let result = empty;\n      let subresult;\n      let offset;\n      let grandparents;\n      if (!test || is2(node, index, parents[parents.length - 1] || void 0)) {\n        result = toResult(visitor(node, parents));\n        if (result[0] === EXIT) {\n          return result;\n        }\n      }\n      if (\"children\" in node && node.children) {\n        const nodeAsParent = (\n          /** @type {UnistParent} */\n          node\n        );\n        if (nodeAsParent.children && result[0] !== SKIP) {\n          offset = (reverse ? nodeAsParent.children.length : -1) + step;\n          grandparents = parents.concat(nodeAsParent);\n          while (offset > -1 && offset < nodeAsParent.children.length) {\n            const child = nodeAsParent.children[offset];\n            subresult = factory(child, offset, grandparents)();\n            if (subresult[0] === EXIT) {\n              return subresult;\n            }\n            offset = typeof subresult[1] === \"number\" ? subresult[1] : offset + step;\n          }\n        }\n      }\n      return result;\n    }\n  }\n}\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === \"number\") {\n    return [CONTINUE, value];\n  }\n  return value === null || value === void 0 ? empty : [value];\n}\n\nexport {\n  convert,\n  EXIT,\n  SKIP,\n  visitParents\n};\n//# sourceMappingURL=chunk-XHSSKPCH.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.751Z",
        "time": 2.1739999974670354,
        "timings": {
          "blocked": 1.2399999996228144,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.5660000005923211,
          "receive": 0.3679999972518999,
          "_blocked_queueing": 1.0949999996228144,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-sanitize.js?v=2a7591ed",
          "lineNumber": 3
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-WA7BIZIN.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/rehype-sanitize.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "7190"
            },
            {
              "name": "Etag",
              "value": "W/\"1c16-ILOn1RdIYogJCAtlPw+5OvvUxs4\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 7190,
            "mimeType": "text/javascript",
            "text": "// node_modules/@ungap/structured-clone/esm/types.js\nvar VOID = -1;\nvar PRIMITIVE = 0;\nvar ARRAY = 1;\nvar OBJECT = 2;\nvar DATE = 3;\nvar REGEXP = 4;\nvar MAP = 5;\nvar SET = 6;\nvar ERROR = 7;\nvar BIGINT = 8;\n\n// node_modules/@ungap/structured-clone/esm/deserialize.js\nvar env = typeof self === \"object\" ? self : globalThis;\nvar deserializer = ($, _) => {\n  const as = (out, index) => {\n    $.set(index, out);\n    return out;\n  };\n  const unpair = (index) => {\n    if ($.has(index))\n      return $.get(index);\n    const [type, value] = _[index];\n    switch (type) {\n      case PRIMITIVE:\n      case VOID:\n        return as(value, index);\n      case ARRAY: {\n        const arr = as([], index);\n        for (const index2 of value)\n          arr.push(unpair(index2));\n        return arr;\n      }\n      case OBJECT: {\n        const object = as({}, index);\n        for (const [key, index2] of value)\n          object[unpair(key)] = unpair(index2);\n        return object;\n      }\n      case DATE:\n        return as(new Date(value), index);\n      case REGEXP: {\n        const { source, flags } = value;\n        return as(new RegExp(source, flags), index);\n      }\n      case MAP: {\n        const map = as(/* @__PURE__ */ new Map(), index);\n        for (const [key, index2] of value)\n          map.set(unpair(key), unpair(index2));\n        return map;\n      }\n      case SET: {\n        const set = as(/* @__PURE__ */ new Set(), index);\n        for (const index2 of value)\n          set.add(unpair(index2));\n        return set;\n      }\n      case ERROR: {\n        const { name, message } = value;\n        return as(new env[name](message), index);\n      }\n      case BIGINT:\n        return as(BigInt(value), index);\n      case \"BigInt\":\n        return as(Object(BigInt(value)), index);\n      case \"ArrayBuffer\":\n        return as(new Uint8Array(value).buffer, value);\n      case \"DataView\": {\n        const { buffer } = new Uint8Array(value);\n        return as(new DataView(buffer), value);\n      }\n    }\n    return as(new env[type](value), index);\n  };\n  return unpair;\n};\nvar deserialize = (serialized) => deserializer(/* @__PURE__ */ new Map(), serialized)(0);\n\n// node_modules/@ungap/structured-clone/esm/serialize.js\nvar EMPTY = \"\";\nvar { toString } = {};\nvar { keys } = Object;\nvar typeOf = (value) => {\n  const type = typeof value;\n  if (type !== \"object\" || !value)\n    return [PRIMITIVE, type];\n  const asString = toString.call(value).slice(8, -1);\n  switch (asString) {\n    case \"Array\":\n      return [ARRAY, EMPTY];\n    case \"Object\":\n      return [OBJECT, EMPTY];\n    case \"Date\":\n      return [DATE, EMPTY];\n    case \"RegExp\":\n      return [REGEXP, EMPTY];\n    case \"Map\":\n      return [MAP, EMPTY];\n    case \"Set\":\n      return [SET, EMPTY];\n    case \"DataView\":\n      return [ARRAY, asString];\n  }\n  if (asString.includes(\"Array\"))\n    return [ARRAY, asString];\n  if (asString.includes(\"Error\"))\n    return [ERROR, asString];\n  return [OBJECT, asString];\n};\nvar shouldSkip = ([TYPE, type]) => TYPE === PRIMITIVE && (type === \"function\" || type === \"symbol\");\nvar serializer = (strict, json, $, _) => {\n  const as = (out, value) => {\n    const index = _.push(out) - 1;\n    $.set(value, index);\n    return index;\n  };\n  const pair = (value) => {\n    if ($.has(value))\n      return $.get(value);\n    let [TYPE, type] = typeOf(value);\n    switch (TYPE) {\n      case PRIMITIVE: {\n        let entry = value;\n        switch (type) {\n          case \"bigint\":\n            TYPE = BIGINT;\n            entry = value.toString();\n            break;\n          case \"function\":\n          case \"symbol\":\n            if (strict)\n              throw new TypeError(\"unable to serialize \" + type);\n            entry = null;\n            break;\n          case \"undefined\":\n            return as([VOID], value);\n        }\n        return as([TYPE, entry], value);\n      }\n      case ARRAY: {\n        if (type) {\n          let spread = value;\n          if (type === \"DataView\") {\n            spread = new Uint8Array(value.buffer);\n          } else if (type === \"ArrayBuffer\") {\n            spread = new Uint8Array(value);\n          }\n          return as([type, [...spread]], value);\n        }\n        const arr = [];\n        const index = as([TYPE, arr], value);\n        for (const entry of value)\n          arr.push(pair(entry));\n        return index;\n      }\n      case OBJECT: {\n        if (type) {\n          switch (type) {\n            case \"BigInt\":\n              return as([type, value.toString()], value);\n            case \"Boolean\":\n            case \"Number\":\n            case \"String\":\n              return as([type, value.valueOf()], value);\n          }\n        }\n        if (json && \"toJSON\" in value)\n          return pair(value.toJSON());\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const key of keys(value)) {\n          if (strict || !shouldSkip(typeOf(value[key])))\n            entries.push([pair(key), pair(value[key])]);\n        }\n        return index;\n      }\n      case DATE:\n        return as([TYPE, value.toISOString()], value);\n      case REGEXP: {\n        const { source, flags } = value;\n        return as([TYPE, { source, flags }], value);\n      }\n      case MAP: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const [key, entry] of value) {\n          if (strict || !(shouldSkip(typeOf(key)) || shouldSkip(typeOf(entry))))\n            entries.push([pair(key), pair(entry)]);\n        }\n        return index;\n      }\n      case SET: {\n        const entries = [];\n        const index = as([TYPE, entries], value);\n        for (const entry of value) {\n          if (strict || !shouldSkip(typeOf(entry)))\n            entries.push(pair(entry));\n        }\n        return index;\n      }\n    }\n    const { message } = value;\n    return as([TYPE, { name: type, message }], value);\n  };\n  return pair;\n};\nvar serialize = (value, { json, lossy } = {}) => {\n  const _ = [];\n  return serializer(!(json || lossy), !!json, /* @__PURE__ */ new Map(), _)(value), _;\n};\n\n// node_modules/@ungap/structured-clone/esm/index.js\nvar esm_default = typeof structuredClone === \"function\" ? (\n  /* c8 ignore start */\n  (any, options) => options && (\"json\" in options || \"lossy\" in options) ? deserialize(serialize(any, options)) : structuredClone(any)\n) : (any, options) => deserialize(serialize(any, options));\n\n// node_modules/unist-util-position/lib/index.js\nvar pointEnd = point(\"end\");\nvar pointStart = point(\"start\");\nfunction point(type) {\n  return point2;\n  function point2(node) {\n    const point3 = node && node.position && node.position[type] || {};\n    if (typeof point3.line === \"number\" && point3.line > 0 && typeof point3.column === \"number\" && point3.column > 0) {\n      return {\n        line: point3.line,\n        column: point3.column,\n        offset: typeof point3.offset === \"number\" && point3.offset > -1 ? point3.offset : void 0\n      };\n    }\n  }\n}\nfunction position(node) {\n  const start = pointStart(node);\n  const end = pointEnd(node);\n  if (start && end) {\n    return { start, end };\n  }\n}\n\nexport {\n  esm_default,\n  pointEnd,\n  pointStart,\n  position\n};\n//# sourceMappingURL=chunk-WA7BIZIN.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.751Z",
        "time": 2.113000002282206,
        "timings": {
          "blocked": 1.2009999998856802,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.5300000004051253,
          "receive": 0.3820000019914005,
          "_blocked_queueing": 1.1709999998856802,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-gfm.js?v=2a7591ed",
          "lineNumber": 9
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-WKZH733J.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/remark-gfm.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "103858"
            },
            {
              "name": "Etag",
              "value": "W/\"195b2-5s/lZHRmSZu0IDG5NdIs9RJCIqE\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 103858,
            "mimeType": "text/javascript",
            "text": "import {\n  visitParents\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-XHSSKPCH.js?v=2a7591ed\";\nimport {\n  asciiAlpha,\n  asciiAlphanumeric,\n  asciiAtext,\n  asciiControl,\n  asciiDigit,\n  asciiHexDigit,\n  asciiPunctuation,\n  codes,\n  constants,\n  factorySpace,\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace,\n  ok,\n  types,\n  unicodePunctuation,\n  unicodeWhitespace,\n  values\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-EIBGEDEJ.js?v=2a7591ed\";\n\n// node_modules/unist-util-visit/lib/index.js\nfunction visit(tree, testOrVisitor, visitorOrReverse, maybeReverse) {\n  let reverse;\n  let test;\n  let visitor;\n  if (typeof testOrVisitor === \"function\" && typeof visitorOrReverse !== \"function\") {\n    test = void 0;\n    visitor = testOrVisitor;\n    reverse = visitorOrReverse;\n  } else {\n    test = testOrVisitor;\n    visitor = visitorOrReverse;\n    reverse = maybeReverse;\n  }\n  visitParents(tree, test, overload, reverse);\n  function overload(node2, parents) {\n    const parent = parents[parents.length - 1];\n    const index = parent ? parent.children.indexOf(node2) : void 0;\n    return visitor(node2, index, parent);\n  }\n}\n\n// node_modules/micromark-util-chunked/dev/index.js\nfunction splice(list2, start, remove, items) {\n  const end = list2.length;\n  let chunkStart = 0;\n  let parameters;\n  if (start < 0) {\n    start = -start > end ? 0 : end + start;\n  } else {\n    start = start > end ? end : start;\n  }\n  remove = remove > 0 ? remove : 0;\n  if (items.length < constants.v8MaxSafeChunkSize) {\n    parameters = Array.from(items);\n    parameters.unshift(start, remove);\n    list2.splice(...parameters);\n  } else {\n    if (remove) list2.splice(start, remove);\n    while (chunkStart < items.length) {\n      parameters = items.slice(\n        chunkStart,\n        chunkStart + constants.v8MaxSafeChunkSize\n      );\n      parameters.unshift(start, 0);\n      list2.splice(...parameters);\n      chunkStart += constants.v8MaxSafeChunkSize;\n      start += constants.v8MaxSafeChunkSize;\n    }\n  }\n}\nfunction push(list2, items) {\n  if (list2.length > 0) {\n    splice(list2, list2.length, 0, items);\n    return list2;\n  }\n  return items;\n}\n\n// node_modules/micromark-util-combine-extensions/index.js\nvar hasOwnProperty = {}.hasOwnProperty;\nfunction combineExtensions(extensions) {\n  const all2 = {};\n  let index = -1;\n  while (++index < extensions.length) {\n    syntaxExtension(all2, extensions[index]);\n  }\n  return all2;\n}\nfunction syntaxExtension(all2, extension) {\n  let hook;\n  for (hook in extension) {\n    const maybe = hasOwnProperty.call(all2, hook) ? all2[hook] : void 0;\n    const left = maybe || (all2[hook] = {});\n    const right = extension[hook];\n    let code;\n    if (right) {\n      for (code in right) {\n        if (!hasOwnProperty.call(left, code)) left[code] = [];\n        const value = right[code];\n        constructs(\n          // @ts-expect-error Looks like a list.\n          left[code],\n          Array.isArray(value) ? value : value ? [value] : []\n        );\n      }\n    }\n  }\n}\nfunction constructs(existing, list2) {\n  let index = -1;\n  const before = [];\n  while (++index < list2.length) {\n    ;\n    (list2[index].add === \"after\" ? existing : before).push(list2[index]);\n  }\n  splice(existing, 0, 0, before);\n}\n\n// node_modules/micromark-util-normalize-identifier/dev/index.js\nfunction normalizeIdentifier(value) {\n  return value.replace(/[\\t\\n\\r ]+/g, values.space).replace(/^ | $/g, \"\").toLowerCase().toUpperCase();\n}\n\n// node_modules/micromark-util-classify-character/dev/index.js\nfunction classifyCharacter(code) {\n  if (code === codes.eof || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {\n    return constants.characterGroupWhitespace;\n  }\n  if (unicodePunctuation(code)) {\n    return constants.characterGroupPunctuation;\n  }\n}\n\n// node_modules/mdast-util-to-string/lib/index.js\nvar emptyOptions = {};\nfunction toString(value, options) {\n  const settings = options || emptyOptions;\n  const includeImageAlt = typeof settings.includeImageAlt === \"boolean\" ? settings.includeImageAlt : true;\n  const includeHtml = typeof settings.includeHtml === \"boolean\" ? settings.includeHtml : true;\n  return one(value, includeImageAlt, includeHtml);\n}\nfunction one(value, includeImageAlt, includeHtml) {\n  if (node(value)) {\n    if (\"value\" in value) {\n      return value.type === \"html\" && !includeHtml ? \"\" : value.value;\n    }\n    if (includeImageAlt && \"alt\" in value && value.alt) {\n      return value.alt;\n    }\n    if (\"children\" in value) {\n      return all(value.children, includeImageAlt, includeHtml);\n    }\n  }\n  if (Array.isArray(value)) {\n    return all(value, includeImageAlt, includeHtml);\n  }\n  return \"\";\n}\nfunction all(values2, includeImageAlt, includeHtml) {\n  const result = [];\n  let index = -1;\n  while (++index < values2.length) {\n    result[index] = one(values2[index], includeImageAlt, includeHtml);\n  }\n  return result.join(\"\");\n}\nfunction node(value) {\n  return Boolean(value && typeof value === \"object\");\n}\n\n// node_modules/decode-named-character-reference/index.dom.js\nvar element = document.createElement(\"i\");\nfunction decodeNamedCharacterReference(value) {\n  const characterReference2 = \"&\" + value + \";\";\n  element.innerHTML = characterReference2;\n  const character = element.textContent;\n  if (\n    // @ts-expect-error: TypeScript is wrong that `textContent` on elements can\n    // yield `null`.\n    character.charCodeAt(character.length - 1) === 59 && value !== \"semi\"\n  ) {\n    return false;\n  }\n  return character === characterReference2 ? false : character;\n}\n\n// node_modules/micromark-util-decode-numeric-character-reference/dev/index.js\nfunction decodeNumericCharacterReference(value, base) {\n  const code = Number.parseInt(value, base);\n  if (\n    // C0 except for HT, LF, FF, CR, space.\n    code < codes.ht || code === codes.vt || code > codes.cr && code < codes.space || // Control character (DEL) of C0, and C1 controls.\n    code > codes.tilde && code < 160 || // Lone high surrogates and low surrogates.\n    code > 55295 && code < 57344 || // Noncharacters.\n    code > 64975 && code < 65008 || /* eslint-disable no-bitwise */\n    (code & 65535) === 65535 || (code & 65535) === 65534 || /* eslint-enable no-bitwise */\n    // Out of range\n    code > 1114111\n  ) {\n    return values.replacementCharacter;\n  }\n  return String.fromCodePoint(code);\n}\n\n// node_modules/micromark-util-decode-string/dev/index.js\nvar characterEscapeOrReference = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\nfunction decodeString(value) {\n  return value.replace(characterEscapeOrReference, decode);\n}\nfunction decode($0, $1, $2) {\n  if ($1) {\n    return $1;\n  }\n  const head = $2.charCodeAt(0);\n  if (head === codes.numberSign) {\n    const head2 = $2.charCodeAt(1);\n    const hex = head2 === codes.lowercaseX || head2 === codes.uppercaseX;\n    return decodeNumericCharacterReference(\n      $2.slice(hex ? 2 : 1),\n      hex ? constants.numericBaseHexadecimal : constants.numericBaseDecimal\n    );\n  }\n  return decodeNamedCharacterReference($2) || $0;\n}\n\n// node_modules/micromark-util-sanitize-uri/dev/index.js\nfunction normalizeUri(value) {\n  const result = [];\n  let index = -1;\n  let start = 0;\n  let skip = 0;\n  while (++index < value.length) {\n    const code = value.charCodeAt(index);\n    let replace = \"\";\n    if (code === codes.percentSign && asciiAlphanumeric(value.charCodeAt(index + 1)) && asciiAlphanumeric(value.charCodeAt(index + 2))) {\n      skip = 2;\n    } else if (code < 128) {\n      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {\n        replace = String.fromCharCode(code);\n      }\n    } else if (code > 55295 && code < 57344) {\n      const next = value.charCodeAt(index + 1);\n      if (code < 56320 && next > 56319 && next < 57344) {\n        replace = String.fromCharCode(code, next);\n        skip = 1;\n      } else {\n        replace = values.replacementCharacter;\n      }\n    } else {\n      replace = String.fromCharCode(code);\n    }\n    if (replace) {\n      result.push(value.slice(start, index), encodeURIComponent(replace));\n      start = index + skip + 1;\n      replace = \"\";\n    }\n    if (skip) {\n      index += skip;\n      skip = 0;\n    }\n  }\n  return result.join(\"\") + value.slice(start);\n}\n\n// node_modules/micromark-util-resolve-all/index.js\nfunction resolveAll(constructs2, events, context) {\n  const called = [];\n  let index = -1;\n  while (++index < constructs2.length) {\n    const resolve = constructs2[index].resolveAll;\n    if (resolve && !called.includes(resolve)) {\n      events = resolve(events, context);\n      called.push(resolve);\n    }\n  }\n  return events;\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/blank-line.js\nvar blankLine = { partial: true, tokenize: tokenizeBlankLine };\nfunction tokenizeBlankLine(effects, ok2, nok) {\n  return start;\n  function start(code) {\n    return markdownSpace(code) ? factorySpace(effects, after, types.linePrefix)(code) : after(code);\n  }\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok2(code) : nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/attention.js\nvar attention = {\n  name: \"attention\",\n  resolveAll: resolveAllAttention,\n  tokenize: tokenizeAttention\n};\nfunction resolveAllAttention(events, context) {\n  let index = -1;\n  let open;\n  let group;\n  let text;\n  let openingSequence;\n  let closingSequence;\n  let use;\n  let nextEvents;\n  let offset;\n  while (++index < events.length) {\n    if (events[index][0] === \"enter\" && events[index][1].type === \"attentionSequence\" && events[index][1]._close) {\n      open = index;\n      while (open--) {\n        if (events[open][0] === \"exit\" && events[open][1].type === \"attentionSequence\" && events[open][1]._open && // If the markers are the same:\n        context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index][1]).charCodeAt(0)) {\n          if ((events[open][1]._close || events[index][1]._open) && (events[index][1].end.offset - events[index][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index][1].end.offset - events[index][1].start.offset) % 3)) {\n            continue;\n          }\n          use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index][1].end.offset - events[index][1].start.offset > 1 ? 2 : 1;\n          const start = { ...events[open][1].end };\n          const end = { ...events[index][1].start };\n          movePoint(start, -use);\n          movePoint(end, use);\n          openingSequence = {\n            type: use > 1 ? types.strongSequence : types.emphasisSequence,\n            start,\n            end: { ...events[open][1].end }\n          };\n          closingSequence = {\n            type: use > 1 ? types.strongSequence : types.emphasisSequence,\n            start: { ...events[index][1].start },\n            end\n          };\n          text = {\n            type: use > 1 ? types.strongText : types.emphasisText,\n            start: { ...events[open][1].end },\n            end: { ...events[index][1].start }\n          };\n          group = {\n            type: use > 1 ? types.strong : types.emphasis,\n            start: { ...openingSequence.start },\n            end: { ...closingSequence.end }\n          };\n          events[open][1].end = { ...openingSequence.start };\n          events[index][1].start = { ...closingSequence.end };\n          nextEvents = [];\n          if (events[open][1].end.offset - events[open][1].start.offset) {\n            nextEvents = push(nextEvents, [\n              [\"enter\", events[open][1], context],\n              [\"exit\", events[open][1], context]\n            ]);\n          }\n          nextEvents = push(nextEvents, [\n            [\"enter\", group, context],\n            [\"enter\", openingSequence, context],\n            [\"exit\", openingSequence, context],\n            [\"enter\", text, context]\n          ]);\n          ok(\n            context.parser.constructs.insideSpan.null,\n            \"expected `insideSpan` to be populated\"\n          );\n          nextEvents = push(\n            nextEvents,\n            resolveAll(\n              context.parser.constructs.insideSpan.null,\n              events.slice(open + 1, index),\n              context\n            )\n          );\n          nextEvents = push(nextEvents, [\n            [\"exit\", text, context],\n            [\"enter\", closingSequence, context],\n            [\"exit\", closingSequence, context],\n            [\"exit\", group, context]\n          ]);\n          if (events[index][1].end.offset - events[index][1].start.offset) {\n            offset = 2;\n            nextEvents = push(nextEvents, [\n              [\"enter\", events[index][1], context],\n              [\"exit\", events[index][1], context]\n            ]);\n          } else {\n            offset = 0;\n          }\n          splice(events, open - 1, index - open + 3, nextEvents);\n          index = open + nextEvents.length - offset - 2;\n          break;\n        }\n      }\n    }\n  }\n  index = -1;\n  while (++index < events.length) {\n    if (events[index][1].type === \"attentionSequence\") {\n      events[index][1].type = \"data\";\n    }\n  }\n  return events;\n}\nfunction tokenizeAttention(effects, ok2) {\n  const attentionMarkers = this.parser.constructs.attentionMarkers.null;\n  const previous2 = this.previous;\n  const before = classifyCharacter(previous2);\n  let marker;\n  return start;\n  function start(code) {\n    ok(\n      code === codes.asterisk || code === codes.underscore,\n      \"expected asterisk or underscore\"\n    );\n    marker = code;\n    effects.enter(\"attentionSequence\");\n    return inside(code);\n  }\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    const token = effects.exit(\"attentionSequence\");\n    const after = classifyCharacter(code);\n    ok(attentionMarkers, \"expected `attentionMarkers` to be populated\");\n    const open = !after || after === constants.characterGroupPunctuation && before || attentionMarkers.includes(code);\n    const close = !before || before === constants.characterGroupPunctuation && after || attentionMarkers.includes(previous2);\n    token._open = Boolean(\n      marker === codes.asterisk ? open : open && (before || !close)\n    );\n    token._close = Boolean(\n      marker === codes.asterisk ? close : close && (after || !open)\n    );\n    return ok2(code);\n  }\n}\nfunction movePoint(point, offset) {\n  point.column += offset;\n  point.offset += offset;\n  point._bufferIndex += offset;\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/autolink.js\nvar autolink = { name: \"autolink\", tokenize: tokenizeAutolink };\nfunction tokenizeAutolink(effects, ok2, nok) {\n  let size = 0;\n  return start;\n  function start(code) {\n    ok(code === codes.lessThan, \"expected `<`\");\n    effects.enter(types.autolink);\n    effects.enter(types.autolinkMarker);\n    effects.consume(code);\n    effects.exit(types.autolinkMarker);\n    effects.enter(types.autolinkProtocol);\n    return open;\n  }\n  function open(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return schemeOrEmailAtext;\n    }\n    if (code === codes.atSign) {\n      return nok(code);\n    }\n    return emailAtext(code);\n  }\n  function schemeOrEmailAtext(code) {\n    if (code === codes.plusSign || code === codes.dash || code === codes.dot || asciiAlphanumeric(code)) {\n      size = 1;\n      return schemeInsideOrEmailAtext(code);\n    }\n    return emailAtext(code);\n  }\n  function schemeInsideOrEmailAtext(code) {\n    if (code === codes.colon) {\n      effects.consume(code);\n      size = 0;\n      return urlInside;\n    }\n    if ((code === codes.plusSign || code === codes.dash || code === codes.dot || asciiAlphanumeric(code)) && size++ < constants.autolinkSchemeSizeMax) {\n      effects.consume(code);\n      return schemeInsideOrEmailAtext;\n    }\n    size = 0;\n    return emailAtext(code);\n  }\n  function urlInside(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.autolinkProtocol);\n      effects.enter(types.autolinkMarker);\n      effects.consume(code);\n      effects.exit(types.autolinkMarker);\n      effects.exit(types.autolink);\n      return ok2;\n    }\n    if (code === codes.eof || code === codes.space || code === codes.lessThan || asciiControl(code)) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return urlInside;\n  }\n  function emailAtext(code) {\n    if (code === codes.atSign) {\n      effects.consume(code);\n      return emailAtSignOrDot;\n    }\n    if (asciiAtext(code)) {\n      effects.consume(code);\n      return emailAtext;\n    }\n    return nok(code);\n  }\n  function emailAtSignOrDot(code) {\n    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);\n  }\n  function emailLabel(code) {\n    if (code === codes.dot) {\n      effects.consume(code);\n      size = 0;\n      return emailAtSignOrDot;\n    }\n    if (code === codes.greaterThan) {\n      effects.exit(types.autolinkProtocol).type = types.autolinkEmail;\n      effects.enter(types.autolinkMarker);\n      effects.consume(code);\n      effects.exit(types.autolinkMarker);\n      effects.exit(types.autolink);\n      return ok2;\n    }\n    return emailValue(code);\n  }\n  function emailValue(code) {\n    if ((code === codes.dash || asciiAlphanumeric(code)) && size++ < constants.autolinkDomainSizeMax) {\n      const next = code === codes.dash ? emailValue : emailLabel;\n      effects.consume(code);\n      return next;\n    }\n    return nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/block-quote.js\nvar blockQuote = {\n  continuation: { tokenize: tokenizeBlockQuoteContinuation },\n  exit,\n  name: \"blockQuote\",\n  tokenize: tokenizeBlockQuoteStart\n};\nfunction tokenizeBlockQuoteStart(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code === codes.greaterThan) {\n      const state = self.containerState;\n      ok(state, \"expected `containerState` to be defined in container\");\n      if (!state.open) {\n        effects.enter(types.blockQuote, { _container: true });\n        state.open = true;\n      }\n      effects.enter(types.blockQuotePrefix);\n      effects.enter(types.blockQuoteMarker);\n      effects.consume(code);\n      effects.exit(types.blockQuoteMarker);\n      return after;\n    }\n    return nok(code);\n  }\n  function after(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.blockQuotePrefixWhitespace);\n      effects.consume(code);\n      effects.exit(types.blockQuotePrefixWhitespace);\n      effects.exit(types.blockQuotePrefix);\n      return ok2;\n    }\n    effects.exit(types.blockQuotePrefix);\n    return ok2(code);\n  }\n}\nfunction tokenizeBlockQuoteContinuation(effects, ok2, nok) {\n  const self = this;\n  return contStart;\n  function contStart(code) {\n    if (markdownSpace(code)) {\n      ok(\n        self.parser.constructs.disable.null,\n        \"expected `disable.null` to be populated\"\n      );\n      return factorySpace(\n        effects,\n        contBefore,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize\n      )(code);\n    }\n    return contBefore(code);\n  }\n  function contBefore(code) {\n    return effects.attempt(blockQuote, ok2, nok)(code);\n  }\n}\nfunction exit(effects) {\n  effects.exit(types.blockQuote);\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/character-escape.js\nvar characterEscape = {\n  name: \"characterEscape\",\n  tokenize: tokenizeCharacterEscape\n};\nfunction tokenizeCharacterEscape(effects, ok2, nok) {\n  return start;\n  function start(code) {\n    ok(code === codes.backslash, \"expected `\\\\`\");\n    effects.enter(types.characterEscape);\n    effects.enter(types.escapeMarker);\n    effects.consume(code);\n    effects.exit(types.escapeMarker);\n    return inside;\n  }\n  function inside(code) {\n    if (asciiPunctuation(code)) {\n      effects.enter(types.characterEscapeValue);\n      effects.consume(code);\n      effects.exit(types.characterEscapeValue);\n      effects.exit(types.characterEscape);\n      return ok2;\n    }\n    return nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/character-reference.js\nvar characterReference = {\n  name: \"characterReference\",\n  tokenize: tokenizeCharacterReference\n};\nfunction tokenizeCharacterReference(effects, ok2, nok) {\n  const self = this;\n  let size = 0;\n  let max;\n  let test;\n  return start;\n  function start(code) {\n    ok(code === codes.ampersand, \"expected `&`\");\n    effects.enter(types.characterReference);\n    effects.enter(types.characterReferenceMarker);\n    effects.consume(code);\n    effects.exit(types.characterReferenceMarker);\n    return open;\n  }\n  function open(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.characterReferenceMarkerNumeric);\n      effects.consume(code);\n      effects.exit(types.characterReferenceMarkerNumeric);\n      return numeric;\n    }\n    effects.enter(types.characterReferenceValue);\n    max = constants.characterReferenceNamedSizeMax;\n    test = asciiAlphanumeric;\n    return value(code);\n  }\n  function numeric(code) {\n    if (code === codes.uppercaseX || code === codes.lowercaseX) {\n      effects.enter(types.characterReferenceMarkerHexadecimal);\n      effects.consume(code);\n      effects.exit(types.characterReferenceMarkerHexadecimal);\n      effects.enter(types.characterReferenceValue);\n      max = constants.characterReferenceHexadecimalSizeMax;\n      test = asciiHexDigit;\n      return value;\n    }\n    effects.enter(types.characterReferenceValue);\n    max = constants.characterReferenceDecimalSizeMax;\n    test = asciiDigit;\n    return value(code);\n  }\n  function value(code) {\n    if (code === codes.semicolon && size) {\n      const token = effects.exit(types.characterReferenceValue);\n      if (test === asciiAlphanumeric && !decodeNamedCharacterReference(self.sliceSerialize(token))) {\n        return nok(code);\n      }\n      effects.enter(types.characterReferenceMarker);\n      effects.consume(code);\n      effects.exit(types.characterReferenceMarker);\n      effects.exit(types.characterReference);\n      return ok2;\n    }\n    if (test(code) && size++ < max) {\n      effects.consume(code);\n      return value;\n    }\n    return nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/code-fenced.js\nvar nonLazyContinuation = {\n  partial: true,\n  tokenize: tokenizeNonLazyContinuation\n};\nvar codeFenced = {\n  concrete: true,\n  name: \"codeFenced\",\n  tokenize: tokenizeCodeFenced\n};\nfunction tokenizeCodeFenced(effects, ok2, nok) {\n  const self = this;\n  const closeStart = { partial: true, tokenize: tokenizeCloseStart };\n  let initialPrefix = 0;\n  let sizeOpen = 0;\n  let marker;\n  return start;\n  function start(code) {\n    return beforeSequenceOpen(code);\n  }\n  function beforeSequenceOpen(code) {\n    ok(\n      code === codes.graveAccent || code === codes.tilde,\n      \"expected `` ` `` or `~`\"\n    );\n    const tail = self.events[self.events.length - 1];\n    initialPrefix = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n    marker = code;\n    effects.enter(types.codeFenced);\n    effects.enter(types.codeFencedFence);\n    effects.enter(types.codeFencedFenceSequence);\n    return sequenceOpen(code);\n  }\n  function sequenceOpen(code) {\n    if (code === marker) {\n      sizeOpen++;\n      effects.consume(code);\n      return sequenceOpen;\n    }\n    if (sizeOpen < constants.codeFencedSequenceSizeMin) {\n      return nok(code);\n    }\n    effects.exit(types.codeFencedFenceSequence);\n    return markdownSpace(code) ? factorySpace(effects, infoBefore, types.whitespace)(code) : infoBefore(code);\n  }\n  function infoBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFencedFence);\n      return self.interrupt ? ok2(code) : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n    effects.enter(types.codeFencedFenceInfo);\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return info(code);\n  }\n  function info(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceInfo);\n      return infoBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceInfo);\n      return factorySpace(effects, metaBefore, types.whitespace)(code);\n    }\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return info;\n  }\n  function metaBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return infoBefore(code);\n    }\n    effects.enter(types.codeFencedFenceMeta);\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return meta(code);\n  }\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit(types.codeFencedFenceMeta);\n      return infoBefore(code);\n    }\n    if (code === codes.graveAccent && code === marker) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return meta;\n  }\n  function atNonLazyBreak(code) {\n    ok(markdownLineEnding(code), \"expected eol\");\n    return effects.attempt(closeStart, after, contentBefore)(code);\n  }\n  function contentBefore(code) {\n    ok(markdownLineEnding(code), \"expected eol\");\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return contentStart;\n  }\n  function contentStart(code) {\n    return initialPrefix > 0 && markdownSpace(code) ? factorySpace(\n      effects,\n      beforeContentChunk,\n      types.linePrefix,\n      initialPrefix + 1\n    )(code) : beforeContentChunk(code);\n  }\n  function beforeContentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code);\n    }\n    effects.enter(types.codeFlowValue);\n    return contentChunk(code);\n  }\n  function contentChunk(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue);\n      return beforeContentChunk(code);\n    }\n    effects.consume(code);\n    return contentChunk;\n  }\n  function after(code) {\n    effects.exit(types.codeFenced);\n    return ok2(code);\n  }\n  function tokenizeCloseStart(effects2, ok3, nok2) {\n    let size = 0;\n    return startBefore;\n    function startBefore(code) {\n      ok(markdownLineEnding(code), \"expected eol\");\n      effects2.enter(types.lineEnding);\n      effects2.consume(code);\n      effects2.exit(types.lineEnding);\n      return start2;\n    }\n    function start2(code) {\n      ok(\n        self.parser.constructs.disable.null,\n        \"expected `disable.null` to be populated\"\n      );\n      effects2.enter(types.codeFencedFence);\n      return markdownSpace(code) ? factorySpace(\n        effects2,\n        beforeSequenceClose,\n        types.linePrefix,\n        self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize\n      )(code) : beforeSequenceClose(code);\n    }\n    function beforeSequenceClose(code) {\n      if (code === marker) {\n        effects2.enter(types.codeFencedFenceSequence);\n        return sequenceClose(code);\n      }\n      return nok2(code);\n    }\n    function sequenceClose(code) {\n      if (code === marker) {\n        size++;\n        effects2.consume(code);\n        return sequenceClose;\n      }\n      if (size >= sizeOpen) {\n        effects2.exit(types.codeFencedFenceSequence);\n        return markdownSpace(code) ? factorySpace(effects2, sequenceCloseAfter, types.whitespace)(code) : sequenceCloseAfter(code);\n      }\n      return nok2(code);\n    }\n    function sequenceCloseAfter(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects2.exit(types.codeFencedFence);\n        return ok3(code);\n      }\n      return nok2(code);\n    }\n  }\n}\nfunction tokenizeNonLazyContinuation(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    ok(markdownLineEnding(code), \"expected eol\");\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok2(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/code-indented.js\nvar codeIndented = {\n  name: \"codeIndented\",\n  tokenize: tokenizeCodeIndented\n};\nvar furtherStart = { partial: true, tokenize: tokenizeFurtherStart };\nfunction tokenizeCodeIndented(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    ok(markdownSpace(code));\n    effects.enter(types.codeIndented);\n    return factorySpace(\n      effects,\n      afterPrefix,\n      types.linePrefix,\n      constants.tabSize + 1\n    )(code);\n  }\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? atBreak(code) : nok(code);\n  }\n  function atBreak(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.attempt(furtherStart, atBreak, after)(code);\n    }\n    effects.enter(types.codeFlowValue);\n    return inside(code);\n  }\n  function inside(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.codeFlowValue);\n      return atBreak(code);\n    }\n    effects.consume(code);\n    return inside;\n  }\n  function after(code) {\n    effects.exit(types.codeIndented);\n    return ok2(code);\n  }\n}\nfunction tokenizeFurtherStart(effects, ok2, nok) {\n  const self = this;\n  return furtherStart2;\n  function furtherStart2(code) {\n    if (self.parser.lazy[self.now().line]) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return furtherStart2;\n    }\n    return factorySpace(\n      effects,\n      afterPrefix,\n      types.linePrefix,\n      constants.tabSize + 1\n    )(code);\n  }\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize ? ok2(code) : markdownLineEnding(code) ? furtherStart2(code) : nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/code-text.js\nvar codeText = {\n  name: \"codeText\",\n  previous,\n  resolve: resolveCodeText,\n  tokenize: tokenizeCodeText\n};\nfunction resolveCodeText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  let index;\n  let enter;\n  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === \"space\") && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === \"space\")) {\n    index = headEnterIndex;\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === types.codeTextData) {\n        events[headEnterIndex][1].type = types.codeTextPadding;\n        events[tailExitIndex][1].type = types.codeTextPadding;\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  }\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n  while (++index <= tailExitIndex) {\n    if (enter === void 0) {\n      if (index !== tailExitIndex && events[index][1].type !== types.lineEnding) {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === types.lineEnding) {\n      events[enter][1].type = types.codeTextData;\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n      enter = void 0;\n    }\n  }\n  return events;\n}\nfunction previous(code) {\n  return code !== codes.graveAccent || this.events[this.events.length - 1][1].type === types.characterEscape;\n}\nfunction tokenizeCodeText(effects, ok2, nok) {\n  const self = this;\n  let sizeOpen = 0;\n  let size;\n  let token;\n  return start;\n  function start(code) {\n    ok(code === codes.graveAccent, \"expected `` ` ``\");\n    ok(previous.call(self, self.previous), \"expected correct previous\");\n    effects.enter(types.codeText);\n    effects.enter(types.codeTextSequence);\n    return sequenceOpen(code);\n  }\n  function sequenceOpen(code) {\n    if (code === codes.graveAccent) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n    effects.exit(types.codeTextSequence);\n    return between(code);\n  }\n  function between(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.space) {\n      effects.enter(\"space\");\n      effects.consume(code);\n      effects.exit(\"space\");\n      return between;\n    }\n    if (code === codes.graveAccent) {\n      token = effects.enter(types.codeTextSequence);\n      size = 0;\n      return sequenceClose(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return between;\n    }\n    effects.enter(types.codeTextData);\n    return data(code);\n  }\n  function data(code) {\n    if (code === codes.eof || code === codes.space || code === codes.graveAccent || markdownLineEnding(code)) {\n      effects.exit(types.codeTextData);\n      return between(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n  function sequenceClose(code) {\n    if (code === codes.graveAccent) {\n      effects.consume(code);\n      size++;\n      return sequenceClose;\n    }\n    if (size === sizeOpen) {\n      effects.exit(types.codeTextSequence);\n      effects.exit(types.codeText);\n      return ok2(code);\n    }\n    token.type = types.codeTextData;\n    return data(code);\n  }\n}\n\n// node_modules/micromark-util-subtokenize/dev/lib/splice-buffer.js\nvar SpliceBuffer = class {\n  /**\n   * @param {ReadonlyArray<T> | null | undefined} [initial]\n   *   Initial items (optional).\n   * @returns\n   *   Splice buffer.\n   */\n  constructor(initial) {\n    this.left = initial ? [...initial] : [];\n    this.right = [];\n  }\n  /**\n   * Array access;\n   * does not move the cursor.\n   *\n   * @param {number} index\n   *   Index.\n   * @return {T}\n   *   Item.\n   */\n  get(index) {\n    if (index < 0 || index >= this.left.length + this.right.length) {\n      throw new RangeError(\n        \"Cannot access index `\" + index + \"` in a splice buffer of size `\" + (this.left.length + this.right.length) + \"`\"\n      );\n    }\n    if (index < this.left.length) return this.left[index];\n    return this.right[this.right.length - index + this.left.length - 1];\n  }\n  /**\n   * The length of the splice buffer, one greater than the largest index in the\n   * array.\n   */\n  get length() {\n    return this.left.length + this.right.length;\n  }\n  /**\n   * Remove and return `list[0]`;\n   * moves the cursor to `0`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  shift() {\n    this.setCursor(0);\n    return this.right.pop();\n  }\n  /**\n   * Slice the buffer to get an array;\n   * does not move the cursor.\n   *\n   * @param {number} start\n   *   Start.\n   * @param {number | null | undefined} [end]\n   *   End (optional).\n   * @returns {Array<T>}\n   *   Array of items.\n   */\n  slice(start, end) {\n    const stop = end === null || end === void 0 ? Number.POSITIVE_INFINITY : end;\n    if (stop < this.left.length) {\n      return this.left.slice(start, stop);\n    }\n    if (start > this.left.length) {\n      return this.right.slice(\n        this.right.length - stop + this.left.length,\n        this.right.length - start + this.left.length\n      ).reverse();\n    }\n    return this.left.slice(start).concat(\n      this.right.slice(this.right.length - stop + this.left.length).reverse()\n    );\n  }\n  /**\n   * Mimics the behavior of Array.prototype.splice() except for the change of\n   * interface necessary to avoid segfaults when patching in very large arrays.\n   *\n   * This operation moves cursor is moved to `start` and results in the cursor\n   * placed after any inserted items.\n   *\n   * @param {number} start\n   *   Start;\n   *   zero-based index at which to start changing the array;\n   *   negative numbers count backwards from the end of the array and values\n   *   that are out-of bounds are clamped to the appropriate end of the array.\n   * @param {number | null | undefined} [deleteCount=0]\n   *   Delete count (default: `0`);\n   *   maximum number of elements to delete, starting from start.\n   * @param {Array<T> | null | undefined} [items=[]]\n   *   Items to include in place of the deleted items (default: `[]`).\n   * @return {Array<T>}\n   *   Any removed items.\n   */\n  splice(start, deleteCount, items) {\n    const count = deleteCount || 0;\n    this.setCursor(Math.trunc(start));\n    const removed = this.right.splice(\n      this.right.length - count,\n      Number.POSITIVE_INFINITY\n    );\n    if (items) chunkedPush(this.left, items);\n    return removed.reverse();\n  }\n  /**\n   * Remove and return the highest-numbered item in the array, so\n   * `list[list.length - 1]`;\n   * Moves the cursor to `length`.\n   *\n   * @returns {T | undefined}\n   *   Item, optional.\n   */\n  pop() {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    return this.left.pop();\n  }\n  /**\n   * Inserts a single item to the high-numbered side of the array;\n   * moves the cursor to `length`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  push(item) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    this.left.push(item);\n  }\n  /**\n   * Inserts many items to the high-numbered side of the array.\n   * Moves the cursor to `length`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  pushMany(items) {\n    this.setCursor(Number.POSITIVE_INFINITY);\n    chunkedPush(this.left, items);\n  }\n  /**\n   * Inserts a single item to the low-numbered side of the array;\n   * Moves the cursor to `0`.\n   *\n   * @param {T} item\n   *   Item.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshift(item) {\n    this.setCursor(0);\n    this.right.push(item);\n  }\n  /**\n   * Inserts many items to the low-numbered side of the array;\n   * moves the cursor to `0`.\n   *\n   * @param {Array<T>} items\n   *   Items.\n   * @returns {undefined}\n   *   Nothing.\n   */\n  unshiftMany(items) {\n    this.setCursor(0);\n    chunkedPush(this.right, items.reverse());\n  }\n  /**\n   * Move the cursor to a specific position in the array. Requires\n   * time proportional to the distance moved.\n   *\n   * If `n < 0`, the cursor will end up at the beginning.\n   * If `n > length`, the cursor will end up at the end.\n   *\n   * @param {number} n\n   *   Position.\n   * @return {undefined}\n   *   Nothing.\n   */\n  setCursor(n) {\n    if (n === this.left.length || n > this.left.length && this.right.length === 0 || n < 0 && this.left.length === 0)\n      return;\n    if (n < this.left.length) {\n      const removed = this.left.splice(n, Number.POSITIVE_INFINITY);\n      chunkedPush(this.right, removed.reverse());\n    } else {\n      const removed = this.right.splice(\n        this.left.length + this.right.length - n,\n        Number.POSITIVE_INFINITY\n      );\n      chunkedPush(this.left, removed.reverse());\n    }\n  }\n};\nfunction chunkedPush(list2, right) {\n  let chunkStart = 0;\n  if (right.length < constants.v8MaxSafeChunkSize) {\n    list2.push(...right);\n  } else {\n    while (chunkStart < right.length) {\n      list2.push(\n        ...right.slice(chunkStart, chunkStart + constants.v8MaxSafeChunkSize)\n      );\n      chunkStart += constants.v8MaxSafeChunkSize;\n    }\n  }\n}\n\n// node_modules/micromark-util-subtokenize/dev/index.js\nfunction subtokenize(eventsArray) {\n  const jumps = {};\n  let index = -1;\n  let event;\n  let lineIndex;\n  let otherIndex;\n  let otherEvent;\n  let parameters;\n  let subevents;\n  let more;\n  const events = new SpliceBuffer(eventsArray);\n  while (++index < events.length) {\n    while (index in jumps) {\n      index = jumps[index];\n    }\n    event = events.get(index);\n    if (index && event[1].type === types.chunkFlow && events.get(index - 1)[1].type === types.listItemPrefix) {\n      ok(event[1]._tokenizer, \"expected `_tokenizer` on subtokens\");\n      subevents = event[1]._tokenizer.events;\n      otherIndex = 0;\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.lineEndingBlank) {\n        otherIndex += 2;\n      }\n      if (otherIndex < subevents.length && subevents[otherIndex][1].type === types.content) {\n        while (++otherIndex < subevents.length) {\n          if (subevents[otherIndex][1].type === types.content) {\n            break;\n          }\n          if (subevents[otherIndex][1].type === types.chunkText) {\n            subevents[otherIndex][1]._isInFirstContentOfListItem = true;\n            otherIndex++;\n          }\n        }\n      }\n    }\n    if (event[0] === \"enter\") {\n      if (event[1].contentType) {\n        Object.assign(jumps, subcontent(events, index));\n        index = jumps[index];\n        more = true;\n      }\n    } else if (event[1]._container) {\n      otherIndex = index;\n      lineIndex = void 0;\n      while (otherIndex--) {\n        otherEvent = events.get(otherIndex);\n        if (otherEvent[1].type === types.lineEnding || otherEvent[1].type === types.lineEndingBlank) {\n          if (otherEvent[0] === \"enter\") {\n            if (lineIndex) {\n              events.get(lineIndex)[1].type = types.lineEndingBlank;\n            }\n            otherEvent[1].type = types.lineEnding;\n            lineIndex = otherIndex;\n          }\n        } else if (otherEvent[1].type === types.linePrefix || otherEvent[1].type === types.listItemIndent) {\n        } else {\n          break;\n        }\n      }\n      if (lineIndex) {\n        event[1].end = { ...events.get(lineIndex)[1].start };\n        parameters = events.slice(lineIndex, index);\n        parameters.unshift(event);\n        events.splice(lineIndex, index - lineIndex + 1, parameters);\n      }\n    }\n  }\n  splice(eventsArray, 0, Number.POSITIVE_INFINITY, events.slice(0));\n  return !more;\n}\nfunction subcontent(events, eventIndex) {\n  const token = events.get(eventIndex)[1];\n  const context = events.get(eventIndex)[2];\n  let startPosition = eventIndex - 1;\n  const startPositions = [];\n  ok(token.contentType, \"expected `contentType` on subtokens\");\n  let tokenizer = token._tokenizer;\n  if (!tokenizer) {\n    tokenizer = context.parser[token.contentType](token.start);\n    if (token._contentTypeTextTrailing) {\n      tokenizer._contentTypeTextTrailing = true;\n    }\n  }\n  const childEvents = tokenizer.events;\n  const jumps = [];\n  const gaps = {};\n  let stream;\n  let previous2;\n  let index = -1;\n  let current = token;\n  let adjust = 0;\n  let start = 0;\n  const breaks = [start];\n  while (current) {\n    while (events.get(++startPosition)[1] !== current) {\n    }\n    ok(\n      !previous2 || current.previous === previous2,\n      \"expected previous to match\"\n    );\n    ok(!previous2 || previous2.next === current, \"expected next to match\");\n    startPositions.push(startPosition);\n    if (!current._tokenizer) {\n      stream = context.sliceStream(current);\n      if (!current.next) {\n        stream.push(codes.eof);\n      }\n      if (previous2) {\n        tokenizer.defineSkip(current.start);\n      }\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = true;\n      }\n      tokenizer.write(stream);\n      if (current._isInFirstContentOfListItem) {\n        tokenizer._gfmTasklistFirstContentOfListItem = void 0;\n      }\n    }\n    previous2 = current;\n    current = current.next;\n  }\n  current = token;\n  while (++index < childEvents.length) {\n    if (\n      // Find a void token that includes a break.\n      childEvents[index][0] === \"exit\" && childEvents[index - 1][0] === \"enter\" && childEvents[index][1].type === childEvents[index - 1][1].type && childEvents[index][1].start.line !== childEvents[index][1].end.line\n    ) {\n      ok(current, \"expected a current token\");\n      start = index + 1;\n      breaks.push(start);\n      current._tokenizer = void 0;\n      current.previous = void 0;\n      current = current.next;\n    }\n  }\n  tokenizer.events = [];\n  if (current) {\n    current._tokenizer = void 0;\n    current.previous = void 0;\n    ok(!current.next, \"expected no next token\");\n  } else {\n    breaks.pop();\n  }\n  index = breaks.length;\n  while (index--) {\n    const slice = childEvents.slice(breaks[index], breaks[index + 1]);\n    const start2 = startPositions.pop();\n    ok(start2 !== void 0, \"expected a start position when splicing\");\n    jumps.push([start2, start2 + slice.length - 1]);\n    events.splice(start2, 2, slice);\n  }\n  jumps.reverse();\n  index = -1;\n  while (++index < jumps.length) {\n    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];\n    adjust += jumps[index][1] - jumps[index][0] - 1;\n  }\n  return gaps;\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/content.js\nvar content = { resolve: resolveContent, tokenize: tokenizeContent };\nvar continuationConstruct = { partial: true, tokenize: tokenizeContinuation };\nfunction resolveContent(events) {\n  subtokenize(events);\n  return events;\n}\nfunction tokenizeContent(effects, ok2) {\n  let previous2;\n  return chunkStart;\n  function chunkStart(code) {\n    ok(\n      code !== codes.eof && !markdownLineEnding(code),\n      \"expected no eof or eol\"\n    );\n    effects.enter(types.content);\n    previous2 = effects.enter(types.chunkContent, {\n      contentType: constants.contentTypeContent\n    });\n    return chunkInside(code);\n  }\n  function chunkInside(code) {\n    if (code === codes.eof) {\n      return contentEnd(code);\n    }\n    if (markdownLineEnding(code)) {\n      return effects.check(\n        continuationConstruct,\n        contentContinue,\n        contentEnd\n      )(code);\n    }\n    effects.consume(code);\n    return chunkInside;\n  }\n  function contentEnd(code) {\n    effects.exit(types.chunkContent);\n    effects.exit(types.content);\n    return ok2(code);\n  }\n  function contentContinue(code) {\n    ok(markdownLineEnding(code), \"expected eol\");\n    effects.consume(code);\n    effects.exit(types.chunkContent);\n    ok(previous2, \"expected previous token\");\n    previous2.next = effects.enter(types.chunkContent, {\n      contentType: constants.contentTypeContent,\n      previous: previous2\n    });\n    previous2 = previous2.next;\n    return chunkInside;\n  }\n}\nfunction tokenizeContinuation(effects, ok2, nok) {\n  const self = this;\n  return startLookahead;\n  function startLookahead(code) {\n    ok(markdownLineEnding(code), \"expected a line ending\");\n    effects.exit(types.chunkContent);\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return factorySpace(effects, prefixed, types.linePrefix);\n  }\n  function prefixed(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code);\n    }\n    ok(\n      self.parser.constructs.disable.null,\n      \"expected `disable.null` to be populated\"\n    );\n    const tail = self.events[self.events.length - 1];\n    if (!self.parser.constructs.disable.null.includes(\"codeIndented\") && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {\n      return ok2(code);\n    }\n    return effects.interrupt(self.parser.constructs.flow, nok, ok2)(code);\n  }\n}\n\n// node_modules/micromark-factory-destination/dev/index.js\nfunction factoryDestination(effects, ok2, nok, type, literalType, literalMarkerType, rawType, stringType, max) {\n  const limit = max || Number.POSITIVE_INFINITY;\n  let balance = 0;\n  return start;\n  function start(code) {\n    if (code === codes.lessThan) {\n      effects.enter(type);\n      effects.enter(literalType);\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      return enclosedBefore;\n    }\n    if (code === codes.eof || code === codes.space || code === codes.rightParenthesis || asciiControl(code)) {\n      return nok(code);\n    }\n    effects.enter(type);\n    effects.enter(rawType);\n    effects.enter(stringType);\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return raw(code);\n  }\n  function enclosedBefore(code) {\n    if (code === codes.greaterThan) {\n      effects.enter(literalMarkerType);\n      effects.consume(code);\n      effects.exit(literalMarkerType);\n      effects.exit(literalType);\n      effects.exit(type);\n      return ok2;\n    }\n    effects.enter(stringType);\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return enclosed(code);\n  }\n  function enclosed(code) {\n    if (code === codes.greaterThan) {\n      effects.exit(types.chunkString);\n      effects.exit(stringType);\n      return enclosedBefore(code);\n    }\n    if (code === codes.eof || code === codes.lessThan || markdownLineEnding(code)) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return code === codes.backslash ? enclosedEscape : enclosed;\n  }\n  function enclosedEscape(code) {\n    if (code === codes.lessThan || code === codes.greaterThan || code === codes.backslash) {\n      effects.consume(code);\n      return enclosed;\n    }\n    return enclosed(code);\n  }\n  function raw(code) {\n    if (!balance && (code === codes.eof || code === codes.rightParenthesis || markdownLineEndingOrSpace(code))) {\n      effects.exit(types.chunkString);\n      effects.exit(stringType);\n      effects.exit(rawType);\n      effects.exit(type);\n      return ok2(code);\n    }\n    if (balance < limit && code === codes.leftParenthesis) {\n      effects.consume(code);\n      balance++;\n      return raw;\n    }\n    if (code === codes.rightParenthesis) {\n      effects.consume(code);\n      balance--;\n      return raw;\n    }\n    if (code === codes.eof || code === codes.space || code === codes.leftParenthesis || asciiControl(code)) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return code === codes.backslash ? rawEscape : raw;\n  }\n  function rawEscape(code) {\n    if (code === codes.leftParenthesis || code === codes.rightParenthesis || code === codes.backslash) {\n      effects.consume(code);\n      return raw;\n    }\n    return raw(code);\n  }\n}\n\n// node_modules/micromark-factory-label/dev/index.js\nfunction factoryLabel(effects, ok2, nok, type, markerType, stringType) {\n  const self = this;\n  let size = 0;\n  let seen;\n  return start;\n  function start(code) {\n    ok(code === codes.leftSquareBracket, \"expected `[`\");\n    effects.enter(type);\n    effects.enter(markerType);\n    effects.consume(code);\n    effects.exit(markerType);\n    effects.enter(stringType);\n    return atBreak;\n  }\n  function atBreak(code) {\n    if (size > constants.linkReferenceSizeMax || code === codes.eof || code === codes.leftSquareBracket || code === codes.rightSquareBracket && !seen || // To do: remove in the future once weve switched from\n    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n    // which doesnt need this.\n    // Hidden footnotes hook.\n    /* c8 ignore next 3 */\n    code === codes.caret && !size && \"_hiddenFootnoteSupport\" in self.parser.constructs) {\n      return nok(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.exit(stringType);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok2;\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return atBreak;\n    }\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return labelInside(code);\n  }\n  function labelInside(code) {\n    if (code === codes.eof || code === codes.leftSquareBracket || code === codes.rightSquareBracket || markdownLineEnding(code) || size++ > constants.linkReferenceSizeMax) {\n      effects.exit(types.chunkString);\n      return atBreak(code);\n    }\n    effects.consume(code);\n    if (!seen) seen = !markdownSpace(code);\n    return code === codes.backslash ? labelEscape : labelInside;\n  }\n  function labelEscape(code) {\n    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {\n      effects.consume(code);\n      size++;\n      return labelInside;\n    }\n    return labelInside(code);\n  }\n}\n\n// node_modules/micromark-factory-title/dev/index.js\nfunction factoryTitle(effects, ok2, nok, type, markerType, stringType) {\n  let marker;\n  return start;\n  function start(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      effects.enter(type);\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      marker = code === codes.leftParenthesis ? codes.rightParenthesis : code;\n      return begin;\n    }\n    return nok(code);\n  }\n  function begin(code) {\n    if (code === marker) {\n      effects.enter(markerType);\n      effects.consume(code);\n      effects.exit(markerType);\n      effects.exit(type);\n      return ok2;\n    }\n    effects.enter(stringType);\n    return atBreak(code);\n  }\n  function atBreak(code) {\n    if (code === marker) {\n      effects.exit(stringType);\n      return begin(marker);\n    }\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return factorySpace(effects, atBreak, types.linePrefix);\n    }\n    effects.enter(types.chunkString, { contentType: constants.contentTypeString });\n    return inside(code);\n  }\n  function inside(code) {\n    if (code === marker || code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      return atBreak(code);\n    }\n    effects.consume(code);\n    return code === codes.backslash ? escape : inside;\n  }\n  function escape(code) {\n    if (code === marker || code === codes.backslash) {\n      effects.consume(code);\n      return inside;\n    }\n    return inside(code);\n  }\n}\n\n// node_modules/micromark-factory-whitespace/dev/index.js\nfunction factoryWhitespace(effects, ok2) {\n  let seen;\n  return start;\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      seen = true;\n      return start;\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(\n        effects,\n        start,\n        seen ? types.linePrefix : types.lineSuffix\n      )(code);\n    }\n    return ok2(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/definition.js\nvar definition = { name: \"definition\", tokenize: tokenizeDefinition };\nvar titleBefore = { partial: true, tokenize: tokenizeTitleBefore };\nfunction tokenizeDefinition(effects, ok2, nok) {\n  const self = this;\n  let identifier;\n  return start;\n  function start(code) {\n    effects.enter(types.definition);\n    return before(code);\n  }\n  function before(code) {\n    ok(code === codes.leftSquareBracket, \"expected `[`\");\n    return factoryLabel.call(\n      self,\n      effects,\n      labelAfter,\n      // Note: we dont need to reset the way `markdown-rs` does.\n      nok,\n      types.definitionLabel,\n      types.definitionLabelMarker,\n      types.definitionLabelString\n    )(code);\n  }\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n    );\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker);\n      effects.consume(code);\n      effects.exit(types.definitionMarker);\n      return markerAfter;\n    }\n    return nok(code);\n  }\n  function markerAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, destinationBefore)(code) : destinationBefore(code);\n  }\n  function destinationBefore(code) {\n    return factoryDestination(\n      effects,\n      destinationAfter,\n      // Note: we dont need to reset the way `markdown-rs` does.\n      nok,\n      types.definitionDestination,\n      types.definitionDestinationLiteral,\n      types.definitionDestinationLiteralMarker,\n      types.definitionDestinationRaw,\n      types.definitionDestinationString\n    )(code);\n  }\n  function destinationAfter(code) {\n    return effects.attempt(titleBefore, after, after)(code);\n  }\n  function after(code) {\n    return markdownSpace(code) ? factorySpace(effects, afterWhitespace, types.whitespace)(code) : afterWhitespace(code);\n  }\n  function afterWhitespace(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition);\n      self.parser.defined.push(identifier);\n      return ok2(code);\n    }\n    return nok(code);\n  }\n}\nfunction tokenizeTitleBefore(effects, ok2, nok) {\n  return titleBefore2;\n  function titleBefore2(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, beforeMarker)(code) : nok(code);\n  }\n  function beforeMarker(code) {\n    return factoryTitle(\n      effects,\n      titleAfter,\n      nok,\n      types.definitionTitle,\n      types.definitionTitleMarker,\n      types.definitionTitleString\n    )(code);\n  }\n  function titleAfter(code) {\n    return markdownSpace(code) ? factorySpace(\n      effects,\n      titleAfterOptionalWhitespace,\n      types.whitespace\n    )(code) : titleAfterOptionalWhitespace(code);\n  }\n  function titleAfterOptionalWhitespace(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok2(code) : nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/hard-break-escape.js\nvar hardBreakEscape = {\n  name: \"hardBreakEscape\",\n  tokenize: tokenizeHardBreakEscape\n};\nfunction tokenizeHardBreakEscape(effects, ok2, nok) {\n  return start;\n  function start(code) {\n    ok(code === codes.backslash, \"expected `\\\\`\");\n    effects.enter(types.hardBreakEscape);\n    effects.consume(code);\n    return after;\n  }\n  function after(code) {\n    if (markdownLineEnding(code)) {\n      effects.exit(types.hardBreakEscape);\n      return ok2(code);\n    }\n    return nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/heading-atx.js\nvar headingAtx = {\n  name: \"headingAtx\",\n  resolve: resolveHeadingAtx,\n  tokenize: tokenizeHeadingAtx\n};\nfunction resolveHeadingAtx(events, context) {\n  let contentEnd = events.length - 2;\n  let contentStart = 3;\n  let content2;\n  let text;\n  if (events[contentStart][1].type === types.whitespace) {\n    contentStart += 2;\n  }\n  if (contentEnd - 2 > contentStart && events[contentEnd][1].type === types.whitespace) {\n    contentEnd -= 2;\n  }\n  if (events[contentEnd][1].type === types.atxHeadingSequence && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === types.whitespace)) {\n    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;\n  }\n  if (contentEnd > contentStart) {\n    content2 = {\n      type: types.atxHeadingText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end\n    };\n    text = {\n      type: types.chunkText,\n      start: events[contentStart][1].start,\n      end: events[contentEnd][1].end,\n      contentType: constants.contentTypeText\n    };\n    splice(events, contentStart, contentEnd - contentStart + 1, [\n      [\"enter\", content2, context],\n      [\"enter\", text, context],\n      [\"exit\", text, context],\n      [\"exit\", content2, context]\n    ]);\n  }\n  return events;\n}\nfunction tokenizeHeadingAtx(effects, ok2, nok) {\n  let size = 0;\n  return start;\n  function start(code) {\n    effects.enter(types.atxHeading);\n    return before(code);\n  }\n  function before(code) {\n    ok(code === codes.numberSign, \"expected `#`\");\n    effects.enter(types.atxHeadingSequence);\n    return sequenceOpen(code);\n  }\n  function sequenceOpen(code) {\n    if (code === codes.numberSign && size++ < constants.atxHeadingOpeningFenceSizeMax) {\n      effects.consume(code);\n      return sequenceOpen;\n    }\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingSequence);\n      return atBreak(code);\n    }\n    return nok(code);\n  }\n  function atBreak(code) {\n    if (code === codes.numberSign) {\n      effects.enter(types.atxHeadingSequence);\n      return sequenceFurther(code);\n    }\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.atxHeading);\n      return ok2(code);\n    }\n    if (markdownSpace(code)) {\n      return factorySpace(effects, atBreak, types.whitespace)(code);\n    }\n    effects.enter(types.atxHeadingText);\n    return data(code);\n  }\n  function sequenceFurther(code) {\n    if (code === codes.numberSign) {\n      effects.consume(code);\n      return sequenceFurther;\n    }\n    effects.exit(types.atxHeadingSequence);\n    return atBreak(code);\n  }\n  function data(code) {\n    if (code === codes.eof || code === codes.numberSign || markdownLineEndingOrSpace(code)) {\n      effects.exit(types.atxHeadingText);\n      return atBreak(code);\n    }\n    effects.consume(code);\n    return data;\n  }\n}\n\n// node_modules/micromark-util-html-tag-name/index.js\nvar htmlBlockNames = [\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"base\",\n  \"basefont\",\n  \"blockquote\",\n  \"body\",\n  \"caption\",\n  \"center\",\n  \"col\",\n  \"colgroup\",\n  \"dd\",\n  \"details\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hr\",\n  \"html\",\n  \"iframe\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"menu\",\n  \"menuitem\",\n  \"nav\",\n  \"noframes\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"p\",\n  \"param\",\n  \"search\",\n  \"section\",\n  \"summary\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"ul\"\n];\nvar htmlRawNames = [\"pre\", \"script\", \"style\", \"textarea\"];\n\n// node_modules/micromark-core-commonmark/dev/lib/html-flow.js\nvar htmlFlow = {\n  concrete: true,\n  name: \"htmlFlow\",\n  resolveTo: resolveToHtmlFlow,\n  tokenize: tokenizeHtmlFlow\n};\nvar blankLineBefore = { partial: true, tokenize: tokenizeBlankLineBefore };\nvar nonLazyContinuationStart = {\n  partial: true,\n  tokenize: tokenizeNonLazyContinuationStart\n};\nfunction resolveToHtmlFlow(events) {\n  let index = events.length;\n  while (index--) {\n    if (events[index][0] === \"enter\" && events[index][1].type === types.htmlFlow) {\n      break;\n    }\n  }\n  if (index > 1 && events[index - 2][1].type === types.linePrefix) {\n    events[index][1].start = events[index - 2][1].start;\n    events[index + 1][1].start = events[index - 2][1].start;\n    events.splice(index - 2, 2);\n  }\n  return events;\n}\nfunction tokenizeHtmlFlow(effects, ok2, nok) {\n  const self = this;\n  let marker;\n  let closingTag;\n  let buffer;\n  let index;\n  let markerB;\n  return start;\n  function start(code) {\n    return before(code);\n  }\n  function before(code) {\n    ok(code === codes.lessThan, \"expected `<`\");\n    effects.enter(types.htmlFlow);\n    effects.enter(types.htmlFlowData);\n    effects.consume(code);\n    return open;\n  }\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n    if (code === codes.slash) {\n      effects.consume(code);\n      closingTag = true;\n      return tagCloseStart;\n    }\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      marker = constants.htmlInstruction;\n      return self.interrupt ? ok2 : continuationDeclarationInside;\n    }\n    if (asciiAlpha(code)) {\n      ok(code !== null);\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n    return nok(code);\n  }\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      marker = constants.htmlComment;\n      return commentOpenInside;\n    }\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      marker = constants.htmlCdata;\n      index = 0;\n      return cdataOpenInside;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      marker = constants.htmlDeclaration;\n      return self.interrupt ? ok2 : continuationDeclarationInside;\n    }\n    return nok(code);\n  }\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return self.interrupt ? ok2 : continuationDeclarationInside;\n    }\n    return nok(code);\n  }\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString;\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code);\n      if (index === value.length) {\n        return self.interrupt ? ok2 : continuation;\n      }\n      return cdataOpenInside;\n    }\n    return nok(code);\n  }\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      ok(code !== null);\n      effects.consume(code);\n      buffer = String.fromCharCode(code);\n      return tagName;\n    }\n    return nok(code);\n  }\n  function tagName(code) {\n    if (code === codes.eof || code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      const slash = code === codes.slash;\n      const name = buffer.toLowerCase();\n      if (!slash && !closingTag && htmlRawNames.includes(name)) {\n        marker = constants.htmlRaw;\n        return self.interrupt ? ok2(code) : continuation(code);\n      }\n      if (htmlBlockNames.includes(buffer.toLowerCase())) {\n        marker = constants.htmlBasic;\n        if (slash) {\n          effects.consume(code);\n          return basicSelfClosing;\n        }\n        return self.interrupt ? ok2(code) : continuation(code);\n      }\n      marker = constants.htmlComplete;\n      return self.interrupt && !self.parser.lazy[self.now().line] ? nok(code) : closingTag ? completeClosingTagAfter(code) : completeAttributeNameBefore(code);\n    }\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return tagName;\n    }\n    return nok(code);\n  }\n  function basicSelfClosing(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return self.interrupt ? ok2 : continuation;\n    }\n    return nok(code);\n  }\n  function completeClosingTagAfter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeClosingTagAfter;\n    }\n    return completeEnd(code);\n  }\n  function completeAttributeNameBefore(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return completeEnd;\n    }\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameBefore;\n    }\n    return completeEnd(code);\n  }\n  function completeAttributeName(code) {\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return completeAttributeName;\n    }\n    return completeAttributeNameAfter(code);\n  }\n  function completeAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeNameAfter;\n    }\n    return completeAttributeNameBefore(code);\n  }\n  function completeAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      markerB = code;\n      return completeAttributeValueQuoted;\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAttributeValueBefore;\n    }\n    return completeAttributeValueUnquoted(code);\n  }\n  function completeAttributeValueQuoted(code) {\n    if (code === markerB) {\n      effects.consume(code);\n      markerB = null;\n      return completeAttributeValueQuotedAfter;\n    }\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return nok(code);\n    }\n    effects.consume(code);\n    return completeAttributeValueQuoted;\n  }\n  function completeAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.slash || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent || markdownLineEndingOrSpace(code)) {\n      return completeAttributeNameAfter(code);\n    }\n    effects.consume(code);\n    return completeAttributeValueUnquoted;\n  }\n  function completeAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownSpace(code)) {\n      return completeAttributeNameBefore(code);\n    }\n    return nok(code);\n  }\n  function completeEnd(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return completeAfter;\n    }\n    return nok(code);\n  }\n  function completeAfter(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuation(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return completeAfter;\n    }\n    return nok(code);\n  }\n  function continuation(code) {\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code);\n      return continuationCommentInside;\n    }\n    if (code === codes.lessThan && marker === constants.htmlRaw) {\n      effects.consume(code);\n      return continuationRawTagOpen;\n    }\n    if (code === codes.greaterThan && marker === constants.htmlDeclaration) {\n      effects.consume(code);\n      return continuationClose;\n    }\n    if (code === codes.questionMark && marker === constants.htmlInstruction) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    if (code === codes.rightSquareBracket && marker === constants.htmlCdata) {\n      effects.consume(code);\n      return continuationCdataInside;\n    }\n    if (markdownLineEnding(code) && (marker === constants.htmlBasic || marker === constants.htmlComplete)) {\n      effects.exit(types.htmlFlowData);\n      return effects.check(\n        blankLineBefore,\n        continuationAfter,\n        continuationStart\n      )(code);\n    }\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return continuationStart(code);\n    }\n    effects.consume(code);\n    return continuation;\n  }\n  function continuationStart(code) {\n    return effects.check(\n      nonLazyContinuationStart,\n      continuationStartNonLazy,\n      continuationAfter\n    )(code);\n  }\n  function continuationStartNonLazy(code) {\n    ok(markdownLineEnding(code));\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return continuationBefore;\n  }\n  function continuationBefore(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return continuationStart(code);\n    }\n    effects.enter(types.htmlFlowData);\n    return continuation(code);\n  }\n  function continuationCommentInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    return continuation(code);\n  }\n  function continuationRawTagOpen(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      buffer = \"\";\n      return continuationRawEndTag;\n    }\n    return continuation(code);\n  }\n  function continuationRawEndTag(code) {\n    if (code === codes.greaterThan) {\n      const name = buffer.toLowerCase();\n      if (htmlRawNames.includes(name)) {\n        effects.consume(code);\n        return continuationClose;\n      }\n      return continuation(code);\n    }\n    if (asciiAlpha(code) && buffer.length < constants.htmlRawSizeMax) {\n      ok(code !== null);\n      effects.consume(code);\n      buffer += String.fromCharCode(code);\n      return continuationRawEndTag;\n    }\n    return continuation(code);\n  }\n  function continuationCdataInside(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    return continuation(code);\n  }\n  function continuationDeclarationInside(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      return continuationClose;\n    }\n    if (code === codes.dash && marker === constants.htmlComment) {\n      effects.consume(code);\n      return continuationDeclarationInside;\n    }\n    return continuation(code);\n  }\n  function continuationClose(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.htmlFlowData);\n      return continuationAfter(code);\n    }\n    effects.consume(code);\n    return continuationClose;\n  }\n  function continuationAfter(code) {\n    effects.exit(types.htmlFlow);\n    return ok2(code);\n  }\n}\nfunction tokenizeNonLazyContinuationStart(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    if (markdownLineEnding(code)) {\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return after;\n    }\n    return nok(code);\n  }\n  function after(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok2(code);\n  }\n}\nfunction tokenizeBlankLineBefore(effects, ok2, nok) {\n  return start;\n  function start(code) {\n    ok(markdownLineEnding(code), \"expected a line ending\");\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return effects.attempt(blankLine, ok2, nok);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/html-text.js\nvar htmlText = { name: \"htmlText\", tokenize: tokenizeHtmlText };\nfunction tokenizeHtmlText(effects, ok2, nok) {\n  const self = this;\n  let marker;\n  let index;\n  let returnState;\n  return start;\n  function start(code) {\n    ok(code === codes.lessThan, \"expected `<`\");\n    effects.enter(types.htmlText);\n    effects.enter(types.htmlTextData);\n    effects.consume(code);\n    return open;\n  }\n  function open(code) {\n    if (code === codes.exclamationMark) {\n      effects.consume(code);\n      return declarationOpen;\n    }\n    if (code === codes.slash) {\n      effects.consume(code);\n      return tagCloseStart;\n    }\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instruction;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n    return nok(code);\n  }\n  function declarationOpen(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentOpenInside;\n    }\n    if (code === codes.leftSquareBracket) {\n      effects.consume(code);\n      index = 0;\n      return cdataOpenInside;\n    }\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return declaration;\n    }\n    return nok(code);\n  }\n  function commentOpenInside(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentEnd;\n    }\n    return nok(code);\n  }\n  function comment(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = comment;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return comment;\n  }\n  function commentClose(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return commentEnd;\n    }\n    return comment(code);\n  }\n  function commentEnd(code) {\n    return code === codes.greaterThan ? end(code) : code === codes.dash ? commentClose(code) : comment(code);\n  }\n  function cdataOpenInside(code) {\n    const value = constants.cdataOpeningString;\n    if (code === value.charCodeAt(index++)) {\n      effects.consume(code);\n      return index === value.length ? cdata : cdataOpenInside;\n    }\n    return nok(code);\n  }\n  function cdata(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = cdata;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return cdata;\n  }\n  function cdataClose(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n    return cdata(code);\n  }\n  function cdataEnd(code) {\n    if (code === codes.greaterThan) {\n      return end(code);\n    }\n    if (code === codes.rightSquareBracket) {\n      effects.consume(code);\n      return cdataEnd;\n    }\n    return cdata(code);\n  }\n  function declaration(code) {\n    if (code === codes.eof || code === codes.greaterThan) {\n      return end(code);\n    }\n    if (markdownLineEnding(code)) {\n      returnState = declaration;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return declaration;\n  }\n  function instruction(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (code === codes.questionMark) {\n      effects.consume(code);\n      return instructionClose;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = instruction;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return instruction;\n  }\n  function instructionClose(code) {\n    return code === codes.greaterThan ? end(code) : instruction(code);\n  }\n  function tagCloseStart(code) {\n    if (asciiAlpha(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n    return nok(code);\n  }\n  function tagClose(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagClose;\n    }\n    return tagCloseBetween(code);\n  }\n  function tagCloseBetween(code) {\n    if (markdownLineEnding(code)) {\n      returnState = tagCloseBetween;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagCloseBetween;\n    }\n    return end(code);\n  }\n  function tagOpen(code) {\n    if (code === codes.dash || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpen;\n    }\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    return nok(code);\n  }\n  function tagOpenBetween(code) {\n    if (code === codes.slash) {\n      effects.consume(code);\n      return end;\n    }\n    if (code === codes.colon || code === codes.underscore || asciiAlpha(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenBetween;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenBetween;\n    }\n    return end(code);\n  }\n  function tagOpenAttributeName(code) {\n    if (code === codes.dash || code === codes.dot || code === codes.colon || code === codes.underscore || asciiAlphanumeric(code)) {\n      effects.consume(code);\n      return tagOpenAttributeName;\n    }\n    return tagOpenAttributeNameAfter(code);\n  }\n  function tagOpenAttributeNameAfter(code) {\n    if (code === codes.equalsTo) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeNameAfter;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeNameAfter;\n    }\n    return tagOpenBetween(code);\n  }\n  function tagOpenAttributeValueBefore(code) {\n    if (code === codes.eof || code === codes.lessThan || code === codes.equalsTo || code === codes.greaterThan || code === codes.graveAccent) {\n      return nok(code);\n    }\n    if (code === codes.quotationMark || code === codes.apostrophe) {\n      effects.consume(code);\n      marker = code;\n      return tagOpenAttributeValueQuoted;\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueBefore;\n      return lineEndingBefore(code);\n    }\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return tagOpenAttributeValueBefore;\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n  function tagOpenAttributeValueQuoted(code) {\n    if (code === marker) {\n      effects.consume(code);\n      marker = void 0;\n      return tagOpenAttributeValueQuotedAfter;\n    }\n    if (code === codes.eof) {\n      return nok(code);\n    }\n    if (markdownLineEnding(code)) {\n      returnState = tagOpenAttributeValueQuoted;\n      return lineEndingBefore(code);\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueQuoted;\n  }\n  function tagOpenAttributeValueUnquoted(code) {\n    if (code === codes.eof || code === codes.quotationMark || code === codes.apostrophe || code === codes.lessThan || code === codes.equalsTo || code === codes.graveAccent) {\n      return nok(code);\n    }\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    effects.consume(code);\n    return tagOpenAttributeValueUnquoted;\n  }\n  function tagOpenAttributeValueQuotedAfter(code) {\n    if (code === codes.slash || code === codes.greaterThan || markdownLineEndingOrSpace(code)) {\n      return tagOpenBetween(code);\n    }\n    return nok(code);\n  }\n  function end(code) {\n    if (code === codes.greaterThan) {\n      effects.consume(code);\n      effects.exit(types.htmlTextData);\n      effects.exit(types.htmlText);\n      return ok2;\n    }\n    return nok(code);\n  }\n  function lineEndingBefore(code) {\n    ok(returnState, \"expected return state\");\n    ok(markdownLineEnding(code), \"expected eol\");\n    effects.exit(types.htmlTextData);\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineEndingAfter;\n  }\n  function lineEndingAfter(code) {\n    ok(\n      self.parser.constructs.disable.null,\n      \"expected `disable.null` to be populated\"\n    );\n    return markdownSpace(code) ? factorySpace(\n      effects,\n      lineEndingAfterPrefix,\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize\n    )(code) : lineEndingAfterPrefix(code);\n  }\n  function lineEndingAfterPrefix(code) {\n    effects.enter(types.htmlTextData);\n    return returnState(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/label-end.js\nvar labelEnd = {\n  name: \"labelEnd\",\n  resolveAll: resolveAllLabelEnd,\n  resolveTo: resolveToLabelEnd,\n  tokenize: tokenizeLabelEnd\n};\nvar resourceConstruct = { tokenize: tokenizeResource };\nvar referenceFullConstruct = { tokenize: tokenizeReferenceFull };\nvar referenceCollapsedConstruct = { tokenize: tokenizeReferenceCollapsed };\nfunction resolveAllLabelEnd(events) {\n  let index = -1;\n  const newEvents = [];\n  while (++index < events.length) {\n    const token = events[index][1];\n    newEvents.push(events[index]);\n    if (token.type === types.labelImage || token.type === types.labelLink || token.type === types.labelEnd) {\n      const offset = token.type === types.labelImage ? 4 : 2;\n      token.type = types.data;\n      index += offset;\n    }\n  }\n  if (events.length !== newEvents.length) {\n    splice(events, 0, events.length, newEvents);\n  }\n  return events;\n}\nfunction resolveToLabelEnd(events, context) {\n  let index = events.length;\n  let offset = 0;\n  let token;\n  let open;\n  let close;\n  let media;\n  while (index--) {\n    token = events[index][1];\n    if (open) {\n      if (token.type === types.link || token.type === types.labelLink && token._inactive) {\n        break;\n      }\n      if (events[index][0] === \"enter\" && token.type === types.labelLink) {\n        token._inactive = true;\n      }\n    } else if (close) {\n      if (events[index][0] === \"enter\" && (token.type === types.labelImage || token.type === types.labelLink) && !token._balanced) {\n        open = index;\n        if (token.type !== types.labelLink) {\n          offset = 2;\n          break;\n        }\n      }\n    } else if (token.type === types.labelEnd) {\n      close = index;\n    }\n  }\n  ok(open !== void 0, \"`open` is supposed to be found\");\n  ok(close !== void 0, \"`close` is supposed to be found\");\n  const group = {\n    type: events[open][1].type === types.labelLink ? types.link : types.image,\n    start: { ...events[open][1].start },\n    end: { ...events[events.length - 1][1].end }\n  };\n  const label = {\n    type: types.label,\n    start: { ...events[open][1].start },\n    end: { ...events[close][1].end }\n  };\n  const text = {\n    type: types.labelText,\n    start: { ...events[open + offset + 2][1].end },\n    end: { ...events[close - 2][1].start }\n  };\n  media = [\n    [\"enter\", group, context],\n    [\"enter\", label, context]\n  ];\n  media = push(media, events.slice(open + 1, open + offset + 3));\n  media = push(media, [[\"enter\", text, context]]);\n  ok(\n    context.parser.constructs.insideSpan.null,\n    \"expected `insideSpan.null` to be populated\"\n  );\n  media = push(\n    media,\n    resolveAll(\n      context.parser.constructs.insideSpan.null,\n      events.slice(open + offset + 4, close - 3),\n      context\n    )\n  );\n  media = push(media, [\n    [\"exit\", text, context],\n    events[close - 2],\n    events[close - 1],\n    [\"exit\", label, context]\n  ]);\n  media = push(media, events.slice(close + 1));\n  media = push(media, [[\"exit\", group, context]]);\n  splice(events, open, events.length, media);\n  return events;\n}\nfunction tokenizeLabelEnd(effects, ok2, nok) {\n  const self = this;\n  let index = self.events.length;\n  let labelStart;\n  let defined;\n  while (index--) {\n    if ((self.events[index][1].type === types.labelImage || self.events[index][1].type === types.labelLink) && !self.events[index][1]._balanced) {\n      labelStart = self.events[index][1];\n      break;\n    }\n  }\n  return start;\n  function start(code) {\n    ok(code === codes.rightSquareBracket, \"expected `]`\");\n    if (!labelStart) {\n      return nok(code);\n    }\n    if (labelStart._inactive) {\n      return labelEndNok(code);\n    }\n    defined = self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize({ start: labelStart.end, end: self.now() })\n      )\n    );\n    effects.enter(types.labelEnd);\n    effects.enter(types.labelMarker);\n    effects.consume(code);\n    effects.exit(types.labelMarker);\n    effects.exit(types.labelEnd);\n    return after;\n  }\n  function after(code) {\n    if (code === codes.leftParenthesis) {\n      return effects.attempt(\n        resourceConstruct,\n        labelEndOk,\n        defined ? labelEndOk : labelEndNok\n      )(code);\n    }\n    if (code === codes.leftSquareBracket) {\n      return effects.attempt(\n        referenceFullConstruct,\n        labelEndOk,\n        defined ? referenceNotFull : labelEndNok\n      )(code);\n    }\n    return defined ? labelEndOk(code) : labelEndNok(code);\n  }\n  function referenceNotFull(code) {\n    return effects.attempt(\n      referenceCollapsedConstruct,\n      labelEndOk,\n      labelEndNok\n    )(code);\n  }\n  function labelEndOk(code) {\n    return ok2(code);\n  }\n  function labelEndNok(code) {\n    labelStart._balanced = true;\n    return nok(code);\n  }\n}\nfunction tokenizeResource(effects, ok2, nok) {\n  return resourceStart;\n  function resourceStart(code) {\n    ok(code === codes.leftParenthesis, \"expected left paren\");\n    effects.enter(types.resource);\n    effects.enter(types.resourceMarker);\n    effects.consume(code);\n    effects.exit(types.resourceMarker);\n    return resourceBefore;\n  }\n  function resourceBefore(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceOpen)(code) : resourceOpen(code);\n  }\n  function resourceOpen(code) {\n    if (code === codes.rightParenthesis) {\n      return resourceEnd(code);\n    }\n    return factoryDestination(\n      effects,\n      resourceDestinationAfter,\n      resourceDestinationMissing,\n      types.resourceDestination,\n      types.resourceDestinationLiteral,\n      types.resourceDestinationLiteralMarker,\n      types.resourceDestinationRaw,\n      types.resourceDestinationString,\n      constants.linkResourceDestinationBalanceMax\n    )(code);\n  }\n  function resourceDestinationAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceBetween)(code) : resourceEnd(code);\n  }\n  function resourceDestinationMissing(code) {\n    return nok(code);\n  }\n  function resourceBetween(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(\n        effects,\n        resourceTitleAfter,\n        nok,\n        types.resourceTitle,\n        types.resourceTitleMarker,\n        types.resourceTitleString\n      )(code);\n    }\n    return resourceEnd(code);\n  }\n  function resourceTitleAfter(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, resourceEnd)(code) : resourceEnd(code);\n  }\n  function resourceEnd(code) {\n    if (code === codes.rightParenthesis) {\n      effects.enter(types.resourceMarker);\n      effects.consume(code);\n      effects.exit(types.resourceMarker);\n      effects.exit(types.resource);\n      return ok2;\n    }\n    return nok(code);\n  }\n}\nfunction tokenizeReferenceFull(effects, ok2, nok) {\n  const self = this;\n  return referenceFull;\n  function referenceFull(code) {\n    ok(code === codes.leftSquareBracket, \"expected left bracket\");\n    return factoryLabel.call(\n      self,\n      effects,\n      referenceFullAfter,\n      referenceFullMissing,\n      types.reference,\n      types.referenceMarker,\n      types.referenceString\n    )(code);\n  }\n  function referenceFullAfter(code) {\n    return self.parser.defined.includes(\n      normalizeIdentifier(\n        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\n      )\n    ) ? ok2(code) : nok(code);\n  }\n  function referenceFullMissing(code) {\n    return nok(code);\n  }\n}\nfunction tokenizeReferenceCollapsed(effects, ok2, nok) {\n  return referenceCollapsedStart;\n  function referenceCollapsedStart(code) {\n    ok(code === codes.leftSquareBracket, \"expected left bracket\");\n    effects.enter(types.reference);\n    effects.enter(types.referenceMarker);\n    effects.consume(code);\n    effects.exit(types.referenceMarker);\n    return referenceCollapsedOpen;\n  }\n  function referenceCollapsedOpen(code) {\n    if (code === codes.rightSquareBracket) {\n      effects.enter(types.referenceMarker);\n      effects.consume(code);\n      effects.exit(types.referenceMarker);\n      effects.exit(types.reference);\n      return ok2;\n    }\n    return nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/label-start-image.js\nvar labelStartImage = {\n  name: \"labelStartImage\",\n  resolveAll: labelEnd.resolveAll,\n  tokenize: tokenizeLabelStartImage\n};\nfunction tokenizeLabelStartImage(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    ok(code === codes.exclamationMark, \"expected `!`\");\n    effects.enter(types.labelImage);\n    effects.enter(types.labelImageMarker);\n    effects.consume(code);\n    effects.exit(types.labelImageMarker);\n    return open;\n  }\n  function open(code) {\n    if (code === codes.leftSquareBracket) {\n      effects.enter(types.labelMarker);\n      effects.consume(code);\n      effects.exit(types.labelMarker);\n      effects.exit(types.labelImage);\n      return after;\n    }\n    return nok(code);\n  }\n  function after(code) {\n    return code === codes.caret && \"_hiddenFootnoteSupport\" in self.parser.constructs ? nok(code) : ok2(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/label-start-link.js\nvar labelStartLink = {\n  name: \"labelStartLink\",\n  resolveAll: labelEnd.resolveAll,\n  tokenize: tokenizeLabelStartLink\n};\nfunction tokenizeLabelStartLink(effects, ok2, nok) {\n  const self = this;\n  return start;\n  function start(code) {\n    ok(code === codes.leftSquareBracket, \"expected `[`\");\n    effects.enter(types.labelLink);\n    effects.enter(types.labelMarker);\n    effects.consume(code);\n    effects.exit(types.labelMarker);\n    effects.exit(types.labelLink);\n    return after;\n  }\n  function after(code) {\n    return code === codes.caret && \"_hiddenFootnoteSupport\" in self.parser.constructs ? nok(code) : ok2(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/line-ending.js\nvar lineEnding = { name: \"lineEnding\", tokenize: tokenizeLineEnding };\nfunction tokenizeLineEnding(effects, ok2) {\n  return start;\n  function start(code) {\n    ok(markdownLineEnding(code), \"expected eol\");\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return factorySpace(effects, ok2, types.linePrefix);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/thematic-break.js\nvar thematicBreak = {\n  name: \"thematicBreak\",\n  tokenize: tokenizeThematicBreak\n};\nfunction tokenizeThematicBreak(effects, ok2, nok) {\n  let size = 0;\n  let marker;\n  return start;\n  function start(code) {\n    effects.enter(types.thematicBreak);\n    return before(code);\n  }\n  function before(code) {\n    ok(\n      code === codes.asterisk || code === codes.dash || code === codes.underscore,\n      \"expected `*`, `-`, or `_`\"\n    );\n    marker = code;\n    return atBreak(code);\n  }\n  function atBreak(code) {\n    if (code === marker) {\n      effects.enter(types.thematicBreakSequence);\n      return sequence(code);\n    }\n    if (size >= constants.thematicBreakMarkerCountMin && (code === codes.eof || markdownLineEnding(code))) {\n      effects.exit(types.thematicBreak);\n      return ok2(code);\n    }\n    return nok(code);\n  }\n  function sequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      size++;\n      return sequence;\n    }\n    effects.exit(types.thematicBreakSequence);\n    return markdownSpace(code) ? factorySpace(effects, atBreak, types.whitespace)(code) : atBreak(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/list.js\nvar list = {\n  continuation: { tokenize: tokenizeListContinuation },\n  exit: tokenizeListEnd,\n  name: \"list\",\n  tokenize: tokenizeListStart\n};\nvar listItemPrefixWhitespaceConstruct = {\n  partial: true,\n  tokenize: tokenizeListItemPrefixWhitespace\n};\nvar indentConstruct = { partial: true, tokenize: tokenizeIndent };\nfunction tokenizeListStart(effects, ok2, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  let initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let size = 0;\n  return start;\n  function start(code) {\n    ok(self.containerState, \"expected state\");\n    const kind = self.containerState.type || (code === codes.asterisk || code === codes.plusSign || code === codes.dash ? types.listUnordered : types.listOrdered);\n    if (kind === types.listUnordered ? !self.containerState.marker || code === self.containerState.marker : asciiDigit(code)) {\n      if (!self.containerState.type) {\n        self.containerState.type = kind;\n        effects.enter(kind, { _container: true });\n      }\n      if (kind === types.listUnordered) {\n        effects.enter(types.listItemPrefix);\n        return code === codes.asterisk || code === codes.dash ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);\n      }\n      if (!self.interrupt || code === codes.digit1) {\n        effects.enter(types.listItemPrefix);\n        effects.enter(types.listItemValue);\n        return inside(code);\n      }\n    }\n    return nok(code);\n  }\n  function inside(code) {\n    ok(self.containerState, \"expected state\");\n    if (asciiDigit(code) && ++size < constants.listItemValueSizeMax) {\n      effects.consume(code);\n      return inside;\n    }\n    if ((!self.interrupt || size < 2) && (self.containerState.marker ? code === self.containerState.marker : code === codes.rightParenthesis || code === codes.dot)) {\n      effects.exit(types.listItemValue);\n      return atMarker(code);\n    }\n    return nok(code);\n  }\n  function atMarker(code) {\n    ok(self.containerState, \"expected state\");\n    ok(code !== codes.eof, \"eof (`null`) is not a marker\");\n    effects.enter(types.listItemMarker);\n    effects.consume(code);\n    effects.exit(types.listItemMarker);\n    self.containerState.marker = self.containerState.marker || code;\n    return effects.check(\n      blankLine,\n      // Cant be empty when interrupting.\n      self.interrupt ? nok : onBlank,\n      effects.attempt(\n        listItemPrefixWhitespaceConstruct,\n        endOfPrefix,\n        otherPrefix\n      )\n    );\n  }\n  function onBlank(code) {\n    ok(self.containerState, \"expected state\");\n    self.containerState.initialBlankLine = true;\n    initialSize++;\n    return endOfPrefix(code);\n  }\n  function otherPrefix(code) {\n    if (markdownSpace(code)) {\n      effects.enter(types.listItemPrefixWhitespace);\n      effects.consume(code);\n      effects.exit(types.listItemPrefixWhitespace);\n      return endOfPrefix;\n    }\n    return nok(code);\n  }\n  function endOfPrefix(code) {\n    ok(self.containerState, \"expected state\");\n    self.containerState.size = initialSize + self.sliceSerialize(effects.exit(types.listItemPrefix), true).length;\n    return ok2(code);\n  }\n}\nfunction tokenizeListContinuation(effects, ok2, nok) {\n  const self = this;\n  ok(self.containerState, \"expected state\");\n  self.containerState._closeFlow = void 0;\n  return effects.check(blankLine, onBlank, notBlank);\n  function onBlank(code) {\n    ok(self.containerState, \"expected state\");\n    ok(typeof self.containerState.size === \"number\", \"expected size\");\n    self.containerState.furtherBlankLines = self.containerState.furtherBlankLines || self.containerState.initialBlankLine;\n    return factorySpace(\n      effects,\n      ok2,\n      types.listItemIndent,\n      self.containerState.size + 1\n    )(code);\n  }\n  function notBlank(code) {\n    ok(self.containerState, \"expected state\");\n    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {\n      self.containerState.furtherBlankLines = void 0;\n      self.containerState.initialBlankLine = void 0;\n      return notInCurrentItem(code);\n    }\n    self.containerState.furtherBlankLines = void 0;\n    self.containerState.initialBlankLine = void 0;\n    return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code);\n  }\n  function notInCurrentItem(code) {\n    ok(self.containerState, \"expected state\");\n    self.containerState._closeFlow = true;\n    self.interrupt = void 0;\n    ok(\n      self.parser.constructs.disable.null,\n      \"expected `disable.null` to be populated\"\n    );\n    return factorySpace(\n      effects,\n      effects.attempt(list, ok2, nok),\n      types.linePrefix,\n      self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize\n    )(code);\n  }\n}\nfunction tokenizeIndent(effects, ok2, nok) {\n  const self = this;\n  ok(self.containerState, \"expected state\");\n  ok(typeof self.containerState.size === \"number\", \"expected size\");\n  return factorySpace(\n    effects,\n    afterPrefix,\n    types.listItemIndent,\n    self.containerState.size + 1\n  );\n  function afterPrefix(code) {\n    ok(self.containerState, \"expected state\");\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === types.listItemIndent && tail[2].sliceSerialize(tail[1], true).length === self.containerState.size ? ok2(code) : nok(code);\n  }\n}\nfunction tokenizeListEnd(effects) {\n  ok(this.containerState, \"expected state\");\n  ok(typeof this.containerState.type === \"string\", \"expected type\");\n  effects.exit(this.containerState.type);\n}\nfunction tokenizeListItemPrefixWhitespace(effects, ok2, nok) {\n  const self = this;\n  ok(\n    self.parser.constructs.disable.null,\n    \"expected `disable.null` to be populated\"\n  );\n  return factorySpace(\n    effects,\n    afterPrefix,\n    types.listItemPrefixWhitespace,\n    self.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : constants.tabSize + 1\n  );\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return !markdownSpace(code) && tail && tail[1].type === types.listItemPrefixWhitespace ? ok2(code) : nok(code);\n  }\n}\n\n// node_modules/micromark-core-commonmark/dev/lib/setext-underline.js\nvar setextUnderline = {\n  name: \"setextUnderline\",\n  resolveTo: resolveToSetextUnderline,\n  tokenize: tokenizeSetextUnderline\n};\nfunction resolveToSetextUnderline(events, context) {\n  let index = events.length;\n  let content2;\n  let text;\n  let definition2;\n  while (index--) {\n    if (events[index][0] === \"enter\") {\n      if (events[index][1].type === types.content) {\n        content2 = index;\n        break;\n      }\n      if (events[index][1].type === types.paragraph) {\n        text = index;\n      }\n    } else {\n      if (events[index][1].type === types.content) {\n        events.splice(index, 1);\n      }\n      if (!definition2 && events[index][1].type === types.definition) {\n        definition2 = index;\n      }\n    }\n  }\n  ok(text !== void 0, \"expected a `text` index to be found\");\n  ok(content2 !== void 0, \"expected a `text` index to be found\");\n  ok(events[content2][2] === context, \"enter context should be same\");\n  ok(\n    events[events.length - 1][2] === context,\n    \"enter context should be same\"\n  );\n  const heading = {\n    type: types.setextHeading,\n    start: { ...events[content2][1].start },\n    end: { ...events[events.length - 1][1].end }\n  };\n  events[text][1].type = types.setextHeadingText;\n  if (definition2) {\n    events.splice(text, 0, [\"enter\", heading, context]);\n    events.splice(definition2 + 1, 0, [\"exit\", events[content2][1], context]);\n    events[content2][1].end = { ...events[definition2][1].end };\n  } else {\n    events[content2][1] = heading;\n  }\n  events.push([\"exit\", heading, context]);\n  return events;\n}\nfunction tokenizeSetextUnderline(effects, ok2, nok) {\n  const self = this;\n  let marker;\n  return start;\n  function start(code) {\n    let index = self.events.length;\n    let paragraph;\n    ok(\n      code === codes.dash || code === codes.equalsTo,\n      \"expected `=` or `-`\"\n    );\n    while (index--) {\n      if (self.events[index][1].type !== types.lineEnding && self.events[index][1].type !== types.linePrefix && self.events[index][1].type !== types.content) {\n        paragraph = self.events[index][1].type === types.paragraph;\n        break;\n      }\n    }\n    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {\n      effects.enter(types.setextHeadingLine);\n      marker = code;\n      return before(code);\n    }\n    return nok(code);\n  }\n  function before(code) {\n    effects.enter(types.setextHeadingLineSequence);\n    return inside(code);\n  }\n  function inside(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return inside;\n    }\n    effects.exit(types.setextHeadingLineSequence);\n    return markdownSpace(code) ? factorySpace(effects, after, types.lineSuffix)(code) : after(code);\n  }\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.setextHeadingLine);\n      return ok2(code);\n    }\n    return nok(code);\n  }\n}\n\nexport {\n  normalizeIdentifier,\n  classifyCharacter,\n  visit,\n  toString,\n  decodeNamedCharacterReference,\n  decodeNumericCharacterReference,\n  decodeString,\n  splice,\n  push,\n  combineExtensions,\n  normalizeUri,\n  resolveAll,\n  attention,\n  autolink,\n  blankLine,\n  blockQuote,\n  characterEscape,\n  characterReference,\n  codeFenced,\n  codeIndented,\n  codeText,\n  subtokenize,\n  content,\n  definition,\n  hardBreakEscape,\n  headingAtx,\n  htmlFlow,\n  htmlText,\n  labelEnd,\n  labelStartImage,\n  labelStartLink,\n  lineEnding,\n  thematicBreak,\n  list,\n  setextUnderline\n};\n//# sourceMappingURL=chunk-WKZH733J.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.752Z",
        "time": 1.9339999998919666,
        "timings": {
          "blocked": 0.6260000020170119,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.45800000115786677,
          "receive": 0.8499999967170879,
          "_blocked_queueing": 0.5970000020170119,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_fromCache": "disk",
        "_initiator": {
          "type": "script",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-markdown.js?v=2a7591ed",
          "lineNumber": 10
        },
        "_priority": "High",
        "_resourceType": "script",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-S725DACQ.js?v=2a7591ed",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/react-markdown.js?v=2a7591ed"
            }
          ],
          "queryString": [
            {
              "name": "v",
              "value": "2a7591ed"
            }
          ],
          "cookies": [],
          "headersSize": -1,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "http/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Cache-Control",
              "value": "max-age=31536000,immutable"
            },
            {
              "name": "Content-Length",
              "value": "37420"
            },
            {
              "name": "Etag",
              "value": "W/\"922c-OWKt+rPeMdAu4LHONJ0ykaSmU6A\""
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:20:28 GMT"
            },
            {
              "name": "Content-Type",
              "value": "text/javascript"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 37420,
            "mimeType": "text/javascript",
            "text": "import {\n  require_react\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-RLJ2RCJQ.js?v=2a7591ed\";\nimport {\n  __commonJS\n} from \"/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-DC5AMYBS.js?v=2a7591ed\";\n\n// node_modules/react/cjs/react-jsx-runtime.development.js\nvar require_react_jsx_runtime_development = __commonJS({\n  \"node_modules/react/cjs/react-jsx-runtime.development.js\"(exports) {\n    \"use strict\";\n    if (true) {\n      (function() {\n        \"use strict\";\n        var React = require_react();\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n          if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n            return null;\n          }\n          var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n          if (typeof maybeIterator === \"function\") {\n            return maybeIterator;\n          }\n          return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n          {\n            {\n              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n                args[_key2 - 1] = arguments[_key2];\n              }\n              printWarning(\"error\", format, args);\n            }\n          }\n        }\n        function printWarning(level, format, args) {\n          {\n            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n            var stack = ReactDebugCurrentFrame2.getStackAddendum();\n            if (stack !== \"\") {\n              format += \"%s\";\n              args = args.concat([stack]);\n            }\n            var argsWithFormat = args.map(function(item) {\n              return String(item);\n            });\n            argsWithFormat.unshift(\"Warning: \" + format);\n            Function.prototype.apply.call(console[level], console, argsWithFormat);\n          }\n        }\n        var enableScopeAPI = false;\n        var enableCacheElement = false;\n        var enableTransitionTracing = false;\n        var enableLegacyHidden = false;\n        var enableDebugTracing = false;\n        var REACT_MODULE_REFERENCE;\n        {\n          REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n        }\n        function isValidElementType(type) {\n          if (typeof type === \"string\" || typeof type === \"function\") {\n            return true;\n          }\n          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n            return true;\n          }\n          if (typeof type === \"object\" && type !== null) {\n            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n            // types supported by any Flight configuration anywhere since\n            // we don't know which Flight build this will end up being used\n            // with.\n            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n              return true;\n            }\n          }\n          return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n          var displayName = outerType.displayName;\n          if (displayName) {\n            return displayName;\n          }\n          var functionName = innerType.displayName || innerType.name || \"\";\n          return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        }\n        function getContextName(type) {\n          return type.displayName || \"Context\";\n        }\n        function getComponentNameFromType(type) {\n          if (type == null) {\n            return null;\n          }\n          {\n            if (typeof type.tag === \"number\") {\n              error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n            }\n          }\n          if (typeof type === \"function\") {\n            return type.displayName || type.name || null;\n          }\n          if (typeof type === \"string\") {\n            return type;\n          }\n          switch (type) {\n            case REACT_FRAGMENT_TYPE:\n              return \"Fragment\";\n            case REACT_PORTAL_TYPE:\n              return \"Portal\";\n            case REACT_PROFILER_TYPE:\n              return \"Profiler\";\n            case REACT_STRICT_MODE_TYPE:\n              return \"StrictMode\";\n            case REACT_SUSPENSE_TYPE:\n              return \"Suspense\";\n            case REACT_SUSPENSE_LIST_TYPE:\n              return \"SuspenseList\";\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_CONTEXT_TYPE:\n                var context = type;\n                return getContextName(context) + \".Consumer\";\n              case REACT_PROVIDER_TYPE:\n                var provider = type;\n                return getContextName(provider._context) + \".Provider\";\n              case REACT_FORWARD_REF_TYPE:\n                return getWrappedName(type, type.render, \"ForwardRef\");\n              case REACT_MEMO_TYPE:\n                var outerName = type.displayName || null;\n                if (outerName !== null) {\n                  return outerName;\n                }\n                return getComponentNameFromType(type.type) || \"Memo\";\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return getComponentNameFromType(init(payload));\n                } catch (x) {\n                  return null;\n                }\n              }\n            }\n          }\n          return null;\n        }\n        var assign = Object.assign;\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {\n        }\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n          {\n            if (disabledDepth === 0) {\n              prevLog = console.log;\n              prevInfo = console.info;\n              prevWarn = console.warn;\n              prevError = console.error;\n              prevGroup = console.group;\n              prevGroupCollapsed = console.groupCollapsed;\n              prevGroupEnd = console.groupEnd;\n              var props = {\n                configurable: true,\n                enumerable: true,\n                value: disabledLog,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                info: props,\n                log: props,\n                warn: props,\n                error: props,\n                group: props,\n                groupCollapsed: props,\n                groupEnd: props\n              });\n            }\n            disabledDepth++;\n          }\n        }\n        function reenableLogs() {\n          {\n            disabledDepth--;\n            if (disabledDepth === 0) {\n              var props = {\n                configurable: true,\n                enumerable: true,\n                writable: true\n              };\n              Object.defineProperties(console, {\n                log: assign({}, props, {\n                  value: prevLog\n                }),\n                info: assign({}, props, {\n                  value: prevInfo\n                }),\n                warn: assign({}, props, {\n                  value: prevWarn\n                }),\n                error: assign({}, props, {\n                  value: prevError\n                }),\n                group: assign({}, props, {\n                  value: prevGroup\n                }),\n                groupCollapsed: assign({}, props, {\n                  value: prevGroupCollapsed\n                }),\n                groupEnd: assign({}, props, {\n                  value: prevGroupEnd\n                })\n              });\n            }\n            if (disabledDepth < 0) {\n              error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n            }\n          }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n          {\n            if (prefix === void 0) {\n              try {\n                throw Error();\n              } catch (x) {\n                var match = x.stack.trim().match(/\\n( *(at )?)/);\n                prefix = match && match[1] || \"\";\n              }\n            }\n            return \"\\n\" + prefix + name;\n          }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n          var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n          componentFrameCache = new PossiblyWeakMap();\n        }\n        function describeNativeComponentFrame(fn, construct) {\n          if (!fn || reentry) {\n            return \"\";\n          }\n          {\n            var frame = componentFrameCache.get(fn);\n            if (frame !== void 0) {\n              return frame;\n            }\n          }\n          var control;\n          reentry = true;\n          var previousPrepareStackTrace = Error.prepareStackTrace;\n          Error.prepareStackTrace = void 0;\n          var previousDispatcher;\n          {\n            previousDispatcher = ReactCurrentDispatcher.current;\n            ReactCurrentDispatcher.current = null;\n            disableLogs();\n          }\n          try {\n            if (construct) {\n              var Fake = function() {\n                throw Error();\n              };\n              Object.defineProperty(Fake.prototype, \"props\", {\n                set: function() {\n                  throw Error();\n                }\n              });\n              if (typeof Reflect === \"object\" && Reflect.construct) {\n                try {\n                  Reflect.construct(Fake, []);\n                } catch (x) {\n                  control = x;\n                }\n                Reflect.construct(fn, [], Fake);\n              } else {\n                try {\n                  Fake.call();\n                } catch (x) {\n                  control = x;\n                }\n                fn.call(Fake.prototype);\n              }\n            } else {\n              try {\n                throw Error();\n              } catch (x) {\n                control = x;\n              }\n              fn();\n            }\n          } catch (sample) {\n            if (sample && control && typeof sample.stack === \"string\") {\n              var sampleLines = sample.stack.split(\"\\n\");\n              var controlLines = control.stack.split(\"\\n\");\n              var s = sampleLines.length - 1;\n              var c = controlLines.length - 1;\n              while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n                c--;\n              }\n              for (; s >= 1 && c >= 0; s--, c--) {\n                if (sampleLines[s] !== controlLines[c]) {\n                  if (s !== 1 || c !== 1) {\n                    do {\n                      s--;\n                      c--;\n                      if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                          _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                        }\n                        {\n                          if (typeof fn === \"function\") {\n                            componentFrameCache.set(fn, _frame);\n                          }\n                        }\n                        return _frame;\n                      }\n                    } while (s >= 1 && c >= 0);\n                  }\n                  break;\n                }\n              }\n            }\n          } finally {\n            reentry = false;\n            {\n              ReactCurrentDispatcher.current = previousDispatcher;\n              reenableLogs();\n            }\n            Error.prepareStackTrace = previousPrepareStackTrace;\n          }\n          var name = fn ? fn.displayName || fn.name : \"\";\n          var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n          {\n            if (typeof fn === \"function\") {\n              componentFrameCache.set(fn, syntheticFrame);\n            }\n          }\n          return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n          {\n            return describeNativeComponentFrame(fn, false);\n          }\n        }\n        function shouldConstruct(Component) {\n          var prototype = Component.prototype;\n          return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n          if (type == null) {\n            return \"\";\n          }\n          if (typeof type === \"function\") {\n            {\n              return describeNativeComponentFrame(type, shouldConstruct(type));\n            }\n          }\n          if (typeof type === \"string\") {\n            return describeBuiltInComponentFrame(type);\n          }\n          switch (type) {\n            case REACT_SUSPENSE_TYPE:\n              return describeBuiltInComponentFrame(\"Suspense\");\n            case REACT_SUSPENSE_LIST_TYPE:\n              return describeBuiltInComponentFrame(\"SuspenseList\");\n          }\n          if (typeof type === \"object\") {\n            switch (type.$$typeof) {\n              case REACT_FORWARD_REF_TYPE:\n                return describeFunctionComponentFrame(type.render);\n              case REACT_MEMO_TYPE:\n                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n              case REACT_LAZY_TYPE: {\n                var lazyComponent = type;\n                var payload = lazyComponent._payload;\n                var init = lazyComponent._init;\n                try {\n                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                } catch (x) {\n                }\n              }\n            }\n          }\n          return \"\";\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame.setExtraStackFrame(null);\n            }\n          }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n          {\n            var has = Function.call.bind(hasOwnProperty);\n            for (var typeSpecName in typeSpecs) {\n              if (has(typeSpecs, typeSpecName)) {\n                var error$1 = void 0;\n                try {\n                  if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                    var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                    err.name = \"Invariant Violation\";\n                    throw err;\n                  }\n                  error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                } catch (ex) {\n                  error$1 = ex;\n                }\n                if (error$1 && !(error$1 instanceof Error)) {\n                  setCurrentlyValidatingElement(element);\n                  error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                  setCurrentlyValidatingElement(null);\n                }\n                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                  loggedTypeFailures[error$1.message] = true;\n                  setCurrentlyValidatingElement(element);\n                  error(\"Failed %s type: %s\", location, error$1.message);\n                  setCurrentlyValidatingElement(null);\n                }\n              }\n            }\n          }\n        }\n        var isArrayImpl = Array.isArray;\n        function isArray(a) {\n          return isArrayImpl(a);\n        }\n        function typeName(value) {\n          {\n            var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n            var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n            return type;\n          }\n        }\n        function willCoercionThrow(value) {\n          {\n            try {\n              testStringCoercion(value);\n              return false;\n            } catch (e) {\n              return true;\n            }\n          }\n        }\n        function testStringCoercion(value) {\n          return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n          {\n            if (willCoercionThrow(value)) {\n              error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n              return testStringCoercion(value);\n            }\n          }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n          key: true,\n          ref: true,\n          __self: true,\n          __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n          didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n          {\n            if (hasOwnProperty.call(config, \"ref\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.ref !== void 0;\n        }\n        function hasValidKey(config) {\n          {\n            if (hasOwnProperty.call(config, \"key\")) {\n              var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n              if (getter && getter.isReactWarning) {\n                return false;\n              }\n            }\n          }\n          return config.key !== void 0;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n          {\n            if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n              var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n              if (!didWarnAboutStringRefs[componentName]) {\n                error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n                didWarnAboutStringRefs[componentName] = true;\n              }\n            }\n          }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n          {\n            var warnAboutAccessingKey = function() {\n              if (!specialPropKeyWarningShown) {\n                specialPropKeyWarningShown = true;\n                error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            };\n            warnAboutAccessingKey.isReactWarning = true;\n            Object.defineProperty(props, \"key\", {\n              get: warnAboutAccessingKey,\n              configurable: true\n            });\n          }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n          {\n            var warnAboutAccessingRef = function() {\n              if (!specialPropRefWarningShown) {\n                specialPropRefWarningShown = true;\n                error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n              }\n            };\n            warnAboutAccessingRef.isReactWarning = true;\n            Object.defineProperty(props, \"ref\", {\n              get: warnAboutAccessingRef,\n              configurable: true\n            });\n          }\n        }\n        var ReactElement = function(type, key, ref, self, source, owner, props) {\n          var element = {\n            // This tag allows us to uniquely identify this as a React Element\n            $$typeof: REACT_ELEMENT_TYPE,\n            // Built-in properties that belong on the element\n            type,\n            key,\n            ref,\n            props,\n            // Record the component responsible for creating this element.\n            _owner: owner\n          };\n          {\n            element._store = {};\n            Object.defineProperty(element._store, \"validated\", {\n              configurable: false,\n              enumerable: false,\n              writable: true,\n              value: false\n            });\n            Object.defineProperty(element, \"_self\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: self\n            });\n            Object.defineProperty(element, \"_source\", {\n              configurable: false,\n              enumerable: false,\n              writable: false,\n              value: source\n            });\n            if (Object.freeze) {\n              Object.freeze(element.props);\n              Object.freeze(element);\n            }\n          }\n          return element;\n        };\n        function jsxDEV(type, config, maybeKey, source, self) {\n          {\n            var propName;\n            var props = {};\n            var key = null;\n            var ref = null;\n            if (maybeKey !== void 0) {\n              {\n                checkKeyStringCoercion(maybeKey);\n              }\n              key = \"\" + maybeKey;\n            }\n            if (hasValidKey(config)) {\n              {\n                checkKeyStringCoercion(config.key);\n              }\n              key = \"\" + config.key;\n            }\n            if (hasValidRef(config)) {\n              ref = config.ref;\n              warnIfStringRefCannotBeAutoConverted(config, self);\n            }\n            for (propName in config) {\n              if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                props[propName] = config[propName];\n              }\n            }\n            if (type && type.defaultProps) {\n              var defaultProps = type.defaultProps;\n              for (propName in defaultProps) {\n                if (props[propName] === void 0) {\n                  props[propName] = defaultProps[propName];\n                }\n              }\n            }\n            if (key || ref) {\n              var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n              if (key) {\n                defineKeyPropWarningGetter(props, displayName);\n              }\n              if (ref) {\n                defineRefPropWarningGetter(props, displayName);\n              }\n            }\n            return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n          }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n          {\n            if (element) {\n              var owner = element._owner;\n              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n              ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n            } else {\n              ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n            }\n          }\n        }\n        var propTypesMisspellWarningShown;\n        {\n          propTypesMisspellWarningShown = false;\n        }\n        function isValidElement(object) {\n          {\n            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n          }\n        }\n        function getDeclarationErrorAddendum() {\n          {\n            if (ReactCurrentOwner$1.current) {\n              var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n              if (name) {\n                return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n              }\n            }\n            return \"\";\n          }\n        }\n        function getSourceInfoErrorAddendum(source) {\n          {\n            if (source !== void 0) {\n              var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n              var lineNumber = source.lineNumber;\n              return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n            }\n            return \"\";\n          }\n        }\n        var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n          {\n            var info = getDeclarationErrorAddendum();\n            if (!info) {\n              var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n              if (parentName) {\n                info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n              }\n            }\n            return info;\n          }\n        }\n        function validateExplicitKey(element, parentType) {\n          {\n            if (!element._store || element._store.validated || element.key != null) {\n              return;\n            }\n            element._store.validated = true;\n            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n              return;\n            }\n            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n            var childOwner = \"\";\n            if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n              childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n            }\n            setCurrentlyValidatingElement$1(element);\n            error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n        function validateChildKeys(node, parentType) {\n          {\n            if (typeof node !== \"object\") {\n              return;\n            }\n            if (isArray(node)) {\n              for (var i = 0; i < node.length; i++) {\n                var child = node[i];\n                if (isValidElement(child)) {\n                  validateExplicitKey(child, parentType);\n                }\n              }\n            } else if (isValidElement(node)) {\n              if (node._store) {\n                node._store.validated = true;\n              }\n            } else if (node) {\n              var iteratorFn = getIteratorFn(node);\n              if (typeof iteratorFn === \"function\") {\n                if (iteratorFn !== node.entries) {\n                  var iterator = iteratorFn.call(node);\n                  var step;\n                  while (!(step = iterator.next()).done) {\n                    if (isValidElement(step.value)) {\n                      validateExplicitKey(step.value, parentType);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        function validatePropTypes(element) {\n          {\n            var type = element.type;\n            if (type === null || type === void 0 || typeof type === \"string\") {\n              return;\n            }\n            var propTypes;\n            if (typeof type === \"function\") {\n              propTypes = type.propTypes;\n            } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n            // Inner props are checked in the reconciler.\n            type.$$typeof === REACT_MEMO_TYPE)) {\n              propTypes = type.propTypes;\n            } else {\n              return;\n            }\n            if (propTypes) {\n              var name = getComponentNameFromType(type);\n              checkPropTypes(propTypes, element.props, \"prop\", name, element);\n            } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n              propTypesMisspellWarningShown = true;\n              var _name = getComponentNameFromType(type);\n              error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n            }\n            if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n              error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n            }\n          }\n        }\n        function validateFragmentProps(fragment) {\n          {\n            var keys = Object.keys(fragment.props);\n            for (var i = 0; i < keys.length; i++) {\n              var key = keys[i];\n              if (key !== \"children\" && key !== \"key\") {\n                setCurrentlyValidatingElement$1(fragment);\n                error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n                setCurrentlyValidatingElement$1(null);\n                break;\n              }\n            }\n            if (fragment.ref !== null) {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n              setCurrentlyValidatingElement$1(null);\n            }\n          }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n          {\n            var validType = isValidElementType(type);\n            if (!validType) {\n              var info = \"\";\n              if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n              }\n              var sourceInfo = getSourceInfoErrorAddendum(source);\n              if (sourceInfo) {\n                info += sourceInfo;\n              } else {\n                info += getDeclarationErrorAddendum();\n              }\n              var typeString;\n              if (type === null) {\n                typeString = \"null\";\n              } else if (isArray(type)) {\n                typeString = \"array\";\n              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n                typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                info = \" Did you accidentally export a JSX literal instead of a component?\";\n              } else {\n                typeString = typeof type;\n              }\n              error(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n            }\n            var element = jsxDEV(type, props, key, source, self);\n            if (element == null) {\n              return element;\n            }\n            if (validType) {\n              var children = props.children;\n              if (children !== void 0) {\n                if (isStaticChildren) {\n                  if (isArray(children)) {\n                    for (var i = 0; i < children.length; i++) {\n                      validateChildKeys(children[i], type);\n                    }\n                    if (Object.freeze) {\n                      Object.freeze(children);\n                    }\n                  } else {\n                    error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n                  }\n                } else {\n                  validateChildKeys(children, type);\n                }\n              }\n            }\n            {\n              if (hasOwnProperty.call(props, \"key\")) {\n                var componentName = getComponentNameFromType(type);\n                var keys = Object.keys(props).filter(function(k) {\n                  return k !== \"key\";\n                });\n                var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                  var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                  error('A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n                  didWarnAboutKeySpread[componentName + beforeExample] = true;\n                }\n              }\n            }\n            if (type === REACT_FRAGMENT_TYPE) {\n              validateFragmentProps(element);\n            } else {\n              validatePropTypes(element);\n            }\n            return element;\n          }\n        }\n        function jsxWithValidationStatic(type, props, key) {\n          {\n            return jsxWithValidation(type, props, key, true);\n          }\n        }\n        function jsxWithValidationDynamic(type, props, key) {\n          {\n            return jsxWithValidation(type, props, key, false);\n          }\n        }\n        var jsx = jsxWithValidationDynamic;\n        var jsxs = jsxWithValidationStatic;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsx = jsx;\n        exports.jsxs = jsxs;\n      })();\n    }\n  }\n});\n\n// node_modules/react/jsx-runtime.js\nvar require_jsx_runtime = __commonJS({\n  \"node_modules/react/jsx-runtime.js\"(exports, module) {\n    if (false) {\n      module.exports = null;\n    } else {\n      module.exports = require_react_jsx_runtime_development();\n    }\n  }\n});\n\nexport {\n  require_jsx_runtime\n};\n/*! Bundled license information:\n\nreact/cjs/react-jsx-runtime.development.js:\n  (**\n   * @license React\n   * react-jsx-runtime.development.js\n   *\n   * Copyright (c) Facebook, Inc. and its affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *)\n*/\n//# sourceMappingURL=chunk-S725DACQ.js.map\n"
          },
          "redirectURL": "",
          "headersSize": -1,
          "bodySize": 0,
          "_transferSize": 0,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.752Z",
        "time": 1.6249999971478246,
        "timings": {
          "blocked": 0.5530000001473818,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0,
          "wait": 0.7400000010218937,
          "receive": 0.3319999959785491,
          "_blocked_queueing": 0.5270000001473818,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184650",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "getStatistics",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 76,
                "columnNumber": 27
              },
              {
                "functionName": "fetchStatistics",
                "scriptId": "146",
                "url": "http://localhost:5174/hooks/useStatistics.ts",
                "lineNumber": 11,
                "columnNumber": 30
              },
              {
                "functionName": "",
                "scriptId": "146",
                "url": "http://localhost:5174/hooks/useStatistics.ts",
                "lineNumber": 20,
                "columnNumber": 4
              },
              {
                "functionName": "commitHookEffectListMount",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 16914,
                "columnNumber": 33
              },
              {
                "functionName": "commitPassiveMountOnFiber",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18155,
                "columnNumber": 18
              },
              {
                "functionName": "commitPassiveMountEffects_complete",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18128,
                "columnNumber": 16
              },
              {
                "functionName": "commitPassiveMountEffects_begin",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18118,
                "columnNumber": 14
              },
              {
                "functionName": "commitPassiveMountEffects",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18108,
                "columnNumber": 10
              },
              {
                "functionName": "flushPassiveEffectsImpl",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19489,
                "columnNumber": 10
              },
              {
                "functionName": "flushPassiveEffects",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19446,
                "columnNumber": 21
              },
              {
                "functionName": "",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19327,
                "columnNumber": 16
              },
              {
                "functionName": "workLoop",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 196,
                "columnNumber": 41
              },
              {
                "functionName": "flushWork",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 175,
                "columnNumber": 21
              },
              {
                "functionName": "performWorkUntilDeadline",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 383,
                "columnNumber": 28
              }
            ],
            "parentId": {
              "id": "4",
              "debuggerId": "-3895047138506156908.5457165050697095993"
            }
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/api/statistics",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"53-3mo5HoiCIURbeVRycbxPOGP+KpI\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 483,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Vary",
              "value": "Origin"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "connection",
              "value": "close"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"53-3mo5HoiCIURbeVRycbxPOGP+KpI\""
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 83,
            "mimeType": "application/json",
            "text": "{\"success\":true,\"data\":{\"promptCount\":66,\"lastUpdated\":\"2025-08-06T21:32:27.546Z\"}}"
          },
          "redirectURL": "",
          "headersSize": 558,
          "bodySize": 0,
          "_transferSize": 558,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.798Z",
        "time": 7.276000000274507,
        "timings": {
          "blocked": 1.4060000000819564,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.14500000000000002,
          "wait": 5.461000001768582,
          "receive": 0.2639999984239694,
          "_blocked_queueing": 0.6880000000819564,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184658",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "getModels",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 72,
                "columnNumber": 27
              },
              {
                "functionName": "fetchModels",
                "scriptId": "147",
                "url": "http://localhost:5174/hooks/useModels.ts",
                "lineNumber": 10,
                "columnNumber": 35
              },
              {
                "functionName": "",
                "scriptId": "147",
                "url": "http://localhost:5174/hooks/useModels.ts",
                "lineNumber": 21,
                "columnNumber": 4
              },
              {
                "functionName": "commitHookEffectListMount",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 16914,
                "columnNumber": 33
              },
              {
                "functionName": "commitPassiveMountOnFiber",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18155,
                "columnNumber": 18
              },
              {
                "functionName": "commitPassiveMountEffects_complete",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18128,
                "columnNumber": 16
              },
              {
                "functionName": "commitPassiveMountEffects_begin",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18118,
                "columnNumber": 14
              },
              {
                "functionName": "commitPassiveMountEffects",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18108,
                "columnNumber": 10
              },
              {
                "functionName": "flushPassiveEffectsImpl",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19489,
                "columnNumber": 10
              },
              {
                "functionName": "flushPassiveEffects",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19446,
                "columnNumber": 21
              },
              {
                "functionName": "",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19327,
                "columnNumber": 16
              },
              {
                "functionName": "workLoop",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 196,
                "columnNumber": 41
              },
              {
                "functionName": "flushWork",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 175,
                "columnNumber": 21
              },
              {
                "functionName": "performWorkUntilDeadline",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 383,
                "columnNumber": 28
              }
            ],
            "parentId": {
              "id": "4",
              "debuggerId": "-3895047138506156908.5457165050697095993"
            }
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/api/llm/models",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"97-RFfviI1KSEPef5unwSMjk2JWc/M\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 483,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Vary",
              "value": "Origin"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "connection",
              "value": "close"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"97-RFfviI1KSEPef5unwSMjk2JWc/M\""
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 151,
            "mimeType": "application/json",
            "text": "{\"success\":true,\"data\":{\"openai\":[\"gpt-4o-mini-2024-07-18\",\"gpt-3.5-turbo-0125\"],\"anthropic\":[\"claude-3-5-haiku-latest\",\"claude-3-5-sonnet-20240620\"]}}"
          },
          "redirectURL": "",
          "headersSize": 558,
          "bodySize": 0,
          "_transferSize": 558,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.798Z",
        "time": 8.301999998366227,
        "timings": {
          "blocked": 1.4349999994805547,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.06900000000000006,
          "wait": 6.464999998930609,
          "receive": 0.3329999999550637,
          "_blocked_queueing": 0.6109999994805548,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184622",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "getStatistics",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 76,
                "columnNumber": 27
              },
              {
                "functionName": "fetchStatistics",
                "scriptId": "146",
                "url": "http://localhost:5174/hooks/useStatistics.ts",
                "lineNumber": 11,
                "columnNumber": 30
              },
              {
                "functionName": "",
                "scriptId": "146",
                "url": "http://localhost:5174/hooks/useStatistics.ts",
                "lineNumber": 20,
                "columnNumber": 4
              },
              {
                "functionName": "commitHookEffectListMount",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 16914,
                "columnNumber": 33
              },
              {
                "functionName": "invokePassiveEffectMountInDEV",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18323,
                "columnNumber": 18
              },
              {
                "functionName": "invokeEffectsInDev",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19700,
                "columnNumber": 18
              },
              {
                "functionName": "commitDoubleInvokeEffectsInDEV",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19685,
                "columnNumber": 14
              },
              {
                "functionName": "flushPassiveEffectsImpl",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19502,
                "columnNumber": 12
              },
              {
                "functionName": "flushPassiveEffects",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19446,
                "columnNumber": 21
              },
              {
                "functionName": "",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19327,
                "columnNumber": 16
              },
              {
                "functionName": "workLoop",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 196,
                "columnNumber": 41
              },
              {
                "functionName": "flushWork",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 175,
                "columnNumber": 21
              },
              {
                "functionName": "performWorkUntilDeadline",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 383,
                "columnNumber": 28
              }
            ],
            "parentId": {
              "id": "4",
              "debuggerId": "-3895047138506156908.5457165050697095993"
            }
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/api/statistics",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"53-3mo5HoiCIURbeVRycbxPOGP+KpI\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 483,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Vary",
              "value": "Origin"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "connection",
              "value": "close"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"53-3mo5HoiCIURbeVRycbxPOGP+KpI\""
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 83,
            "mimeType": "application/json",
            "text": "{\"success\":true,\"data\":{\"promptCount\":66,\"lastUpdated\":\"2025-08-06T21:32:27.546Z\"}}"
          },
          "redirectURL": "",
          "headersSize": 558,
          "bodySize": 0,
          "_transferSize": 558,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.798Z",
        "time": 11.07400000182679,
        "timings": {
          "blocked": 7.052000000228174,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.12799999999999923,
          "wait": 3.601000000633067,
          "receive": 0.2930000009655487,
          "_blocked_queueing": 0.49500000022817403,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184618",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "getModels",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 72,
                "columnNumber": 27
              },
              {
                "functionName": "fetchModels",
                "scriptId": "147",
                "url": "http://localhost:5174/hooks/useModels.ts",
                "lineNumber": 10,
                "columnNumber": 35
              },
              {
                "functionName": "",
                "scriptId": "147",
                "url": "http://localhost:5174/hooks/useModels.ts",
                "lineNumber": 21,
                "columnNumber": 4
              },
              {
                "functionName": "commitHookEffectListMount",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 16914,
                "columnNumber": 33
              },
              {
                "functionName": "invokePassiveEffectMountInDEV",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18323,
                "columnNumber": 18
              },
              {
                "functionName": "invokeEffectsInDev",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19700,
                "columnNumber": 18
              },
              {
                "functionName": "commitDoubleInvokeEffectsInDEV",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19685,
                "columnNumber": 14
              },
              {
                "functionName": "flushPassiveEffectsImpl",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19502,
                "columnNumber": 12
              },
              {
                "functionName": "flushPassiveEffects",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19446,
                "columnNumber": 21
              },
              {
                "functionName": "",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 19327,
                "columnNumber": 16
              },
              {
                "functionName": "workLoop",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 196,
                "columnNumber": 41
              },
              {
                "functionName": "flushWork",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 175,
                "columnNumber": 21
              },
              {
                "functionName": "performWorkUntilDeadline",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 383,
                "columnNumber": 28
              }
            ],
            "parentId": {
              "id": "4",
              "debuggerId": "-3895047138506156908.5457165050697095993"
            }
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/api/llm/models",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"97-RFfviI1KSEPef5unwSMjk2JWc/M\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 483,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Vary",
              "value": "Origin"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "connection",
              "value": "close"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"97-RFfviI1KSEPef5unwSMjk2JWc/M\""
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 151,
            "mimeType": "application/json",
            "text": "{\"success\":true,\"data\":{\"openai\":[\"gpt-4o-mini-2024-07-18\",\"gpt-3.5-turbo-0125\"],\"anthropic\":[\"claude-3-5-haiku-latest\",\"claude-3-5-sonnet-20240620\"]}}"
          },
          "redirectURL": "",
          "headersSize": 558,
          "bodySize": 0,
          "_transferSize": 558,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.799Z",
        "time": 12.455000000045402,
        "timings": {
          "blocked": 8.131000000314089,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.11800000000000033,
          "wait": 3.844000000872649,
          "receive": 0.3619999988586642,
          "_blocked_queueing": 0.5060000003140885,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184622",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [],
            "parent": {
              "description": "Image",
              "callFrames": [
                {
                  "functionName": "commitMount",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 8411,
                  "columnNumber": 31
                },
                {
                  "functionName": "commitLayoutEffectOnFiber",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 17101,
                  "columnNumber": 18
                },
                {
                  "functionName": "commitLayoutMountEffects_complete",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 17979,
                  "columnNumber": 16
                },
                {
                  "functionName": "commitLayoutEffects_begin",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 17968,
                  "columnNumber": 14
                },
                {
                  "functionName": "commitLayoutEffects",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 17919,
                  "columnNumber": 10
                },
                {
                  "functionName": "commitRootImpl",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 19352,
                  "columnNumber": 12
                },
                {
                  "functionName": "commitRoot",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 19276,
                  "columnNumber": 12
                },
                {
                  "functionName": "finishConcurrentRender",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 18804,
                  "columnNumber": 14
                },
                {
                  "functionName": "performConcurrentWorkOnRoot",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 18717,
                  "columnNumber": 14
                },
                {
                  "functionName": "workLoop",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 196,
                  "columnNumber": 41
                },
                {
                  "functionName": "flushWork",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 175,
                  "columnNumber": 21
                },
                {
                  "functionName": "performWorkUntilDeadline",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 383,
                  "columnNumber": 28
                }
              ],
              "parentId": {
                "id": "4",
                "debuggerId": "-3895047138506156908.5457165050697095993"
              }
            }
          }
        },
        "_priority": "High",
        "_resourceType": "image",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/logo-compacto.png",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-Modified-Since",
              "value": "Tue, 05 Aug 2025 23:56:08 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"1953-1754438168898\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "image"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 588,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 1953,
            "mimeType": "image/png",
            "text": "iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAAAXNSR0IArs4c6QAAB1tJREFUeF7lnE2IHEUUx998udnVDcSsRHBBw8pGQUEM+HkSBD0oe/SgN/HiQcSjF9dLjiIechFvevAY9KAgePMLAoqCuhg2wkYMuAns9+7MTkv1dM9UV1e9j6rq7tHMJWGn6l/v/eq9+uyeVpIkCQg/qkJL1Rn/RyiQFZdXx2rI1cr2yzVaOEC5oB9Kv1qodTWZHh0gabdWgCzrx7XWWgRAmy1Ft/8PEEKIlwGKiIgK+9sZ1ExQ5ZLNplpwBPpT+W/WjACwAsfjBkkFBrolPSLQEIvpfKZFSdq+p+pEoWpphAEw1LTQ+lFcr0Bk5FdrmCSJWhQ35mYdDYe2gdRHI9Cs10+GsNk/hK3BQNijLQC14Um3L/zPV+9fSQs/++ZS+m8oB6zlXrsFs+0OLPRmoNtqs41kpPBIq58cw/r+HlvYu2ACoFJCsTYBemsKKiqQizNz0Msgpp3mG4F6u38f7XtEnsByS9EmACoz5jqdFCLnw47Aqwc7cDRUXVHfpymAKgrPnriD5Sgb4NreNkvQp5ArQyoByBxIl+fmWa5UADCf01nto4W8AGKACt/hdlYAcCebB20+x4Om1K+v7cB3n2zA+vc30sbOPn4nPPHyIpxZ5qVVcNclAMu3NxaBYesNBe/Tt36GweGwwKE704aX3nuYDZGZqU7WegRiWqMUZrRW5Rioe3Hpnd/gyjebVseWnj4NK6sPBAdYKkD4HCWF9TbqAvjBC9+Woi8npqLwjc+ftANkBIGEfBSAeoMigLkziFPnfvjM6s+rq6eg27dvWQa9BD5avWmt9/tjL0r4kGWDAZq+iwBazDP1XACf+3ge7vu1Z3Xw6oN9+PIV+3IKBegRncEATQ84ACV2ugAuXOvAyocnS1Goou/Sa1vwzz3HNUeg7lXZQ20diLvPAYjmhSHvAqg0FMTzX8/B4h/dVHLj/gFcfmbPCU+VmboU9olAambTNUcAJTGLD1vNAmT4QUYgQ6MMUPuLsL6JUwcYKJVKNzAGynYjWAqTU6SlQNwIbMHyHG/XU8FemOd+AWAWMrIuKLYTF2CFEchLDxqFOAKJhr0AIpoNpDAv8vJSYoCEPA6Q7lBTvjGAUjBy12QdhU02mFLjAGOACdOw5yc31RsHaF/i8UZQnxgbw+aMlQwzagRYjBNpCvvAyuv4RCg7AmfnWdewXssYrANRgIyeJ4EGarABiu9EMMMSgLV93qXSGGCgoxOQ0YRSyeoAEl2/trvtDOn8DuPPyzfgYDhkbf7JSHMU8Elb/XDiRLsD954/VbpjMbspyhjIOZF23WHYjp98nDc52jRaoG4l7IewruMx6o5FAFDdlhMPrSApjN1hYAegtgAbwYmbspMD2rLu0lOnYeVd+x2LE6Ahw55ELl740ZpUv3xxHYbHSrX8wY7gfVNYWg+7Imh3WvDQ82cyySKZ199+hNUU80A1gYsXfpoygLxI5QMsuucBUAm4jXKdB8ZMYVaXG4WotMfuWLxS2Gx/9KIN3ZsugOYkkitRdxg+sHzqlCeRkYURJxHeq17YifRkGXMTDobHlS5jyhDLnW/O1Hdd68Cj2R2Laxlj6gpmYRvAslHokb5WPMpWLtejE0MclNRCOm9yDJCwoTgLI4XJO5HMlRLACiCIqWkVKIB5UVcEmu6wlzHeAEO8LdSN0xOhAEsLe+7rrs0DjNMTtxjAOFGnox8DJKQDJ5Fyb48jkGg4yiQSJ9isKpMIrP0J1W3GapHveWzQ3NTkDquyBywZfutjYIzEmgqAiN8VpDD2jLSyRHZYVQvAQk+77bMFhAnQFTS8ZQz7RHpiJBWlsY/+vVK4jgjMQXCXMYzRIC2iAMpiFld2AqR60iFLpnCmy4tAAKgCIBc2p5wC6MlqIq8JkACzWtMBUPc8AVj461Z9wJITKq49c/Z3ySO++hAQawwsHSZYfNL7ezoiUDMy/kPm+uvkynXeh5/Cw8R1oVVoyT0G+k0FnNcczDFNv2MxW+VEoGSMtAG01WdGYAJre2odWP3H+0UbT9NcUPkRyPzxsdizcNHwSTyhr3qNryH9ol7CeMoBugHEetkQhUXksvr6nPjZGKJ7QiNQMv40/rprM0/p8xJEAlL0wrVEmGFqmsIMTeYkQu9EsLZIO/IC+Soje9JEBJABxVrEYZzHGIi7uX6wA/0p/9EJsqMEkD0AjtRdRmwc7sLecfEtcjLEAz2qJQItUE92u3D3bbMs3OwUVr9atL6/yxKNVSgUoE//mT+8Q/nCBqiEFMStQR82+0e4ro/lFsVQgCNJ+5LJNDH/6Sdu5OXmigA6qWnWFAzjgMzKcIpS0WD/vjrltHvG98Ljdqpt0A8CVqtZe+NEYHwqmWI4nHAF3DkewKqsiKwrldOXn8RDzk6KzQIM2bASUU/CjDRkkQBNQ0jDcsdsBdmVKxsTysKBNjkABqqy/K+jDZYh5H7AVNEtLwEMciuosnsfxJfll+ShddsUdx3ItcbpXxWO085zzcbKkWNgjEYmGnFAhaqM6oeqjLz6FwrJfU2F5OuZAAAAAElFTkSuQmCC",
            "encoding": "base64"
          },
          "redirectURL": "",
          "headersSize": 127,
          "bodySize": 0,
          "_transferSize": 127,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.799Z",
        "time": 4.862000001594424,
        "timings": {
          "blocked": 1.0480000011834782,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.069,
          "wait": 3.4819999986875336,
          "receive": 0.2630000017234124,
          "_blocked_queueing": 0.7020000011834782,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184654",
        "_initiator": {
          "type": "other"
        },
        "_priority": "High",
        "_resourceType": "other",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/favicon.png",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-Modified-Since",
              "value": "Tue, 05 Aug 2025 23:56:08 GMT"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"825-1754438168898\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "image"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "no-cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 581,
          "bodySize": 0
        },
        "response": {
          "status": 304,
          "statusText": "Not Modified",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:06 GMT"
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Vary",
              "value": "Origin"
            }
          ],
          "cookies": [],
          "content": {
            "size": 825,
            "mimeType": "image/png",
            "text": "iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAvNJREFUWEeVV7tuVDEQHfMQRQTFIhC66XalbAekSUON+ICg1EjkF1iaaGlokl9gkaiR8gXUNGkipVuJ0LFBQdBEQUKgGNke2zP22L7X2iLZ9ePMmTPHY9VN5hqKQwGAth9Q9mP/tAO/C0u1mRC3snPTOcI6xQD49WZ1FZTfqd88pRVoAo6ucgAI0hClBlAqRuG+ZxzUTo+/YVB2L2GF6sZzt+/QzRN6TYAmC3woUODi4yfEQHgKWlogOaRMuQCSEQAqUFoL4BBUXYQFXtLogziHp0h14zeaqrdfYtuzqhVD0l1MgRQL39SVnShOofxK3GRVkNU3CXa1mJL/nOqCusmh3e6SV4GgEQ88MNAnexaAZC7hOPfj+u4Sld/kEQopkOFwBiSBOgCOATQRH33ilB6zyIA/nsIwdf7tPU1BWYgsBakHpBXUKkN6TMpAiILeEQDIQBkgC6wEwB9G2fA+1C7CfEbUReKVDkDEtLO9CXuvn8LV7RswOz2GD99P0ab9wooKhTvlxYMxHEw24drFP3i7/wk+Hh4z20/uAoCTo1dwd7RmT/vx9w/c/3yIJ5uaN87eGngpoPjOn2zDvZu37KKfvy7h4dYB2yCrgpOjGYxGa5YTDmDgdYVscAC/4dHWPvYJ6ATrk7ntG/zYef4Y9mbP4OrOdZh9MSn42go5MOQg8iGloChCenmeLaYy3Q0jytNEvSGPBVOQGE+ghLZZCs4WG+WWjOxtfCC1Mt4ZxMmJBuqGvHo35Syb5JnLIBmiEVltkkbEa7VoRLQRxb+DN4jdD3ahyltxQzpozcJdULw4YbXYwMuoUJIIVGKgBGdQS5alAHdNIXcvlyRVTPPRtEUGpP6fyUlmx35r1/a51D0X6ANGA9Ltxyirll6/Qws85P1Aa7vW7w54v1mmpqMGSBstPyF6GuIQAAbqkH4gg2B6QpP/wrPLzq+mjwHIvcszUcwfefe0SJdfTgIAfhh9WNVSQByOvaD5i1m4CYaLcIgS+sz9D3yvUHF7AVAGAAAAAElFTkSuQmCC",
            "encoding": "base64"
          },
          "redirectURL": "",
          "headersSize": 127,
          "bodySize": 0,
          "_transferSize": 127,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:06.833Z",
        "time": 3.426999999646796,
        "timings": {
          "blocked": 1.264999996641418,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.09299999999999997,
          "wait": 1.8280000014537945,
          "receive": 0.2410000015515834,
          "_blocked_queueing": 0.924999996641418,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "184995",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "uploadFiles",
                "scriptId": "149",
                "url": "http://localhost:5174/services/file.api.ts",
                "lineNumber": 10,
                "columnNumber": 29
              },
              {
                "functionName": "handlePromptSubmit",
                "scriptId": "135",
                "url": "http://localhost:5174/App.tsx",
                "lineNumber": 49,
                "columnNumber": 45
              },
              {
                "functionName": "handleSubmit",
                "scriptId": "143",
                "url": "http://localhost:5174/components/PromptInput.tsx",
                "lineNumber": 27,
                "columnNumber": 6
              },
              {
                "functionName": "callCallback2",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 3673,
                "columnNumber": 21
              },
              {
                "functionName": "invokeGuardedCallbackDev",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 3698,
                "columnNumber": 23
              },
              {
                "functionName": "invokeGuardedCallback",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 3732,
                "columnNumber": 38
              },
              {
                "functionName": "invokeGuardedCallbackAndCatchFirstError",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 3735,
                "columnNumber": 32
              },
              {
                "functionName": "executeDispatch",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 7013,
                "columnNumber": 10
              },
              {
                "functionName": "processDispatchQueueItemsInOrder",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 7033,
                "columnNumber": 14
              },
              {
                "functionName": "processDispatchQueue",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 7042,
                "columnNumber": 12
              },
              {
                "functionName": "dispatchEventsForPlugins",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 7050,
                "columnNumber": 10
              },
              {
                "functionName": "",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 7173,
                "columnNumber": 19
              },
              {
                "functionName": "batchedUpdates$1",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 18912,
                "columnNumber": 19
              },
              {
                "functionName": "batchedUpdates",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 3578,
                "columnNumber": 19
              },
              {
                "functionName": "dispatchEventForPluginEventSystem",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 7172,
                "columnNumber": 10
              },
              {
                "functionName": "dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 5477,
                "columnNumber": 12
              },
              {
                "functionName": "dispatchEvent",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 5471,
                "columnNumber": 12
              },
              {
                "functionName": "dispatchDiscreteEvent",
                "scriptId": "150",
                "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                "lineNumber": 5448,
                "columnNumber": 12
              }
            ]
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "3000",
        "pageref": "page_1",
        "request": {
          "method": "POST",
          "url": "http://localhost:3000/api/upload/upload",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Content-Length",
              "value": "42920"
            },
            {
              "name": "Content-Type",
              "value": "multipart/form-data; boundary=----WebKitFormBoundaryIlIcD9Pd8j0BpZiO"
            },
            {
              "name": "Host",
              "value": "localhost:3000"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-site"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 572,
          "bodySize": 201,
          "postData": {
            "mimeType": "multipart/form-data; boundary=----WebKitFormBoundaryIlIcD9Pd8j0BpZiO",
            "text": "------WebKitFormBoundaryIlIcD9Pd8j0BpZiO\r\nContent-Disposition: form-data; name=\"files\"; filename=\"02_ECG_historia_infarto.png\"\r\nContent-Type: image/png\r\n\r\n\r\n------WebKitFormBoundaryIlIcD9Pd8j0BpZiO--\r\n",
            "params": [
              {
                "name": "files",
                "value": "(binary)"
              }
            ]
          }
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Access-Control-Allow-Origin",
              "value": "*"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Content-Length",
              "value": "281"
            },
            {
              "name": "Content-Type",
              "value": "application/json; charset=utf-8"
            },
            {
              "name": "Cross-Origin-Opener-Policy",
              "value": "same-origin"
            },
            {
              "name": "Cross-Origin-Resource-Policy",
              "value": "same-origin"
            },
            {
              "name": "Date",
              "value": "Wed, 06 Aug 2025 21:33:21 GMT"
            },
            {
              "name": "ETag",
              "value": "W/\"119-mbNF6cy+EyvHF+VyRLBhmFEhdG0\""
            },
            {
              "name": "Keep-Alive",
              "value": "timeout=5"
            },
            {
              "name": "Origin-Agent-Cluster",
              "value": "?1"
            },
            {
              "name": "Referrer-Policy",
              "value": "no-referrer"
            },
            {
              "name": "Strict-Transport-Security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "X-Content-Type-Options",
              "value": "nosniff"
            },
            {
              "name": "X-DNS-Prefetch-Control",
              "value": "off"
            },
            {
              "name": "X-Download-Options",
              "value": "noopen"
            },
            {
              "name": "X-Frame-Options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "X-Permitted-Cross-Domain-Policies",
              "value": "none"
            },
            {
              "name": "X-XSS-Protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 281,
            "mimeType": "application/json",
            "compression": 0,
            "text": "{\"success\":true,\"data\":{\"files\":[{\"id\":\"6696d5dc97e989317f1fa210848de18e\",\"name\":\"02_ECG_historia_infarto.png\",\"type\":\"image\",\"size\":42719,\"mimeType\":\"image/png\",\"preview\":\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlEAAAGlCAYAAADal6NMAAAACXBIWXMAAAsTAAALEwEAmpwYAAAgAE...\"}]}}"
          },
          "redirectURL": "",
          "headersSize": 631,
          "bodySize": 281,
          "_transferSize": 912,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "127.0.0.1",
        "startedDateTime": "2025-08-06T21:33:21.611Z",
        "time": 324.01000000187804,
        "timings": {
          "blocked": 1.5530000012398233,
          "dns": 0.006000000000000005,
          "ssl": -1,
          "connect": 309.456,
          "send": 1.3670000000000186,
          "wait": 11.37799999967774,
          "receive": 0.2500000009604264,
          "_blocked_queueing": 1.1750000012398232,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "185000",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "streamResponse",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 13,
                "columnNumber": 27
              },
              {
                "functionName": "handlePromptSubmit",
                "scriptId": "135",
                "url": "http://localhost:5174/App.tsx",
                "lineNumber": 67,
                "columnNumber": 18
              }
            ],
            "parent": {
              "description": "await",
              "callFrames": [
                {
                  "functionName": "handleSubmit",
                  "scriptId": "143",
                  "url": "http://localhost:5174/components/PromptInput.tsx",
                  "lineNumber": 27,
                  "columnNumber": 6
                },
                {
                  "functionName": "callCallback2",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 3673,
                  "columnNumber": 21
                },
                {
                  "functionName": "invokeGuardedCallbackDev",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 3698,
                  "columnNumber": 23
                },
                {
                  "functionName": "invokeGuardedCallback",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 3732,
                  "columnNumber": 38
                },
                {
                  "functionName": "invokeGuardedCallbackAndCatchFirstError",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 3735,
                  "columnNumber": 32
                },
                {
                  "functionName": "executeDispatch",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 7013,
                  "columnNumber": 10
                },
                {
                  "functionName": "processDispatchQueueItemsInOrder",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 7033,
                  "columnNumber": 14
                },
                {
                  "functionName": "processDispatchQueue",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 7042,
                  "columnNumber": 12
                },
                {
                  "functionName": "dispatchEventsForPlugins",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 7050,
                  "columnNumber": 10
                },
                {
                  "functionName": "",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 7173,
                  "columnNumber": 19
                },
                {
                  "functionName": "batchedUpdates$1",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 18912,
                  "columnNumber": 19
                },
                {
                  "functionName": "batchedUpdates",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 3578,
                  "columnNumber": 19
                },
                {
                  "functionName": "dispatchEventForPluginEventSystem",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 7172,
                  "columnNumber": 10
                },
                {
                  "functionName": "dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 5477,
                  "columnNumber": 12
                },
                {
                  "functionName": "dispatchEvent",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 5471,
                  "columnNumber": 12
                },
                {
                  "functionName": "dispatchDiscreteEvent",
                  "scriptId": "150",
                  "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                  "lineNumber": 5448,
                  "columnNumber": 12
                }
              ]
            }
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "POST",
          "url": "http://localhost:5174/api/llm/stream",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Content-Length",
              "value": "224"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "Origin",
              "value": "http://localhost:5174"
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 517,
          "bodySize": 224,
          "postData": {
            "mimeType": "application/json",
            "text": "{\"prompt\":\"revisa imagen\",\"provider\":\"dual\",\"openaiModel\":\"gpt-4o-mini-2024-07-18\",\"anthropicModel\":\"claude-3-5-haiku-latest\",\"openaiTemperature\":0.7,\"anthropicTemperature\":0.7,\"fileIds\":[\"6696d5dc97e989317f1fa210848de18e\"]}"
          }
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Vary",
              "value": "Origin"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "cache-control",
              "value": "no-cache"
            },
            {
              "name": "connection",
              "value": "keep-alive"
            },
            {
              "name": "content-type",
              "value": "text/event-stream"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Wed, 06 Aug 2025 21:33:22 GMT"
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "transfer-encoding",
              "value": "chunked"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 1242,
            "mimeType": "text/event-stream",
            "compression": -161,
            "text": "data: {\"openai\":\"Lo\"}\n\ndata: {\"openai\":\" siento\"}\n\ndata: {\"anthropic\":\"Lo\"}\n\ndata: {\"anthropic\":\" siento, pero\"}\n\ndata: {\"anthropic\":\" no v\"}\n\ndata: {\"anthropic\":\"eo ninguna imagen en\"}\n\ndata: {\"anthropic\":\" nu\"}\n\ndata: {\"anthropic\":\"estra conversacin. \"}\n\ndata: {\"openai\":\",\"}\n\ndata: {\"openai\":\" pero\"}\n\ndata: {\"anthropic\":\"Po\"}\n\ndata: {\"openai\":\" no\"}\n\ndata: {\"openai\":\" puedo\"}\n\ndata: {\"anthropic\":\"dras sub\"}\n\ndata: {\"openai\":\" revisar\"}\n\ndata: {\"openai\":\" imgenes\"}\n\ndata: {\"anthropic\":\"ir la imagen que qu\"}\n\ndata: {\"openai\":\".\"}\n\ndata: {\"openai\":\" Sin\"}\n\ndata: {\"anthropic\":\"ieres que\"}\n\ndata: {\"openai\":\" embargo\"}\n\ndata: {\"openai\":\",\"}\n\ndata: {\"openai\":\" puedo\"}\n\ndata: {\"openai\":\" ayudarte\"}\n\ndata: {\"anthropic\":\" revise?\"}\n\ndata: {\"openai\":\" a\"}\n\ndata: {\"openai\":\" responder\"}\n\ndata: {\"openai\":\" preguntas\"}\n\ndata: {\"openai\":\" o\"}\n\ndata: {\"openai\":\" darte\"}\n\ndata: {\"openai\":\" informacin\"}\n\ndata: {\"openai\":\" sobre\"}\n\ndata: {\"openai\":\" un\"}\n\ndata: {\"openai\":\" tema\"}\n\ndata: {\"openai\":\" especfico\"}\n\ndata: {\"openai\":\".\"}\n\ndata: {\"openai\":\" \"}\n\ndata: {\"openai\":\"En\"}\n\ndata: {\"openai\":\" qu\"}\n\ndata: {\"openai\":\" puedo\"}\n\ndata: {\"openai\":\" ayudarte\"}\n\ndata: {\"openai\":\" hoy\"}\n\ndata: {\"openai\":\"?\"}\n\ndata: {\"done\":true}\n\n"
          },
          "redirectURL": "",
          "headersSize": 597,
          "bodySize": 1403,
          "_transferSize": 2000,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:21.936Z",
        "time": 1517.4449999999624,
        "timings": {
          "blocked": 1.0740000004512258,
          "dns": 0.0040000000000000036,
          "ssl": -1,
          "connect": 0.45699999999999996,
          "send": 0.31600000000000006,
          "wait": 925.0219999985362,
          "receive": 590.5720000009751,
          "_blocked_queueing": 0.9470000004512258,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      },
      {
        "_connectionId": "185000",
        "_initiator": {
          "type": "script",
          "stack": {
            "callFrames": [
              {
                "functionName": "getStatistics",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 76,
                "columnNumber": 27
              },
              {
                "functionName": "fetchStatistics",
                "scriptId": "146",
                "url": "http://localhost:5174/hooks/useStatistics.ts",
                "lineNumber": 11,
                "columnNumber": 30
              },
              {
                "functionName": "onComplete",
                "scriptId": "135",
                "url": "http://localhost:5174/App.tsx",
                "lineNumber": 92,
                "columnNumber": 14
              },
              {
                "functionName": "streamResponse",
                "scriptId": "148",
                "url": "http://localhost:5174/services/api.ts",
                "lineNumber": 43,
                "columnNumber": 40
              }
            ],
            "parent": {
              "description": "await",
              "callFrames": [
                {
                  "functionName": "handlePromptSubmit",
                  "scriptId": "135",
                  "url": "http://localhost:5174/App.tsx",
                  "lineNumber": 67,
                  "columnNumber": 18
                }
              ],
              "parent": {
                "description": "await",
                "callFrames": [
                  {
                    "functionName": "handleSubmit",
                    "scriptId": "143",
                    "url": "http://localhost:5174/components/PromptInput.tsx",
                    "lineNumber": 27,
                    "columnNumber": 6
                  },
                  {
                    "functionName": "callCallback2",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 3673,
                    "columnNumber": 21
                  },
                  {
                    "functionName": "invokeGuardedCallbackDev",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 3698,
                    "columnNumber": 23
                  },
                  {
                    "functionName": "invokeGuardedCallback",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 3732,
                    "columnNumber": 38
                  },
                  {
                    "functionName": "invokeGuardedCallbackAndCatchFirstError",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 3735,
                    "columnNumber": 32
                  },
                  {
                    "functionName": "executeDispatch",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 7013,
                    "columnNumber": 10
                  },
                  {
                    "functionName": "processDispatchQueueItemsInOrder",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 7033,
                    "columnNumber": 14
                  },
                  {
                    "functionName": "processDispatchQueue",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 7042,
                    "columnNumber": 12
                  },
                  {
                    "functionName": "dispatchEventsForPlugins",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 7050,
                    "columnNumber": 10
                  },
                  {
                    "functionName": "",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 7173,
                    "columnNumber": 19
                  },
                  {
                    "functionName": "batchedUpdates$1",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 18912,
                    "columnNumber": 19
                  },
                  {
                    "functionName": "batchedUpdates",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 3578,
                    "columnNumber": 19
                  },
                  {
                    "functionName": "dispatchEventForPluginEventSystem",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 7172,
                    "columnNumber": 10
                  },
                  {
                    "functionName": "dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 5477,
                    "columnNumber": 12
                  },
                  {
                    "functionName": "dispatchEvent",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 5471,
                    "columnNumber": 12
                  },
                  {
                    "functionName": "dispatchDiscreteEvent",
                    "scriptId": "150",
                    "url": "http://localhost:5174/@fs/home/jano/DEV_WSL/LLM/node_modules/.vite/deps/chunk-NUMECXU6.js?v=2a7591ed",
                    "lineNumber": 5448,
                    "columnNumber": 12
                  }
                ]
              }
            }
          }
        },
        "_priority": "High",
        "_resourceType": "fetch",
        "cache": {},
        "connection": "5174",
        "pageref": "page_1",
        "request": {
          "method": "GET",
          "url": "http://localhost:5174/api/statistics",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Accept",
              "value": "*/*"
            },
            {
              "name": "Accept-Encoding",
              "value": "gzip, deflate, br, zstd"
            },
            {
              "name": "Accept-Language",
              "value": "es-ES,es;q=0.6"
            },
            {
              "name": "Connection",
              "value": "keep-alive"
            },
            {
              "name": "Host",
              "value": "localhost:5174"
            },
            {
              "name": "If-None-Match",
              "value": "W/\"53-3mo5HoiCIURbeVRycbxPOGP+KpI\""
            },
            {
              "name": "Referer",
              "value": "http://localhost:5174/"
            },
            {
              "name": "Sec-Fetch-Dest",
              "value": "empty"
            },
            {
              "name": "Sec-Fetch-Mode",
              "value": "cors"
            },
            {
              "name": "Sec-Fetch-Site",
              "value": "same-origin"
            },
            {
              "name": "Sec-GPC",
              "value": "1"
            },
            {
              "name": "User-Agent",
              "value": "Mozilla/5.0 (iPhone; CPU iPhone OS 16_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.6 Mobile/15E148 Safari/604.1"
            }
          ],
          "queryString": [],
          "cookies": [],
          "headersSize": 483,
          "bodySize": 0
        },
        "response": {
          "status": 200,
          "statusText": "OK",
          "httpVersion": "HTTP/1.1",
          "headers": [
            {
              "name": "Vary",
              "value": "Origin"
            },
            {
              "name": "access-control-allow-origin",
              "value": "*"
            },
            {
              "name": "connection",
              "value": "close"
            },
            {
              "name": "content-length",
              "value": "83"
            },
            {
              "name": "content-type",
              "value": "application/json; charset=utf-8"
            },
            {
              "name": "cross-origin-opener-policy",
              "value": "same-origin"
            },
            {
              "name": "cross-origin-resource-policy",
              "value": "same-origin"
            },
            {
              "name": "date",
              "value": "Wed, 06 Aug 2025 21:33:23 GMT"
            },
            {
              "name": "etag",
              "value": "W/\"53-NsFvUH/H9vcZI52YqzgvlOSvCF8\""
            },
            {
              "name": "origin-agent-cluster",
              "value": "?1"
            },
            {
              "name": "referrer-policy",
              "value": "no-referrer"
            },
            {
              "name": "strict-transport-security",
              "value": "max-age=15552000; includeSubDomains"
            },
            {
              "name": "x-content-type-options",
              "value": "nosniff"
            },
            {
              "name": "x-dns-prefetch-control",
              "value": "off"
            },
            {
              "name": "x-download-options",
              "value": "noopen"
            },
            {
              "name": "x-frame-options",
              "value": "SAMEORIGIN"
            },
            {
              "name": "x-permitted-cross-domain-policies",
              "value": "none"
            },
            {
              "name": "x-xss-protection",
              "value": "0"
            }
          ],
          "cookies": [],
          "content": {
            "size": 83,
            "mimeType": "application/json",
            "compression": 0,
            "text": "{\"success\":true,\"data\":{\"promptCount\":67,\"lastUpdated\":\"2025-08-06T21:33:21.942Z\"}}"
          },
          "redirectURL": "",
          "headersSize": 615,
          "bodySize": 83,
          "_transferSize": 698,
          "_error": null,
          "_fetchedViaServiceWorker": false
        },
        "serverIPAddress": "[::1]",
        "startedDateTime": "2025-08-06T21:33:23.453Z",
        "time": 5.503000000317115,
        "timings": {
          "blocked": 1.2439999992484227,
          "dns": -1,
          "ssl": -1,
          "connect": -1,
          "send": 0.11100000000000004,
          "wait": 3.602999998465646,
          "receive": 0.5450000026030466,
          "_blocked_queueing": 0.7929999992484227,
          "_workerStart": -1,
          "_workerReady": -1,
          "_workerFetchStart": -1,
          "_workerRespondWithSettled": -1
        }
      }
    ]
  }
}